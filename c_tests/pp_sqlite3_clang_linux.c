# 1 "c_tests/sqlite3.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 409 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "c_tests/sqlite3.c" 2
# 356 "c_tests/sqlite3.c"
# 1 "/usr/lib/llvm-20/lib/clang/20/include/stdarg.h" 1 3
# 47 "/usr/lib/llvm-20/lib/clang/20/include/stdarg.h" 3
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stdarg_header_macro.h" 1 3
# 48 "/usr/lib/llvm-20/lib/clang/20/include/stdarg.h" 2 3



# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stdarg___gnuc_va_list.h" 1 3
# 12 "/usr/lib/llvm-20/lib/clang/20/include/__stdarg___gnuc_va_list.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 52 "/usr/lib/llvm-20/lib/clang/20/include/stdarg.h" 2 3




# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stdarg_va_list.h" 1 3
# 12 "/usr/lib/llvm-20/lib/clang/20/include/__stdarg_va_list.h" 3
typedef __builtin_va_list va_list;
# 57 "/usr/lib/llvm-20/lib/clang/20/include/stdarg.h" 2 3




# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stdarg_va_arg.h" 1 3
# 62 "/usr/lib/llvm-20/lib/clang/20/include/stdarg.h" 2 3




# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stdarg___va_copy.h" 1 3
# 67 "/usr/lib/llvm-20/lib/clang/20/include/stdarg.h" 2 3




# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stdarg_va_copy.h" 1 3
# 72 "/usr/lib/llvm-20/lib/clang/20/include/stdarg.h" 2 3
# 357 "c_tests/sqlite3.c" 2
# 509 "c_tests/sqlite3.c"
           const char sqlite3_version[] = "3.51.2";
           const char *sqlite3_libversion(void);
           const char *sqlite3_sourceid(void);
           int sqlite3_libversion_number(void);
# 537 "c_tests/sqlite3.c"
           int sqlite3_compileoption_used(const char *zOptName);
           const char *sqlite3_compileoption_get(int N);
# 580 "c_tests/sqlite3.c"
           int sqlite3_threadsafe(void);
# 596 "c_tests/sqlite3.c"
typedef struct sqlite3 sqlite3;
# 625 "c_tests/sqlite3.c"
  typedef long long int sqlite_int64;
  typedef unsigned long long int sqlite_uint64;

typedef sqlite_int64 sqlite3_int64;
typedef sqlite_uint64 sqlite3_uint64;
# 677 "c_tests/sqlite3.c"
           int sqlite3_close(sqlite3*);
           int sqlite3_close_v2(sqlite3*);






typedef int (*sqlite3_callback)(void*,int,char**, char**);
# 751 "c_tests/sqlite3.c"
           int sqlite3_exec(
  sqlite3*,
  const char *sql,
  int (*callback)(void*,int,char**,char**),
  void *,
  char **errmsg
);
# 1067 "c_tests/sqlite3.c"
typedef struct sqlite3_file sqlite3_file;
struct sqlite3_file {
  const struct sqlite3_io_methods *pMethods;
};
# 1174 "c_tests/sqlite3.c"
typedef struct sqlite3_io_methods sqlite3_io_methods;
struct sqlite3_io_methods {
  int iVersion;
  int (*xClose)(sqlite3_file*);
  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);
  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);
  int (*xSync)(sqlite3_file*, int flags);
  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);
  int (*xLock)(sqlite3_file*, int);
  int (*xUnlock)(sqlite3_file*, int);
  int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);
  int (*xFileControl)(sqlite3_file*, int op, void *pArg);
  int (*xSectorSize)(sqlite3_file*);
  int (*xDeviceCharacteristics)(sqlite3_file*);

  int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);
  int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);
  void (*xShmBarrier)(sqlite3_file*);
  int (*xShmUnmap)(sqlite3_file*, int deleteFlag);

  int (*xFetch)(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);
  int (*xUnfetch)(sqlite3_file*, sqlite3_int64 iOfst, void *p);


};
# 1625 "c_tests/sqlite3.c"
typedef struct sqlite3_mutex sqlite3_mutex;
# 1635 "c_tests/sqlite3.c"
typedef struct sqlite3_api_routines sqlite3_api_routines;
# 1655 "c_tests/sqlite3.c"
typedef const char *sqlite3_filename;
# 1826 "c_tests/sqlite3.c"
typedef struct sqlite3_vfs sqlite3_vfs;
typedef void (*sqlite3_syscall_ptr)(void);
struct sqlite3_vfs {
  int iVersion;
  int szOsFile;
  int mxPathname;
  sqlite3_vfs *pNext;
  const char *zName;
  void *pAppData;
  int (*xOpen)(sqlite3_vfs*, sqlite3_filename zName, sqlite3_file*,
               int flags, int *pOutFlags);
  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);
  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);
  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);
  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);
  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);
  void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);
  void (*xDlClose)(sqlite3_vfs*, void*);
  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);
  int (*xSleep)(sqlite3_vfs*, int microseconds);
  int (*xCurrentTime)(sqlite3_vfs*, double*);
  int (*xGetLastError)(sqlite3_vfs*, int, char *);




  int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);




  int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);
  sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);
  const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);





};
# 2004 "c_tests/sqlite3.c"
           int sqlite3_initialize(void);
           int sqlite3_shutdown(void);
           int sqlite3_os_init(void);
           int sqlite3_os_end(void);
# 2043 "c_tests/sqlite3.c"
           int sqlite3_config(int, ...);
# 2062 "c_tests/sqlite3.c"
           int sqlite3_db_config(sqlite3*, int op, ...);
# 2127 "c_tests/sqlite3.c"
typedef struct sqlite3_mem_methods sqlite3_mem_methods;
struct sqlite3_mem_methods {
  void *(*xMalloc)(int);
  void (*xFree)(void*);
  void *(*xRealloc)(void*,int);
  int (*xSize)(void*);
  int (*xRoundup)(int);
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  void *pAppData;
};
# 3023 "c_tests/sqlite3.c"
           int sqlite3_extended_result_codes(sqlite3*, int onoff);
# 3085 "c_tests/sqlite3.c"
           sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
# 3095 "c_tests/sqlite3.c"
           void sqlite3_set_last_insert_rowid(sqlite3*,sqlite3_int64);
# 3160 "c_tests/sqlite3.c"
           int sqlite3_changes(sqlite3*);
           sqlite3_int64 sqlite3_changes64(sqlite3*);
# 3202 "c_tests/sqlite3.c"
           int sqlite3_total_changes(sqlite3*);
           sqlite3_int64 sqlite3_total_changes64(sqlite3*);
# 3244 "c_tests/sqlite3.c"
           void sqlite3_interrupt(sqlite3*);
           int sqlite3_is_interrupted(sqlite3*);
# 3280 "c_tests/sqlite3.c"
           int sqlite3_complete(const char *sql);
           int sqlite3_complete16(const void *sql);
# 3342 "c_tests/sqlite3.c"
           int sqlite3_busy_handler(sqlite3*,int(*)(void*,int),void*);
# 3365 "c_tests/sqlite3.c"
           int sqlite3_busy_timeout(sqlite3*, int ms);
# 3398 "c_tests/sqlite3.c"
           int sqlite3_setlk_timeout(sqlite3*, int ms, int flags);
# 3478 "c_tests/sqlite3.c"
           int sqlite3_get_table(
  sqlite3 *db,
  const char *zSql,
  char ***pazResult,
  int *pnRow,
  int *pnColumn,
  char **pzErrmsg
);
           void sqlite3_free_table(char **result);
# 3528 "c_tests/sqlite3.c"
           char *sqlite3_mprintf(const char*,...);
           char *sqlite3_vmprintf(const char*, va_list);
           char *sqlite3_snprintf(int,char*,const char*, ...);
           char *sqlite3_vsnprintf(int,char*,const char*, va_list);
# 3608 "c_tests/sqlite3.c"
           void *sqlite3_malloc(int);
           void *sqlite3_malloc64(sqlite3_uint64);
           void *sqlite3_realloc(void*, int);
           void *sqlite3_realloc64(void*, sqlite3_uint64);
           void sqlite3_free(void*);
           sqlite3_uint64 sqlite3_msize(void*);
# 3638 "c_tests/sqlite3.c"
           sqlite3_int64 sqlite3_memory_used(void);
           sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
# 3662 "c_tests/sqlite3.c"
           void sqlite3_randomness(int N, void *P);
# 3753 "c_tests/sqlite3.c"
           int sqlite3_set_authorizer(
  sqlite3*,
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pUserData
);
# 3861 "c_tests/sqlite3.c"
                             void *sqlite3_trace(sqlite3*,
   void(*xTrace)(void*,const char*), void*);
                             void *sqlite3_profile(sqlite3*,
   void(*xProfile)(void*,const char*,sqlite3_uint64), void*);
# 3954 "c_tests/sqlite3.c"
           int sqlite3_trace_v2(
  sqlite3*,
  unsigned uMask,
  int(*xCallback)(unsigned,void*,void*,void*),
  void *pCtx
);
# 4000 "c_tests/sqlite3.c"
           void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
# 4280 "c_tests/sqlite3.c"
           int sqlite3_open(
  const char *filename,
  sqlite3 **ppDb
);
           int sqlite3_open16(
  const void *filename,
  sqlite3 **ppDb
);
           int sqlite3_open_v2(
  const char *filename,
  sqlite3 **ppDb,
  int flags,
  const char *zVfs
);
# 4361 "c_tests/sqlite3.c"
           const char *sqlite3_uri_parameter(sqlite3_filename z, const char *zParam);
           int sqlite3_uri_boolean(sqlite3_filename z, const char *zParam, int bDefault);
           sqlite3_int64 sqlite3_uri_int64(sqlite3_filename, const char*, sqlite3_int64);
           const char *sqlite3_uri_key(sqlite3_filename z, int N);
# 4393 "c_tests/sqlite3.c"
           const char *sqlite3_filename_database(sqlite3_filename);
           const char *sqlite3_filename_journal(sqlite3_filename);
           const char *sqlite3_filename_wal(sqlite3_filename);
# 4414 "c_tests/sqlite3.c"
           sqlite3_file *sqlite3_database_file_object(const char*);
# 4461 "c_tests/sqlite3.c"
           sqlite3_filename sqlite3_create_filename(
  const char *zDatabase,
  const char *zJournal,
  const char *zWal,
  int nParam,
  const char **azParam
);
           void sqlite3_free_filename(sqlite3_filename);
# 4533 "c_tests/sqlite3.c"
           int sqlite3_errcode(sqlite3 *db);
           int sqlite3_extended_errcode(sqlite3 *db);
           const char *sqlite3_errmsg(sqlite3*);
           const void *sqlite3_errmsg16(sqlite3*);
           const char *sqlite3_errstr(int);
           int sqlite3_error_offset(sqlite3 *db);
# 4566 "c_tests/sqlite3.c"
           int sqlite3_set_errmsg(sqlite3 *db, int errcode, const char *zErrMsg);
# 4592 "c_tests/sqlite3.c"
typedef struct sqlite3_stmt sqlite3_stmt;
# 4634 "c_tests/sqlite3.c"
           int sqlite3_limit(sqlite3*, int id, int newVal);
# 4859 "c_tests/sqlite3.c"
           int sqlite3_prepare(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
           int sqlite3_prepare_v2(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
           int sqlite3_prepare_v3(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  unsigned int prepFlags,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
           int sqlite3_prepare16(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
           int sqlite3_prepare16_v2(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
           int sqlite3_prepare16_v3(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  unsigned int prepFlags,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
# 4945 "c_tests/sqlite3.c"
           const char *sqlite3_sql(sqlite3_stmt *pStmt);
           char *sqlite3_expanded_sql(sqlite3_stmt *pStmt);
# 4998 "c_tests/sqlite3.c"
           int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
# 5010 "c_tests/sqlite3.c"
           int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt);
# 5045 "c_tests/sqlite3.c"
           int sqlite3_stmt_explain(sqlite3_stmt *pStmt, int eMode);
# 5066 "c_tests/sqlite3.c"
           int sqlite3_stmt_busy(sqlite3_stmt*);
# 5110 "c_tests/sqlite3.c"
typedef struct sqlite3_value sqlite3_value;
# 5124 "c_tests/sqlite3.c"
typedef struct sqlite3_context sqlite3_context;
# 5268 "c_tests/sqlite3.c"
           int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
           int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,
                        void(*)(void*));
           int sqlite3_bind_double(sqlite3_stmt*, int, double);
           int sqlite3_bind_int(sqlite3_stmt*, int, int);
           int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
           int sqlite3_bind_null(sqlite3_stmt*, int);
           int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
           int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
           int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
                         void(*)(void*), unsigned char encoding);
           int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
           int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*));
           int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
           int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);
# 5303 "c_tests/sqlite3.c"
           int sqlite3_bind_parameter_count(sqlite3_stmt*);
# 5331 "c_tests/sqlite3.c"
           const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
# 5349 "c_tests/sqlite3.c"
           int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
# 5359 "c_tests/sqlite3.c"
           int sqlite3_clear_bindings(sqlite3_stmt*);
# 5375 "c_tests/sqlite3.c"
           int sqlite3_column_count(sqlite3_stmt *pStmt);
# 5404 "c_tests/sqlite3.c"
           const char *sqlite3_column_name(sqlite3_stmt*, int N);
           const void *sqlite3_column_name16(sqlite3_stmt*, int N);
# 5449 "c_tests/sqlite3.c"
           const char *sqlite3_column_database_name(sqlite3_stmt*,int);
           const void *sqlite3_column_database_name16(sqlite3_stmt*,int);
           const char *sqlite3_column_table_name(sqlite3_stmt*,int);
           const void *sqlite3_column_table_name16(sqlite3_stmt*,int);
           const char *sqlite3_column_origin_name(sqlite3_stmt*,int);
           const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);
# 5486 "c_tests/sqlite3.c"
           const char *sqlite3_column_decltype(sqlite3_stmt*,int);
           const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
# 5571 "c_tests/sqlite3.c"
           int sqlite3_step(sqlite3_stmt*);
# 5592 "c_tests/sqlite3.c"
           int sqlite3_data_count(sqlite3_stmt *pStmt);
# 5839 "c_tests/sqlite3.c"
           const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
           double sqlite3_column_double(sqlite3_stmt*, int iCol);
           int sqlite3_column_int(sqlite3_stmt*, int iCol);
           sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
           const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
           const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
           sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
           int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
           int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
           int sqlite3_column_type(sqlite3_stmt*, int iCol);
# 5876 "c_tests/sqlite3.c"
           int sqlite3_finalize(sqlite3_stmt *pStmt);
# 5915 "c_tests/sqlite3.c"
           int sqlite3_reset(sqlite3_stmt *pStmt);
# 6041 "c_tests/sqlite3.c"
           int sqlite3_create_function(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
           int sqlite3_create_function16(
  sqlite3 *db,
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
           int sqlite3_create_function_v2(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*),
  void(*xDestroy)(void*)
);
           int sqlite3_create_window_function(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*),
  void (*xValue)(sqlite3_context*),
  void (*xInverse)(sqlite3_context*,int,sqlite3_value**),
  void(*xDestroy)(void*)
);
# 6215 "c_tests/sqlite3.c"
                             int sqlite3_aggregate_count(sqlite3_context*);
                             int sqlite3_expired(sqlite3_stmt*);
                             int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
                             int sqlite3_global_recover(void);
                             void sqlite3_thread_cleanup(void);
                             int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),
                      void*,sqlite3_int64);
# 6352 "c_tests/sqlite3.c"
           const void *sqlite3_value_blob(sqlite3_value*);
           double sqlite3_value_double(sqlite3_value*);
           int sqlite3_value_int(sqlite3_value*);
           sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
           void *sqlite3_value_pointer(sqlite3_value*, const char*);
           const unsigned char *sqlite3_value_text(sqlite3_value*);
           const void *sqlite3_value_text16(sqlite3_value*);
           const void *sqlite3_value_text16le(sqlite3_value*);
           const void *sqlite3_value_text16be(sqlite3_value*);
           int sqlite3_value_bytes(sqlite3_value*);
           int sqlite3_value_bytes16(sqlite3_value*);
           int sqlite3_value_type(sqlite3_value*);
           int sqlite3_value_numeric_type(sqlite3_value*);
           int sqlite3_value_nochange(sqlite3_value*);
           int sqlite3_value_frombind(sqlite3_value*);
# 6388 "c_tests/sqlite3.c"
           int sqlite3_value_encoding(sqlite3_value*);
# 6406 "c_tests/sqlite3.c"
           unsigned int sqlite3_value_subtype(sqlite3_value*);
# 6423 "c_tests/sqlite3.c"
           sqlite3_value *sqlite3_value_dup(const sqlite3_value*);
           void sqlite3_value_free(sqlite3_value*);
# 6469 "c_tests/sqlite3.c"
           void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);
# 6484 "c_tests/sqlite3.c"
           void *sqlite3_user_data(sqlite3_context*);
# 6496 "c_tests/sqlite3.c"
           sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
# 6565 "c_tests/sqlite3.c"
           void *sqlite3_get_auxdata(sqlite3_context*, int N);
           void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));
# 6622 "c_tests/sqlite3.c"
           void *sqlite3_get_clientdata(sqlite3*,const char*);
           int sqlite3_set_clientdata(sqlite3*, const char*, void*, void(*)(void*));
# 6639 "c_tests/sqlite3.c"
typedef void (*sqlite3_destructor_type)(void*);
# 6790 "c_tests/sqlite3.c"
           void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));
           void sqlite3_result_blob64(sqlite3_context*,const void*,
                           sqlite3_uint64,void(*)(void*));
           void sqlite3_result_double(sqlite3_context*, double);
           void sqlite3_result_error(sqlite3_context*, const char*, int);
           void sqlite3_result_error16(sqlite3_context*, const void*, int);
           void sqlite3_result_error_toobig(sqlite3_context*);
           void sqlite3_result_error_nomem(sqlite3_context*);
           void sqlite3_result_error_code(sqlite3_context*, int);
           void sqlite3_result_int(sqlite3_context*, int);
           void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
           void sqlite3_result_null(sqlite3_context*);
           void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));
           void sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,
                           void(*)(void*), unsigned char encoding);
           void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));
           void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
           void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
           void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
           void sqlite3_result_pointer(sqlite3_context*, void*,const char*,void(*)(void*));
           void sqlite3_result_zeroblob(sqlite3_context*, int n);
           int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);
# 6840 "c_tests/sqlite3.c"
           void sqlite3_result_subtype(sqlite3_context*,unsigned int);
# 6923 "c_tests/sqlite3.c"
           int sqlite3_create_collation(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
           int sqlite3_create_collation_v2(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDestroy)(void*)
);
           int sqlite3_create_collation16(
  sqlite3*,
  const void *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
# 6973 "c_tests/sqlite3.c"
           int sqlite3_collation_needed(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const char*)
);
           int sqlite3_collation_needed16(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const void*)
);
# 7018 "c_tests/sqlite3.c"
           int sqlite3_sleep(int);
# 7076 "c_tests/sqlite3.c"
           char *sqlite3_temp_directory;
# 7113 "c_tests/sqlite3.c"
           char *sqlite3_data_directory;
# 7134 "c_tests/sqlite3.c"
           int sqlite3_win32_set_directory(
  unsigned long type,
  void *zValue
);
           int sqlite3_win32_set_directory8(unsigned long type, const char *zValue);
           int sqlite3_win32_set_directory16(unsigned long type, const void *zValue);
# 7172 "c_tests/sqlite3.c"
           int sqlite3_get_autocommit(sqlite3*);
# 7185 "c_tests/sqlite3.c"
           sqlite3 *sqlite3_db_handle(sqlite3_stmt*);
# 7207 "c_tests/sqlite3.c"
           const char *sqlite3_db_name(sqlite3 *db, int N);
# 7239 "c_tests/sqlite3.c"
           sqlite3_filename sqlite3_db_filename(sqlite3 *db, const char *zDbName);
# 7249 "c_tests/sqlite3.c"
           int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);
# 7267 "c_tests/sqlite3.c"
           int sqlite3_txn_state(sqlite3*,const char *zSchema);
# 7316 "c_tests/sqlite3.c"
           sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
# 7365 "c_tests/sqlite3.c"
           void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
           void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
# 7426 "c_tests/sqlite3.c"
           int sqlite3_autovacuum_pages(
  sqlite3 *db,
  unsigned int(*)(void*,const char*,unsigned int,unsigned int,unsigned int),
  void*,
  void(*)(void*)
);
# 7491 "c_tests/sqlite3.c"
           void *sqlite3_update_hook(
  sqlite3*,
  void(*)(void *,int ,char const *,char const *,sqlite3_int64),
  void*
);
# 7541 "c_tests/sqlite3.c"
           int sqlite3_enable_shared_cache(int);
# 7557 "c_tests/sqlite3.c"
           int sqlite3_release_memory(int);
# 7571 "c_tests/sqlite3.c"
           int sqlite3_db_release_memory(sqlite3*);
# 7637 "c_tests/sqlite3.c"
           sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);
           sqlite3_int64 sqlite3_hard_heap_limit64(sqlite3_int64 N);
# 7649 "c_tests/sqlite3.c"
                             void sqlite3_soft_heap_limit(int N);
# 7721 "c_tests/sqlite3.c"
           int sqlite3_table_column_metadata(
  sqlite3 *db,
  const char *zDbName,
  const char *zTableName,
  const char *zColumnName,
  char const **pzDataType,
  char const **pzCollSeq,
  int *pNotNull,
  int *pPrimaryKey,
  int *pAutoinc
);
# 7777 "c_tests/sqlite3.c"
           int sqlite3_load_extension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
);
# 7809 "c_tests/sqlite3.c"
           int sqlite3_enable_load_extension(sqlite3 *db, int onoff);
# 7847 "c_tests/sqlite3.c"
           int sqlite3_auto_extension(void(*xEntryPoint)(void));
# 7859 "c_tests/sqlite3.c"
           int sqlite3_cancel_auto_extension(void(*xEntryPoint)(void));







           void sqlite3_reset_auto_extension(void);




typedef struct sqlite3_vtab sqlite3_vtab;
typedef struct sqlite3_index_info sqlite3_index_info;
typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;
typedef struct sqlite3_module sqlite3_module;
# 7893 "c_tests/sqlite3.c"
struct sqlite3_module {
  int iVersion;
  int (*xCreate)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xConnect)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);
  int (*xDisconnect)(sqlite3_vtab *pVTab);
  int (*xDestroy)(sqlite3_vtab *pVTab);
  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);
  int (*xClose)(sqlite3_vtab_cursor*);
  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,
                int argc, sqlite3_value **argv);
  int (*xNext)(sqlite3_vtab_cursor*);
  int (*xEof)(sqlite3_vtab_cursor*);
  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);
  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);
  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);
  int (*xBegin)(sqlite3_vtab *pVTab);
  int (*xSync)(sqlite3_vtab *pVTab);
  int (*xCommit)(sqlite3_vtab *pVTab);
  int (*xRollback)(sqlite3_vtab *pVTab);
  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,
                       void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),
                       void **ppArg);
  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);


  int (*xSavepoint)(sqlite3_vtab *pVTab, int);
  int (*xRelease)(sqlite3_vtab *pVTab, int);
  int (*xRollbackTo)(sqlite3_vtab *pVTab, int);


  int (*xShadowName)(const char*);


  int (*xIntegrity)(sqlite3_vtab *pVTab, const char *zSchema,
                    const char *zTabName, int mFlags, char **pzErr);
};
# 8039 "c_tests/sqlite3.c"
struct sqlite3_index_info {

  int nConstraint;
  struct sqlite3_index_constraint {
     int iColumn;
     unsigned char op;
     unsigned char usable;
     int iTermOffset;
  } *aConstraint;
  int nOrderBy;
  struct sqlite3_index_orderby {
     int iColumn;
     unsigned char desc;
  } *aOrderBy;

  struct sqlite3_index_constraint_usage {
    int argvIndex;
    unsigned char omit;
  } *aConstraintUsage;
  int idxNum;
  char *idxStr;
  int needToFreeIdxStr;
  int orderByConsumed;
  double estimatedCost;

  sqlite3_int64 estimatedRows;

  int idxFlags;

  sqlite3_uint64 colUsed;
};
# 8170 "c_tests/sqlite3.c"
           int sqlite3_create_module(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData
);
           int sqlite3_create_module_v2(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData,
  void(*xDestroy)(void*)
);
# 8196 "c_tests/sqlite3.c"
           int sqlite3_drop_modules(
  sqlite3 *db,
  const char **azKeep
);
# 8219 "c_tests/sqlite3.c"
struct sqlite3_vtab {
  const sqlite3_module *pModule;
  int nRef;
  char *zErrMsg;

};
# 8243 "c_tests/sqlite3.c"
struct sqlite3_vtab_cursor {
  sqlite3_vtab *pVtab;

};
# 8256 "c_tests/sqlite3.c"
           int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
# 8275 "c_tests/sqlite3.c"
           int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
# 8289 "c_tests/sqlite3.c"
typedef struct sqlite3_blob sqlite3_blob;
# 8374 "c_tests/sqlite3.c"
           int sqlite3_blob_open(
  sqlite3*,
  const char *zDb,
  const char *zTable,
  const char *zColumn,
  sqlite3_int64 iRow,
  int flags,
  sqlite3_blob **ppBlob
);
# 8407 "c_tests/sqlite3.c"
           int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
# 8430 "c_tests/sqlite3.c"
           int sqlite3_blob_close(sqlite3_blob *);
# 8446 "c_tests/sqlite3.c"
           int sqlite3_blob_bytes(sqlite3_blob *);
# 8475 "c_tests/sqlite3.c"
           int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
# 8517 "c_tests/sqlite3.c"
           int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
# 8548 "c_tests/sqlite3.c"
           sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);
           int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
           int sqlite3_vfs_unregister(sqlite3_vfs*);
# 8668 "c_tests/sqlite3.c"
           sqlite3_mutex *sqlite3_mutex_alloc(int);
           void sqlite3_mutex_free(sqlite3_mutex*);
           void sqlite3_mutex_enter(sqlite3_mutex*);
           int sqlite3_mutex_try(sqlite3_mutex*);
           void sqlite3_mutex_leave(sqlite3_mutex*);
# 8739 "c_tests/sqlite3.c"
typedef struct sqlite3_mutex_methods sqlite3_mutex_methods;
struct sqlite3_mutex_methods {
  int (*xMutexInit)(void);
  int (*xMutexEnd)(void);
  sqlite3_mutex *(*xMutexAlloc)(int);
  void (*xMutexFree)(sqlite3_mutex *);
  void (*xMutexEnter)(sqlite3_mutex *);
  int (*xMutexTry)(sqlite3_mutex *);
  void (*xMutexLeave)(sqlite3_mutex *);
  int (*xMutexHeld)(sqlite3_mutex *);
  int (*xMutexNotheld)(sqlite3_mutex *);
};
# 8782 "c_tests/sqlite3.c"
           int sqlite3_mutex_held(sqlite3_mutex*);
           int sqlite3_mutex_notheld(sqlite3_mutex*);
# 8827 "c_tests/sqlite3.c"
           sqlite3_mutex *sqlite3_db_mutex(sqlite3*);
# 8870 "c_tests/sqlite3.c"
           int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);
# 8889 "c_tests/sqlite3.c"
           int sqlite3_test_control(int op, ...);
# 8987 "c_tests/sqlite3.c"
           int sqlite3_keyword_count(void);
           int sqlite3_keyword_name(int,const char**,int*);
           int sqlite3_keyword_check(const char*,int);
# 9007 "c_tests/sqlite3.c"
typedef struct sqlite3_str sqlite3_str;
# 9034 "c_tests/sqlite3.c"
           sqlite3_str *sqlite3_str_new(sqlite3*);
# 9049 "c_tests/sqlite3.c"
           char *sqlite3_str_finish(sqlite3_str*);
# 9083 "c_tests/sqlite3.c"
           void sqlite3_str_appendf(sqlite3_str*, const char *zFormat, ...);
           void sqlite3_str_vappendf(sqlite3_str*, const char *zFormat, va_list);
           void sqlite3_str_append(sqlite3_str*, const char *zIn, int N);
           void sqlite3_str_appendall(sqlite3_str*, const char *zIn);
           void sqlite3_str_appendchar(sqlite3_str*, int N, char C);
           void sqlite3_str_reset(sqlite3_str*);
# 9119 "c_tests/sqlite3.c"
           int sqlite3_str_errcode(sqlite3_str*);
           int sqlite3_str_length(sqlite3_str*);
           char *sqlite3_str_value(sqlite3_str*);
# 9149 "c_tests/sqlite3.c"
           int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
           int sqlite3_status64(
  int op,
  sqlite3_int64 *pCurrent,
  sqlite3_int64 *pHighwater,
  int resetFlag
);
# 9267 "c_tests/sqlite3.c"
           int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);
           int sqlite3_db_status64(sqlite3*,int,sqlite3_int64*,sqlite3_int64*,int);
# 9440 "c_tests/sqlite3.c"
           int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
# 9528 "c_tests/sqlite3.c"
typedef struct sqlite3_pcache sqlite3_pcache;
# 9540 "c_tests/sqlite3.c"
typedef struct sqlite3_pcache_page sqlite3_pcache_page;
struct sqlite3_pcache_page {
  void *pBuf;
  void *pExtra;
};
# 9705 "c_tests/sqlite3.c"
typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;
struct sqlite3_pcache_methods2 {
  int iVersion;
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);
  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*,
      unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
  void (*xShrink)(sqlite3_pcache*);
};






typedef struct sqlite3_pcache_methods sqlite3_pcache_methods;
struct sqlite3_pcache_methods {
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, void*, int discard);
  void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
};
# 9754 "c_tests/sqlite3.c"
typedef struct sqlite3_backup sqlite3_backup;
# 9952 "c_tests/sqlite3.c"
           sqlite3_backup *sqlite3_backup_init(
  sqlite3 *pDest,
  const char *zDestName,
  sqlite3 *pSource,
  const char *zSourceName
);
           int sqlite3_backup_step(sqlite3_backup *p, int nPage);
           int sqlite3_backup_finish(sqlite3_backup *p);
           int sqlite3_backup_remaining(sqlite3_backup *p);
           int sqlite3_backup_pagecount(sqlite3_backup *p);
# 10078 "c_tests/sqlite3.c"
           int sqlite3_unlock_notify(
  sqlite3 *pBlocked,
  void (*xNotify)(void **apArg, int nArg),
  void *pNotifyArg
);
# 10093 "c_tests/sqlite3.c"
           int sqlite3_stricmp(const char *, const char *);
           int sqlite3_strnicmp(const char *, const char *, int);
# 10111 "c_tests/sqlite3.c"
           int sqlite3_strglob(const char *zGlob, const char *zStr);
# 10134 "c_tests/sqlite3.c"
           int sqlite3_strlike(const char *zGlob, const char *zStr, unsigned int cEsc);
# 10157 "c_tests/sqlite3.c"
           void sqlite3_log(int iErrCode, const char *zFormat, ...);
# 10207 "c_tests/sqlite3.c"
           void *sqlite3_wal_hook(
  sqlite3*,
  int(*)(void *,sqlite3*,const char*,int),
  void*
);
# 10243 "c_tests/sqlite3.c"
           int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
# 10265 "c_tests/sqlite3.c"
           int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
# 10364 "c_tests/sqlite3.c"
           int sqlite3_wal_checkpoint_v2(
  sqlite3 *db,
  const char *zDb,
  int eMode,
  int *pnLog,
  int *pnCkpt
);
# 10405 "c_tests/sqlite3.c"
           int sqlite3_vtab_config(sqlite3*, int op, ...);
# 10493 "c_tests/sqlite3.c"
           int sqlite3_vtab_on_conflict(sqlite3 *);
# 10519 "c_tests/sqlite3.c"
           int sqlite3_vtab_nochange(sqlite3_context*);
# 10554 "c_tests/sqlite3.c"
           const char *sqlite3_vtab_collation(sqlite3_index_info*,int);
# 10648 "c_tests/sqlite3.c"
           int sqlite3_vtab_distinct(sqlite3_index_info*);
# 10721 "c_tests/sqlite3.c"
           int sqlite3_vtab_in(sqlite3_index_info*, int iCons, int bHandle);
# 10768 "c_tests/sqlite3.c"
           int sqlite3_vtab_in_first(sqlite3_value *pVal, sqlite3_value **ppOut);
           int sqlite3_vtab_in_next(sqlite3_value *pVal, sqlite3_value **ppOut);
# 10811 "c_tests/sqlite3.c"
           int sqlite3_vtab_rhs_value(sqlite3_index_info*, int, sqlite3_value **ppVal);
# 10940 "c_tests/sqlite3.c"
           int sqlite3_stmt_scanstatus(
  sqlite3_stmt *pStmt,
  int idx,
  int iScanStatusOp,
  void *pOut
);
           int sqlite3_stmt_scanstatus_v2(
  sqlite3_stmt *pStmt,
  int idx,
  int iScanStatusOp,
  int flags,
  void *pOut
);
# 10969 "c_tests/sqlite3.c"
           void sqlite3_stmt_scanstatus_reset(sqlite3_stmt*);
# 11002 "c_tests/sqlite3.c"
           int sqlite3_db_cacheflush(sqlite3*);
# 11132 "c_tests/sqlite3.c"
           int sqlite3_system_errno(sqlite3*);
# 11154 "c_tests/sqlite3.c"
typedef struct sqlite3_snapshot {
  unsigned char hidden[48];
} sqlite3_snapshot;
# 11209 "c_tests/sqlite3.c"
           int sqlite3_snapshot_get(
  sqlite3 *db,
  const char *zSchema,
  sqlite3_snapshot **ppSnapshot
);
# 11258 "c_tests/sqlite3.c"
           int sqlite3_snapshot_open(
  sqlite3 *db,
  const char *zSchema,
  sqlite3_snapshot *pSnapshot
);
# 11275 "c_tests/sqlite3.c"
           void sqlite3_snapshot_free(sqlite3_snapshot*);
# 11302 "c_tests/sqlite3.c"
           int sqlite3_snapshot_cmp(
  sqlite3_snapshot *p1,
  sqlite3_snapshot *p2
);
# 11330 "c_tests/sqlite3.c"
           int sqlite3_snapshot_recover(sqlite3 *db, const char *zDb);
# 11376 "c_tests/sqlite3.c"
           unsigned char *sqlite3_serialize(
  sqlite3 *db,
  const char *zSchema,
  sqlite3_int64 *piSize,
  unsigned int mFlags
);
# 11443 "c_tests/sqlite3.c"
           int sqlite3_deserialize(
  sqlite3 *db,
  const char *zSchema,
  unsigned char *pData,
  sqlite3_int64 szDb,
  sqlite3_int64 szBuf,
  unsigned mFlags
);
# 11493 "c_tests/sqlite3.c"
           int sqlite3_carray_bind(
  sqlite3_stmt *pStmt,
  int i,
  void *aData,
  int nData,
  int mFlags,
  void (*xDel)(void*)
);
# 11571 "c_tests/sqlite3.c"
typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry;
typedef struct sqlite3_rtree_query_info sqlite3_rtree_query_info;







  typedef double sqlite3_rtree_dbl;
# 11589 "c_tests/sqlite3.c"
           int sqlite3_rtree_geometry_callback(
  sqlite3 *db,
  const char *zGeom,
  int (*xGeom)(sqlite3_rtree_geometry*, int, sqlite3_rtree_dbl*,int*),
  void *pContext
);






struct sqlite3_rtree_geometry {
  void *pContext;
  int nParam;
  sqlite3_rtree_dbl *aParam;
  void *pUser;
  void (*xDelUser)(void *);
};







           int sqlite3_rtree_query_callback(
  sqlite3 *db,
  const char *zQueryFunc,
  int (*xQueryFunc)(sqlite3_rtree_query_info*),
  void *pContext,
  void (*xDestructor)(void*)
);
# 11633 "c_tests/sqlite3.c"
struct sqlite3_rtree_query_info {
  void *pContext;
  int nParam;
  sqlite3_rtree_dbl *aParam;
  void *pUser;
  void (*xDelUser)(void*);
  sqlite3_rtree_dbl *aCoord;
  unsigned int *anQueue;
  int nCoord;
  int iLevel;
  int mxLevel;
  sqlite3_int64 iRowid;
  sqlite3_rtree_dbl rParentScore;
  int eParentWithin;
  int eWithin;
  sqlite3_rtree_dbl rScore;

  sqlite3_value **apSqlParam;
};
# 13569 "c_tests/sqlite3.c"
typedef struct Fts5ExtensionApi Fts5ExtensionApi;
typedef struct Fts5Context Fts5Context;
typedef struct Fts5PhraseIter Fts5PhraseIter;

typedef void (*fts5_extension_function)(
  const Fts5ExtensionApi *pApi,
  Fts5Context *pFts,
  sqlite3_context *pCtx,
  int nVal,
  sqlite3_value **apVal
);

struct Fts5PhraseIter {
  const unsigned char *a;
  const unsigned char *b;
};
# 13882 "c_tests/sqlite3.c"
struct Fts5ExtensionApi {
  int iVersion;

  void *(*xUserData)(Fts5Context*);

  int (*xColumnCount)(Fts5Context*);
  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);
  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);

  int (*xTokenize)(Fts5Context*,
    const char *pText, int nText,
    void *pCtx,
    int (*xToken)(void*, int, const char*, int, int, int)
  );

  int (*xPhraseCount)(Fts5Context*);
  int (*xPhraseSize)(Fts5Context*, int iPhrase);

  int (*xInstCount)(Fts5Context*, int *pnInst);
  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);

  sqlite3_int64 (*xRowid)(Fts5Context*);
  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);
  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);

  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,
    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)
  );
  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));
  void *(*xGetAuxdata)(Fts5Context*, int bClear);

  int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);
  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);

  int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);
  void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol);


  int (*xQueryToken)(Fts5Context*,
      int iPhrase, int iToken,
      const char **ppToken, int *pnToken
  );
  int (*xInstToken)(Fts5Context*, int iIdx, int iToken, const char**, int*);


  int (*xColumnLocale)(Fts5Context*, int iCol, const char **pz, int *pn);
  int (*xTokenize_v2)(Fts5Context*,
    const char *pText, int nText,
    const char *pLocale, int nLocale,
    void *pCtx,
    int (*xToken)(void*, int, const char*, int, int, int)
  );
};
# 14163 "c_tests/sqlite3.c"
typedef struct Fts5Tokenizer Fts5Tokenizer;
typedef struct fts5_tokenizer_v2 fts5_tokenizer_v2;
struct fts5_tokenizer_v2 {
  int iVersion;

  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);
  void (*xDelete)(Fts5Tokenizer*);
  int (*xTokenize)(Fts5Tokenizer*,
      void *pCtx,
      int flags,
      const char *pText, int nText,
      const char *pLocale, int nLocale,
      int (*xToken)(
        void *pCtx,
        int tflags,
        const char *pToken,
        int nToken,
        int iStart,
        int iEnd
      )
  );
};






typedef struct fts5_tokenizer fts5_tokenizer;
struct fts5_tokenizer {
  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);
  void (*xDelete)(Fts5Tokenizer*);
  int (*xTokenize)(Fts5Tokenizer*,
      void *pCtx,
      int flags,
      const char *pText, int nText,
      int (*xToken)(
        void *pCtx,
        int tflags,
        const char *pToken,
        int nToken,
        int iStart,
        int iEnd
      )
  );
};
# 14228 "c_tests/sqlite3.c"
typedef struct fts5_api fts5_api;
struct fts5_api {
  int iVersion;


  int (*xCreateTokenizer)(
    fts5_api *pApi,
    const char *zName,
    void *pUserData,
    fts5_tokenizer *pTokenizer,
    void (*xDestroy)(void*)
  );


  int (*xFindTokenizer)(
    fts5_api *pApi,
    const char *zName,
    void **ppUserData,
    fts5_tokenizer *pTokenizer
  );


  int (*xCreateFunction)(
    fts5_api *pApi,
    const char *zName,
    void *pUserData,
    fts5_extension_function xFunction,
    void (*xDestroy)(void*)
  );




  int (*xCreateTokenizer_v2)(
    fts5_api *pApi,
    const char *zName,
    void *pUserData,
    fts5_tokenizer_v2 *pTokenizer,
    void (*xDestroy)(void*)
  );


  int (*xFindTokenizer_v2)(
    fts5_api *pApi,
    const char *zName,
    void **ppUserData,
    fts5_tokenizer_v2 **ppTokenizer
  );
};
# 14971 "c_tests/sqlite3.c"
typedef struct Hash Hash;
typedef struct HashElem HashElem;
# 14995 "c_tests/sqlite3.c"
struct Hash {
  unsigned int htsize;
  unsigned int count;
  HashElem *first;
  struct _ht {
    unsigned int count;
    HashElem *chain;
  } *ht;
};







struct HashElem {
  HashElem *next, *prev;
  void *data;
  const char *pKey;
  unsigned int h;
};




static void sqlite3HashInit(Hash*);
static void *sqlite3HashInsert(Hash*, const char *pKey, void *pData);
static void *sqlite3HashFind(const Hash*, const char *pKey);
static void sqlite3HashClear(Hash*);
# 15244 "c_tests/sqlite3.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 28 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 415 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 416 "/usr/include/features.h" 2 3 4
# 501 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 502 "/usr/include/features.h" 2 3 4
# 523 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 730 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 731 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 732 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 524 "/usr/include/features.h" 2 3 4
# 547 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 548 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 29 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 18 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 3 4
typedef long unsigned int size_t;
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 108 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_null.h" 1 3 4
# 109 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 35 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/llvm-20/lib/clang/20/include/stdarg.h" 1 3 4
# 38 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 44 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2:24;

  char _short_backupbuf[1];
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  struct _IO_FILE **_prevchain;
  int _mode;

  char _unused2[15 * sizeof (int) - 5 * sizeof (void *)];
};
# 45 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 48 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 66 "/usr/include/stdio.h" 3 4
typedef __off64_t off_t;




typedef __off64_t off64_t;






typedef __ssize_t ssize_t;
# 87 "/usr/include/stdio.h" 3 4
typedef __fpos64_t fpos_t;


typedef __fpos64_t fpos64_t;
# 129 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 130 "/usr/include/stdio.h" 2 3 4
# 149 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ ));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ ));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ ));
# 176 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ ));






extern int fclose (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 198 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __asm__ ("" "tmpfile64")
  __attribute__ ((__malloc__)) ;






extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) ;



extern char *tmpnam (char[20]) __attribute__ ((__nothrow__ )) ;




extern char *tmpnam_r (char __s[20]) __attribute__ ((__nothrow__ )) ;
# 228 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;






extern int fflush (FILE *__stream);
# 245 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 255 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 276 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename, const char *__restrict __modes) __asm__ ("" "fopen64")

  __attribute__ ((__malloc__)) ;
extern FILE *freopen (const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream) __asm__ ("" "freopen64")


        __attribute__ ((__nonnull__ (3)));






extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) __attribute__ ((__nonnull__ (3)));




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ ))
  __attribute__ ((__malloc__)) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ ))
  __attribute__ ((__malloc__)) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ ))
  __attribute__ ((__malloc__)) ;
# 334 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ ))
  __attribute__ ((__nonnull__ (1)));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...) __attribute__ ((__nonnull__ (1)));




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nonnull__ (1)));




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__nonnull__ (1)));




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ ));





# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 83 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 97 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 131 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 132 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 438 "/usr/include/stdio.h" 2 3 4




extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc23_fscanf") __attribute__ ((__nonnull__ (1)));


extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc23_scanf") ;

extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc23_sscanf") __attribute__ ((__nothrow__ ));
# 490 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__nonnull__ (1)));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format__ (__scanf__, 2, 0)));






extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc23_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__nonnull__ (1)));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc23_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc23_vsscanf") __attribute__ ((__nothrow__ ))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 575 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern int getc (FILE *__stream) __attribute__ ((__nonnull__ (1)));





extern int getchar (void);






extern int getc_unlocked (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern int getchar_unlocked (void);
# 600 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 611 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));
extern int putc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));





extern int putchar (int __c);
# 627 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));







extern int putc_unlocked (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream) __attribute__ ((__nonnull__ (1)));


extern int putw (int __w, FILE *__stream) __attribute__ ((__nonnull__ (2)));







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
                                                          __attribute__ ((__nonnull__ (3)));
# 677 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
                                                   __attribute__ ((__nonnull__ (3)));
# 689 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) __attribute__ ((__nonnull__ (4)));
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) __attribute__ ((__nonnull__ (4)));


extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) __attribute__ ((__nonnull__ (3)));







extern int fputs (const char *__restrict __s, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (2)));





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream) __attribute__ ((__nonnull__ (2)));






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (4)));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s) __attribute__ ((__nonnull__ (4)));
# 745 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream) __attribute__ ((__nonnull__ (2)));
# 756 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (4)));
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream)
  __attribute__ ((__nonnull__ (4)));







extern int fseek (FILE *__stream, long int __off, int __whence)
  __attribute__ ((__nonnull__ (1)));




extern long int ftell (FILE *__stream) __attribute__ ((__nonnull__ (1)));




extern void rewind (FILE *__stream) __attribute__ ((__nonnull__ (1)));
# 802 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off64_t __off, int __whence) __asm__ ("" "fseeko64") __attribute__ ((__nonnull__ (1)));


extern __off64_t ftello (FILE *__stream) __asm__ ("" "ftello64")
  __attribute__ ((__nonnull__ (1)));
# 828 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos) __asm__ ("" "fgetpos64")

  __attribute__ ((__nonnull__ (1)));
extern int fsetpos (FILE *__stream, const fpos_t *__pos) __asm__ ("" "fsetpos64")

  __attribute__ ((__nonnull__ (1)));







extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence)
  __attribute__ ((__nonnull__ (1)));
extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__nonnull__ (1)));
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos)
  __attribute__ ((__nonnull__ (1)));
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos) __attribute__ ((__nonnull__ (1)));



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern void perror (const char *__s) __attribute__ ((__cold__));




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 887 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream) __attribute__ ((__nonnull__ (1)));





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) ;






extern char *ctermid (char *__s) __attribute__ ((__nothrow__ ))
                                     ;





extern char *cuserid (char *__s)
                                     ;




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 949 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 15245 "c_tests/sqlite3.c" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 103 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_wchar_t.h" 1 3 4
# 24 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_wchar_t.h" 3 4
typedef int wchar_t;
# 104 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4




# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_null.h" 1 3 4
# 109 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 33 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ )) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern long int strtol (const char *__restrict __nptr, char **__restrict __endptr, int __base) __asm__ ("" "__isoc23_strtol") __attribute__ ((__nothrow__ ))


     __attribute__ ((__nonnull__ (1)));
extern unsigned long int strtoul (const char *__restrict __nptr, char **__restrict __endptr, int __base) __asm__ ("" "__isoc23_strtoul") __attribute__ ((__nothrow__ ))



     __attribute__ ((__nonnull__ (1)));

__extension__
extern long long int strtoq (const char *__restrict __nptr, char **__restrict __endptr, int __base) __asm__ ("" "__isoc23_strtoll") __attribute__ ((__nothrow__ ))


     __attribute__ ((__nonnull__ (1)));
__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr, char **__restrict __endptr, int __base) __asm__ ("" "__isoc23_strtoull") __attribute__ ((__nothrow__ ))



     __attribute__ ((__nonnull__ (1)));

__extension__
extern long long int strtoll (const char *__restrict __nptr, char **__restrict __endptr, int __base) __asm__ ("" "__isoc23_strtoll") __attribute__ ((__nothrow__ ))


     __attribute__ ((__nonnull__ (1)));
__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr, char **__restrict __endptr, int __base) __asm__ ("" "__isoc23_strtoull") __attribute__ ((__nothrow__ ))



     __attribute__ ((__nonnull__ (1)));
# 278 "/usr/include/stdlib.h" 3 4
extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));
# 298 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));
# 338 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 339 "/usr/include/stdlib.h" 2 3 4

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 4)));





extern long int strtol_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) __asm__ ("" "__isoc23_strtol_l") __attribute__ ((__nothrow__ ))



     __attribute__ ((__nonnull__ (1, 4)));
extern unsigned long int strtoul_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) __asm__ ("" "__isoc23_strtoul_l") __attribute__ ((__nothrow__ ))




     __attribute__ ((__nonnull__ (1, 4)));
__extension__
extern long long int strtoll_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) __asm__ ("" "__isoc23_strtoll_l") __attribute__ ((__nothrow__ ))




     __attribute__ ((__nonnull__ (1, 4)));
__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) __asm__ ("" "__isoc23_strtoull_l") __attribute__ ((__nothrow__ ))




     __attribute__ ((__nonnull__ (1, 4)));
# 415 "/usr/include/stdlib.h" 3 4
extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));
# 436 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));
# 505 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ )) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;






typedef __ino64_t ino_t;




typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{



  return ((__uint16_t) ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8)));

}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{



  return ((((__bsx) & 0xff000000u) >> 24) | (((__bsx) & 0x00ff0000u) >> 8) | (((__bsx) & 0x0000ff00u) << 8) | (((__bsx) & 0x000000ffu) << 24));

}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{



  return ((((__bsx) & 0xff00000000000000ull) >> 56) | (((__bsx) & 0x00ff000000000000ull) >> 40) | (((__bsx) & 0x0000ff0000000000ull) >> 24) | (((__bsx) & 0x000000ff00000000ull) >> 8) | (((__bsx) & 0x00000000ff000000ull) << 8) | (((__bsx) & 0x0000000000ff0000ull) << 24) | (((__bsx) & 0x000000000000ff00ull) << 40) | (((__bsx) & 0x00000000000000ffull) << 56));

}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 102 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;
# 205 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt_t;



typedef __fsblkcnt64_t fsblkcnt_t;



typedef __fsfilcnt64_t fsfilcnt_t;





typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_size[2] ;
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
  unsigned int __unused_initialized_1;
  unsigned int __unused_initialized_2;
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 515 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ ));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ ));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ ));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ ));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ ));







extern double drand48 (void) __attribute__ ((__nothrow__ ));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ ));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ ));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ ));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern __uint32_t arc4random (void)
     __attribute__ ((__nothrow__ )) ;


extern void arc4random_buf (void *__buf, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern __uint32_t arc4random_uniform (__uint32_t __upper_bound)
     __attribute__ ((__nothrow__ )) ;




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__))
                                         ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__)) ;


extern void free (void *__ptr) __attribute__ ((__nothrow__ ));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__))

                       ;


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ )) ;



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ ));
# 707 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__))
                                         ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
                                         ;



extern void abort (void) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__)) __attribute__ ((__cold__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ ));
# 814 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 830 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __asm__ ("" "mkstemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 852 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __asm__ ("" "mkstemps64") __attribute__ ((__nonnull__ (1))) ;






extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 870 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 884 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __asm__ ("" "mkostemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 905 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags) __asm__ ("" "mkostemps64")

     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 923 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
                              ;
# 940 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ )) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
# 1012 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ ));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ ));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ))
                                      ;

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ ))

                                    ;






extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 1099 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ ));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ ));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ )) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 1155 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1156 "/usr/include/stdlib.h" 2 3 4
# 15246 "c_tests/sqlite3.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 108 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_null.h" 1 3 4
# 109 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 107 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 120 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 133 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
                                           ;





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)))
                                           ;





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 246 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 286 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 323 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 350 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 380 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))

                                         ;



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ ));
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;




extern const char *strerrordesc_np (int __err) __attribute__ ((__nothrow__ ));

extern const char *strerrorname_np (int __err) __attribute__ ((__nothrow__ ));





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ ));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 24 "/usr/include/strings.h" 2 3 4
# 34 "/usr/include/strings.h" 3 4
extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)))
                                                  ;



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ ));



extern const char *sigabbrev_np (int __sig) __attribute__ ((__nothrow__ ));


extern const char *sigdescr_np (int __sig) __attribute__ ((__nothrow__ ));



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlcpy (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;



extern size_t strlcat (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)))
                                          ;
# 540 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 15247 "c_tests/sqlite3.c" 2
# 1 "/usr/include/assert.h" 1 3 4
# 15248 "c_tests/sqlite3.c" 2
# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3
# 84 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_header_macro.h" 1 3
# 85 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3



# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_ptrdiff_t.h" 1 3
# 18 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_ptrdiff_t.h" 3
typedef long int ptrdiff_t;
# 89 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3




# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3
# 103 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_wchar_t.h" 1 3
# 104 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3




# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_null.h" 1 3
# 109 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3
# 128 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_offsetof.h" 1 3
# 129 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3
# 15249 "c_tests/sqlite3.c" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ ));
extern int isalpha (int) __attribute__ ((__nothrow__ ));
extern int iscntrl (int) __attribute__ ((__nothrow__ ));
extern int isdigit (int) __attribute__ ((__nothrow__ ));
extern int islower (int) __attribute__ ((__nothrow__ ));
extern int isgraph (int) __attribute__ ((__nothrow__ ));
extern int isprint (int) __attribute__ ((__nothrow__ ));
extern int ispunct (int) __attribute__ ((__nothrow__ ));
extern int isspace (int) __attribute__ ((__nothrow__ ));
extern int isupper (int) __attribute__ ((__nothrow__ ));
extern int isxdigit (int) __attribute__ ((__nothrow__ ));



extern int tolower (int __c) __attribute__ ((__nothrow__ ));


extern int toupper (int __c) __attribute__ ((__nothrow__ ));




extern int isblank (int) __attribute__ ((__nothrow__ ));




extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ ));






extern int isascii (int __c) __attribute__ ((__nothrow__ ));



extern int toascii (int __c) __attribute__ ((__nothrow__ ));



extern int _toupper (int) __attribute__ ((__nothrow__ ));
extern int _tolower (int) __attribute__ ((__nothrow__ ));
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ ));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ ));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ ));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ ));
# 15250 "c_tests/sqlite3.c" 2
# 15456 "c_tests/sqlite3.c"
typedef sqlite_int64 i64;
typedef sqlite_uint64 u64;
typedef unsigned int u32;
typedef unsigned short int u16;
typedef short int i16;
typedef unsigned char u8;
typedef signed char i8;




typedef unsigned bft;
# 15481 "c_tests/sqlite3.c"
typedef u64 tRowcnt;
# 15506 "c_tests/sqlite3.c"
typedef short int LogEst;
# 15533 "c_tests/sqlite3.c"
  typedef u64 uptr;
# 15771 "c_tests/sqlite3.c"
static u32 sqlite3WhereTrace;
# 15823 "c_tests/sqlite3.c"
typedef struct BusyHandler BusyHandler;
struct BusyHandler {
  int (*xBusyHandler)(void *,int);
  void *pBusyArg;
  int nBusy;
};
# 15933 "c_tests/sqlite3.c"
typedef struct AggInfo AggInfo;
typedef struct AuthContext AuthContext;
typedef struct AutoincInfo AutoincInfo;
typedef struct Bitvec Bitvec;
typedef struct CollSeq CollSeq;
typedef struct Column Column;
typedef struct Cte Cte;
typedef struct CteUse CteUse;
typedef struct Db Db;
typedef struct DbClientData DbClientData;
typedef struct DbFixer DbFixer;
typedef struct Schema Schema;
typedef struct Expr Expr;
typedef struct ExprList ExprList;
typedef struct FKey FKey;
typedef struct FpDecode FpDecode;
typedef struct FuncDestructor FuncDestructor;
typedef struct FuncDef FuncDef;
typedef struct FuncDefHash FuncDefHash;
typedef struct IdList IdList;
typedef struct Index Index;
typedef struct IndexedExpr IndexedExpr;
typedef struct IndexSample IndexSample;
typedef struct KeyClass KeyClass;
typedef struct KeyInfo KeyInfo;
typedef struct Lookaside Lookaside;
typedef struct LookasideSlot LookasideSlot;
typedef struct Module Module;
typedef struct NameContext NameContext;
typedef struct OnOrUsing OnOrUsing;
typedef struct Parse Parse;
typedef struct ParseCleanup ParseCleanup;
typedef struct PreUpdate PreUpdate;
typedef struct PrintfArguments PrintfArguments;
typedef struct RCStr RCStr;
typedef struct RenameToken RenameToken;
typedef struct Returning Returning;
typedef struct RowSet RowSet;
typedef struct Savepoint Savepoint;
typedef struct Select Select;
typedef struct SQLiteThread SQLiteThread;
typedef struct SelectDest SelectDest;
typedef struct Subquery Subquery;
typedef struct SrcItem SrcItem;
typedef struct SrcList SrcList;
typedef struct sqlite3_str StrAccum;
typedef struct Table Table;
typedef struct TableLock TableLock;
typedef struct Token Token;
typedef struct TreeView TreeView;
typedef struct Trigger Trigger;
typedef struct TriggerPrg TriggerPrg;
typedef struct TriggerStep TriggerStep;
typedef struct UnpackedRecord UnpackedRecord;
typedef struct Upsert Upsert;
typedef struct VTable VTable;
typedef struct VtabCtx VtabCtx;
typedef struct Walker Walker;
typedef struct WhereInfo WhereInfo;
typedef struct Window Window;
typedef struct With With;
# 16006 "c_tests/sqlite3.c"
  typedef u64 Bitmask;
# 16030 "c_tests/sqlite3.c"
typedef int VList;
# 16304 "c_tests/sqlite3.c"
static int sqlite3OsInit(void);




static void sqlite3OsClose(sqlite3_file*);
static int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset);
static int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset);
static int sqlite3OsTruncate(sqlite3_file*, i64 size);
static int sqlite3OsSync(sqlite3_file*, int);
static int sqlite3OsFileSize(sqlite3_file*, i64 *pSize);
static int sqlite3OsLock(sqlite3_file*, int);
static int sqlite3OsUnlock(sqlite3_file*, int);
static int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut);
static int sqlite3OsFileControl(sqlite3_file*,int,void*);
static void sqlite3OsFileControlHint(sqlite3_file*,int,void*);

static int sqlite3OsSectorSize(sqlite3_file *id);
static int sqlite3OsDeviceCharacteristics(sqlite3_file *id);

static int sqlite3OsShmMap(sqlite3_file *,int,int,int,void volatile **);
static int sqlite3OsShmLock(sqlite3_file *id, int, int, int);
static void sqlite3OsShmBarrier(sqlite3_file *id);
static int sqlite3OsShmUnmap(sqlite3_file *id, int);

static int sqlite3OsFetch(sqlite3_file *id, i64, int, void **);
static int sqlite3OsUnfetch(sqlite3_file *, i64, void *);





static int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *);
static int sqlite3OsDelete(sqlite3_vfs *, const char *, int);
static int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int *pResOut);
static int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *);

static void *sqlite3OsDlOpen(sqlite3_vfs *, const char *);
static void sqlite3OsDlError(sqlite3_vfs *, int, char *);
static void (*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *))(void);
static void sqlite3OsDlClose(sqlite3_vfs *, void *);

static int sqlite3OsRandomness(sqlite3_vfs *, int, char *);
static int sqlite3OsSleep(sqlite3_vfs *, int);
static int sqlite3OsGetLastError(sqlite3_vfs*);
static int sqlite3OsCurrentTimeInt64(sqlite3_vfs *, sqlite3_int64*);





static int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int,int*);
static void sqlite3OsCloseFree(sqlite3_file *);
# 16396 "c_tests/sqlite3.c"
typedef u32 Pgno;




typedef struct Pager Pager;




typedef struct PgHdr DbPage;
# 16496 "c_tests/sqlite3.c"
static int sqlite3PagerOpen(
  sqlite3_vfs*,
  Pager **ppPager,
  const char*,
  int,
  int,
  int,
  void(*)(DbPage*)
);
static int sqlite3PagerClose(Pager *pPager, sqlite3*);
static int sqlite3PagerReadFileheader(Pager*, int, unsigned char*);


static void sqlite3PagerSetBusyHandler(Pager*, int(*)(void *), void *);
static int sqlite3PagerSetPagesize(Pager*, u32*, int);
static Pgno sqlite3PagerMaxPageCount(Pager*, Pgno);
static void sqlite3PagerSetCachesize(Pager*, int);
static int sqlite3PagerSetSpillsize(Pager*, int);
static void sqlite3PagerSetMmapLimit(Pager *, sqlite3_int64);
static void sqlite3PagerShrink(Pager*);
static void sqlite3PagerSetFlags(Pager*,unsigned);
static int sqlite3PagerLockingMode(Pager *, int);
static int sqlite3PagerSetJournalMode(Pager *, int);
static int sqlite3PagerGetJournalMode(Pager*);
static int sqlite3PagerOkToChangeJournalMode(Pager*);
static i64 sqlite3PagerJournalSizeLimit(Pager *, i64);
static sqlite3_backup **sqlite3PagerBackupPtr(Pager*);
static int sqlite3PagerFlush(Pager*);


static int sqlite3PagerGet(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag);
static DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno);
static void sqlite3PagerRef(DbPage*);
static void sqlite3PagerUnref(DbPage*);
static void sqlite3PagerUnrefNotNull(DbPage*);
static void sqlite3PagerUnrefPageOne(DbPage*);


static int sqlite3PagerWrite(DbPage*);
static void sqlite3PagerDontWrite(DbPage*);
static int sqlite3PagerMovepage(Pager*,DbPage*,Pgno,int);
static int sqlite3PagerPageRefcount(DbPage*);
static void *sqlite3PagerGetData(DbPage *);
static void *sqlite3PagerGetExtra(DbPage *);


static void sqlite3PagerPagecount(Pager*, int*);
static int sqlite3PagerBegin(Pager*, int exFlag, int);
static int sqlite3PagerCommitPhaseOne(Pager*,const char *zSuper, int);
static int sqlite3PagerExclusiveLock(Pager*);
static int sqlite3PagerSync(Pager *pPager, const char *zSuper);
static int sqlite3PagerCommitPhaseTwo(Pager*);
static int sqlite3PagerRollback(Pager*);
static int sqlite3PagerOpenSavepoint(Pager *pPager, int n);
static int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint);
static int sqlite3PagerSharedLock(Pager *pPager);


static int sqlite3PagerCheckpoint(Pager *pPager, sqlite3*, int, int*, int*);
static int sqlite3PagerWalSupported(Pager *pPager);
static int sqlite3PagerWalCallback(Pager *pPager);
static int sqlite3PagerOpenWal(Pager *pPager, int *pisOpen);
static int sqlite3PagerCloseWal(Pager *pPager, sqlite3*);
# 16577 "c_tests/sqlite3.c"
static int sqlite3PagerDirectReadOk(Pager *pPager, Pgno pgno);







static u8 sqlite3PagerIsreadonly(Pager*);
static u32 sqlite3PagerDataVersion(Pager*);



static int sqlite3PagerMemUsed(Pager*);
static const char *sqlite3PagerFilename(const Pager*, int);
static sqlite3_vfs *sqlite3PagerVfs(Pager*);
static sqlite3_file *sqlite3PagerFile(Pager*);
static sqlite3_file *sqlite3PagerJrnlFile(Pager*);
static const char *sqlite3PagerJournalname(Pager*);
static void *sqlite3PagerTempSpace(Pager*);
static int sqlite3PagerIsMemdb(Pager*);
static void sqlite3PagerCacheStat(Pager *, int, int, u64*);
static void sqlite3PagerClearCache(Pager*);
static int sqlite3SectorSize(sqlite3_file *);


static void sqlite3PagerTruncateImage(Pager*,Pgno);

static void sqlite3PagerRekey(DbPage*, Pgno, u16);
# 16670 "c_tests/sqlite3.c"
typedef struct Btree Btree;
typedef struct BtCursor BtCursor;
typedef struct BtShared BtShared;
typedef struct BtreePayload BtreePayload;


static int sqlite3BtreeOpen(
  sqlite3_vfs *pVfs,
  const char *zFilename,
  sqlite3 *db,
  Btree **ppBtree,
  int flags,
  int vfsFlags
);
# 16696 "c_tests/sqlite3.c"
static int sqlite3BtreeClose(Btree*);
static int sqlite3BtreeSetCacheSize(Btree*,int);
static int sqlite3BtreeSetSpillSize(Btree*,int);

static int sqlite3BtreeSetMmapLimit(Btree*,sqlite3_int64);

static int sqlite3BtreeSetPagerFlags(Btree*,unsigned);
static int sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix);
static int sqlite3BtreeGetPageSize(Btree*);
static Pgno sqlite3BtreeMaxPageCount(Btree*,Pgno);
static Pgno sqlite3BtreeLastPage(Btree*);
static int sqlite3BtreeSecureDelete(Btree*,int);
static int sqlite3BtreeGetRequestedReserve(Btree*);
static int sqlite3BtreeGetReserveNoMutex(Btree *p);
static int sqlite3BtreeSetAutoVacuum(Btree *, int);
static int sqlite3BtreeGetAutoVacuum(Btree *);
static int sqlite3BtreeBeginTrans(Btree*,int,int*);
static int sqlite3BtreeCommitPhaseOne(Btree*, const char*);
static int sqlite3BtreeCommitPhaseTwo(Btree*, int);
static int sqlite3BtreeCommit(Btree*);
static int sqlite3BtreeRollback(Btree*,int,int);
static int sqlite3BtreeBeginStmt(Btree*,int);
static int sqlite3BtreeCreateTable(Btree*, Pgno*, int flags);
static int sqlite3BtreeTxnState(Btree*);
static int sqlite3BtreeIsInBackup(Btree*);

static void *sqlite3BtreeSchema(Btree *, int, void(*)(void *));
static int sqlite3BtreeSchemaLocked(Btree *pBtree);

static int sqlite3BtreeLockTable(Btree *pBtree, int iTab, u8 isWriteLock);




static int sqlite3BtreeSavepoint(Btree *, int, int);



static int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);


static const char *sqlite3BtreeGetFilename(Btree *);
static const char *sqlite3BtreeGetJournalname(Btree *);
static int sqlite3BtreeCopyFile(Btree *, Btree *);

static int sqlite3BtreeIncrVacuum(Btree *);
# 16756 "c_tests/sqlite3.c"
static int sqlite3BtreeDropTable(Btree*, int, int*);
static int sqlite3BtreeClearTable(Btree*, int, i64*);
static int sqlite3BtreeClearTableOfCursor(BtCursor*);
static int sqlite3BtreeTripAllCursors(Btree*, int, int);

static void sqlite3BtreeGetMeta(Btree *pBtree, int idx, u32 *pValue);
static int sqlite3BtreeUpdateMeta(Btree*, int idx, u32 value);

static int sqlite3BtreeNewDb(Btree *p);
# 16865 "c_tests/sqlite3.c"
static int sqlite3BtreeCursor(
  Btree*,
  Pgno iTable,
  int wrFlag,
  struct KeyInfo*,
  BtCursor *pCursor
);
static BtCursor *sqlite3BtreeFakeValidCursor(void);
static int sqlite3BtreeCursorSize(void);



static void sqlite3BtreeCursorZero(BtCursor*);
static void sqlite3BtreeCursorHintFlags(BtCursor*, unsigned);




static int sqlite3BtreeCloseCursor(BtCursor*);
static int sqlite3BtreeTableMoveto(
  BtCursor*,
  i64 intKey,
  int bias,
  int *pRes
);
static int sqlite3BtreeIndexMoveto(
  BtCursor*,
  UnpackedRecord *pUnKey,
  int *pRes
);
static int sqlite3BtreeCursorHasMoved(BtCursor*);
static int sqlite3BtreeCursorRestore(BtCursor*, int*);
static int sqlite3BtreeDelete(BtCursor*, u8 flags);
# 16938 "c_tests/sqlite3.c"
struct BtreePayload {
  const void *pKey;
  sqlite3_int64 nKey;
  const void *pData;
  sqlite3_value *aMem;
  u16 nMem;
  int nData;
  int nZero;
};

static int sqlite3BtreeInsert(BtCursor*, const BtreePayload *pPayload,
                       int flags, int seekResult);
static int sqlite3BtreeFirst(BtCursor*, int *pRes);
static int sqlite3BtreeIsEmpty(BtCursor *pCur, int *pRes);
static int sqlite3BtreeLast(BtCursor*, int *pRes);
static int sqlite3BtreeNext(BtCursor*, int flags);
static int sqlite3BtreeEof(BtCursor*);
static int sqlite3BtreePrevious(BtCursor*, int flags);
static i64 sqlite3BtreeIntegerKey(BtCursor*);
static void sqlite3BtreeCursorPin(BtCursor*);
static void sqlite3BtreeCursorUnpin(BtCursor*);
static i64 sqlite3BtreeOffset(BtCursor*);
static int sqlite3BtreePayload(BtCursor*, u32 offset, u32 amt, void*);
static const void *sqlite3BtreePayloadFetch(BtCursor*, u32 *pAmt);
static u32 sqlite3BtreePayloadSize(BtCursor*);
static sqlite3_int64 sqlite3BtreeMaxRecordSize(BtCursor*);

static int sqlite3BtreeIntegrityCheck(
  sqlite3 *db,
  Btree *p,
  Pgno *aRoot,
  sqlite3_value *aCnt,
  int nRoot,
  int mxErr,
  int *pnErr,
  char **pzOut
);
static struct Pager *sqlite3BtreePager(Btree*);
static i64 sqlite3BtreeRowCountEst(BtCursor*);


static int sqlite3BtreePayloadChecked(BtCursor*, u32 offset, u32 amt, void*);
static int sqlite3BtreePutData(BtCursor*, u32 offset, u32 amt, void*);
static void sqlite3BtreeIncrblobCursor(BtCursor *);

static void sqlite3BtreeClearCursor(BtCursor *);
static int sqlite3BtreeSetVersion(Btree *pBt, int iVersion);
static int sqlite3BtreeCursorHasHint(BtCursor*, unsigned int mask);
static int sqlite3BtreeIsReadonly(Btree *pBt);
static int sqlite3HeaderSizeBtree(void);
# 16998 "c_tests/sqlite3.c"
static int sqlite3BtreeCursorIsValidNN(BtCursor*);

static int sqlite3BtreeCount(sqlite3*, BtCursor*, i64*);







static int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);


static int sqlite3BtreeTransferRow(BtCursor*, BtCursor*, i64);

static void sqlite3BtreeClearCache(Btree*);







static void sqlite3BtreeEnter(Btree*);
static void sqlite3BtreeEnterAll(sqlite3*);
static int sqlite3BtreeSharable(Btree*);
static void sqlite3BtreeEnterCursor(BtCursor*);
static int sqlite3BtreeConnectionCount(Btree*);
# 17035 "c_tests/sqlite3.c"
static void sqlite3BtreeLeave(Btree*);
static void sqlite3BtreeLeaveCursor(BtCursor*);
static void sqlite3BtreeLeaveAll(sqlite3*);
# 17088 "c_tests/sqlite3.c"
typedef struct Vdbe Vdbe;





typedef struct sqlite3_value Mem;
typedef struct SubProgram SubProgram;
typedef struct SubrtnSig SubrtnSig;





struct SubrtnSig {
  int selId;
  u8 bComplete;
  char *zAff;
  int iTable;
  int iAddr;
  int regReturn;
};






struct VdbeOp {
  u8 opcode;
  signed char p4type;
  u16 p5;
  int p1;
  int p2;
  int p3;
  union p4union {
    int i;
    void *p;
    char *z;
    i64 *pI64;
    double *pReal;
    FuncDef *pFunc;
    sqlite3_context *pCtx;
    CollSeq *pColl;
    Mem *pMem;
    VTable *pVtab;
    KeyInfo *pKeyInfo;
    u32 *ai;
    SubProgram *pProgram;
    Table *pTab;
    SubrtnSig *pSubrtnSig;



  } p4;
# 17154 "c_tests/sqlite3.c"
};
typedef struct VdbeOp VdbeOp;





struct SubProgram {
  VdbeOp *aOp;
  int nOp;
  int nMem;
  int nCsr;
  u8 *aOnce;
  void *token;
  SubProgram *pNext;
};





struct VdbeOpList {
  u8 opcode;
  signed char p1;
  signed char p2;
  signed char p3;
};
typedef struct VdbeOpList VdbeOpList;
# 17499 "c_tests/sqlite3.c"
static Vdbe *sqlite3VdbeCreate(Parse*);
static Parse *sqlite3VdbeParser(Vdbe*);
static int sqlite3VdbeAddOp0(Vdbe*,int);
static int sqlite3VdbeAddOp1(Vdbe*,int,int);
static int sqlite3VdbeAddOp2(Vdbe*,int,int,int);
static int sqlite3VdbeGoto(Vdbe*,int);
static int sqlite3VdbeLoadString(Vdbe*,int,const char*);
static void sqlite3VdbeMultiLoad(Vdbe*,int,const char*,...);
static int sqlite3VdbeAddOp3(Vdbe*,int,int,int,int);
static int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);
static int sqlite3VdbeAddOp4Dup8(Vdbe*,int,int,int,int,const u8*,int);
static int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);
static int sqlite3VdbeAddFunctionCall(Parse*,int,int,int,int,const FuncDef*,int);
static void sqlite3VdbeEndCoroutine(Vdbe*,int);
# 17527 "c_tests/sqlite3.c"
static VdbeOp *sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp,int iLineno);

static int sqlite3VdbeExplain(Parse*,u8,const char*,...);
static void sqlite3VdbeExplainPop(Parse*);
static int sqlite3VdbeExplainParent(Parse*);
# 17552 "c_tests/sqlite3.c"
static void sqlite3VdbeAddParseSchemaOp(Vdbe*, int, char*, u16);
static void sqlite3VdbeChangeOpcode(Vdbe*, int addr, u8);
static void sqlite3VdbeChangeP1(Vdbe*, int addr, int P1);
static void sqlite3VdbeChangeP2(Vdbe*, int addr, int P2);
static void sqlite3VdbeChangeP3(Vdbe*, int addr, int P3);
static void sqlite3VdbeChangeP5(Vdbe*, u16 P5);
static void sqlite3VdbeTypeofColumn(Vdbe*, int);
static void sqlite3VdbeJumpHere(Vdbe*, int addr);
static void sqlite3VdbeJumpHereOrPopInst(Vdbe*, int addr);
static int sqlite3VdbeChangeToNoop(Vdbe*, int addr);
static int sqlite3VdbeDeletePriorOpcode(Vdbe*, u8 op);





static void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N);
static void sqlite3VdbeAppendP4(Vdbe*, void *pP4, int p4type);
static void sqlite3VdbeSetP4KeyInfo(Parse*, Index*);
static void sqlite3VdbeUsesBtree(Vdbe*, int);
static VdbeOp *sqlite3VdbeGetOp(Vdbe*, int);
static VdbeOp *sqlite3VdbeGetLastOp(Vdbe*);
static int sqlite3VdbeMakeLabel(Parse*);
static void sqlite3VdbeRunOnlyOnce(Vdbe*);
static void sqlite3VdbeReusable(Vdbe*);
static void sqlite3VdbeDelete(Vdbe*);
static void sqlite3VdbeMakeReady(Vdbe*,Parse*);
static int sqlite3VdbeFinalize(Vdbe*);
static void sqlite3VdbeResolveLabel(Vdbe*, int);
static int sqlite3VdbeCurrentAddr(Vdbe*);



static void sqlite3VdbeResetStepResult(Vdbe*);
static void sqlite3VdbeRewind(Vdbe*);
static int sqlite3VdbeReset(Vdbe*);
static void sqlite3VdbeSetNumCols(Vdbe*,int);
static int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*));
static void sqlite3VdbeCountChanges(Vdbe*);
static sqlite3 *sqlite3VdbeDb(Vdbe*);
static u8 sqlite3VdbePrepareFlags(Vdbe*);
static void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, u8);




static void sqlite3VdbeSwap(Vdbe*,Vdbe*);
static VdbeOp *sqlite3VdbeTakeOpArray(Vdbe*, int*, int*);
static sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe*, int, u8);
static void sqlite3VdbeSetVarmask(Vdbe*, int);

static char *sqlite3VdbeExpandSql(Vdbe*, const char*);

static int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*);
static int sqlite3BlobCompare(const Mem*, const Mem*);




static void sqlite3VdbeRecordUnpack(int,const void*,UnpackedRecord*);
static int sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*);
static int sqlite3VdbeRecordCompareWithSkip(int, const void *, UnpackedRecord *, int);
static UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo*);

typedef int (*RecordCompare)(int,const void*,UnpackedRecord*);
static RecordCompare sqlite3VdbeFindCompare(UnpackedRecord*);

static void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);
static int sqlite3VdbeHasSubProgram(Vdbe*);

static void sqlite3MemSetArrayInt64(sqlite3_value *aMem, int iIdx, i64 val);


static int sqlite3NotPureFunc(sqlite3_context*);
# 17761 "c_tests/sqlite3.c"
typedef struct PgHdr PgHdr;
typedef struct PCache PCache;





struct PgHdr {
  sqlite3_pcache_page *pPage;
  void *pData;
  void *pExtra;
  PCache *pCache;
  PgHdr *pDirty;
  Pager *pPager;
  Pgno pgno;



  u16 flags;






  i64 nRef;
  PgHdr *pDirtyNext;
  PgHdr *pDirtyPrev;


};
# 17805 "c_tests/sqlite3.c"
static int sqlite3PcacheInitialize(void);
static void sqlite3PcacheShutdown(void);




static void sqlite3PCacheBufferSetup(void *, int sz, int n);





static int sqlite3PcacheOpen(
  int szPage,
  int szExtra,
  int bPurgeable,
  int (*xStress)(void*, PgHdr*),
  void *pStress,
  PCache *pToInit
);


static int sqlite3PcacheSetPageSize(PCache *, int);




static int sqlite3PcacheSize(void);




static sqlite3_pcache_page *sqlite3PcacheFetch(PCache*, Pgno, int createFlag);
static int sqlite3PcacheFetchStress(PCache*, Pgno, sqlite3_pcache_page**);
static PgHdr *sqlite3PcacheFetchFinish(PCache*, Pgno, sqlite3_pcache_page *pPage);
static void sqlite3PcacheRelease(PgHdr*);

static void sqlite3PcacheDrop(PgHdr*);
static void sqlite3PcacheMakeDirty(PgHdr*);
static void sqlite3PcacheMakeClean(PgHdr*);
static void sqlite3PcacheCleanAll(PCache*);
static void sqlite3PcacheClearWritable(PCache*);


static void sqlite3PcacheMove(PgHdr*, Pgno);


static void sqlite3PcacheTruncate(PCache*, Pgno x);


static PgHdr *sqlite3PcacheDirtyList(PCache*);


static void sqlite3PcacheClose(PCache*);


static void sqlite3PcacheClearSyncFlags(PCache *);


static void sqlite3PcacheClear(PCache*);


static i64 sqlite3PcacheRefCount(PCache*);


static void sqlite3PcacheRef(PgHdr*);

static i64 sqlite3PcachePageRefcount(PgHdr*);


static int sqlite3PcachePagecount(PCache*);
# 17896 "c_tests/sqlite3.c"
static void sqlite3PcacheSetCachesize(PCache *, int);
# 17906 "c_tests/sqlite3.c"
static int sqlite3PcacheSetSpillsize(PCache *, int);


static void sqlite3PcacheShrink(PCache*);
# 17920 "c_tests/sqlite3.c"
static void sqlite3PCacheSetDefault(void);


static int sqlite3HeaderSizePcache(void);
static int sqlite3HeaderSizePcache1(void);


static int sqlite3PCachePercentDirty(PCache*);


static int sqlite3PCacheIsDirty(PCache *pCache);
# 18008 "c_tests/sqlite3.c"
           int sqlite3_mutex_held(sqlite3_mutex*);
# 18052 "c_tests/sqlite3.c"
struct Db {
  char *zDbSName;
  Btree *pBt;
  u8 safety_level;
  u8 bSyncSet;
  Schema *pSchema;
};
# 18077 "c_tests/sqlite3.c"
struct Schema {
  int schema_cookie;
  int iGeneration;
  Hash tblHash;
  Hash idxHash;
  Hash trigHash;
  Hash fkeyHash;
  Table *pSeqTab;
  u8 file_format;
  u8 enc;
  u16 schemaFlags;
  int cache_size;
};
# 18165 "c_tests/sqlite3.c"
struct Lookaside {
  u32 bDisable;
  u16 sz;
  u16 szTrue;
  u8 bMalloced;
  u32 nSlot;
  u32 anStat[3];
  LookasideSlot *pInit;
  LookasideSlot *pFree;

  LookasideSlot *pSmallInit;
  LookasideSlot *pSmallFree;
  void *pMiddle;


  void *pStart;
  void *pEnd;
  void *pTrueEnd;
};
struct LookasideSlot {
  LookasideSlot *pNext;
};
# 18208 "c_tests/sqlite3.c"
struct FuncDefHash {
  FuncDef *a[23];
};





typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,
                             const char*);
# 18240 "c_tests/sqlite3.c"
struct sqlite3 {
  sqlite3_vfs *pVfs;
  struct Vdbe *pVdbe;
  CollSeq *pDfltColl;
  sqlite3_mutex *mutex;
  Db *aDb;
  int nDb;
  u32 mDbFlags;
  u64 flags;
  i64 lastRowid;
  i64 szMmap;
  u32 nSchemaLock;
  unsigned int openFlags;
  int errCode;
  int errByteOffset;
  int errMask;
  int iSysErrno;
  u32 dbOptFlags;
  u8 enc;
  u8 autoCommit;
  u8 temp_store;
  u8 mallocFailed;
  u8 bBenignMalloc;
  u8 dfltLockMode;
  signed char nextAutovac;
  u8 suppressErr;
  u8 vtabOnConflict;
  u8 isTransactionSavepoint;
  u8 mTrace;
  u8 noSharedCache;
  u8 nSqlExec;
  u8 eOpenState;
  int nextPagesize;
  i64 nChange;
  i64 nTotalChange;
  int aLimit[(11 +1)];
  int nMaxSorterMmap;
  struct sqlite3InitInfo {
    Pgno newTnum;
    u8 iDb;
    u8 busy;
    unsigned orphanTrigger : 1;
    unsigned imposterTable : 2;
    unsigned reopenMemdb : 1;
    const char **azInit;
  } init;
  int nVdbeActive;
  int nVdbeRead;
  int nVdbeWrite;
  int nVdbeExec;
  int nVDestroy;
  int nExtension;
  void **aExtension;
  union {
    void (*xLegacy)(void*,const char*);
    int (*xV2)(u32,void*,void*,void*);
  } trace;
  void *pTraceArg;

  void (*xProfile)(void*,const char*,u64);
  void *pProfileArg;

  void *pCommitArg;
  int (*xCommitCallback)(void*);
  void *pRollbackArg;
  void (*xRollbackCallback)(void*);
  void *pUpdateArg;
  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);
  void *pAutovacPagesArg;
  void (*xAutovacDestr)(void*);
  unsigned int (*xAutovacPages)(void*,const char*,u32,u32,u32);
  Parse *pParse;
# 18320 "c_tests/sqlite3.c"
  int (*xWalCallback)(void *, sqlite3 *, const char *, int);
  void *pWalArg;

  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);
  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);
  void *pCollNeededArg;
  sqlite3_value *pErr;
  union {
    volatile int isInterrupted;
    double notUsed1;
  } u1;
  Lookaside lookaside;

  sqlite3_xauth xAuth;
  void *pAuthArg;


  int (*xProgress)(void *);
  void *pProgressArg;
  unsigned nProgressOps;


  int nVTrans;
  Hash aModule;
  VtabCtx *pVtabCtx;
  VTable **aVTrans;
  VTable *pDisconnect;

  Hash aFunc;
  Hash aCollSeq;
  BusyHandler busyHandler;
  Db aDbStatic[2];
  Savepoint *pSavepoint;
  int nAnalysisLimit;
  int busyTimeout;




  int nSavepoint;
  int nStatement;
  i64 nDeferredCons;
  i64 nDeferredImmCons;
  int *pnBytesFreed;
  DbClientData *pDbData;
  u64 nSpill;
# 18383 "c_tests/sqlite3.c"
};
# 18545 "c_tests/sqlite3.c"
struct FuncDef {
  i16 nArg;
  u32 funcFlags;
  void *pUserData;
  FuncDef *pNext;
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**);
  void (*xFinalize)(sqlite3_context*);
  void (*xValue)(sqlite3_context*);
  void (*xInverse)(sqlite3_context*,int,sqlite3_value**);
  const char *zName;
  union {
    FuncDef *pHash;
    FuncDestructor *pDestructor;
  } u;
};
# 18575 "c_tests/sqlite3.c"
struct FuncDestructor {
  int nRef;
  void (*xDestroy)(void *);
  void *pUserData;
};
# 18767 "c_tests/sqlite3.c"
struct Savepoint {
  char *zName;
  i64 nDeferredCons;
  i64 nDeferredImmCons;
  Savepoint *pNext;
};
# 18788 "c_tests/sqlite3.c"
struct Module {
  const sqlite3_module *pModule;
  const char *zName;
  int nRefModule;
  void *pAux;
  void (*xDestroy)(void *);
  Table *pEpoTab;
};
# 18822 "c_tests/sqlite3.c"
struct Column {
  char *zCnName;
  unsigned notNull :4;
  unsigned eCType :4;
  char affinity;
  u8 szEst;
  u8 hName;
  u16 iDflt;
  u16 colFlags;
};
# 18879 "c_tests/sqlite3.c"
struct CollSeq {
  char *zName;
  u8 enc;
  void *pUser;
  int (*xCmp)(void*,int, const void*, int, const void*);
  void (*xDel)(void*);
};
# 18980 "c_tests/sqlite3.c"
struct VTable {
  sqlite3 *db;
  Module *pMod;
  sqlite3_vtab *pVtab;
  int nRef;
  u8 bConstraint;
  u8 bAllSchemas;
  u8 eVtabRisk;
  int iSavepoint;
  VTable *pNext;
};
# 19002 "c_tests/sqlite3.c"
struct Table {
  char *zName;
  Column *aCol;
  Index *pIndex;
  char *zColAff;
  ExprList *pCheck;

  Pgno tnum;
  u32 nTabRef;
  u32 tabFlags;
  i16 iPKey;
  i16 nCol;
  i16 nNVCol;
  LogEst nRowLogEst;
  LogEst szTabRow;



  u8 keyConf;
  u8 eTabType;
  union {
    struct {
      int addColOffset;
      FKey *pFKey;
      ExprList *pDfltList;

    } tab;
    struct {
      Select *pSelect;
    } view;
    struct {
      int nArg;
      char **azArg;
      VTable *p;
    } vtab;
  } u;
  Trigger *pTrigger;
  Schema *pSchema;
  u8 aHx[16];
};
# 19161 "c_tests/sqlite3.c"
struct FKey {
  Table *pFrom;
  FKey *pNextFrom;
  char *zTo;
  FKey *pNextTo;
  FKey *pPrevTo;
  int nCol;

  u8 isDeferred;
  u8 aAction[2];
  Trigger *apTrigger[2];
  struct sColMap {
    int iFrom;
    char *zCol;
  } aCol[];
};
# 19242 "c_tests/sqlite3.c"
struct KeyInfo {
  u32 nRef;
  u8 enc;
  u16 nKeyField;
  u16 nAllField;
  sqlite3 *db;
  u8 *aSortFlags;
  CollSeq *aColl[];
};
# 19304 "c_tests/sqlite3.c"
struct UnpackedRecord {
  KeyInfo *pKeyInfo;
  Mem *aMem;
  union {
    char *z;
    i64 i;
  } u;
  int n;
  u16 nField;
  i8 default_rc;
  u8 errCode;
  i8 r1;
  i8 r2;
  u8 eqSeen;
};
# 19367 "c_tests/sqlite3.c"
struct Index {
  char *zName;
  i16 *aiColumn;
  LogEst *aiRowLogEst;
  Table *pTable;
  char *zColAff;
  Index *pNext;
  Schema *pSchema;
  u8 *aSortOrder;
  const char **azColl;
  Expr *pPartIdxWhere;
  ExprList *aColExpr;
  Pgno tnum;
  LogEst szIdxRow;
  u16 nKeyCol;
  u16 nColumn;
  u8 onError;
  unsigned idxType:2;
  unsigned bUnordered:1;
  unsigned uniqNotNull:1;
  unsigned isResized:1;
  unsigned isCovering:1;
  unsigned noSkipScan:1;
  unsigned hasStat1:1;
  unsigned bNoQuery:1;
  unsigned bAscKeyBug:1;
  unsigned bHasVCol:1;
  unsigned bHasExpr:1;
# 19405 "c_tests/sqlite3.c"
  Bitmask colNotIdxed;
};
# 19433 "c_tests/sqlite3.c"
struct IndexSample {
  void *p;
  int n;
  tRowcnt *anEq;
  tRowcnt *anLt;
  tRowcnt *anDLt;
};
# 19457 "c_tests/sqlite3.c"
struct Token {
  const char *z;
  unsigned int n;
};
# 19475 "c_tests/sqlite3.c"
struct AggInfo {
  u8 directMode;

  u8 useSortingIdx;

  u32 nSortingColumn;
  int sortingIdx;
  int sortingIdxPTab;
  int iFirstReg;
  ExprList *pGroupBy;
  struct AggInfo_col {
    Table *pTab;
    Expr *pCExpr;
    int iTable;
    int iColumn;
    int iSorterColumn;
  } *aCol;
  int nColumn;
  int nAccumulator;


  struct AggInfo_func {
    Expr *pFExpr;
    FuncDef *pFunc;
    int iDistinct;
    int iDistAddr;
    int iOBTab;
    u8 bOBPayload;
    u8 bOBUnique;
    u8 bUseSubtype;
  } *aFunc;
  int nFunc;
  u32 selId;



};
# 19541 "c_tests/sqlite3.c"
typedef i16 ynVar;
# 19609 "c_tests/sqlite3.c"
struct Expr {
  u8 op;
  char affExpr;
  u8 op2;






  u32 flags;
  union {
    char *zToken;
    int iValue;
  } u;






  Expr *pLeft;
  Expr *pRight;
  union {
    ExprList *pList;
    Select *pSelect;
  } x;







  int nHeight;

  int iTable;






  ynVar iColumn;


  i16 iAgg;
  union {
    int iJoin;
    int iOfst;
  } w;
  AggInfo *pAggInfo;
  union {
    Table *pTab;

    Window *pWin;
    int nReg;
    struct {
      int iAddr;
      int regReturn;
    } sub;
  } y;
};
# 19809 "c_tests/sqlite3.c"
struct ExprList {
  int nExpr;
  int nAlloc;
  struct ExprList_item {
    Expr *pExpr;
    char *zEName;
    struct {
      u8 sortFlags;
      unsigned eEName :2;
      unsigned done :1;
      unsigned reusable :1;
      unsigned bSorterRef :1;
      unsigned bNulls :1;
      unsigned bUsed :1;
      unsigned bUsingTerm:1;
      unsigned bNoExpand: 1;

    } fg;
    union {
      struct {
        u16 iOrderByCol;
        u16 iAlias;
      } x;
      int iConstExprReg;

    } u;
  } a[];
};
# 19866 "c_tests/sqlite3.c"
struct IdList {
  int nId;
  struct IdList_item {
    char *zName;
  } a[];
};
# 19887 "c_tests/sqlite3.c"
struct Subquery {
  Select *pSelect;
  int addrFillSub;
  int regReturn;
  int regResult;
};
# 19931 "c_tests/sqlite3.c"
struct SrcItem {
  char *zName;
  char *zAlias;
  Table *pSTab;
  struct {
    u8 jointype;
    unsigned notIndexed :1;
    unsigned isIndexedBy :1;
    unsigned isSubquery :1;
    unsigned isTabFunc :1;
    unsigned isCorrelated :1;
    unsigned isMaterialized:1;
    unsigned viaCoroutine :1;
    unsigned isRecursive :1;
    unsigned fromDDL :1;
    unsigned isCte :1;
    unsigned notCte :1;
    unsigned isUsing :1;
    unsigned isOn :1;
    unsigned isSynthUsing :1;
    unsigned isNestedFrom :1;
    unsigned rowidUsed :1;
    unsigned fixedSchema :1;
    unsigned hadSchema :1;
    unsigned fromExists :1;
  } fg;
  int iCursor;
  Bitmask colUsed;
  union {
    char *zIndexedBy;
    ExprList *pFuncArg;
    u32 nRow;
  } u1;
  union {
    Index *pIBIndex;
    CteUse *pCteUse;
  } u2;
  union {
    Expr *pOn;
    IdList *pUsing;
  } u3;
  union {
    Schema *pSchema;
    char *zDatabase;
    Subquery *pSubq;
  } u4;
};





struct OnOrUsing {
  Expr *pOn;
  IdList *pUsing;
};
# 19995 "c_tests/sqlite3.c"
struct SrcList {
  int nSrc;
  u32 nAlloc;
  SrcItem a[];
};
# 20076 "c_tests/sqlite3.c"
struct NameContext {
  Parse *pParse;
  SrcList *pSrcList;
  union {
    ExprList *pEList;
    AggInfo *pAggInfo;
    Upsert *pUpsert;
    int iBaseReg;
  } uNC;
  NameContext *pNext;
  int nRef;
  int nNcErr;
  int ncFlags;
  u32 nNestedSelect;
  Select *pWinSelect;
};
# 20140 "c_tests/sqlite3.c"
struct Upsert {
  ExprList *pUpsertTarget;
  Expr *pUpsertTargetWhere;
  ExprList *pUpsertSet;
  Expr *pUpsertWhere;
  Upsert *pNextUpsert;
  u8 isDoUpdate;
  u8 isDup;


  void *pToFree;





  Index *pUpsertIdx;
  SrcList *pUpsertSrc;
  int regData;
  int iDataCur;
  int iIdxCur;
};
# 20180 "c_tests/sqlite3.c"
struct Select {
  u8 op;
  LogEst nSelectRow;
  u32 selFlags;
  int iLimit, iOffset;
  u32 selId;
  int addrOpenEphm[2];
  ExprList *pEList;
  SrcList *pSrc;
  Expr *pWhere;
  ExprList *pGroupBy;
  Expr *pHaving;
  ExprList *pOrderBy;
  Select *pPrior;
  Select *pNext;
  Expr *pLimit;
  With *pWith;

  Window *pWin;
  Window *pWinDefn;

};
# 20352 "c_tests/sqlite3.c"
struct SelectDest {
  u8 eDest;
  int iSDParm;
  int iSDParm2;
  int iSdst;
  int nSdst;
  char *zAffSdst;
  ExprList *pOrderBy;
};
# 20371 "c_tests/sqlite3.c"
struct AutoincInfo {
  AutoincInfo *pNext;
  Table *pTab;
  int iDb;
  int regCtr;
};
# 20396 "c_tests/sqlite3.c"
struct TriggerPrg {
  Trigger *pTrigger;
  TriggerPrg *pNext;
  SubProgram *pProgram;
  int orconf;
  u32 aColmask[2];
};
# 20415 "c_tests/sqlite3.c"
  typedef unsigned int yDbMask;
# 20433 "c_tests/sqlite3.c"
struct IndexedExpr {
  Expr *pExpr;
  int iDataCur;
  int iIdxCur;
  int iIdxCol;
  u8 bMaybeNullRow;
  u8 aff;
  IndexedExpr *pIENext;



};






struct ParseCleanup {
  ParseCleanup *pNext;
  void *pPtr;
  void (*xCleanup)(sqlite3*,void*);
};
# 20473 "c_tests/sqlite3.c"
struct Parse {
  sqlite3 *db;
  char *zErrMsg;
  Vdbe *pVdbe;
  int rc;
  LogEst nQueryLoop;
  u8 nested;
  u8 nTempReg;
  u8 isMultiWrite;
  u8 mayAbort;
  u8 hasCompound;
  u8 disableLookaside;
  u8 prepFlags;
  u8 withinRJSubrtn;
  u8 bHasExists;
  u8 mSubrtnSig;
  u8 eTriggerOp;
  u8 bReturning;
  u8 eOrconf;
  u8 disableTriggers;
# 20501 "c_tests/sqlite3.c"
  bft colNamesSet :1;
  bft bHasWith :1;
  bft okConstFactor :1;
  bft checkSchema :1;
  int nRangeReg;
  int iRangeReg;
  int nErr;
  int nTab;
  int nMem;
  int szOpAlloc;
  int iSelfTab;

  int nLabel;
  int nLabelAlloc;
  int *aLabel;
  ExprList *pConstExpr;
  IndexedExpr *pIdxEpr;
  IndexedExpr *pIdxPartExpr;
  yDbMask writeMask;
  yDbMask cookieMask;
  int nMaxArg;
  int nSelect;

  u32 nProgressSteps;


  int nTableLock;
  TableLock *aTableLock;

  AutoincInfo *pAinc;
  Parse *pToplevel;
  Table *pTriggerTab;
  TriggerPrg *pTriggerPrg;
  ParseCleanup *pCleanup;
# 20543 "c_tests/sqlite3.c"
  int aTempReg[8];
  Parse *pOuterParse;
  Token sNameToken;
  u32 oldmask;
  u32 newmask;
  union {
    struct {
      int addrCrTab;
      int regRowid;
      int regRoot;
      Token constraintName;
    } cr;
    struct {
      Returning *pReturning;
    } d;
  } u1;
# 20567 "c_tests/sqlite3.c"
  Token sLastToken;
  ynVar nVar;
  u8 iPkSortOrder;
  u8 explain;
  u8 eParseMode;

  int nVtabLock;

  int nHeight;
  int addrExplain;
  VList *pVList;
  Vdbe *pReprepare;
  const char *zTail;
  Table *pNewTable;
  Index *pNewIndex;


  Trigger *pNewTrigger;
  const char *zAuthContext;

  Token sArg;
  Table **apVtabLock;

  With *pWith;

  RenameToken *pRename;

};
# 20637 "c_tests/sqlite3.c"
struct AuthContext {
  const char *zAuthContext;
  Parse *pParse;
};
# 20691 "c_tests/sqlite3.c"
struct Trigger {
  char *zName;
  char *table;
  u8 op;
  u8 tr_tm;
  u8 bReturning;
  Expr *pWhen;
  IdList *pColumns;

  Schema *pSchema;
  Schema *pTabSchema;
  TriggerStep *step_list;
  Trigger *pNext;
};
# 20759 "c_tests/sqlite3.c"
struct TriggerStep {
  u8 op;

  u8 orconf;
  Trigger *pTrig;
  Select *pSelect;
  char *zTarget;
  SrcList *pFrom;
  Expr *pWhere;
  ExprList *pExprList;
  IdList *pIdList;
  Upsert *pUpsert;
  char *zSpan;
  TriggerStep *pNext;
  TriggerStep *pLast;
};




struct Returning {
  Parse *pParse;
  ExprList *pReturnEL;
  Trigger retTrig;
  TriggerStep retTStep;
  int iRetCur;
  int nRetCol;
  int iRetReg;
  char zName[40];
};





struct sqlite3_str {
  sqlite3 *db;
  char *zText;
  u32 nAlloc;
  u32 mxAlloc;
  u32 nChar;
  u8 accError;
  u8 printfFlags;
};
# 20827 "c_tests/sqlite3.c"
struct RCStr {
  u64 nRCRef;

};





typedef struct {
  sqlite3 *db;
  char **pzErrMsg;
  int iDb;
  int rc;
  u32 mInitFlags;
  u32 nInitRow;
  Pgno mxPage;
} InitData;
# 20875 "c_tests/sqlite3.c"
struct Sqlite3Config {
  int bMemstat;
  u8 bCoreMutex;
  u8 bFullMutex;
  u8 bOpenUri;
  u8 bUseCis;
  u8 bSmallMalloc;
  u8 bExtraSchemaChecks;



  int mxStrlen;
  int neverCorrupt;
  int szLookaside;
  int nLookaside;
  int nStmtSpill;
  sqlite3_mem_methods m;
  sqlite3_mutex_methods mutex;
  sqlite3_pcache_methods2 pcache2;
  void *pHeap;
  int nHeap;
  int mnReq, mxReq;
  sqlite3_int64 szMmap;
  sqlite3_int64 mxMmap;
  void *pPage;
  int szPage;
  int nPage;
  int mxParserStack;
  int sharedCacheEnabled;
  u32 szPma;


  int isInit;
  int inProgress;
  int isMutexInit;
  int isMallocInit;
  int isPCacheInit;
  int nRefInitMutex;
  sqlite3_mutex *pInitMutex;
  void (*xLog)(void*,int,const char*);
  void *pLogArg;
# 20928 "c_tests/sqlite3.c"
  sqlite3_int64 mxMemdbSize;


  int (*xTestCallback)(int);






  int bLocaltimeFault;
  int (*xAltLocaltime)(const void*,void*);
  int iOnceResetThreshold;
  u32 szSorterRef;
  unsigned int iPrngSeed;




};
# 20970 "c_tests/sqlite3.c"
struct Walker {
  Parse *pParse;
  int (*xExprCallback)(Walker*, Expr*);
  int (*xSelectCallback)(Walker*,Select*);
  void (*xSelectCallback2)(Walker*,Select*);
  int walkerDepth;
  u16 eCode;
  u16 mWFlags;
  union {
    NameContext *pNC;
    int n;
    int iCur;
    SrcList *pSrcList;
    struct CCurHint *pCCurHint;
    struct RefSrcList *pRefSrcList;
    int *aiCol;
    struct IdxCover *pIdxCover;
    ExprList *pGroupBy;
    Select *pSelect;
    struct WindowRewrite *pRewrite;
    struct WhereConst *pConst;
    struct RenameCtx *pRename;
    struct Table *pTab;
    struct CoveringIndexCheck *pCovIdxCk;
    SrcItem *pSrcItem;
    DbFixer *pFix;
    Mem *aMem;
    struct CheckOnCtx *pCheckOnCtx;
  } u;
};






struct DbFixer {
  Parse *pParse;
  Walker w;
  Schema *pSchema;
  u8 bTemp;
  const char *zDb;
  const char *zType;
  const Token *pName;
};


static int sqlite3WalkExpr(Walker*, Expr*);
static int sqlite3WalkExprNN(Walker*, Expr*);
static int sqlite3WalkExprList(Walker*, ExprList*);
static int sqlite3WalkSelect(Walker*, Select*);
static int sqlite3WalkSelectExpr(Walker*, Select*);
static int sqlite3WalkSelectFrom(Walker*, Select*);
static int sqlite3ExprWalkNoop(Walker*, Expr*);
static int sqlite3SelectWalkNoop(Walker*, Select*);
static int sqlite3SelectWalkFail(Walker*, Select*);
static int sqlite3WalkerDepthIncrease(Walker*,Select*);
static void sqlite3WalkerDepthDecrease(Walker*,Select*);
static void sqlite3WalkWinDefnDummyCallback(Walker*,Select*);






static void sqlite3SelectPopWith(Walker*, Select*);
# 21051 "c_tests/sqlite3.c"
struct Cte {
  char *zName;
  ExprList *pCols;
  Select *pSelect;
  const char *zCteErr;
  CteUse *pUse;
  u8 eM10d;
};
# 21071 "c_tests/sqlite3.c"
struct With {
  int nCte;
  int bView;
  With *pOuter;
  Cte a[];
};
# 21093 "c_tests/sqlite3.c"
struct CteUse {
  int nUse;
  int addrM9e;
  int regRtn;
  int iCur;
  LogEst nRowEst;
  u8 eM10d;
};





struct DbClientData {
  DbClientData *pNext;
  void *pData;
  void (*xDestructor)(void*);
  char zName[];
};
# 21151 "c_tests/sqlite3.c"
struct Window {
  char *zName;
  char *zBase;
  ExprList *pPartition;
  ExprList *pOrderBy;
  u8 eFrmType;
  u8 eStart;
  u8 eEnd;
  u8 bImplicitFrame;
  u8 eExclude;
  Expr *pStart;
  Expr *pEnd;
  Window **ppThis;
  Window *pNextWin;
  Expr *pFilter;
  FuncDef *pWFunc;
  int iEphCsr;
  int regAccum;
  int regResult;
  int csrApp;
  int regApp;
  int regPart;
  Expr *pOwner;
  int nBufferCol;
  int iArgCol;
  int regOne;
  int regStartRowid;
  int regEndRowid;
  u8 bExprArgs;

};

static Select *sqlite3MultiValues(Parse *pParse, Select *pLeft, ExprList *pRow);
static void sqlite3MultiValuesEnd(Parse *pParse, Select *pVal);


static void sqlite3WindowDelete(sqlite3*, Window*);
static void sqlite3WindowUnlinkFromSelect(Window*);
static void sqlite3WindowListDelete(sqlite3 *db, Window *p);
static Window *sqlite3WindowAlloc(Parse*, int, int, Expr*, int , Expr*, u8);
static void sqlite3WindowAttach(Parse*, Expr*, Window*);
static void sqlite3WindowLink(Select *pSel, Window *pWin);
static int sqlite3WindowCompare(const Parse*, const Window*, const Window*, int);
static void sqlite3WindowCodeInit(Parse*, Select*);
static void sqlite3WindowCodeStep(Parse*, Select*, WhereInfo*, int, int);
static int sqlite3WindowRewrite(Parse*, Select*);
static void sqlite3WindowUpdate(Parse*, Window*, Window*, FuncDef*);
static Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p);
static Window *sqlite3WindowListDup(sqlite3 *db, Window *p);
static void sqlite3WindowFunctions(void);
static void sqlite3WindowChain(Parse*, Window*, Window*);
static Window *sqlite3WindowAssemble(Parse*, Window*, ExprList*, ExprList*, Token*);
# 21226 "c_tests/sqlite3.c"
static int sqlite3ReportError(int iErr, int lineno, const char *zType);
static int sqlite3CorruptError(int);
static int sqlite3MisuseError(int);
static int sqlite3CantopenError(int);
# 21294 "c_tests/sqlite3.c"
static int sqlite3IsIdChar(u8);




static int sqlite3StrICmp(const char*,const char*);
static int sqlite3Strlen30(const char*);

static char *sqlite3ColumnType(Column*,char*);


static int sqlite3MallocInit(void);
static void sqlite3MallocEnd(void);
static void *sqlite3Malloc(u64);
static void *sqlite3MallocZero(u64);
static void *sqlite3DbMallocZero(sqlite3*, u64);
static void *sqlite3DbMallocRaw(sqlite3*, u64);
static void *sqlite3DbMallocRawNN(sqlite3*, u64);
static char *sqlite3DbStrDup(sqlite3*,const char*);
static char *sqlite3DbStrNDup(sqlite3*,const char*, u64);
static char *sqlite3DbSpanDup(sqlite3*,const char*,const char*);
static void *sqlite3Realloc(void*, u64);
static void *sqlite3DbReallocOrFree(sqlite3 *, void *, u64);
static void *sqlite3DbRealloc(sqlite3 *, void *, u64);
static void sqlite3DbFree(sqlite3*, void*);
static void sqlite3DbFreeNN(sqlite3*, void*);
static void sqlite3DbNNFreeNN(sqlite3*, void*);
static int sqlite3MallocSize(const void*);
static int sqlite3DbMallocSize(sqlite3*, const void*);
static void *sqlite3PageMalloc(int);
static void sqlite3PageFree(void*);
static void sqlite3MemSetDefault(void);

static void sqlite3BenignMallocHooks(void (*)(void), void (*)(void));

static int sqlite3HeapNearlyFull(void);
# 21364 "c_tests/sqlite3.c"
static sqlite3_mutex_methods const *sqlite3DefaultMutex(void);
static sqlite3_mutex_methods const *sqlite3NoopMutex(void);
static sqlite3_mutex *sqlite3MutexAlloc(int);
static int sqlite3MutexInit(void);
static int sqlite3MutexEnd(void);


static void sqlite3MemoryBarrier(void);




static sqlite3_int64 sqlite3StatusValue(int);
static void sqlite3StatusUp(int, int);
static void sqlite3StatusDown(int, int);
static void sqlite3StatusHighwater(int, int);
static int sqlite3LookasideUsed(sqlite3*,int*);


static sqlite3_mutex *sqlite3Pcache1Mutex(void);
static sqlite3_mutex *sqlite3MallocMutex(void);
# 21397 "c_tests/sqlite3.c"
static int sqlite3IsNaN(double);
static int sqlite3IsOverflow(double);
# 21409 "c_tests/sqlite3.c"
struct PrintfArguments {
  int nArg;
  int nUsed;
  sqlite3_value **apArg;
};





struct FpDecode {
  char sign;
  char isSpecial;
  int n;
  int iDP;
  char *z;
  char zBuf[24];
};

static void sqlite3FpDecode(FpDecode*,double,int,int);
static char *sqlite3MPrintf(sqlite3*,const char*, ...);
static char *sqlite3VMPrintf(sqlite3*,const char*, va_list);
# 21488 "c_tests/sqlite3.c"
static void sqlite3SetString(char **, sqlite3*, const char*);
static void sqlite3ProgressCheck(Parse*);
static void sqlite3ErrorMsg(Parse*, const char*, ...);
static int sqlite3ErrorToParser(sqlite3*,int);
static void sqlite3Dequote(char*);
static void sqlite3DequoteExpr(Expr*);
static void sqlite3DequoteToken(Token*);
static void sqlite3DequoteNumber(Parse*, Expr*);
static void sqlite3TokenInit(Token*,char*);
static int sqlite3KeywordCode(const unsigned char*, int);
static int sqlite3RunParser(Parse*, const char*);
static void sqlite3FinishCoding(Parse*);
static int sqlite3GetTempReg(Parse*);
static void sqlite3ReleaseTempReg(Parse*,int);
static int sqlite3GetTempRange(Parse*,int);
static void sqlite3ReleaseTempRange(Parse*,int,int);
static void sqlite3ClearTempRegCache(Parse*);
static void sqlite3TouchRegister(Parse*,int);






static Expr *sqlite3ExprAlloc(sqlite3*,int,const Token*,int);
static Expr *sqlite3Expr(sqlite3*,int,const char*);
static void sqlite3ExprAttachSubtrees(sqlite3*,Expr*,Expr*,Expr*);
static Expr *sqlite3PExpr(Parse*, int, Expr*, Expr*);
static void sqlite3PExprAddSelect(Parse*, Expr*, Select*);
static Expr *sqlite3ExprAnd(Parse*,Expr*, Expr*);
static Expr *sqlite3ExprSimplifiedAndOr(Expr*);
static Expr *sqlite3ExprFunction(Parse*,ExprList*, const Token*, int);
static void sqlite3ExprAddFunctionOrderBy(Parse*,Expr*,ExprList*);
static void sqlite3ExprOrderByAggregateError(Parse*,Expr*);
static void sqlite3ExprFunctionUsable(Parse*,const Expr*,const FuncDef*);
static void sqlite3ExprAssignVarNumber(Parse*, Expr*, u32);
static void sqlite3ExprDelete(sqlite3*, Expr*);
static void sqlite3ExprDeleteGeneric(sqlite3*,void*);
static int sqlite3ExprDeferredDelete(Parse*, Expr*);
static void sqlite3ExprUnmapAndDelete(Parse*, Expr*);
static ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);
static ExprList *sqlite3ExprListAppendVector(Parse*,ExprList*,IdList*,Expr*);
static Select *sqlite3ExprListToValues(Parse*, int, ExprList*);
static void sqlite3ExprListSetSortOrder(ExprList*,int,int);
static void sqlite3ExprListSetName(Parse*,ExprList*,const Token*,int);
static void sqlite3ExprListSetSpan(Parse*,ExprList*,const char*,const char*);
static void sqlite3ExprListDelete(sqlite3*, ExprList*);
static void sqlite3ExprListDeleteGeneric(sqlite3*,void*);
static u32 sqlite3ExprListFlags(const ExprList*);
static int sqlite3IndexHasDuplicateRootPage(Index*);
static int sqlite3Init(sqlite3*, char**);
static int sqlite3InitCallback(void*, int, char**, char**);
static int sqlite3InitOne(sqlite3*, int, char**, u32);
static void sqlite3Pragma(Parse*,Token*,Token*,Token*,int);

static Module *sqlite3PragmaVtabRegister(sqlite3*,const char *zName);

static void sqlite3ResetAllSchemasOfConnection(sqlite3*);
static void sqlite3ResetOneSchema(sqlite3*,int);
static void sqlite3CollapseDatabaseArray(sqlite3*);
static void sqlite3CommitInternalChanges(sqlite3*);
static void sqlite3ColumnSetExpr(Parse*,Table*,Column*,Expr*);
static Expr *sqlite3ColumnExpr(Table*,Column*);
static void sqlite3ColumnSetColl(sqlite3*,Column*,const char*zColl);
static const char *sqlite3ColumnColl(Column*);
static void sqlite3DeleteColumnNames(sqlite3*,Table*);
static void sqlite3GenerateColumnNames(Parse *pParse, Select *pSelect);
static int sqlite3ColumnsFromExprList(Parse*,ExprList*,i16*,Column**);
static void sqlite3SubqueryColumnTypes(Parse*,Table*,Select*,char);
static Table *sqlite3ResultSetOfSelect(Parse*,Select*,char);
static void sqlite3OpenSchemaTable(Parse *, int);
static Index *sqlite3PrimaryKeyIndex(Table*);
static int sqlite3TableColumnToIndex(Index*, int);




static i16 sqlite3TableColumnToStorage(Table*, i16);
static i16 sqlite3StorageColumnToTable(Table*, i16);

static void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);





static void sqlite3AddColumn(Parse*,Token,Token);
static void sqlite3AddNotNull(Parse*, int);
static void sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int);
static void sqlite3AddCheckConstraint(Parse*, Expr*, const char*, const char*);
static void sqlite3AddDefaultValue(Parse*,Expr*,const char*,const char*);
static void sqlite3AddCollateType(Parse*, Token*);
static void sqlite3AddGenerated(Parse*,Expr*,Token*);
static void sqlite3EndTable(Parse*,Token*,Token*,u32,Select*);
static void sqlite3AddReturning(Parse*,ExprList*);
static int sqlite3ParseUri(const char*,const char*,unsigned int*,
                    sqlite3_vfs**,char**,char **);

static Btree *sqlite3DbNameToBtree(sqlite3*,const char*);




static int sqlite3FaultSim(int);


static Bitvec *sqlite3BitvecCreate(u32);
static int sqlite3BitvecTest(Bitvec*, u32);
static int sqlite3BitvecTestNotNull(Bitvec*, u32);
static int sqlite3BitvecSet(Bitvec*, u32);
static void sqlite3BitvecClear(Bitvec*, u32, void*);
static void sqlite3BitvecDestroy(Bitvec*);
static u32 sqlite3BitvecSize(Bitvec*);

static int sqlite3BitvecBuiltinTest(int,int*);


static RowSet *sqlite3RowSetInit(sqlite3*);
static void sqlite3RowSetDelete(void*);
static void sqlite3RowSetClear(void*);
static void sqlite3RowSetInsert(RowSet*, i64);
static int sqlite3RowSetTest(RowSet*, int iBatch, i64);
static int sqlite3RowSetNext(RowSet*, i64*);

static void sqlite3CreateView(Parse*,Token*,Token*,Token*,ExprList*,Select*,int,int);


static int sqlite3ViewGetColumnNames(Parse*,Table*);







static void sqlite3DropTable(Parse*, SrcList*, int, int);
static void sqlite3CodeDropTable(Parse*, Table*, int, int);
static void sqlite3DeleteTable(sqlite3*, Table*);
static void sqlite3DeleteTableGeneric(sqlite3*, void*);
static void sqlite3FreeIndex(sqlite3*, Index*);

static void sqlite3AutoincrementBegin(Parse *pParse);
static void sqlite3AutoincrementEnd(Parse *pParse);




static void sqlite3Insert(Parse*, SrcList*, Select*, IdList*, int, Upsert*);

static void sqlite3ComputeGeneratedColumns(Parse*, int, Table*);

static void *sqlite3ArrayAllocate(sqlite3*,void*,int,int*,int*);
static IdList *sqlite3IdListAppend(Parse*, IdList*, Token*);
static int sqlite3IdListIndex(IdList*,const char*);
static SrcList *sqlite3SrcListEnlarge(Parse*, SrcList*, int, int);
static SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2);
static SrcList *sqlite3SrcListAppend(Parse*, SrcList*, Token*, Token*);
static void sqlite3SubqueryDelete(sqlite3*,Subquery*);
static Select *sqlite3SubqueryDetach(sqlite3*,SrcItem*);
static int sqlite3SrcItemAttachSubquery(Parse*, SrcItem*, Select*, int);
static SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,
                                      Token*, Select*, OnOrUsing*);
static void sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *);
static void sqlite3SrcListFuncArgs(Parse*, SrcList*, ExprList*);
static int sqlite3IndexedByLookup(Parse *, SrcItem *);
static void sqlite3SrcListShiftJoinType(Parse*,SrcList*);
static void sqlite3SrcListAssignCursors(Parse*, SrcList*);
static void sqlite3IdListDelete(sqlite3*, IdList*);
static void sqlite3ClearOnOrUsing(sqlite3*, OnOrUsing*);
static void sqlite3SrcListDelete(sqlite3*, SrcList*);
static Index *sqlite3AllocateIndexObject(sqlite3*,int,int,char**);
static void sqlite3CreateIndex(Parse*,Token*,Token*,SrcList*,ExprList*,int,Token*,
                          Expr*, int, int, u8);
static void sqlite3DropIndex(Parse*, SrcList*, int);
static int sqlite3Select(Parse*, Select*, SelectDest*);
static Select *sqlite3SelectNew(Parse*,ExprList*,SrcList*,Expr*,ExprList*,
                         Expr*,ExprList*,u32,Expr*);
static void sqlite3SelectDelete(sqlite3*, Select*);
static void sqlite3SelectDeleteGeneric(sqlite3*,void*);
static Table *sqlite3SrcListLookup(Parse*, SrcList*);
static int sqlite3IsReadOnly(Parse*, Table*, Trigger*);
static void sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int);



static void sqlite3CodeChangeCount(Vdbe*,int,const char*);
static void sqlite3DeleteFrom(Parse*, SrcList*, Expr*, ExprList*, Expr*);
static void sqlite3Update(Parse*, SrcList*, ExprList*,Expr*,int,ExprList*,Expr*,
                   Upsert*);
static WhereInfo *sqlite3WhereBegin(Parse*,SrcList*,Expr*,ExprList*,
                             ExprList*,Select*,u16,int);
static void sqlite3WhereEnd(WhereInfo*);
static LogEst sqlite3WhereOutputRowCount(WhereInfo*);
static int sqlite3WhereIsDistinct(WhereInfo*);
static int sqlite3WhereIsOrdered(WhereInfo*);
static int sqlite3WhereOrderByLimitOptLabel(WhereInfo*);
static void sqlite3WhereMinMaxOptEarlyOut(Vdbe*,WhereInfo*);
static int sqlite3WhereIsSorted(WhereInfo*);
static int sqlite3WhereContinueLabel(WhereInfo*);
static int sqlite3WhereBreakLabel(WhereInfo*);
static int sqlite3WhereOkOnePass(WhereInfo*, int*);



static int sqlite3WhereUsesDeferredSeek(WhereInfo*);
static void sqlite3ExprCodeLoadIndexColumn(Parse*, Index*, int, int, int);
static int sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int, u8);
static void sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int);
static void sqlite3ExprCodeMove(Parse*, int, int, int);
static void sqlite3ExprToRegister(Expr *pExpr, int iReg);
static void sqlite3ExprCode(Parse*, Expr*, int);

static void sqlite3ExprCodeGeneratedColumn(Parse*, Table*, Column*, int);

static void sqlite3ExprCodeCopy(Parse*, Expr*, int);
static void sqlite3ExprCodeFactorable(Parse*, Expr*, int);
static int sqlite3ExprCodeRunJustOnce(Parse*, Expr*, int);
static void sqlite3ExprNullRegisterRange(Parse*, int, int);
static int sqlite3ExprCodeTemp(Parse*, Expr*, int*);
static int sqlite3ExprCodeTarget(Parse*, Expr*, int);
static int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int, u8);




static void sqlite3ExprIfTrue(Parse*, Expr*, int, int);
static void sqlite3ExprIfFalse(Parse*, Expr*, int, int);
static void sqlite3ExprIfFalseDup(Parse*, Expr*, int, int);
static Table *sqlite3FindTable(sqlite3*,const char*, const char*);


static Table *sqlite3LocateTable(Parse*,u32 flags,const char*, const char*);
static const char *sqlite3PreferredTableName(const char*);
static Table *sqlite3LocateTableItem(Parse*,u32 flags,SrcItem *);
static Index *sqlite3FindIndex(sqlite3*,const char*, const char*);
static void sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*);
static void sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*);
static void sqlite3Vacuum(Parse*,Token*,Expr*);
static int sqlite3RunVacuum(char**, sqlite3*, int, sqlite3_value*);
static char *sqlite3NameFromToken(sqlite3*, const Token*);
static int sqlite3ExprCompare(const Parse*,const Expr*,const Expr*, int);
static int sqlite3ExprCompareSkip(Expr*,Expr*,int);
static int sqlite3ExprListCompare(const ExprList*,const ExprList*, int);
static int sqlite3ExprImpliesExpr(const Parse*,const Expr*,const Expr*, int);
static int sqlite3ExprImpliesNonNullRow(Expr*,int,int);
static void sqlite3AggInfoPersistWalkerInit(Walker*,Parse*);
static void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);
static void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);
static int sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx);
static int sqlite3ReferencesSrcList(Parse*, Expr*, SrcList*);
static Vdbe *sqlite3GetVdbe(Parse*);

static void sqlite3PrngSaveState(void);
static void sqlite3PrngRestoreState(void);

static void sqlite3RollbackAll(sqlite3*,int);
static void sqlite3CodeVerifySchema(Parse*, int);
static void sqlite3CodeVerifyNamedSchema(Parse*, const char *zDb);
static void sqlite3BeginTransaction(Parse*, int);
static void sqlite3EndTransaction(Parse*,int);
static void sqlite3Savepoint(Parse*, int, Token*);
static void sqlite3CloseSavepoints(sqlite3 *);
static void sqlite3LeaveMutexAndCloseZombie(sqlite3*);
static u32 sqlite3IsTrueOrFalse(const char*);
static int sqlite3ExprIdToTrueFalse(Expr*);
static int sqlite3ExprTruthValue(const Expr*);
static int sqlite3ExprIsConstant(Parse*,Expr*);
static int sqlite3ExprIsConstantOrFunction(Expr*, u8);
static int sqlite3ExprIsConstantOrGroupBy(Parse*, Expr*, ExprList*);
static int sqlite3ExprIsSingleTableConstraint(Expr*,const SrcList*,int,int);



static int sqlite3ExprIsInteger(const Expr*, int*, Parse*);
static int sqlite3ExprCanBeNull(const Expr*);
static int sqlite3ExprNeedsNoAffinityChange(const Expr*, char);
static int sqlite3IsRowid(const char*);
static const char *sqlite3RowidAlias(Table *pTab);
static void sqlite3GenerateRowDelete(
    Parse*,Table*,Trigger*,int,int,int,i16,u8,u8,u8,int);
static void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int, int*, int);
static int sqlite3GenerateIndexKey(Parse*, Index*, int, int, int, int*,Index*,int);
static void sqlite3ResolvePartIdxLabel(Parse*,int);
static int sqlite3ExprReferencesUpdatedColumn(Expr*,int*,int);
static void sqlite3GenerateConstraintChecks(Parse*,Table*,int*,int,int,int,int,
                                     u8,u8,int,int*,int*,Upsert*);





static void sqlite3CompleteInsertion(Parse*,Table*,int,int,int,int*,int,int,int);
static int sqlite3OpenTableAndIndices(Parse*, Table*, int, u8, int, u8*, int*, int*);
static void sqlite3BeginWriteOperation(Parse*, int, int);
static void sqlite3MultiWrite(Parse*);
static void sqlite3MayAbort(Parse*);
static void sqlite3HaltConstraint(Parse*, int, int, char*, i8, u8);
static void sqlite3UniqueConstraint(Parse*, int, Index*);
static void sqlite3RowidConstraint(Parse*, int, Table*);
static Expr *sqlite3ExprDup(sqlite3*,const Expr*,int);
static ExprList *sqlite3ExprListDup(sqlite3*,const ExprList*,int);
static SrcList *sqlite3SrcListDup(sqlite3*,const SrcList*,int);
static IdList *sqlite3IdListDup(sqlite3*,const IdList*);
static Select *sqlite3SelectDup(sqlite3*,const Select*,int);
static FuncDef *sqlite3FunctionSearch(int,const char*);
static void sqlite3InsertBuiltinFuncs(FuncDef*,int);
static FuncDef *sqlite3FindFunction(sqlite3*,const char*,int,u8,u8);
static void sqlite3QuoteValue(StrAccum*,sqlite3_value*,int);
static int sqlite3AppendOneUtf8Character(char*, u32);
static void sqlite3RegisterBuiltinFunctions(void);
static void sqlite3RegisterDateTimeFunctions(void);
static void sqlite3RegisterJsonFunctions(void);
static void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3*);

static Module *sqlite3JsonVtabRegister(sqlite3*,const char*);

static int sqlite3SafetyCheckOk(sqlite3*);
static int sqlite3SafetyCheckSickOrOk(sqlite3*);
static void sqlite3ChangeCookie(Parse*, int);
static With *sqlite3WithDup(sqlite3 *db, With *p);






static void sqlite3MaterializeView(Parse*, Table*, Expr*, ExprList*,Expr*,int);



static void sqlite3BeginTrigger(Parse*, Token*,Token*,int,int,IdList*,SrcList*,
                           Expr*,int, int);
static void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*);
static void sqlite3DropTrigger(Parse*, SrcList*, int);
static void sqlite3DropTriggerPtr(Parse*, Trigger*);
static Trigger *sqlite3TriggersExist(Parse *, Table*, int, ExprList*, int *pMask);
static Trigger *sqlite3TriggerList(Parse *, Table *);
static void sqlite3CodeRowTrigger(Parse*, Trigger *, int, ExprList*, int, Table *,
                            int, int, int);
static void sqlite3CodeRowTriggerDirect(Parse *, Trigger *, Table *, int, int, int);
  void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*);
static void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*);
static TriggerStep *sqlite3TriggerSelectStep(sqlite3*,Select*,
                                        const char*,const char*);
static TriggerStep *sqlite3TriggerInsertStep(Parse*,Token*, IdList*,
                                        Select*,u8,Upsert*,
                                        const char*,const char*);
static TriggerStep *sqlite3TriggerUpdateStep(Parse*,Token*,SrcList*,ExprList*,
                                        Expr*, u8, const char*,const char*);
static TriggerStep *sqlite3TriggerDeleteStep(Parse*,Token*, Expr*,
                                        const char*,const char*);
static void sqlite3DeleteTrigger(sqlite3*, Trigger*);
static void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);
static u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int);
static SrcList *sqlite3TriggerStepSrc(Parse*, TriggerStep*);
# 21859 "c_tests/sqlite3.c"
static int sqlite3JoinType(Parse*, Token*, Token*, Token*);
static int sqlite3ColumnIndex(Table *pTab, const char *zCol);
static void sqlite3SrcItemColumnUsed(SrcItem*,int);
static void sqlite3SetJoinExpr(Expr*,int,u32);
static void sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int);
static void sqlite3DeferForeignKey(Parse*, int);

static void sqlite3AuthRead(Parse*,Expr*,Schema*,SrcList*);
static int sqlite3AuthCheck(Parse*,int, const char*, const char*, const char*);
static void sqlite3AuthContextPush(Parse*, AuthContext*, const char*);
static void sqlite3AuthContextPop(AuthContext*);
static int sqlite3AuthReadCol(Parse*, const char *, const char *, int);






static int sqlite3DbIsNamed(sqlite3 *db, int iDb, const char *zName);
static void sqlite3Attach(Parse*, Expr*, Expr*, Expr*);
static void sqlite3Detach(Parse*, Expr*);
static void sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*);
static int sqlite3FixSrcList(DbFixer*, SrcList*);
static int sqlite3FixSelect(DbFixer*, Select*);
static int sqlite3FixExpr(DbFixer*, Expr*);
static int sqlite3FixTriggerStep(DbFixer*, TriggerStep*);

static int sqlite3RealSameAsInt(double,sqlite3_int64);
static i64 sqlite3RealToI64(double);
static int sqlite3Int64ToText(i64,char*);
static int sqlite3AtoF(const char *z, double*, int, u8);
static int sqlite3GetInt32(const char *, int*);
static int sqlite3GetUInt32(const char*, u32*);
static int sqlite3Atoi(const char*);

static int sqlite3Utf16ByteLen(const void *pData, int nByte, int nChar);

static int sqlite3Utf8CharLen(const char *pData, int nByte);
static u32 sqlite3Utf8Read(const u8**);
static int sqlite3Utf8ReadLimited(const u8*, int, u32*);
static LogEst sqlite3LogEst(u64);
static LogEst sqlite3LogEstAdd(LogEst,LogEst);
static LogEst sqlite3LogEstFromDouble(double);
static u64 sqlite3LogEstToInt(LogEst);
static VList *sqlite3VListAdd(sqlite3*,VList*,const char*,int,int);
static const char *sqlite3VListNumToName(VList*,int);
static int sqlite3VListNameToNum(VList*,const char*,int);






static int sqlite3PutVarint(unsigned char*, u64);
static u8 sqlite3GetVarint(const unsigned char *, u64 *);
static u8 sqlite3GetVarint32(const unsigned char *, u32 *);
static int sqlite3VarintLen(u64 v);
# 21933 "c_tests/sqlite3.c"
static const char *sqlite3IndexAffinityStr(sqlite3*, Index*);
static char *sqlite3TableAffinityStr(sqlite3*,const Table*);
static void sqlite3TableAffinity(Vdbe*, Table*, int);
static char sqlite3CompareAffinity(const Expr *pExpr, char aff2);
static int sqlite3IndexAffinityOk(const Expr *pExpr, char idx_affinity);
static char sqlite3TableColumnAffinity(const Table*,int);
static char sqlite3ExprAffinity(const Expr *pExpr);
static int sqlite3ExprDataType(const Expr *pExpr);
static int sqlite3Atoi64(const char*, i64*, int, u8);
static int sqlite3DecOrHexToI64(const char*, i64*);
static void sqlite3ErrorWithMsg(sqlite3*, int, const char*,...);
static void sqlite3Error(sqlite3*,int);
static void sqlite3ErrorClear(sqlite3*);
static void sqlite3SystemError(sqlite3*,int);

static void *sqlite3HexToBlob(sqlite3*, const char *z, int n);

static u8 sqlite3HexToInt(int h);
static int sqlite3TwoPartName(Parse *, Token *, Token *, Token **);






static int sqlite3MemdbInit(void);
static int sqlite3IsMemdb(const sqlite3_vfs*);




static const char *sqlite3ErrStr(int);
static int sqlite3ReadSchema(Parse *pParse);
static CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);
static int sqlite3IsBinary(const CollSeq*);
static CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);
static void sqlite3SetTextEncoding(sqlite3 *db, u8);
static CollSeq *sqlite3ExprCollSeq(Parse *pParse, const Expr *pExpr);
static CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, const Expr *pExpr);
static int sqlite3ExprCollSeqMatch(Parse*,const Expr*,const Expr*);
static Expr *sqlite3ExprAddCollateToken(const Parse *pParse, Expr*, const Token*, int);
static Expr *sqlite3ExprAddCollateString(const Parse*,Expr*,const char*);
static Expr *sqlite3ExprSkipCollate(Expr*);
static Expr *sqlite3ExprSkipCollateAndLikely(Expr*);
static int sqlite3CheckCollSeq(Parse *, CollSeq *);
static int sqlite3WritableSchema(sqlite3*);
static int sqlite3CheckObjectName(Parse*, const char*,const char*,const char*);
static void sqlite3VdbeSetChanges(sqlite3 *, i64);
static int sqlite3AddInt64(i64*,i64);
static int sqlite3SubInt64(i64*,i64);
static int sqlite3MulInt64(i64*,i64);
static int sqlite3AbsInt32(int);





static u8 sqlite3GetBoolean(const char *z,u8);

static const void *sqlite3ValueText(sqlite3_value*, u8);
static int sqlite3ValueIsOfClass(const sqlite3_value*, void(*)(void*));
static int sqlite3ValueBytes(sqlite3_value*, u8);
static void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,
                        void(*)(void*));
static void sqlite3ValueSetNull(sqlite3_value*);
static void sqlite3ValueFree(sqlite3_value*);

static void sqlite3ResultIntReal(sqlite3_context*);

static sqlite3_value *sqlite3ValueNew(sqlite3 *);

static char *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);

static int sqlite3ValueFromExpr(sqlite3 *, const Expr *, u8, u8, sqlite3_value **);
static void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);
# 22028 "c_tests/sqlite3.c"
static void sqlite3RootPageMoved(sqlite3*, int, Pgno, Pgno);
static void sqlite3Reindex(Parse*, Token*, Token*);
static void sqlite3AlterFunctions(void);
static void sqlite3AlterRenameTable(Parse*, SrcList*, Token*);
static void sqlite3AlterRenameColumn(Parse*, SrcList*, Token*, Token*);
static i64 sqlite3GetToken(const unsigned char *, int *);
static void sqlite3NestedParse(Parse*, const char*, ...);
static void sqlite3ExpirePreparedStatements(sqlite3*, int);
static void sqlite3CodeRhsOfIN(Parse*, Expr*, int);
static int sqlite3CodeSubselect(Parse*, Expr*);
static void sqlite3SelectPrep(Parse*, Select*, NameContext*);
static int sqlite3ExpandSubquery(Parse*, SrcItem*);
static void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);
static int sqlite3MatchEName(
  const struct ExprList_item*,
  const char*,
  const char*,
  const char*,
  int*
);
static Bitmask sqlite3ExprColUsed(Expr*);
static u8 sqlite3StrIHash(const char*);
static int sqlite3ResolveExprNames(NameContext*, Expr*);
static int sqlite3ResolveExprListNames(NameContext*, ExprList*);
static void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);
static int sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*);
static int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);
static void sqlite3ColumnDefault(Vdbe *, Table *, int, int);
static void sqlite3AlterFinishAddColumn(Parse *, Token *);
static void sqlite3AlterBeginAddColumn(Parse *, SrcList *);
static void sqlite3AlterDropColumn(Parse*, SrcList*, const Token*);
static const void *sqlite3RenameTokenMap(Parse*, const void*, const Token*);
static void sqlite3RenameTokenRemap(Parse*, const void *pTo, const void *pFrom);
static void sqlite3RenameExprUnmap(Parse*, Expr*);
static void sqlite3RenameExprlistUnmap(Parse*, ExprList*);
static CollSeq *sqlite3GetCollSeq(Parse*, u8, CollSeq *, const char*);
static char sqlite3AffinityType(const char*, Column*);
static void sqlite3Analyze(Parse*, Token*, Token*);
static int sqlite3InvokeBusyHandler(BusyHandler*);
static int sqlite3FindDb(sqlite3*, Token*);
static int sqlite3FindDbName(sqlite3 *, const char *);
static int sqlite3AnalysisLoad(sqlite3*,int iDB);
static void sqlite3DeleteIndexSamples(sqlite3*,Index*);
static void sqlite3DefaultRowEst(Index*);
static void sqlite3RegisterLikeFunctions(sqlite3*, int);
static int sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*);
static void sqlite3SchemaClear(void *);
static Schema *sqlite3SchemaGet(sqlite3 *, Btree *);
static int sqlite3SchemaToIndex(sqlite3 *db, Schema *);
static KeyInfo *sqlite3KeyInfoAlloc(sqlite3*,int,int);
static void sqlite3KeyInfoUnref(KeyInfo*);
static KeyInfo *sqlite3KeyInfoRef(KeyInfo*);
static KeyInfo *sqlite3KeyInfoOfIndex(Parse*, Index*);
static KeyInfo *sqlite3KeyInfoFromExprList(Parse*, ExprList*, int, int);
static const char *sqlite3SelectOpName(int);
static int sqlite3HasExplicitNulls(Parse*, ExprList*);




static int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,
  void (*)(sqlite3_context*,int,sqlite3_value **),
  void (*)(sqlite3_context*,int,sqlite3_value **),
  void (*)(sqlite3_context*),
  void (*)(sqlite3_context*),
  void (*)(sqlite3_context*,int,sqlite3_value **),
  FuncDestructor *pDestructor
);
static void sqlite3NoopDestructor(void*);
static void *sqlite3OomFault(sqlite3*);
static void sqlite3OomClear(sqlite3*);
static int sqlite3ApiExit(sqlite3 *db, int);
static int sqlite3OpenTempDatabase(Parse *);

static char *sqlite3RCStrRef(char*);
static void sqlite3RCStrUnref(void*);
static char *sqlite3RCStrNew(u64);
static char *sqlite3RCStrResize(char*,u64);

static void sqlite3StrAccumInit(StrAccum*, sqlite3*, char*, int, int);
static int sqlite3StrAccumEnlarge(StrAccum*, i64);
static char *sqlite3StrAccumFinish(StrAccum*);
static void sqlite3StrAccumSetError(StrAccum*, u8);
static void sqlite3ResultStrAccum(sqlite3_context*,StrAccum*);
static void sqlite3SelectDestInit(SelectDest*,int,int);
static Expr *sqlite3CreateColumnExpr(sqlite3 *, SrcList *, int, int);
static void sqlite3RecordErrorByteOffset(sqlite3*,const char*);
static void sqlite3RecordErrorOffsetOfExpr(sqlite3*,const Expr*);

static void sqlite3BackupRestart(sqlite3_backup *);
static void sqlite3BackupUpdate(sqlite3_backup *, Pgno, const u8 *);


static int sqlite3ExprCheckIN(Parse*, Expr*);
# 22142 "c_tests/sqlite3.c"
static void sqlite3Parser(void*, int, Token);
static int sqlite3ParserFallback(int);




static void sqlite3AutoLoadExtensions(sqlite3*);

static void sqlite3CloseExtensions(sqlite3*);





static void sqlite3TableLock(Parse *, int, Pgno, u8, const char *);
# 22178 "c_tests/sqlite3.c"
static void sqlite3VtabClear(sqlite3 *db, Table*);
static void sqlite3VtabDisconnect(sqlite3 *db, Table *p);
static int sqlite3VtabSync(sqlite3 *db, Vdbe*);
static int sqlite3VtabRollback(sqlite3 *db);
static int sqlite3VtabCommit(sqlite3 *db);
static void sqlite3VtabLock(VTable *);
static void sqlite3VtabUnlock(VTable *);
static void sqlite3VtabModuleUnref(sqlite3*,Module*);
static void sqlite3VtabUnlockList(sqlite3*);
static int sqlite3VtabSavepoint(sqlite3 *, int, int);
static void sqlite3VtabImportErrmsg(Vdbe*, sqlite3_vtab*);
static VTable *sqlite3GetVTable(sqlite3*, Table*);
static Module *sqlite3VtabCreateModule(
     sqlite3*,
     const char*,
     const sqlite3_module*,
     void*,
     void(*)(void*)
   );


static int sqlite3ReadOnlyShadowTables(sqlite3 *db);

static int sqlite3ShadowTableName(sqlite3 *db, const char *zName);
static int sqlite3IsShadowTableOf(sqlite3*,Table*,const char*);
static void sqlite3MarkAllShadowTablesOf(sqlite3*, Table*);





static int sqlite3VtabEponymousTableInit(Parse*,Module*);
static void sqlite3VtabEponymousTableClear(sqlite3*,Module*);
static void sqlite3VtabMakeWritable(Parse*,Table*);
static void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*, int);
static void sqlite3VtabFinishParse(Parse*, Token*);
static void sqlite3VtabArgInit(Parse*);
static void sqlite3VtabArgExtend(Parse*, Token*);
static int sqlite3VtabCallCreate(sqlite3*, int, const char *, char **);
static int sqlite3VtabCallConnect(Parse*, Table*);
static int sqlite3VtabCallDestroy(sqlite3*, int, const char *);
static int sqlite3VtabBegin(sqlite3 *, VTable *);

static FuncDef *sqlite3VtabOverloadFunction(sqlite3 *,FuncDef*, int nArg, Expr*);
static void sqlite3VtabUsesAllSchemas(Parse*);
static sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context*);
static int sqlite3VdbeParameterIndex(Vdbe*, const char*, int);
static int sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *);
static void sqlite3ParseObjectInit(Parse*,sqlite3*);
static void sqlite3ParseObjectReset(Parse*);
static void *sqlite3ParserAddCleanup(Parse*,void(*)(sqlite3*,void*),void*);



static int sqlite3Reprepare(Vdbe*);
static void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);
static CollSeq *sqlite3ExprCompareCollSeq(Parse*,const Expr*);
static CollSeq *sqlite3BinaryCompareCollSeq(Parse *, const Expr*, const Expr*);
static int sqlite3TempInMemory(const sqlite3*);
static const char *sqlite3JournalModename(int);

static int sqlite3Checkpoint(sqlite3*, int, int, int*, int*);
static int sqlite3WalDefaultHook(void*,sqlite3*,const char*,int);


static Cte *sqlite3CteNew(Parse*,Token*,ExprList*,Select*,u8);
static void sqlite3CteDelete(sqlite3*,Cte*);
static With *sqlite3WithAdd(Parse*,With*,Cte*);
static void sqlite3WithDelete(sqlite3*,With*);
static void sqlite3WithDeleteGeneric(sqlite3*,void*);
static With *sqlite3WithPush(Parse*, With*, u8);
# 22257 "c_tests/sqlite3.c"
static Upsert *sqlite3UpsertNew(sqlite3*,ExprList*,Expr*,ExprList*,Expr*,Upsert*);
static void sqlite3UpsertDelete(sqlite3*,Upsert*);
static Upsert *sqlite3UpsertDup(sqlite3*,Upsert*);
static int sqlite3UpsertAnalyzeTarget(Parse*,SrcList*,Upsert*,Upsert*);
static void sqlite3UpsertDoUpdate(Parse*,Upsert*,Table*,Index*,int);
static Upsert *sqlite3UpsertOfIndex(Upsert*,Index*);
static int sqlite3UpsertNextIsIPK(Upsert*);
# 22281 "c_tests/sqlite3.c"
static void sqlite3FkCheck(Parse*, Table*, int, int, int*, int);
static void sqlite3FkDropTable(Parse*, SrcList *, Table*);
static void sqlite3FkActions(Parse*, Table*, ExprList*, int, int*, int);
static int sqlite3FkRequired(Parse*, Table*, int*, int);
static u32 sqlite3FkOldmask(Parse*, Table*);
static FKey *sqlite3FkReferences(Table *);
static void sqlite3FkClearTriggerCache(sqlite3*,int);
# 22298 "c_tests/sqlite3.c"
static void sqlite3FkDelete(sqlite3 *, Table*);
static int sqlite3FkLocateIndex(Parse*,Table*,FKey*,Index**,int**);
# 22318 "c_tests/sqlite3.c"
static void sqlite3BeginBenignMalloc(void);
static void sqlite3EndBenignMalloc(void);
# 22339 "c_tests/sqlite3.c"
static int sqlite3FindInIndex(Parse *, Expr *, u32, int*, int*, int*);

static int sqlite3JournalOpen(sqlite3_vfs *, const char *, sqlite3_file *, int, int);
static int sqlite3JournalSize(sqlite3_vfs *);





static int sqlite3JournalIsInMemory(sqlite3_file *p);
static void sqlite3MemJournalOpen(sqlite3_file *);

static void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p);

static int sqlite3SelectExprHeight(const Select *);
static int sqlite3ExprCheckHeight(Parse*, int);




static void sqlite3ExprSetErrorOffset(Expr*,int);

static u32 sqlite3Get4byte(const u8*);
static void sqlite3Put4byte(u8*, u32);
# 22440 "c_tests/sqlite3.c"
static int sqlite3ThreadCreate(SQLiteThread**,void*(*)(void*),void*);
static int sqlite3ThreadJoin(SQLiteThread*, void**);
# 22451 "c_tests/sqlite3.c"
static int sqlite3ExprVectorSize(const Expr *pExpr);
static int sqlite3ExprIsVector(const Expr *pExpr);
static Expr *sqlite3VectorFieldSubexpr(Expr*, int);
static Expr *sqlite3ExprForVectorField(Parse*,Expr*,int,int);
static void sqlite3VectorErrorMsg(Parse*, Expr*);


static const char **sqlite3CompileOptions(int *pnOpt);
# 22637 "c_tests/sqlite3.c"
static const char * const sqlite3azCompileOpt[] = {
# 22657 "c_tests/sqlite3.c"
  "ATOMIC_INTRINSICS=" "1",
# 22675 "c_tests/sqlite3.c"
  "COMPILER=clang-" "20" "."
                    "1" "."
                    "2",
# 22693 "c_tests/sqlite3.c"
  "DEFAULT_AUTOVACUUM",


  "DEFAULT_CACHE_SIZE=" "-2000",





  "DEFAULT_FILE_FORMAT=" "4",
# 22711 "c_tests/sqlite3.c"
  "DEFAULT_JOURNAL_SIZE_LIMIT=" "-1",
# 22725 "c_tests/sqlite3.c"
  "DEFAULT_MMAP_SIZE=" "0",


  "DEFAULT_PAGE_SIZE=" "4096",


  "DEFAULT_PCACHE_INITSZ=" "20",





  "DEFAULT_RECURSIVE_TRIGGERS",





  "DEFAULT_SECTOR_SIZE=" "4096",


  "DEFAULT_SYNCHRONOUS=" "2",


  "DEFAULT_WAL_AUTOCHECKPOINT=" "1000",


  "DEFAULT_WAL_SYNCHRONOUS=" "2",


  "DEFAULT_WORKER_THREADS=" "0",


  "DIRECT_OVERFLOW_READ",
# 23018 "c_tests/sqlite3.c"
  "MALLOC_SOFT_LIMIT=" "1024",


  "MAX_ATTACHED=" "10",


  "MAX_COLUMN=" "2000",


  "MAX_COMPOUND_SELECT=" "500",


  "MAX_DEFAULT_PAGE_SIZE=" "8192",


  "MAX_EXPR_DEPTH=" "1000",


  "MAX_FUNCTION_ARG=" "1000",


  "MAX_LENGTH=" "1000000000",


  "MAX_LIKE_PATTERN_LENGTH=" "50000",





  "MAX_MMAP_SIZE=" "0x7fff0000",





  "MAX_PAGE_COUNT=" "0xfffffffe",


  "MAX_PAGE_SIZE=" "65536",





  "MAX_SQL_LENGTH=" "1000000000",


  "MAX_TRIGGER_DEPTH=" "1000",


  "MAX_VARIABLE_NUMBER=" "32766",


  "MAX_VDBE_OP=" "250000000",


  "MAX_WORKER_THREADS=" "8",
# 23093 "c_tests/sqlite3.c"
  "MUTEX_PTHREADS",
# 23343 "c_tests/sqlite3.c"
  "SYSTEM_MALLOC",





  "TEMP_STORE=" "1",





  "THREADSAFE=" "1",
# 23386 "c_tests/sqlite3.c"
} ;

static const char **sqlite3CompileOptions(int *pnOpt){
  *pnOpt = sizeof(sqlite3azCompileOpt) / sizeof(sqlite3azCompileOpt[0]);
  return (const char**)sqlite3azCompileOpt;
}
# 23420 "c_tests/sqlite3.c"
static const unsigned char sqlite3UpperToLower[] = {

      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
     36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
     54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,
    104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,
    122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,
    108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,
    126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,
    162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,
    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,
    198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,
    216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,
    234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,
    252,253,254,255,
# 23478 "c_tests/sqlite3.c"
   1, 0, 0, 1, 1, 0,
   0, 1, 0, 1, 0, 1,
   1, 0, 1, 0, 0, 1
};
static const unsigned char *sqlite3aLTb = &sqlite3UpperToLower[256-53];
static const unsigned char *sqlite3aEQb = &sqlite3UpperToLower[256+6-53];
static const unsigned char *sqlite3aGTb = &sqlite3UpperToLower[256+12-53];
# 23514 "c_tests/sqlite3.c"
static const unsigned char sqlite3CtypeMap[256] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
  0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
  0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40,
  0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
  0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,

  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40
};
# 23634 "c_tests/sqlite3.c"
static struct Sqlite3Config sqlite3Config = {
   1,
   1,
   1==1,
   0,
   1,
   0,
   1,



   0x7ffffffe,
   0,
   1200,40,
   (64*1024),
   {0,0,0,0,0,0,0,0},
   {0,0,0,0,0,0,0,0,0},
   {0,0,0,0,0,0,0,0,0,0,0,0,0},
   (void*)0,
   0,
   0, 0,
   0,
   0x7fff0000,
   (void*)0,
   0,
   20,
   0,
   0,
   250,

   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
# 23682 "c_tests/sqlite3.c"
   1073741824,


   0,




   0,
   0,
   0x7ffffffe,
   0x7fffffff,
   0,



};






static FuncDefHash sqlite3BuiltinFunctions;
# 23746 "c_tests/sqlite3.c"
static int sqlite3PendingByte = 0x40000000;





static u32 sqlite3TreeTrace = 0;
static u32 sqlite3WhereTrace = 0;
# 23762 "c_tests/sqlite3.c"
static const unsigned char sqlite3OpcodeProperty[] = { 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x41, 0x00, 0x81, 0x01, 0x01, 0x81, 0x83, 0x83, 0x01, 0x01, 0x03, 0x03, 0x01, 0x12, 0x01, 0xc9, 0xc9, 0xc9, 0xc9, 0x01, 0x49, 0x49, 0x49, 0x49, 0xc9, 0x49, 0xc1, 0x01, 0x41, 0x41, 0xc1, 0x01, 0x01, 0x41, 0x41, 0x41, 0x41, 0x26, 0x26, 0x41, 0x41, 0x23, 0x0b, 0x81, 0x01, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x01, 0x03, 0x03, 0x03, 0x01, 0x41, 0x01, 0x00, 0x00, 0x02, 0x02, 0x08, 0x00, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x00, 0x00, 0x12, 0x1e, 0x20, 0x40, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x40, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x40, 0x00, 0x12, 0x40, 0x40, 0x10, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x40, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x50, 0x00, 0x40, 0x04, 0x04, 0x00, 0x40, 0x50, 0x40, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x06, 0x10, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x50, 0x40, 0x00, 0x10, 0x10, 0x02, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,};




static const char sqlite3StrBINARY[] = "BINARY";
# 23781 "c_tests/sqlite3.c"
static const unsigned char sqlite3StdTypeLen[] = { 3, 4, 3, 7, 4, 4 };
static const char sqlite3StdTypeAffinity[] = {
  0x43,
  0x41,
  0x44,
  0x44,
  0x45,
  0x42
};
static const char *sqlite3StdType[] = {
  "ANY",
  "BLOB",
  "INT",
  "INTEGER",
  "REAL",
  "TEXT"
};
# 23864 "c_tests/sqlite3.c"
typedef struct VdbeOp Op;




typedef unsigned Bool;


typedef struct VdbeSorter VdbeSorter;


typedef struct AuxData AuxData;


typedef struct VdbeTxtBlbCache VdbeTxtBlbCache;
# 23896 "c_tests/sqlite3.c"
typedef struct VdbeCursor VdbeCursor;
struct VdbeCursor {
  u8 eCurType;
  i8 iDb;
  u8 nullRow;
  u8 deferredMoveto;
  u8 isTable;




  Bool isEphemeral:1;
  Bool useRandomRowid:1;
  Bool isOrdered:1;
  Bool noReuse:1;
  Bool colCache:1;
  u16 seekHit;
  union {
    Btree *pBtx;
    u32 *aAltMap;
  } ub;
  i64 seqCount;





  u32 cacheStatus;
  int seekResult;
# 23933 "c_tests/sqlite3.c"
  VdbeCursor *pAltCursor;
  union {
    BtCursor *pCursor;
    sqlite3_vtab_cursor *pVCur;
    VdbeSorter *pSorter;
  } uc;
  KeyInfo *pKeyInfo;
  u32 iHdrOffset;
  Pgno pgnoRoot;
  i16 nField;
  u16 nHdrParsed;
  i64 movetoTarget;
  u32 *aOffset;
  const u8 *aRow;
  u32 payloadSize;
  u32 szRow;



  VdbeTxtBlbCache *pCache;



  u32 aType[];
};
# 23983 "c_tests/sqlite3.c"
struct VdbeTxtBlbCache {
  char *pCValue;
  i64 iOffset;
  int iCol;
  u32 cacheStatus;
  u32 colCacheCtr;
};
# 24012 "c_tests/sqlite3.c"
typedef struct VdbeFrame VdbeFrame;
struct VdbeFrame {
  Vdbe *v;
  VdbeFrame *pParent;
  Op *aOp;
  Mem *aMem;
  VdbeCursor **apCsr;
  u8 *aOnce;
  void *token;
  i64 lastRowid;
  AuxData *pAuxData;



  int nCursor;
  int pc;
  int nOp;
  int nMem;
  int nChildMem;
  int nChildCsr;
  i64 nChange;
  i64 nDbChange;
};
# 24050 "c_tests/sqlite3.c"
struct sqlite3_value {
  union MemValue {
    double r;
    i64 i;
    int nZero;
    const char *zPType;
    FuncDef *pDef;
  } u;
  char *z;
  int n;
  u16 flags;
  u8 enc;
  u8 eSubtype;

  sqlite3 *db;
  int szMalloc;
  u32 uTemp;
  char *zMalloc;
  void (*xDel)(void*);





};
# 24192 "c_tests/sqlite3.c"
struct AuxData {
  int iAuxOp;
  int iAuxArg;
  void *pAux;
  void (*xDeleteAux)(void*);
  AuxData *pNextAux;
};
# 24213 "c_tests/sqlite3.c"
struct sqlite3_context {
  Mem *pOut;
  FuncDef *pFunc;
  Mem *pMem;
  Vdbe *pVdbe;
  int iOp;
  int isError;
  u8 enc;
  u8 skipFlag;
  u16 argc;
  sqlite3_value *argv[];
};
# 24245 "c_tests/sqlite3.c"
typedef struct ScanStatus ScanStatus;
struct ScanStatus {
  int addrExplain;
  int aAddrRange[6];
  int addrLoop;
  int addrVisit;
  int iSelectID;
  LogEst nEst;
  char *zName;
};
# 24263 "c_tests/sqlite3.c"
typedef struct DblquoteStr DblquoteStr;
struct DblquoteStr {
  DblquoteStr *pNextStr;
  char z[8];
};
# 24276 "c_tests/sqlite3.c"
struct Vdbe {
  sqlite3 *db;
  Vdbe **ppVPrev,*pVNext;
  Parse *pParse;
  ynVar nVar;
  int nMem;
  int nCursor;
  u32 cacheCtr;
  int pc;
  int rc;
  i64 nChange;
  int iStatement;
  i64 iCurrentTime;
  i64 nFkConstraint;
  i64 nStmtDefCons;
  i64 nStmtDefImmCons;
  Mem *aMem;
  Mem **apArg;
  VdbeCursor **apCsr;
  Mem *aVar;




  Op *aOp;
  int nOp;
  int nOpAlloc;
  Mem *aColName;
  Mem *pResultRow;
  char *zErrMsg;
  VList *pVList;

  i64 startTime;






  u16 nResColumn;
  u16 nResAlloc;
  u8 errorAction;
  u8 minWriteFileFormat;
  u8 prepFlags;
  u8 eVdbeState;
  bft expired:2;
  bft explain:2;
  bft changeCntOn:1;
  bft usesStmtJournal:1;
  bft readOnly:1;
  bft bIsReader:1;
  bft haveEqpOps:1;
  yDbMask btreeMask;
  yDbMask lockMask;
  u32 aCounter[9];
  char *zSql;




  void *pFree;
  VdbeFrame *pFrame;
  VdbeFrame *pDelFrame;
  int nFrame;
  u32 expmask;
  SubProgram *pProgram;
  AuxData *pAuxData;




};
# 24361 "c_tests/sqlite3.c"
struct PreUpdate {
  Vdbe *v;
  VdbeCursor *pCsr;
  int op;
  u8 *aRecord;
  KeyInfo *pKeyinfo;
  UnpackedRecord *pUnpacked;
  UnpackedRecord *pNewUnpacked;
  int iNewReg;
  int iBlobWrite;
  i64 iKey1;
  i64 iKey2;
  Mem oldipk;
  Mem *aNew;
  Table *pTab;
  Index *pPk;
  sqlite3_value **apDflt;
  struct {
    u8 keyinfoSpace[sizeof(KeyInfo)];
  } uKey;
};
# 24395 "c_tests/sqlite3.c"
typedef struct ValueList ValueList;
struct ValueList {
  BtCursor *pCsr;
  sqlite3_value *pOut;
};
# 24411 "c_tests/sqlite3.c"
static void sqlite3VdbeError(Vdbe*, const char *, ...);
static void sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*);
static void sqlite3VdbeFreeCursorNN(Vdbe*,VdbeCursor*);
void sqliteVdbePopStack(Vdbe*,int);
static int __attribute__((noinline)) sqlite3VdbeHandleMovedCursor(VdbeCursor *p);
static int __attribute__((noinline)) sqlite3VdbeFinishMoveto(VdbeCursor*);
static int sqlite3VdbeCursorRestore(VdbeCursor*);
static u32 sqlite3VdbeSerialTypeLen(u32);
static u8 sqlite3VdbeOneByteSerialTypeLen(u8);






static void sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*);
static void sqlite3VdbeDeleteAuxData(sqlite3*, AuxData**, int, int);

int sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *);
static int sqlite3VdbeIdxKeyCompare(sqlite3*,VdbeCursor*,UnpackedRecord*,int*);
static int sqlite3VdbeIdxRowid(sqlite3*, BtCursor*, i64*);
static int sqlite3VdbeExec(Vdbe*);

static int sqlite3VdbeNextOpcode(Vdbe*,Mem*,int,int*,int*,Op**);
static char *sqlite3VdbeDisplayP4(sqlite3*,Op*);





static int sqlite3VdbeList(Vdbe*);

static int sqlite3VdbeHalt(Vdbe*);
static int sqlite3VdbeChangeEncoding(Mem *, int);
static int sqlite3VdbeMemTooBig(Mem*);
static int sqlite3VdbeMemCopy(Mem*, const Mem*);
static void sqlite3VdbeMemShallowCopy(Mem*, const Mem*, int);
static void sqlite3VdbeMemMove(Mem*, Mem*);
static int sqlite3VdbeMemNulTerminate(Mem*);
static int sqlite3VdbeMemSetStr(Mem*, const char*, i64, u8, void(*)(void*));
static void sqlite3VdbeMemSetInt64(Mem*, i64);



static void sqlite3VdbeMemSetDouble(Mem*, double);

static void sqlite3VdbeMemSetPointer(Mem*, void*, const char*, void(*)(void*));
static void sqlite3VdbeMemInit(Mem*,sqlite3*,u16);
static void sqlite3VdbeMemSetNull(Mem*);

static void sqlite3VdbeMemSetZeroBlob(Mem*,int);






static int sqlite3VdbeMemSetRowSet(Mem*);
static void sqlite3VdbeMemZeroTerminateIfAble(Mem*);
static int sqlite3VdbeMemMakeWriteable(Mem*);
static int sqlite3VdbeMemStringify(Mem*, u8, u8);
static int sqlite3IntFloatCompare(i64,double);
static i64 sqlite3VdbeIntValue(const Mem*);
static int sqlite3VdbeMemIntegerify(Mem*);
static double sqlite3VdbeRealValue(Mem*);
static int sqlite3VdbeBooleanValue(Mem*, int ifNull);
static void sqlite3VdbeIntegerAffinity(Mem*);
static int sqlite3VdbeMemRealify(Mem*);
static int sqlite3VdbeMemNumerify(Mem*);
static int sqlite3VdbeMemCast(Mem*,u8,u8);
static int sqlite3VdbeMemFromBtree(BtCursor*,u32,u32,Mem*);
static int sqlite3VdbeMemFromBtreeZeroOffset(BtCursor*,u32,Mem*);
static void sqlite3VdbeMemRelease(Mem *p);
static void sqlite3VdbeMemReleaseMalloc(Mem*p);
static int sqlite3VdbeMemFinalize(Mem*, FuncDef*);

static int sqlite3VdbeMemAggValue(Mem*, Mem*, FuncDef*);


static const char *sqlite3OpcodeName(int);

static int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve);
static int sqlite3VdbeMemClearAndResize(Mem *pMem, int n);
static int sqlite3VdbeCloseStatement(Vdbe *, int);



static void sqlite3VdbeFrameMemDel(void*);
static void sqlite3VdbeFrameDelete(VdbeFrame*);
static int sqlite3VdbeFrameRestore(VdbeFrame *);




static int sqlite3VdbeTransferError(Vdbe *p);

static int sqlite3VdbeSorterInit(sqlite3 *, int, VdbeCursor *);
static void sqlite3VdbeSorterReset(sqlite3 *, VdbeSorter *);
static void sqlite3VdbeSorterClose(sqlite3 *, VdbeCursor *);
static int sqlite3VdbeSorterRowkey(const VdbeCursor *, Mem *);
static int sqlite3VdbeSorterNext(sqlite3 *, const VdbeCursor *);
static int sqlite3VdbeSorterRewind(const VdbeCursor *, int *);
static int sqlite3VdbeSorterWrite(const VdbeCursor *, Mem *);
static int sqlite3VdbeSorterCompare(const VdbeCursor *, Mem *, int, int *);

static void sqlite3VdbeValueListFree(void*);
# 24527 "c_tests/sqlite3.c"
static void sqlite3VdbeEnter(Vdbe*);





static void sqlite3VdbeLeave(Vdbe*);
# 24544 "c_tests/sqlite3.c"
static int sqlite3VdbeCheckFkImmediate(Vdbe*);
static int sqlite3VdbeCheckFkDeferred(Vdbe*);
# 24556 "c_tests/sqlite3.c"
static int sqlite3VdbeMemTranslate(Mem*, u8);
static int sqlite3VdbeMemHandleBom(Mem *pMem);



static int sqlite3VdbeMemExpandBlob(Mem *);
# 24577 "c_tests/sqlite3.c"
typedef sqlite3_int64 sqlite3StatValueType;



typedef struct sqlite3StatType sqlite3StatType;
static struct sqlite3StatType {
  sqlite3StatValueType nowValue[10];
  sqlite3StatValueType mxValue[10];
} sqlite3Stat = { {0,}, {0,} };





static const char statMutex[] = {
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
};
# 24623 "c_tests/sqlite3.c"
static sqlite3_int64 sqlite3StatusValue(int op){
             ;
  ((void) (0));
  ((void) (0));
  ((void) (0));

  return sqlite3Stat.nowValue[op];
}
# 24643 "c_tests/sqlite3.c"
static void sqlite3StatusUp(int op, int N){
             ;
  ((void) (0));
  ((void) (0));
  ((void) (0));

  sqlite3Stat.nowValue[op] += N;
  if( sqlite3Stat.nowValue[op]>sqlite3Stat.mxValue[op] ){
    sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op];
  }
}
static void sqlite3StatusDown(int op, int N){
             ;
  ((void) (0));
  ((void) (0));
  ((void) (0));

  ((void) (0));
  sqlite3Stat.nowValue[op] -= N;
}





static void sqlite3StatusHighwater(int op, int X){
  sqlite3StatValueType newValue;
             ;
  ((void) (0));
  newValue = (sqlite3StatValueType)X;
  ((void) (0));
  ((void) (0));
  ((void) (0));

  ((void) (0));


  if( newValue>sqlite3Stat.mxValue[op] ){
    sqlite3Stat.mxValue[op] = newValue;
  }
}




           int sqlite3_status64(
  int op,
  sqlite3_int64 *pCurrent,
  sqlite3_int64 *pHighwater,
  int resetFlag
){
  sqlite3_mutex *pMutex;
             ;
  if( op<0 || op>=((int)(sizeof(sqlite3Stat.nowValue)/sizeof(sqlite3Stat.nowValue[0]))) ){
    return sqlite3MisuseError(24697);
  }



  pMutex = statMutex[op] ? sqlite3Pcache1Mutex() : sqlite3MallocMutex();
  sqlite3_mutex_enter(pMutex);
  *pCurrent = sqlite3Stat.nowValue[op];
  *pHighwater = sqlite3Stat.mxValue[op];
  if( resetFlag ){
    sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op];
  }
  sqlite3_mutex_leave(pMutex);
  (void)pMutex;
  return 0;
}
           int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){
  sqlite3_int64 iCur = 0, iHwtr = 0;
  int rc;



  rc = sqlite3_status64(op, &iCur, &iHwtr, resetFlag);
  if( rc==0 ){
    *pCurrent = (int)iCur;
    *pHighwater = (int)iHwtr;
  }
  return rc;
}




static u32 countLookasideSlots(LookasideSlot *p){
  u32 cnt = 0;
  while( p ){
    p = p->pNext;
    cnt++;
  }
  return cnt;
}




static int sqlite3LookasideUsed(sqlite3 *db, int *pHighwater){
  u32 nInit = countLookasideSlots(db->lookaside.pInit);
  u32 nFree = countLookasideSlots(db->lookaside.pFree);

  nInit += countLookasideSlots(db->lookaside.pSmallInit);
  nFree += countLookasideSlots(db->lookaside.pSmallFree);

  ((void) (0));
  if( pHighwater ) *pHighwater = (int)(db->lookaside.nSlot - nInit);
  return (int)(db->lookaside.nSlot - (nInit+nFree));
}




           int sqlite3_db_status64(
  sqlite3 *db,
  int op,
  sqlite3_int64 *pCurrent,
  sqlite3_int64 *pHighwtr,
  int resetFlag
){
  int rc = 0;





  sqlite3_mutex_enter(db->mutex);
  switch( op ){
    case 0: {
      int H = 0;
      *pCurrent = sqlite3LookasideUsed(db, &H);
      *pHighwtr = H;
      if( resetFlag ){
        LookasideSlot *p = db->lookaside.pFree;
        if( p ){
          while( p->pNext ) p = p->pNext;
          p->pNext = db->lookaside.pInit;
          db->lookaside.pInit = db->lookaside.pFree;
          db->lookaside.pFree = 0;
        }

        p = db->lookaside.pSmallFree;
        if( p ){
          while( p->pNext ) p = p->pNext;
          p->pNext = db->lookaside.pSmallInit;
          db->lookaside.pSmallInit = db->lookaside.pSmallFree;
          db->lookaside.pSmallFree = 0;
        }

      }
      break;
    }

    case 4:
    case 5:
    case 6: {
                                                   ;
                                                         ;
                                                         ;
      ((void) (0));
      ((void) (0));
      *pCurrent = 0;
      *pHighwtr = db->lookaside.anStat[op-4];
      if( resetFlag ){
        db->lookaside.anStat[op - 4] = 0;
      }
      break;
    }






    case 11:
    case 1: {
      sqlite3_int64 totalUsed = 0;
      int i;
      sqlite3BtreeEnterAll(db);
      for(i=0; i<db->nDb; i++){
        Btree *pBt = db->aDb[i].pBt;
        if( pBt ){
          Pager *pPager = sqlite3BtreePager(pBt);
          int nByte = sqlite3PagerMemUsed(pPager);
          if( op==11 ){
            nByte = nByte / sqlite3BtreeConnectionCount(pBt);
          }
          totalUsed += nByte;
        }
      }
      sqlite3BtreeLeaveAll(db);
      *pCurrent = totalUsed;
      *pHighwtr = 0;
      break;
    }






    case 2: {
      int i;
      int nByte = 0;

      sqlite3BtreeEnterAll(db);
      db->pnBytesFreed = &nByte;
      ((void) (0));
      db->lookaside.pEnd = db->lookaside.pStart;
      for(i=0; i<db->nDb; i++){
        Schema *pSchema = db->aDb[i].pSchema;
        if( (pSchema!=0) ){
          HashElem *p;

          nByte += sqlite3Config.m.xRoundup(sizeof(HashElem)) * (
              pSchema->tblHash.count
            + pSchema->trigHash.count
            + pSchema->idxHash.count
            + pSchema->fkeyHash.count
          );
          nByte += sqlite3_msize(pSchema->tblHash.ht);
          nByte += sqlite3_msize(pSchema->trigHash.ht);
          nByte += sqlite3_msize(pSchema->idxHash.ht);
          nByte += sqlite3_msize(pSchema->fkeyHash.ht);

          for(p=((&pSchema->trigHash)->first); p; p=((p)->next)){
            sqlite3DeleteTrigger(db, (Trigger*)((p)->data));
          }
          for(p=((&pSchema->tblHash)->first); p; p=((p)->next)){
            sqlite3DeleteTable(db, (Table *)((p)->data));
          }
        }
      }
      db->pnBytesFreed = 0;
      db->lookaside.pEnd = db->lookaside.pTrueEnd;
      sqlite3BtreeLeaveAll(db);

      *pHighwtr = 0;
      *pCurrent = nByte;
      break;
    }






    case 3: {
      struct Vdbe *pVdbe;
      int nByte = 0;

      db->pnBytesFreed = &nByte;
      ((void) (0));
      db->lookaside.pEnd = db->lookaside.pStart;
      for(pVdbe=db->pVdbe; pVdbe; pVdbe=pVdbe->pVNext){
        sqlite3VdbeDelete(pVdbe);
      }
      db->lookaside.pEnd = db->lookaside.pTrueEnd;
      db->pnBytesFreed = 0;

      *pHighwtr = 0;
      *pCurrent = nByte;

      break;
    }






    case 12:
      op = 9 +1;
                     __attribute__((fallthrough));
    case 7:
    case 8:
    case 9:{
      int i;
      u64 nRet = 0;
      ((void) (0));
      ((void) (0));

      for(i=0; i<db->nDb; i++){
        if( db->aDb[i].pBt ){
          Pager *pPager = sqlite3BtreePager(db->aDb[i].pBt);
          sqlite3PagerCacheStat(pPager, op, resetFlag, &nRet);
        }
      }
      *pHighwtr = 0;


      *pCurrent = nRet;
      break;
    }






    case 13: {
      u64 nRet = 0;
      if( db->aDb[1].pBt ){
        Pager *pPager = sqlite3BtreePager(db->aDb[1].pBt);
        sqlite3PagerCacheStat(pPager, 9,
                              resetFlag, &nRet);
        nRet *= sqlite3BtreeGetPageSize(db->aDb[1].pBt);
      }
      nRet += db->nSpill;
      if( resetFlag ) db->nSpill = 0;
      *pHighwtr = 0;
      *pCurrent = nRet;
      break;
    }





    case 10: {
      *pHighwtr = 0;
      *pCurrent = db->nDeferredImmCons>0 || db->nDeferredCons>0;
      break;
    }

    default: {
      rc = 1;
    }
  }
  sqlite3_mutex_leave(db->mutex);
  return rc;
}




           int sqlite3_db_status(
  sqlite3 *db,
  int op,
  int *pCurrent,
  int *pHighwtr,
  int resetFlag
){
  sqlite3_int64 C = 0, H = 0;
  int rc;





  rc = sqlite3_db_status64(db, op, &C, &H, resetFlag);
  if( rc==0 ){
    *pCurrent = C & 0x7fffffff;
    *pHighwtr = H & 0x7fffffff;
  }
  return rc;
}
# 25052 "c_tests/sqlite3.c"
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 108 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_null.h" 1 3 4
# 109 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
# 58 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;

};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4








# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 72 "/usr/include/time.h" 3 4
extern clock_t clock (void) __attribute__ ((__nothrow__ ));



extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ ));


extern double difftime (time_t __time1, time_t __time0);


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ ));
# 99 "/usr/include/time.h" 3 4
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp)
   __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3, 4)));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ ));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ ));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) __attribute__ ((__nothrow__ ));






extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ ));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ ));
# 154 "/usr/include/time.h" 3 4
extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));
# 179 "/usr/include/time.h" 3 4
extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ ));



extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ ));
# 197 "/usr/include/time.h" 3 4
extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ ));



extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ ));
# 217 "/usr/include/time.h" 3 4
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ ));



extern int daylight;
extern long int timezone;
# 246 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ ));
# 263 "/usr/include/time.h" 3 4
extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ ));







extern int dysize (int __year) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 281 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);


extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ ));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 323 "/usr/include/time.h" 3 4
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);
# 338 "/usr/include/time.h" 3 4
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ ));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ ));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ ));



extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ ));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ ));
# 376 "/usr/include/time.h" 3 4
extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ ));






extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 399 "/usr/include/time.h" 3 4
extern int timespec_getres (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ ));
# 425 "/usr/include/time.h" 3 4
extern int getdate_err;
# 434 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 448 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);
# 25053 "c_tests/sqlite3.c" 2
# 25069 "c_tests/sqlite3.c"
typedef struct DateTime DateTime;
struct DateTime {
  sqlite3_int64 iJD;
  int Y, M, D;
  int h, m;
  int tz;
  double s;
  char validJD;
  char validYMD;
  char validHMS;
  char nFloor;
  unsigned rawS : 1;
  unsigned isError : 1;
  unsigned useSubsec : 1;
  unsigned isUtc : 1;
  unsigned isLocal : 1;
};
# 25115 "c_tests/sqlite3.c"
static int getDigits(const char *zDate, const char *zFormat, ...){


  static const u16 aMx[] = { 12, 14, 24, 31, 59, 14712 };
  va_list ap;
  int cnt = 0;
  char nextC;
  __builtin_va_start(ap, zFormat);
  do{
    char N = zFormat[0] - '0';
    char min = zFormat[1] - '0';
    int val = 0;
    u16 max;

    ((void) (0));
    max = aMx[zFormat[2] - 'a'];
    nextC = zFormat[3];
    val = 0;
    while( N-- ){
      if( !(sqlite3CtypeMap[(unsigned char)(*zDate)]&0x04) ){
        goto end_getDigits;
      }
      val = val*10 + *zDate - '0';
      zDate++;
    }
    if( val<(int)min || val>(int)max || (nextC!=0 && nextC!=*zDate) ){
      goto end_getDigits;
    }
    *__builtin_va_arg(ap, int*) = val;
    zDate++;
    cnt++;
    zFormat += 4;
  }while( nextC );
end_getDigits:
  __builtin_va_end(ap);
  return cnt;
}
# 25169 "c_tests/sqlite3.c"
static int parseTimezone(const char *zDate, DateTime *p){
  int sgn = 0;
  int nHr, nMn;
  int c;
  while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x01) ){ zDate++; }
  p->tz = 0;
  c = *zDate;
  if( c=='-' ){
    sgn = -1;
  }else if( c=='+' ){
    sgn = +1;
  }else if( c=='Z' || c=='z' ){
    zDate++;
    p->isLocal = 0;
    p->isUtc = 1;
    goto zulu_time;
  }else{
    return c!=0;
  }
  zDate++;
  if( getDigits(zDate, "20b:20e", &nHr, &nMn)!=2 ){
    return 1;
  }
  zDate += 5;
  p->tz = sgn*(nMn + nHr*60);
  if( p->tz==0 ){
    p->isLocal = 0;
    p->isUtc = 1;
  }
zulu_time:
  while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x01) ){ zDate++; }
  return *zDate!=0;
}
# 25210 "c_tests/sqlite3.c"
static int parseHhMmSs(const char *zDate, DateTime *p){
  int h, m, s;
  double ms = 0.0;
  if( getDigits(zDate, "20c:20e", &h, &m)!=2 ){
    return 1;
  }
  zDate += 5;
  if( *zDate==':' ){
    zDate++;
    if( getDigits(zDate, "20e", &s)!=1 ){
      return 1;
    }
    zDate += 2;
    if( *zDate=='.' && (sqlite3CtypeMap[(unsigned char)(zDate[1])]&0x04) ){
      double rScale = 1.0;
      zDate++;
      while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x04) ){
        ms = ms*10.0 + *zDate - '0';
        rScale *= 10.0;
        zDate++;
      }
      ms /= rScale;


      if( ms>0.999 ) ms = 0.999;
    }
  }else{
    s = 0;
  }
  p->validJD = 0;
  p->rawS = 0;
  p->validHMS = 1;
  p->h = h;
  p->m = m;
  p->s = s + ms;
  if( parseTimezone(zDate, p) ) return 1;
  return 0;
}




static void datetimeError(DateTime *p){
  memset(p, 0, sizeof(*p));
  p->isError = 1;
}







static void computeJD(DateTime *p){
  int Y, M, D, A, B, X1, X2;

  if( p->validJD ) return;
  if( p->validYMD ){
    Y = p->Y;
    M = p->M;
    D = p->D;
  }else{
    Y = 2000;
    M = 1;
    D = 1;
  }
  if( Y<-4713 || Y>9999 || p->rawS ){
    datetimeError(p);
    return;
  }
  if( M<=2 ){
    Y--;
    M += 12;
  }
  A = (Y+4800)/100;
  B = 38 - A + (A/4);
  X1 = 36525*(Y+4716)/100;
  X2 = 306001*(M+1)/10000;
  p->iJD = (sqlite3_int64)((X1 + X2 + D + B - 1524.5 ) * 86400000);
  p->validJD = 1;
  if( p->validHMS ){
    p->iJD += p->h*3600000 + p->m*60000 + (sqlite3_int64)(p->s*1000 + 0.5);
    if( p->tz ){
      p->iJD -= p->tz*60000;
      p->validYMD = 0;
      p->validHMS = 0;
      p->tz = 0;
      p->isUtc = 1;
      p->isLocal = 0;
    }
  }
}







static void computeFloor(DateTime *p){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( p->D<=28 ){
    p->nFloor = 0;
  }else if( (1<<p->M) & 0x15aa ){
    p->nFloor = 0;
  }else if( p->M!=2 ){
    p->nFloor = (p->D==31);
  }else if( p->Y%4!=0 || (p->Y%100==0 && p->Y%400!=0) ){
    p->nFloor = p->D - 28;
  }else{
    p->nFloor = p->D - 29;
  }
}
# 25338 "c_tests/sqlite3.c"
static int parseYyyyMmDd(const char *zDate, DateTime *p){
  int Y, M, D, neg;

  if( zDate[0]=='-' ){
    zDate++;
    neg = 1;
  }else{
    neg = 0;
  }
  if( getDigits(zDate, "40f-21a-21d", &Y, &M, &D)!=3 ){
    return 1;
  }
  zDate += 10;
  while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x01) || 'T'==*(u8*)zDate ){ zDate++; }
  if( parseHhMmSs(zDate, p)==0 ){

  }else if( *zDate==0 ){
    p->validHMS = 0;
  }else{
    return 1;
  }
  p->validJD = 0;
  p->validYMD = 1;
  p->Y = neg ? -Y : Y;
  p->M = M;
  p->D = D;
  computeFloor(p);
  if( p->tz ){
    computeJD(p);
  }
  return 0;
}


static void clearYMD_HMS_TZ(DateTime *p);






static int setDateTimeToCurrent(sqlite3_context *context, DateTime *p){
  p->iJD = sqlite3StmtCurrentTime(context);
  if( p->iJD>0 ){
    p->validJD = 1;
    p->isUtc = 1;
    p->isLocal = 0;
    clearYMD_HMS_TZ(p);
    return 0;
  }else{
    return 1;
  }
}







static void setRawDateNumber(DateTime *p, double r){
  p->s = r;
  p->rawS = 1;
  if( r>=0.0 && r<5373484.5 ){
    p->iJD = (sqlite3_int64)(r*86400000.0 + 0.5);
    p->validJD = 1;
  }
}
# 25423 "c_tests/sqlite3.c"
static int parseDateOrTime(
  sqlite3_context *context,
  const char *zDate,
  DateTime *p
){
  double r;
  if( parseYyyyMmDd(zDate,p)==0 ){
    return 0;
  }else if( parseHhMmSs(zDate, p)==0 ){
    return 0;
  }else if( sqlite3StrICmp(zDate,"now")==0 && sqlite3NotPureFunc(context) ){
    return setDateTimeToCurrent(context, p);
  }else if( sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), 1)>0 ){
    setRawDateNumber(p, r);
    return 0;
  }else if( (sqlite3StrICmp(zDate,"subsec")==0
             || sqlite3StrICmp(zDate,"subsecond")==0)
           && sqlite3NotPureFunc(context) ){
    p->useSubsec = 1;
    return setDateTimeToCurrent(context, p);
  }
  return 1;
}
# 25461 "c_tests/sqlite3.c"
static int validJulianDay(sqlite3_int64 iJD){
  return iJD>=0 && iJD<=((((i64)0x1a640)<<32)|0x1072fdff);
}




static void computeYMD(DateTime *p){
  int Z, alpha, A, B, C, D, E, X1;
  if( p->validYMD ) return;
  if( !p->validJD ){
    p->Y = 2000;
    p->M = 1;
    p->D = 1;
  }else if( !validJulianDay(p->iJD) ){
    datetimeError(p);
    return;
  }else{
    Z = (int)((p->iJD + 43200000)/86400000);
    alpha = (int)((Z + 32044.75)/36524.25) - 52;
    A = Z + 1 + alpha - ((alpha+100)/4) + 25;
    B = A + 1524;
    C = (int)((B - 122.1)/365.25);
    D = (36525*(C&32767))/100;
    E = (int)((B-D)/30.6001);
    X1 = (int)(30.6001*E);
    p->D = B - D - X1;
    p->M = E<14 ? E-1 : E-13;
    p->Y = p->M>2 ? C - 4716 : C - 4715;
  }
  p->validYMD = 1;
}




static void computeHMS(DateTime *p){
  int day_ms, day_min;
  if( p->validHMS ) return;
  computeJD(p);
  day_ms = (int)((p->iJD + 43200000) % 86400000);
  p->s = (day_ms % 60000)/1000.0;
  day_min = day_ms/60000;
  p->m = day_min % 60;
  p->h = day_min / 60;
  p->rawS = 0;
  p->validHMS = 1;
}




static void computeYMD_HMS(DateTime *p){
  computeYMD(p);
  computeHMS(p);
}




static void clearYMD_HMS_TZ(DateTime *p){
  p->validYMD = 0;
  p->validHMS = 0;
  p->tz = 0;
}
# 25561 "c_tests/sqlite3.c"
static int osLocaltime(time_t *t, struct tm *pTm){
  int rc;

  struct tm *pX;

  sqlite3_mutex *mutex = sqlite3MutexAlloc(2);

  sqlite3_mutex_enter(mutex);
  pX = localtime(t);

  if( sqlite3Config.bLocaltimeFault ){
    if( sqlite3Config.xAltLocaltime!=0
     && 0==sqlite3Config.xAltLocaltime((const void*)t,(void*)pTm)
    ){
      pX = pTm;
    }else{
      pX = 0;
    }
  }

  if( pX ) *pTm = *pX;

  sqlite3_mutex_leave(mutex);

  rc = pX==0;
# 25602 "c_tests/sqlite3.c"
  return rc;
}







static int toLocaltime(
  DateTime *p,
  sqlite3_context *pCtx
){
  time_t t;
  struct tm sLocal;
  int iYearDiff;


  memset(&sLocal, 0, sizeof(sLocal));

  computeJD(p);
  if( p->iJD<2108667600*(i64)100000
   || p->iJD>2130141456*(i64)100000
  ){





    DateTime x = *p;
    computeYMD_HMS(&x);
    iYearDiff = (2000 + x.Y%4) - x.Y;
    x.Y += iYearDiff;
    x.validJD = 0;
    computeJD(&x);
    t = (time_t)(x.iJD/1000 - 21086676*(i64)10000);
  }else{
    iYearDiff = 0;
    t = (time_t)(p->iJD/1000 - 21086676*(i64)10000);
  }
  if( osLocaltime(&t, &sLocal) ){
    sqlite3_result_error(pCtx, "local time unavailable", -1);
    return 1;
  }
  p->Y = sLocal.tm_year + 1900 - iYearDiff;
  p->M = sLocal.tm_mon + 1;
  p->D = sLocal.tm_mday;
  p->h = sLocal.tm_hour;
  p->m = sLocal.tm_min;
  p->s = sLocal.tm_sec + (p->iJD%1000)*0.001;
  p->validYMD = 1;
  p->validHMS = 1;
  p->validJD = 0;
  p->rawS = 0;
  p->tz = 0;
  p->isError = 0;
  return 0;
}
# 25670 "c_tests/sqlite3.c"
static const struct {
  u8 nName;
  char zName[7];
  float rLimit;
  float rXform;
} aXformType[] = {
          { 6, "second", 4.6427e+14, 1.0 },
          { 6, "minute", 7.7379e+12, 60.0 },
          { 4, "hour", 1.2897e+11, 3600.0 },
          { 3, "day", 5373485.0, 86400.0 },
          { 5, "month", 176546.0, 2592000.0 },
          { 4, "year", 14713.0, 31536000.0 },
};






static void autoAdjustDate(DateTime *p){
  if( !p->rawS || p->validJD ){
    p->rawS = 0;
  }else if( p->s>=-21086676*(i64)10000
         && p->s<=(25340230*(i64)10000)+799
  ){
    double r = p->s*1000.0 + 210866760000000.0;
    clearYMD_HMS_TZ(p);
    p->iJD = (sqlite3_int64)(r + 0.5);
    p->validJD = 1;
    p->rawS = 0;
  }
}
# 25733 "c_tests/sqlite3.c"
static int parseModifier(
  sqlite3_context *pCtx,
  const char *z,
  int n,
  DateTime *p,
  int idx
){
  int rc = 1;
  double r;
  switch(sqlite3UpperToLower[(u8)z[0]] ){
    case 'a': {






      if( sqlite3_stricmp(z, "auto")==0 ){
        if( idx>1 ) return 1;
        autoAdjustDate(p);
        rc = 0;
      }
      break;
    }
    case 'c': {







      if( sqlite3_stricmp(z, "ceiling")==0 ){
        computeJD(p);
        clearYMD_HMS_TZ(p);
        rc = 0;
        p->nFloor = 0;
      }
      break;
    }
    case 'f': {






      if( sqlite3_stricmp(z, "floor")==0 ){
        computeJD(p);
        p->iJD -= p->nFloor*86400000;
        clearYMD_HMS_TZ(p);
        rc = 0;
      }
      break;
    }
    case 'j': {
# 25797 "c_tests/sqlite3.c"
      if( sqlite3_stricmp(z, "julianday")==0 ){
        if( idx>1 ) return 1;
        if( p->validJD && p->rawS ){
          rc = 0;
          p->rawS = 0;
        }
      }
      break;
    }

    case 'l': {





      if( sqlite3_stricmp(z, "localtime")==0 && sqlite3NotPureFunc(pCtx) ){
        rc = p->isLocal ? 0 : toLocaltime(p, pCtx);
        p->isUtc = 0;
        p->isLocal = 1;
      }
      break;
    }

    case 'u': {






      if( sqlite3_stricmp(z, "unixepoch")==0 && p->rawS ){
        if( idx>1 ) return 1;
        r = p->s*1000.0 + 210866760000000.0;
        if( r>=0.0 && r<464269060800000.0 ){
          clearYMD_HMS_TZ(p);
          p->iJD = (sqlite3_int64)(r + 0.5);
          p->validJD = 1;
          p->rawS = 0;
          rc = 0;
        }
      }

      else if( sqlite3_stricmp(z, "utc")==0 && sqlite3NotPureFunc(pCtx) ){
        if( p->isUtc==0 ){
          i64 iOrigJD;
          i64 iGuess;
          int cnt = 0;
          i64 iErr;

          computeJD(p);
          iGuess = iOrigJD = p->iJD;
          iErr = 0;
          do{
            DateTime new;
            memset(&new, 0, sizeof(new));
            iGuess -= iErr;
            new.iJD = iGuess;
            new.validJD = 1;
            rc = toLocaltime(&new, pCtx);
            if( rc ) return rc;
            computeJD(&new);
            iErr = new.iJD - iOrigJD;
          }while( iErr && cnt++<3 );
          memset(p, 0, sizeof(*p));
          p->iJD = iGuess;
          p->validJD = 1;
          p->isUtc = 1;
          p->isLocal = 0;
        }
        rc = 0;
      }

      break;
    }
    case 'w': {







      if( sqlite3_strnicmp(z, "weekday ", 8)==0
               && sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), 1)>0
               && r>=0.0 && r<7.0 && (n=(int)r)==r ){
        sqlite3_int64 Z;
        computeYMD_HMS(p);
        p->tz = 0;
        p->validJD = 0;
        computeJD(p);
        Z = ((p->iJD + 129600000)/86400000) % 7;
        if( Z>n ) Z -= 7;
        p->iJD += (n - Z)*86400000;
        clearYMD_HMS_TZ(p);
        rc = 0;
      }
      break;
    }
    case 's': {
# 25909 "c_tests/sqlite3.c"
      if( sqlite3_strnicmp(z, "start of ", 9)!=0 ){
        if( sqlite3_stricmp(z, "subsec")==0
         || sqlite3_stricmp(z, "subsecond")==0
        ){
          p->useSubsec = 1;
          rc = 0;
        }
        break;
      }
      if( !p->validJD && !p->validYMD && !p->validHMS ) break;
      z += 9;
      computeYMD(p);
      p->validHMS = 1;
      p->h = p->m = 0;
      p->s = 0.0;
      p->rawS = 0;
      p->tz = 0;
      p->validJD = 0;
      if( sqlite3_stricmp(z,"month")==0 ){
        p->D = 1;
        rc = 0;
      }else if( sqlite3_stricmp(z,"year")==0 ){
        p->M = 1;
        p->D = 1;
        rc = 0;
      }else if( sqlite3_stricmp(z,"day")==0 ){
        rc = 0;
      }
      break;
    }
    case '+':
    case '-':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': {
      double rRounder;
      int i;
      int Y,M,D,h,m,x;
      const char *z2 = z;
      char z0 = z[0];
      for(n=1; z[n]; n++){
        if( z[n]==':' ) break;
        if( (sqlite3CtypeMap[(unsigned char)(z[n])]&0x01) ) break;
        if( z[n]=='-' ){
          if( n==5 && getDigits(&z[1], "40f", &Y)==1 ) break;
          if( n==6 && getDigits(&z[1], "50f", &Y)==1 ) break;
        }
      }
      if( sqlite3AtoF(z, &r, n, 1)<=0 ){
        ((void) (0));
        break;
      }
      if( z[n]=='-' ){




        if( z0!='+' && z0!='-' ) break;
        if( n==5 ){
          if( getDigits(&z[1], "40f-20a-20d", &Y, &M, &D)!=3 ) break;
        }else{
          ((void) (0));
          if( getDigits(&z[1], "50f-20a-20d", &Y, &M, &D)!=3 ) break;
          z++;
        }
        if( M>=12 ) break;
        if( D>=31 ) break;
        computeYMD_HMS(p);
        p->validJD = 0;
        if( z0=='-' ){
          p->Y -= Y;
          p->M -= M;
          D = -D;
        }else{
          p->Y += Y;
          p->M += M;
        }
        x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12;
        p->Y += x;
        p->M -= x*12;
        computeFloor(p);
        computeJD(p);
        p->validHMS = 0;
        p->validYMD = 0;
        p->iJD += (i64)D*86400000;
        if( z[11]==0 ){
          rc = 0;
          break;
        }
        if( (sqlite3CtypeMap[(unsigned char)(z[11])]&0x01)
         && getDigits(&z[12], "20c:20e", &h, &m)==2
        ){
          z2 = &z[12];
          n = 2;
        }else{
          break;
        }
      }
      if( z2[n]==':' ){






        DateTime tx;
        sqlite3_int64 day;
        if( !(sqlite3CtypeMap[(unsigned char)(*z2)]&0x04) ) z2++;
        memset(&tx, 0, sizeof(tx));
        if( parseHhMmSs(z2, &tx) ) break;
        computeJD(&tx);
        tx.iJD -= 43200000;
        day = tx.iJD/86400000;
        tx.iJD -= day*86400000;
        if( z0=='-' ) tx.iJD = -tx.iJD;
        computeJD(p);
        clearYMD_HMS_TZ(p);
        p->iJD += tx.iJD;
        rc = 0;
        break;
      }



      z += n;
      while( (sqlite3CtypeMap[(unsigned char)(*z)]&0x01) ) z++;
      n = sqlite3Strlen30(z);
      if( n<3 || n>10 ) break;
      if( sqlite3UpperToLower[(u8)z[n-1]]=='s' ) n--;
      computeJD(p);
      ((void) (0));
      rRounder = r<0 ? -0.5 : +0.5;
      p->nFloor = 0;
      for(i=0; i<((int)(sizeof(aXformType)/sizeof(aXformType[0]))); i++){
        if( aXformType[i].nName==n
         && sqlite3_strnicmp(aXformType[i].zName, z, n)==0
         && r>-aXformType[i].rLimit && r<aXformType[i].rLimit
        ){
          switch( i ){
            case 4: {
              ((void) (0));
              computeYMD_HMS(p);
              p->M += (int)r;
              x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12;
              p->Y += x;
              p->M -= x*12;
              computeFloor(p);
              p->validJD = 0;
              r -= (int)r;
              break;
            }
            case 5: {
              int y = (int)r;
              ((void) (0));
              computeYMD_HMS(p);
              ((void) (0));
              p->Y += y;
              computeFloor(p);
              p->validJD = 0;
              r -= (int)r;
              break;
            }
          }
          computeJD(p);
          p->iJD += (sqlite3_int64)(r*1000.0*aXformType[i].rXform + rRounder);
          rc = 0;
          break;
        }
      }
      clearYMD_HMS_TZ(p);
      break;
    }
    default: {
      break;
    }
  }
  return rc;
}
# 26104 "c_tests/sqlite3.c"
static int isDate(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv,
  DateTime *p
){
  int i, n;
  const unsigned char *z;
  int eType;
  memset(p, 0, sizeof(*p));
  if( argc==0 ){
    if( !sqlite3NotPureFunc(context) ) return 1;
    return setDateTimeToCurrent(context, p);
  }
  if( (eType = sqlite3_value_type(argv[0]))==2
                   || eType==1 ){
    setRawDateNumber(p, sqlite3_value_double(argv[0]));
  }else{
    z = sqlite3_value_text(argv[0]);
    if( !z || parseDateOrTime(context, (char*)z, p) ){
      return 1;
    }
  }
  for(i=1; i<argc; i++){
    z = sqlite3_value_text(argv[i]);
    n = sqlite3_value_bytes(argv[i]);
    if( z==0 || parseModifier(context, (char*)z, n, p, i) ) return 1;
  }
  computeJD(p);
  if( p->isError || !validJulianDay(p->iJD) ) return 1;
  if( argc==1 && p->validYMD && p->D>28 ){


    ((void) (0));
    p->validYMD = 0;
  }
  return 0;
}
# 26154 "c_tests/sqlite3.c"
static void juliandayFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    computeJD(&x);
    sqlite3_result_double(context, x.iJD/86400000.0);
  }
}







static void unixepochFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    computeJD(&x);
    if( x.useSubsec ){
      sqlite3_result_double(context, (x.iJD - 21086676*(i64)10000000)/1000.0);
    }else{
      sqlite3_result_int64(context, x.iJD/1000 - 21086676*(i64)10000);
    }
  }
}






static void datetimeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    int Y, s, n;
    char zBuf[32];
    computeYMD_HMS(&x);
    Y = x.Y;
    if( Y<0 ) Y = -Y;
    zBuf[1] = '0' + (Y/1000)%10;
    zBuf[2] = '0' + (Y/100)%10;
    zBuf[3] = '0' + (Y/10)%10;
    zBuf[4] = '0' + (Y)%10;
    zBuf[5] = '-';
    zBuf[6] = '0' + (x.M/10)%10;
    zBuf[7] = '0' + (x.M)%10;
    zBuf[8] = '-';
    zBuf[9] = '0' + (x.D/10)%10;
    zBuf[10] = '0' + (x.D)%10;
    zBuf[11] = ' ';
    zBuf[12] = '0' + (x.h/10)%10;
    zBuf[13] = '0' + (x.h)%10;
    zBuf[14] = ':';
    zBuf[15] = '0' + (x.m/10)%10;
    zBuf[16] = '0' + (x.m)%10;
    zBuf[17] = ':';
    if( x.useSubsec ){
      s = (int)(1000.0*x.s + 0.5);
      zBuf[18] = '0' + (s/10000)%10;
      zBuf[19] = '0' + (s/1000)%10;
      zBuf[20] = '.';
      zBuf[21] = '0' + (s/100)%10;
      zBuf[22] = '0' + (s/10)%10;
      zBuf[23] = '0' + (s)%10;
      zBuf[24] = 0;
      n = 24;
    }else{
      s = (int)x.s;
      zBuf[18] = '0' + (s/10)%10;
      zBuf[19] = '0' + (s)%10;
      zBuf[20] = 0;
      n = 20;
    }
    if( x.Y<0 ){
      zBuf[0] = '-';
      sqlite3_result_text(context, zBuf, n, ((sqlite3_destructor_type)-1));
    }else{
      sqlite3_result_text(context, &zBuf[1], n-1, ((sqlite3_destructor_type)-1));
    }
  }
}






static void timeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    int s, n;
    char zBuf[16];
    computeHMS(&x);
    zBuf[0] = '0' + (x.h/10)%10;
    zBuf[1] = '0' + (x.h)%10;
    zBuf[2] = ':';
    zBuf[3] = '0' + (x.m/10)%10;
    zBuf[4] = '0' + (x.m)%10;
    zBuf[5] = ':';
    if( x.useSubsec ){
      s = (int)(1000.0*x.s + 0.5);
      zBuf[6] = '0' + (s/10000)%10;
      zBuf[7] = '0' + (s/1000)%10;
      zBuf[8] = '.';
      zBuf[9] = '0' + (s/100)%10;
      zBuf[10] = '0' + (s/10)%10;
      zBuf[11] = '0' + (s)%10;
      zBuf[12] = 0;
      n = 12;
    }else{
      s = (int)x.s;
      zBuf[6] = '0' + (s/10)%10;
      zBuf[7] = '0' + (s)%10;
      zBuf[8] = 0;
      n = 8;
    }
    sqlite3_result_text(context, zBuf, n, ((sqlite3_destructor_type)-1));
  }
}






static void dateFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    int Y;
    char zBuf[16];
    computeYMD(&x);
    Y = x.Y;
    if( Y<0 ) Y = -Y;
    zBuf[1] = '0' + (Y/1000)%10;
    zBuf[2] = '0' + (Y/100)%10;
    zBuf[3] = '0' + (Y/10)%10;
    zBuf[4] = '0' + (Y)%10;
    zBuf[5] = '-';
    zBuf[6] = '0' + (x.M/10)%10;
    zBuf[7] = '0' + (x.M)%10;
    zBuf[8] = '-';
    zBuf[9] = '0' + (x.D/10)%10;
    zBuf[10] = '0' + (x.D)%10;
    zBuf[11] = 0;
    if( x.Y<0 ){
      zBuf[0] = '-';
      sqlite3_result_text(context, zBuf, 11, ((sqlite3_destructor_type)-1));
    }else{
      sqlite3_result_text(context, &zBuf[1], 10, ((sqlite3_destructor_type)-1));
    }
  }
}
# 26336 "c_tests/sqlite3.c"
static int daysAfterJan01(DateTime *pDate){
  DateTime jan01 = *pDate;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  jan01.validJD = 0;
  jan01.M = 1;
  jan01.D = 1;
  computeJD(&jan01);
  return (int)((pDate->iJD-jan01.iJD+43200000)/86400000);
}
# 26356 "c_tests/sqlite3.c"
static int daysAfterMonday(DateTime *pDate){
  ((void) (0));
  return (int)((pDate->iJD+43200000)/86400000) % 7;
}
# 26369 "c_tests/sqlite3.c"
static int daysAfterSunday(DateTime *pDate){
  ((void) (0));
  return (int)((pDate->iJD+129600000)/86400000) % 7;
}
# 26407 "c_tests/sqlite3.c"
static void strftimeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  size_t i,j;
  sqlite3 *db;
  const char *zFmt;
  sqlite3_str sRes;


  if( argc==0 ) return;
  zFmt = (const char*)sqlite3_value_text(argv[0]);
  if( zFmt==0 || isDate(context, argc-1, argv+1, &x) ) return;
  db = sqlite3_context_db_handle(context);
  sqlite3StrAccumInit(&sRes, 0, 0, 0, db->aLimit[0]);

  computeJD(&x);
  computeYMD_HMS(&x);
  for(i=j=0; zFmt[i]; i++){
    char cf;
    if( zFmt[i]!='%' ) continue;
    if( j<i ) sqlite3_str_append(&sRes, zFmt+j, (int)(i-j));
    i++;
    j = i + 1;
    cf = zFmt[i];
    switch( cf ){
      case 'd':
      case 'e': {
        sqlite3_str_appendf(&sRes, cf=='d' ? "%02d" : "%2d", x.D);
        break;
      }
      case 'f': {
        double s = x.s;
        if( (s>59.999) ) s = 59.999;
        sqlite3_str_appendf(&sRes, "%06.3f", s);
        break;
      }
      case 'F': {
        sqlite3_str_appendf(&sRes, "%04d-%02d-%02d", x.Y, x.M, x.D);
        break;
      }
      case 'G':
      case 'g': {
        DateTime y = x;
        ((void) (0));

        y.iJD += (3 - daysAfterMonday(&x))*86400000;
        y.validYMD = 0;
        computeYMD(&y);
        if( cf=='g' ){
          sqlite3_str_appendf(&sRes, "%02d", y.Y%100);
        }else{
          sqlite3_str_appendf(&sRes, "%04d", y.Y);
        }
        break;
      }
      case 'H':
      case 'k': {
        sqlite3_str_appendf(&sRes, cf=='H' ? "%02d" : "%2d", x.h);
        break;
      }
      case 'I':
      case 'l': {
        int h = x.h;
        if( h>12 ) h -= 12;
        if( h==0 ) h = 12;
        sqlite3_str_appendf(&sRes, cf=='I' ? "%02d" : "%2d", h);
        break;
      }
      case 'j': {
        sqlite3_str_appendf(&sRes,"%03d",daysAfterJan01(&x)+1);
        break;
      }
      case 'J': {
        sqlite3_str_appendf(&sRes,"%.16g",x.iJD/86400000.0);
        break;
      }
      case 'm': {
        sqlite3_str_appendf(&sRes,"%02d",x.M);
        break;
      }
      case 'M': {
        sqlite3_str_appendf(&sRes,"%02d",x.m);
        break;
      }
      case 'p':
      case 'P': {
        if( x.h>=12 ){
          sqlite3_str_append(&sRes, cf=='p' ? "PM" : "pm", 2);
        }else{
          sqlite3_str_append(&sRes, cf=='p' ? "AM" : "am", 2);
        }
        break;
      }
      case 'R': {
        sqlite3_str_appendf(&sRes, "%02d:%02d", x.h, x.m);
        break;
      }
      case 's': {
        if( x.useSubsec ){
          sqlite3_str_appendf(&sRes,"%.3f",
                (x.iJD - 21086676*(i64)10000000)/1000.0);
        }else{
          i64 iS = (i64)(x.iJD/1000 - 21086676*(i64)10000);
          sqlite3_str_appendf(&sRes,"%lld",iS);
        }
        break;
      }
      case 'S': {
        sqlite3_str_appendf(&sRes,"%02d",(int)x.s);
        break;
      }
      case 'T': {
        sqlite3_str_appendf(&sRes,"%02d:%02d:%02d", x.h, x.m, (int)x.s);
        break;
      }
      case 'u':
      case 'w': {
        char c = (char)daysAfterSunday(&x) + '0';
        if( c=='0' && cf=='u' ) c = '7';
        sqlite3_str_appendchar(&sRes, 1, c);
        break;
      }
      case 'U': {
        sqlite3_str_appendf(&sRes,"%02d",
              (daysAfterJan01(&x)-daysAfterSunday(&x)+7)/7);
        break;
      }
      case 'V': {
        DateTime y = x;

        ((void) (0));
        y.iJD += (3 - daysAfterMonday(&x))*86400000;
        y.validYMD = 0;
        computeYMD(&y);
        sqlite3_str_appendf(&sRes,"%02d", daysAfterJan01(&y)/7+1);
        break;
      }
      case 'W': {
        sqlite3_str_appendf(&sRes,"%02d",
           (daysAfterJan01(&x)-daysAfterMonday(&x)+7)/7);
        break;
      }
      case 'Y': {
        sqlite3_str_appendf(&sRes,"%04d",x.Y);
        break;
      }
      case '%': {
        sqlite3_str_appendchar(&sRes, 1, '%');
        break;
      }
      default: {
        sqlite3_str_reset(&sRes);
        return;
      }
    }
  }
  if( j<i ) sqlite3_str_append(&sRes, zFmt+j, (int)(i-j));
  sqlite3ResultStrAccum(context, &sRes);
}






static void ctimeFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);
  timeFunc(context, 0, 0);
}






static void cdateFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);
  dateFunc(context, 0, 0);
}
# 26615 "c_tests/sqlite3.c"
static void timediffFunc(
  sqlite3_context *context,
  int NotUsed1,
  sqlite3_value **argv
){
  char sign;
  int Y, M;
  DateTime d1, d2;
  sqlite3_str sRes;
  (void)(NotUsed1);
  if( isDate(context, 1, &argv[0], &d1) ) return;
  if( isDate(context, 1, &argv[1], &d2) ) return;
  computeYMD_HMS(&d1);
  computeYMD_HMS(&d2);
  if( d1.iJD>=d2.iJD ){
    sign = '+';
    Y = d1.Y - d2.Y;
    if( Y ){
      d2.Y = d1.Y;
      d2.validJD = 0;
      computeJD(&d2);
    }
    M = d1.M - d2.M;
    if( M<0 ){
      Y--;
      M += 12;
    }
    if( M!=0 ){
      d2.M = d1.M;
      d2.validJD = 0;
      computeJD(&d2);
    }
    while( d1.iJD<d2.iJD ){
      M--;
      if( M<0 ){
        M = 11;
        Y--;
      }
      d2.M--;
      if( d2.M<1 ){
        d2.M = 12;
        d2.Y--;
      }
      d2.validJD = 0;
      computeJD(&d2);
    }
    d1.iJD -= d2.iJD;
    d1.iJD += (u64)1486995408 * (u64)100000;
  }else {
    sign = '-';
    Y = d2.Y - d1.Y;
    if( Y ){
      d2.Y = d1.Y;
      d2.validJD = 0;
      computeJD(&d2);
    }
    M = d2.M - d1.M;
    if( M<0 ){
      Y--;
      M += 12;
    }
    if( M!=0 ){
      d2.M = d1.M;
      d2.validJD = 0;
      computeJD(&d2);
    }
    while( d1.iJD>d2.iJD ){
      M--;
      if( M<0 ){
        M = 11;
        Y--;
      }
      d2.M++;
      if( d2.M>12 ){
        d2.M = 1;
        d2.Y++;
      }
      d2.validJD = 0;
      computeJD(&d2);
    }
    d1.iJD = d2.iJD - d1.iJD;
    d1.iJD += (u64)1486995408 * (u64)100000;
  }
  clearYMD_HMS_TZ(&d1);
  computeYMD_HMS(&d1);
  sqlite3StrAccumInit(&sRes, 0, 0, 0, 100);
  sqlite3_str_appendf(&sRes, "%c%04d-%02d-%02d %02d:%02d:%06.3f",
       sign, Y, M, d1.D-1, d1.h, d1.m, d1.s);
  sqlite3ResultStrAccum(context, &sRes);
}







static void ctimestampFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);
  datetimeFunc(context, 0, 0);
}
# 26802 "c_tests/sqlite3.c"
static void sqlite3RegisterDateTimeFunctions(void){
  static FuncDef aDateTimeFuncs[] = {

    {-1, 0x00800000| 0x2000|1|0x0800, (void*)&sqlite3Config, 0, juliandayFunc, 0, 0, 0, "julianday", {0} },
    {-1, 0x00800000| 0x2000|1|0x0800, (void*)&sqlite3Config, 0, unixepochFunc, 0, 0, 0, "unixepoch", {0} },
    {-1, 0x00800000| 0x2000|1|0x0800, (void*)&sqlite3Config, 0, dateFunc, 0, 0, 0, "date", {0} },
    {-1, 0x00800000| 0x2000|1|0x0800, (void*)&sqlite3Config, 0, timeFunc, 0, 0, 0, "time", {0} },
    {-1, 0x00800000| 0x2000|1|0x0800, (void*)&sqlite3Config, 0, datetimeFunc, 0, 0, 0, "datetime", {0} },
    {-1, 0x00800000| 0x2000|1|0x0800, (void*)&sqlite3Config, 0, strftimeFunc, 0, 0, 0, "strftime", {0} },
    {2, 0x00800000| 0x2000|1|0x0800, (void*)&sqlite3Config, 0, timediffFunc, 0, 0, 0, "timediff", {0} },



    {0, 0x00800000|0x2000|1, 0, 0, ctimeFunc, 0, 0, 0, "current_time", {0} },
    {0, 0x00800000|0x2000|1, 0, 0, ctimestampFunc, 0, 0, 0, "current_timestamp", {0} },
    {0, 0x00800000|0x2000|1, 0, 0, cdateFunc, 0, 0, 0, "current_date", {0} },





  };
  sqlite3InsertBuiltinFuncs(aDateTimeFuncs, ((int)(sizeof(aDateTimeFuncs)/sizeof(aDateTimeFuncs[0]))));
}
# 26910 "c_tests/sqlite3.c"
static void sqlite3OsClose(sqlite3_file *pId){
  if( pId->pMethods ){
    pId->pMethods->xClose(pId);
    pId->pMethods = 0;
  }
}
static int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset){
                       ;
  return id->pMethods->xRead(id, pBuf, amt, offset);
}
static int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset){
                       ;
  return id->pMethods->xWrite(id, pBuf, amt, offset);
}
static int sqlite3OsTruncate(sqlite3_file *id, i64 size){
  return id->pMethods->xTruncate(id, size);
}
static int sqlite3OsSync(sqlite3_file *id, int flags){
                       ;
  return flags ? id->pMethods->xSync(id, flags) : 0;
}
static int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize){
                       ;
  return id->pMethods->xFileSize(id, pSize);
}
static int sqlite3OsLock(sqlite3_file *id, int lockType){
                       ;
  ((void) (0));
  return id->pMethods->xLock(id, lockType);
}
static int sqlite3OsUnlock(sqlite3_file *id, int lockType){
  ((void) (0));
  return id->pMethods->xUnlock(id, lockType);
}
static int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut){
                       ;
  return id->pMethods->xCheckReservedLock(id, pResOut);
}
# 26957 "c_tests/sqlite3.c"
static int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){
  if( id->pMethods==0 ) return 12;
# 26983 "c_tests/sqlite3.c"
  return id->pMethods->xFileControl(id, op, pArg);
}
static void sqlite3OsFileControlHint(sqlite3_file *id, int op, void *pArg){
  if( id->pMethods ) (void)id->pMethods->xFileControl(id, op, pArg);
}

static int sqlite3OsSectorSize(sqlite3_file *id){
  int (*xSectorSize)(sqlite3_file*) = id->pMethods->xSectorSize;
  return (xSectorSize ? xSectorSize(id) : 4096);
}
static int sqlite3OsDeviceCharacteristics(sqlite3_file *id){
  if( (id->pMethods==0) ) return 0;
  return id->pMethods->xDeviceCharacteristics(id);
}

static int sqlite3OsShmLock(sqlite3_file *id, int offset, int n, int flags){
  return id->pMethods->xShmLock(id, offset, n, flags);
}
static void sqlite3OsShmBarrier(sqlite3_file *id){
  id->pMethods->xShmBarrier(id);
}
static int sqlite3OsShmUnmap(sqlite3_file *id, int deleteFlag){
  return id->pMethods->xShmUnmap(id, deleteFlag);
}
static int sqlite3OsShmMap(
  sqlite3_file *id,
  int iPage,
  int pgsz,
  int bExtend,
  void volatile **pp
){
                       ;
  return id->pMethods->xShmMap(id, iPage, pgsz, bExtend, pp);
}




static int sqlite3OsFetch(sqlite3_file *id, i64 iOff, int iAmt, void **pp){
                       ;
  return id->pMethods->xFetch(id, iOff, iAmt, pp);
}
static int sqlite3OsUnfetch(sqlite3_file *id, i64 iOff, void *p){
  return id->pMethods->xUnfetch(id, iOff, p);
}
# 27043 "c_tests/sqlite3.c"
static int sqlite3OsOpen(
  sqlite3_vfs *pVfs,
  const char *zPath,
  sqlite3_file *pFile,
  int flags,
  int *pFlagsOut
){
  int rc;
                      ;




  ((void) (0));
  rc = pVfs->xOpen(pVfs, zPath, pFile, flags & 0x1087f7f, pFlagsOut);
  ((void) (0));
  return rc;
}
static int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){
                      ;
  ((void) (0));
  return pVfs->xDelete!=0 ? pVfs->xDelete(pVfs, zPath, dirSync) : 0;
}
static int sqlite3OsAccess(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int flags,
  int *pResOut
){
                      ;
  return pVfs->xAccess(pVfs, zPath, flags, pResOut);
}
static int sqlite3OsFullPathname(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int nPathOut,
  char *zPathOut
){
                      ;
  zPathOut[0] = 0;
  return pVfs->xFullPathname(pVfs, zPath, nPathOut, zPathOut);
}

static void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath){
  ((void) (0));
  ((void) (0));
  return pVfs->xDlOpen(pVfs, zPath);
}
static void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
  pVfs->xDlError(pVfs, nByte, zBufOut);
}
static void (*sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHdle, const char *zSym))(void){
  return pVfs->xDlSym(pVfs, pHdle, zSym);
}
static void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){
  pVfs->xDlClose(pVfs, pHandle);
}

static int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
  if( sqlite3Config.iPrngSeed ){
    memset(zBufOut, 0, nByte);
    if( (nByte>(signed)sizeof(unsigned)) ) nByte = sizeof(unsigned int);
    memcpy(zBufOut, &sqlite3Config.iPrngSeed, nByte);
    return 0;
  }else{
    return pVfs->xRandomness(pVfs, nByte, zBufOut);
  }

}
static int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){
  return pVfs->xSleep(pVfs, nMicro);
}
static int sqlite3OsGetLastError(sqlite3_vfs *pVfs){
  return pVfs->xGetLastError ? pVfs->xGetLastError(pVfs, 0, 0) : 0;
}
static int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){
  int rc;






  if( pVfs->iVersion>=2 && pVfs->xCurrentTimeInt64 ){
    rc = pVfs->xCurrentTimeInt64(pVfs, pTimeOut);
  }else{
    double r;
    rc = pVfs->xCurrentTime(pVfs, &r);
    *pTimeOut = (sqlite3_int64)(r*86400000.0);
  }
  return rc;
}

static int sqlite3OsOpenMalloc(
  sqlite3_vfs *pVfs,
  const char *zFile,
  sqlite3_file **ppFile,
  int flags,
  int *pOutFlags
){
  int rc;
  sqlite3_file *pFile;
  pFile = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile);
  if( pFile ){
    rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags);
    if( rc!=0 ){
      sqlite3_free(pFile);
      *ppFile = 0;
    }else{
      *ppFile = pFile;
    }
  }else{
    *ppFile = 0;
    rc = 7;
  }
  ((void) (0));
  return rc;
}
static void sqlite3OsCloseFree(sqlite3_file *pFile){
  ((void) (0));
  sqlite3OsClose(pFile);
  sqlite3_free(pFile);
}







static int sqlite3OsInit(void){
  void *p = sqlite3_malloc(10);
  if( p==0 ) return 7;
  sqlite3_free(p);
  return sqlite3_os_init();
}




static sqlite3_vfs * vfsList = 0;






           sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){
  sqlite3_vfs *pVfs = 0;

  sqlite3_mutex *mutex;


  int rc = sqlite3_initialize();
  if( rc ) return 0;


  mutex = sqlite3MutexAlloc(2);

  sqlite3_mutex_enter(mutex);
  for(pVfs = vfsList; pVfs; pVfs=pVfs->pNext){
    if( zVfs==0 ) break;
    if( strcmp(zVfs, pVfs->zName)==0 ) break;
  }
  sqlite3_mutex_leave(mutex);
  return pVfs;
}




static void vfsUnlink(sqlite3_vfs *pVfs){
  ((void) (0));
  if( pVfs==0 ){

  }else if( vfsList==pVfs ){
    vfsList = pVfs->pNext;
  }else if( vfsList ){
    sqlite3_vfs *p = vfsList;
    while( p->pNext && p->pNext!=pVfs ){
      p = p->pNext;
    }
    if( p->pNext==pVfs ){
      p->pNext = pVfs->pNext;
    }
  }
}






           int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){
  sqlite3_mutex *mutex;

  int rc = sqlite3_initialize();
  if( rc ) return rc;





  mutex = sqlite3MutexAlloc(2);
  sqlite3_mutex_enter(mutex);
  vfsUnlink(pVfs);
  if( makeDflt || vfsList==0 ){
    pVfs->pNext = vfsList;
    vfsList = pVfs;
  }else{
    pVfs->pNext = vfsList->pNext;
    vfsList->pNext = pVfs;
  }
  ((void) (0));
  sqlite3_mutex_leave(mutex);
  return 0;
}




           int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){
  sqlite3_mutex *mutex;

  int rc = sqlite3_initialize();
  if( rc ) return rc;

  mutex = sqlite3MutexAlloc(2);
  sqlite3_mutex_enter(mutex);
  vfsUnlink(pVfs);
  sqlite3_mutex_leave(mutex);
  return 0;
}
# 27312 "c_tests/sqlite3.c"
typedef struct BenignMallocHooks BenignMallocHooks;
static struct BenignMallocHooks {
  void (*xBenignBegin)(void);
  void (*xBenignEnd)(void);
} sqlite3Hooks = { 0, 0 };
# 27338 "c_tests/sqlite3.c"
static void sqlite3BenignMallocHooks(
  void (*xBenignBegin)(void),
  void (*xBenignEnd)(void)
){
              ;
  sqlite3Hooks.xBenignBegin = xBenignBegin;
  sqlite3Hooks.xBenignEnd = xBenignEnd;
}






static void sqlite3BeginBenignMalloc(void){
              ;
  if( sqlite3Hooks.xBenignBegin ){
    sqlite3Hooks.xBenignBegin();
  }
}
static void sqlite3EndBenignMalloc(void){
              ;
  if( sqlite3Hooks.xBenignEnd ){
    sqlite3Hooks.xBenignEnd();
  }
}
# 27558 "c_tests/sqlite3.c"
static void *sqlite3MemMalloc(int nByte){
# 27569 "c_tests/sqlite3.c"
  sqlite3_int64 *p;
  ((void) (0));
                                  ;
  p = malloc(nByte+8);
  if( p ){
    p[0] = nByte;
    p++;
  }else{
                                           ;
    sqlite3_log(7, "failed to allocate %u bytes of memory", nByte);
  }
  return (void *)p;

}
# 27592 "c_tests/sqlite3.c"
static void sqlite3MemFree(void *pPrior){



  sqlite3_int64 *p = (sqlite3_int64*)pPrior;
  ((void) (0));
  p--;
  free(p);

}





static int sqlite3MemSize(void *pPrior){




  sqlite3_int64 *p;
  ((void) (0));
  p = (sqlite3_int64*)pPrior;
  p--;
  return (int)p[0];

}
# 27630 "c_tests/sqlite3.c"
static void *sqlite3MemRealloc(void *pPrior, int nByte){
# 27641 "c_tests/sqlite3.c"
  sqlite3_int64 *p = (sqlite3_int64*)pPrior;
  ((void) (0));
  ((void) (0));
  p--;
  p = realloc((p),(nByte+8));
  if( p ){
    p[0] = nByte;
    p++;
  }else{
                                           ;
    sqlite3_log(7,
      "failed memory resize %u to %u bytes",
      sqlite3MemSize(pPrior), nByte);
  }
  return (void*)p;

}




static int sqlite3MemRoundup(int n){
  return (((n)+7)&~7);
}




static int sqlite3MemInit(void *NotUsed){
# 27689 "c_tests/sqlite3.c"
  (void)(NotUsed);
  return 0;
}




static void sqlite3MemShutdown(void *NotUsed){
  (void)(NotUsed);
  return;
}







static void sqlite3MemSetDefault(void){
  static const sqlite3_mem_methods defaultMethods = {
     sqlite3MemMalloc,
     sqlite3MemFree,
     sqlite3MemRealloc,
     sqlite3MemSize,
     sqlite3MemRoundup,
     sqlite3MemInit,
     sqlite3MemShutdown,
     0
  };
  sqlite3_config(4, &defaultMethods);
}
# 29752 "c_tests/sqlite3.c"
static int sqlite3MutexInit(void){
  int rc = 0;
  if( !sqlite3Config.mutex.xMutexAlloc ){





    sqlite3_mutex_methods const *pFrom;
    sqlite3_mutex_methods *pTo = &sqlite3Config.mutex;

    if( sqlite3Config.bCoreMutex ){



      pFrom = sqlite3DefaultMutex();

    }else{
      pFrom = sqlite3NoopMutex();
    }
    pTo->xMutexInit = pFrom->xMutexInit;
    pTo->xMutexEnd = pFrom->xMutexEnd;
    pTo->xMutexFree = pFrom->xMutexFree;
    pTo->xMutexEnter = pFrom->xMutexEnter;
    pTo->xMutexTry = pFrom->xMutexTry;
    pTo->xMutexLeave = pFrom->xMutexLeave;
    pTo->xMutexHeld = pFrom->xMutexHeld;
    pTo->xMutexNotheld = pFrom->xMutexNotheld;
    sqlite3MemoryBarrier();
    pTo->xMutexAlloc = pFrom->xMutexAlloc;
  }
  ((void) (0));
  rc = sqlite3Config.mutex.xMutexInit();





  sqlite3MemoryBarrier();
  return rc;
}





static int sqlite3MutexEnd(void){
  int rc = 0;
  if( sqlite3Config.mutex.xMutexEnd ){
    rc = sqlite3Config.mutex.xMutexEnd();
  }





  return rc;
}




           sqlite3_mutex *sqlite3_mutex_alloc(int id){

  if( id<=1 && sqlite3_initialize() ) return 0;
  if( id>1 && sqlite3MutexInit() ) return 0;

  ((void) (0));
  return sqlite3Config.mutex.xMutexAlloc(id);
}

static sqlite3_mutex *sqlite3MutexAlloc(int id){
  if( !sqlite3Config.bCoreMutex ){
    return 0;
  }
  ((void) (0));
  ((void) (0));
  return sqlite3Config.mutex.xMutexAlloc(id);
}




           void sqlite3_mutex_free(sqlite3_mutex *p){
  if( p ){
    ((void) (0));
    sqlite3Config.mutex.xMutexFree(p);
  }
}





           void sqlite3_mutex_enter(sqlite3_mutex *p){
  if( p ){
    ((void) (0));
    sqlite3Config.mutex.xMutexEnter(p);
  }
}





           int sqlite3_mutex_try(sqlite3_mutex *p){
  int rc = 0;
  if( p ){
    ((void) (0));
    return sqlite3Config.mutex.xMutexTry(p);
  }
  return rc;
}







           void sqlite3_mutex_leave(sqlite3_mutex *p){
  if( p ){
    ((void) (0));
    sqlite3Config.mutex.xMutexLeave(p);
  }
}
# 29948 "c_tests/sqlite3.c"
static int noopMutexInit(void){ return 0; }
static int noopMutexEnd(void){ return 0; }
static sqlite3_mutex *noopMutexAlloc(int id){
  (void)(id);
  return (sqlite3_mutex*)8;
}
static void noopMutexFree(sqlite3_mutex *p){ (void)(p); return; }
static void noopMutexEnter(sqlite3_mutex *p){ (void)(p); return; }
static int noopMutexTry(sqlite3_mutex *p){
  (void)(p);
  return 0;
}
static void noopMutexLeave(sqlite3_mutex *p){ (void)(p); return; }

static sqlite3_mutex_methods const *sqlite3NoopMutex(void){
  static const sqlite3_mutex_methods sMutex = {
    noopMutexInit,
    noopMutexEnd,
    noopMutexAlloc,
    noopMutexFree,
    noopMutexEnter,
    noopMutexTry,
    noopMutexLeave,

    0,
    0,
  };

  return &sMutex;
}
# 30153 "c_tests/sqlite3.c"
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 108 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_null.h" 1 3 4
# 109 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sched.h" 1 3 4
# 63 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
# 1 "/usr/include/linux/sched/types.h" 1 3 4




# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 12 "/usr/include/x86_64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 1 3 4






# 1 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 3 4
typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


typedef unsigned long __kernel_old_dev_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_old_time_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 19 "/usr/include/x86_64-linux-gnu/asm/posix_types_64.h" 2 3 4
# 8 "/usr/include/x86_64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4


typedef __signed__ __int128 __s128 __attribute__((aligned(16)));
typedef unsigned __int128 __u128 __attribute__((aligned(16)));
# 31 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 55 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 6 "/usr/include/linux/sched/types.h" 2 3 4
# 98 "/usr/include/linux/sched/types.h" 3 4
struct sched_attr {
 __u32 size;

 __u32 sched_policy;
 __u64 sched_flags;


 __s32 sched_nice;


 __u32 sched_priority;


 __u64 sched_runtime;
 __u64 sched_deadline;
 __u64 sched_period;


 __u32 sched_util_min;
 __u32 sched_util_max;

};
# 64 "/usr/include/x86_64-linux-gnu/bits/sched.h" 2 3 4
# 126 "/usr/include/x86_64-linux-gnu/bits/sched.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h" 3 4
struct sched_param
{
  int sched_priority;
};
# 127 "/usr/include/x86_64-linux-gnu/bits/sched.h" 2 3 4





extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) __attribute__ ((__nothrow__ ));


extern int unshare (int __flags) __attribute__ ((__nothrow__ ));


extern int sched_getcpu (void) __attribute__ ((__nothrow__ ));


extern int getcpu (unsigned int *, unsigned int *) __attribute__ ((__nothrow__ ));


extern int setns (int __fd, int __nstype) __attribute__ ((__nothrow__ ));


int sched_setattr (pid_t tid, struct sched_attr *attr, unsigned int flags)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



int sched_getattr (pid_t tid, struct sched_attr *attr, unsigned int size,
     unsigned int flags)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 117 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h" 3 4
extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     __attribute__ ((__nothrow__ ));
extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__ )) ;
extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__ ));
# 45 "/usr/include/sched.h" 2 3 4
# 54 "/usr/include/sched.h" 3 4
extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     __attribute__ ((__nothrow__ ));


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__ ));


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) __attribute__ ((__nothrow__ ));


extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__ ));


extern int sched_yield (void) __attribute__ ((__nothrow__ ));


extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__ ));


extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__ ));



extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__ ));
# 130 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) __attribute__ ((__nothrow__ ));


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) __attribute__ ((__nothrow__ ));
# 23 "/usr/include/pthread.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 3 4
struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };
# 32 "/usr/include/pthread.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4
extern long int __sysconf (int __name) __attribute__ ((__nothrow__ ));
# 34 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 104 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 124 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 159 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 202 "/usr/include/pthread.h" 3 4
extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __attribute__ ((__nothrow__ ));
# 233 "/usr/include/pthread.h" 3 4
extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);
# 243 "/usr/include/pthread.h" 3 4
extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,
                                 clockid_t __clockid,
     const struct timespec *__abstime);
# 269 "/usr/include/pthread.h" 3 4
extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__ ));



extern pthread_t pthread_self (void) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  __attribute__ ((__nothrow__ )) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_setsigmask_np (pthread_attr_t *__attr,
           const __sigset_t *sigmask);




extern int pthread_attr_getsigmask_np (const pthread_attr_t *__attr,
           __sigset_t *sigmask);







extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __attribute__ ((__nothrow__ ));




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) __attribute__ ((__nothrow__ ));


extern int pthread_setconcurrency (int __level) __attribute__ ((__nothrow__ ));



extern int pthread_yield (void) __attribute__ ((__nothrow__ ));

extern int pthread_yield (void) __asm__ ("" "sched_yield") __attribute__ ((__nothrow__ ))
  __attribute__ ((__deprecated__ ("pthread_yield is deprecated, use sched_yield instead")));
# 489 "/usr/include/pthread.h" 3 4
extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));
# 509 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 521 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




struct __cancel_jmp_buf_tag
{
  __jmp_buf __cancel_jmp_buf;
  int __mask_was_saved;
};

typedef struct
{
  struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 557 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 697 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
                            ;
# 709 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
                         ;
# 732 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
                            ;
# 745 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
                         ;



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
                             __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;
# 773 "/usr/include/pthread.h" 3 4
extern int __sigsetjmp (struct __jmp_buf_tag __env[1],
   int __savemask) __attribute__ ((__nothrow__));






extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,
        clockid_t __clockid,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
# 835 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_consistent_np (pthread_mutex_t *) __asm__ ("" "pthread_mutex_consistent") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)))

  __attribute__ ((__deprecated__ ("pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent")));
# 874 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_getrobust_np (pthread_mutexattr_t *, int *) __asm__ ("" "pthread_mutexattr_getrobust") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)))


  __attribute__ ((__deprecated__ ("pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust")));







extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *, int) __asm__ ("" "pthread_mutexattr_setrobust") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)))


  __attribute__ ((__deprecated__ ("pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust")));
# 967 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 1004 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
# 1023 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 1051 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
# 1071 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1145 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 1171 "/usr/include/pthread.h" 3 4
extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __clockid_t __clock_id,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 4)));
# 1194 "/usr/include/pthread.h" 3 4
extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 1230 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 1297 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__ ));


extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__ ));


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer)
  __attribute__ ((__nothrow__ )) ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 1332 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) __attribute__ ((__nothrow__ ));
# 30154 "c_tests/sqlite3.c" 2
# 30169 "c_tests/sqlite3.c"
struct sqlite3_mutex {
  pthread_mutex_t mutex;
# 30179 "c_tests/sqlite3.c"
};
# 30219 "c_tests/sqlite3.c"
static void sqlite3MemoryBarrier(void){



  __sync_synchronize();

}




static int pthreadMutexInit(void){ return 0; }
static int pthreadMutexEnd(void){ return 0; }
# 30281 "c_tests/sqlite3.c"
static sqlite3_mutex *pthreadMutexAlloc(int iType){
  static sqlite3_mutex staticMutexes[] = {
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } },
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } },
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } },
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } },
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } },
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } },
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } },
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } },
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } },
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } },
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } },
    { { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, 0, { ((void*)0), ((void*)0) } } } }
  };
  sqlite3_mutex *p;
  switch( iType ){
    case 1: {
      p = sqlite3MallocZero( sizeof(*p) );
      if( p ){






        pthread_mutexattr_t recursiveAttr;
        pthread_mutexattr_init(&recursiveAttr);
        pthread_mutexattr_settype(&recursiveAttr, PTHREAD_MUTEX_RECURSIVE);
        pthread_mutex_init(&p->mutex, &recursiveAttr);
        pthread_mutexattr_destroy(&recursiveAttr);




      }
      break;
    }
    case 0: {
      p = sqlite3MallocZero( sizeof(*p) );
      if( p ){
        pthread_mutex_init(&p->mutex, 0);



      }
      break;
    }
    default: {






      p = &staticMutexes[iType-2];
      break;
    }
  }



  return p;
}







static void pthreadMutexFree(sqlite3_mutex *p){
  ((void) (0));



  {
    pthread_mutex_destroy(&p->mutex);
    sqlite3_free(p);
  }





}
# 30379 "c_tests/sqlite3.c"
static void pthreadMutexEnter(sqlite3_mutex *p){
  ((void) (0));
# 30407 "c_tests/sqlite3.c"
  pthread_mutex_lock(&p->mutex);
# 30420 "c_tests/sqlite3.c"
}
static int pthreadMutexTry(sqlite3_mutex *p){
  int rc;
  ((void) (0));
# 30453 "c_tests/sqlite3.c"
  if( pthread_mutex_trylock(&p->mutex)==0 ){




    rc = 0;
  }else{
    rc = 5;
  }







  return rc;
}







static void pthreadMutexLeave(sqlite3_mutex *p){
  ((void) (0));




  ((void) (0));






  pthread_mutex_unlock(&p->mutex);







}

static sqlite3_mutex_methods const *sqlite3DefaultMutex(void){
  static const sqlite3_mutex_methods sMutex = {
    pthreadMutexInit,
    pthreadMutexEnd,
    pthreadMutexAlloc,
    pthreadMutexFree,
    pthreadMutexEnter,
    pthreadMutexTry,
    pthreadMutexLeave,




    0,
    0

  };

  return &sMutex;
}
# 31044 "c_tests/sqlite3.c"
           int sqlite3_release_memory(int n){






  (void)(n);
  return 0;

}
# 31066 "c_tests/sqlite3.c"
static struct Mem0Global {
  sqlite3_mutex *mutex;
  sqlite3_int64 alarmThreshold;
  sqlite3_int64 hardLimit;





  int nearlyFull;
} mem0 = { 0, 0, 0, 0 };






static sqlite3_mutex *sqlite3MallocMutex(void){
  return mem0.mutex;
}







           int sqlite3_memory_alarm(
  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),
  void *pArg,
  sqlite3_int64 iThreshold
){
  (void)xCallback;
  (void)pArg;
  (void)iThreshold;
  return 0;
}
# 31116 "c_tests/sqlite3.c"
           sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){
  sqlite3_int64 priorLimit;
  sqlite3_int64 excess;
  sqlite3_int64 nUsed;

  int rc = sqlite3_initialize();
  if( rc ) return -1;

  sqlite3_mutex_enter(mem0.mutex);
  priorLimit = mem0.alarmThreshold;
  if( n<0 ){
    sqlite3_mutex_leave(mem0.mutex);
    return priorLimit;
  }
  if( mem0.hardLimit>0 && (n>mem0.hardLimit || n==0) ){
    n = mem0.hardLimit;
  }
  mem0.alarmThreshold = n;
  nUsed = sqlite3StatusValue(0);
  __atomic_store_n((&mem0.nearlyFull),(n>0 && n<=nUsed),0);
  sqlite3_mutex_leave(mem0.mutex);
  excess = sqlite3_memory_used() - n;
  if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));
  return priorLimit;
}
           void sqlite3_soft_heap_limit(int n){
  if( n<0 ) n = 0;
  sqlite3_soft_heap_limit64(n);
}
# 31158 "c_tests/sqlite3.c"
           sqlite3_int64 sqlite3_hard_heap_limit64(sqlite3_int64 n){
  sqlite3_int64 priorLimit;

  int rc = sqlite3_initialize();
  if( rc ) return -1;

  sqlite3_mutex_enter(mem0.mutex);
  priorLimit = mem0.hardLimit;
  if( n>=0 ){
    mem0.hardLimit = n;
    if( n<mem0.alarmThreshold || mem0.alarmThreshold==0 ){
      mem0.alarmThreshold = n;
    }
  }
  sqlite3_mutex_leave(mem0.mutex);
  return priorLimit;
}





static int sqlite3MallocInit(void){
  int rc;
  if( sqlite3Config.m.xMalloc==0 ){
    sqlite3MemSetDefault();
  }
  mem0.mutex = sqlite3MutexAlloc(3);
  if( sqlite3Config.pPage==0 || sqlite3Config.szPage<512
      || sqlite3Config.nPage<=0 ){
    sqlite3Config.pPage = 0;
    sqlite3Config.szPage = 0;
  }
  rc = sqlite3Config.m.xInit(sqlite3Config.m.pAppData);
  if( rc!=0 ) memset(&mem0, 0, sizeof(mem0));
  return rc;
}






static int sqlite3HeapNearlyFull(void){
  return __atomic_load_n((&mem0.nearlyFull),0);
}




static void sqlite3MallocEnd(void){
  if( sqlite3Config.m.xShutdown ){
    sqlite3Config.m.xShutdown(sqlite3Config.m.pAppData);
  }
  memset(&mem0, 0, sizeof(mem0));
}




           sqlite3_int64 sqlite3_memory_used(void){
  sqlite3_int64 res, mx;
  sqlite3_status64(0, &res, &mx, 0);
  return res;
}






           sqlite3_int64 sqlite3_memory_highwater(int resetFlag){
  sqlite3_int64 res, mx;
  sqlite3_status64(0, &res, &mx, resetFlag);
  return mx;
}




static void sqlite3MallocAlarm(int nByte){
  if( mem0.alarmThreshold<=0 ) return;
  sqlite3_mutex_leave(mem0.mutex);
  sqlite3_release_memory(nByte);
  sqlite3_mutex_enter(mem0.mutex);
}
# 31267 "c_tests/sqlite3.c"
static void mallocWithAlarm(int n, void **pp){
  void *p;
  int nFull;
  ((void) (0));
  ((void) (0));






  nFull = sqlite3Config.m.xRoundup(n);

  sqlite3StatusHighwater(5, n);
  if( mem0.alarmThreshold>0 ){
    sqlite3_int64 nUsed = sqlite3StatusValue(0);
    if( nUsed >= mem0.alarmThreshold - nFull ){
      __atomic_store_n((&mem0.nearlyFull),(1),0);
      sqlite3MallocAlarm(nFull);
      if( mem0.hardLimit ){
        nUsed = sqlite3StatusValue(0);
        if( nUsed >= mem0.hardLimit - nFull ){
                                ;
          *pp = 0;
          return;
        }
      }
    }else{
      __atomic_store_n((&mem0.nearlyFull),(0),0);
    }
  }
  p = sqlite3Config.m.xMalloc(nFull);






  if( p ){
    nFull = sqlite3MallocSize(p);
    sqlite3StatusUp(0, nFull);
    sqlite3StatusUp(9, 1);
  }
  *pp = p;
}
# 31338 "c_tests/sqlite3.c"
static void *sqlite3Malloc(u64 n){
  void *p;
  if( n==0 || n>2147483391 ){
    p = 0;
  }else if( sqlite3Config.bMemstat ){
    sqlite3_mutex_enter(mem0.mutex);
    mallocWithAlarm((int)n, &p);
    sqlite3_mutex_leave(mem0.mutex);
  }else{
    p = sqlite3Config.m.xMalloc((int)n);
  }
  ((void) (0));
  return p;
}






           void *sqlite3_malloc(int n){

  if( sqlite3_initialize() ) return 0;

  return n<=0 ? 0 : sqlite3Malloc(n);
}
           void *sqlite3_malloc64(sqlite3_uint64 n){

  if( sqlite3_initialize() ) return 0;

  return sqlite3Malloc(n);
}





static int isLookaside(sqlite3 *db, const void *p){
  return (((uptr)(p)>=(uptr)(db->lookaside.pStart))&&((uptr)(p)<(uptr)(db->lookaside.pTrueEnd)));
}
# 31386 "c_tests/sqlite3.c"
static int sqlite3MallocSize(const void *p){
  ((void) (0));
  return sqlite3Config.m.xSize((void*)p);
}
static int lookasideMallocSize(sqlite3 *db, const void *p){

  return p<db->lookaside.pMiddle ? db->lookaside.szTrue : 128;



}
static int sqlite3DbMallocSize(sqlite3 *db, const void *p){
  ((void) (0));
# 31408 "c_tests/sqlite3.c"
  if( db ){
    if( ((uptr)p)<(uptr)(db->lookaside.pTrueEnd) ){

      if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){
        ((void) (0));
        return 128;
      }

      if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){
        ((void) (0));
        return db->lookaside.szTrue;
      }
    }
  }
  return sqlite3Config.m.xSize((void*)p);
}
           sqlite3_uint64 sqlite3_msize(void *p){
  ((void) (0));
  ((void) (0));
  return p ? sqlite3Config.m.xSize(p) : 0;
}




           void sqlite3_free(void *p){
  if( p==0 ) return;
  ((void) (0));
  ((void) (0));
  if( sqlite3Config.bMemstat ){
    sqlite3_mutex_enter(mem0.mutex);
    sqlite3StatusDown(0, sqlite3MallocSize(p));
    sqlite3StatusDown(9, 1);
    sqlite3Config.m.xFree(p);
    sqlite3_mutex_leave(mem0.mutex);
  }else{
    sqlite3Config.m.xFree(p);
  }
}





static __attribute__((noinline)) void measureAllocationSize(sqlite3 *db, void *p){
  *db->pnBytesFreed += sqlite3DbMallocSize(db,p);
}






static void sqlite3DbFreeNN(sqlite3 *db, void *p){
  ((void) (0));
  ((void) (0));
  if( db ){
    if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){

      if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){
        LookasideSlot *pBuf = (LookasideSlot*)p;
        ((void) (0));



        pBuf->pNext = db->lookaside.pSmallFree;
        db->lookaside.pSmallFree = pBuf;
        return;
      }

      if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){
        LookasideSlot *pBuf = (LookasideSlot*)p;
        ((void) (0));



        pBuf->pNext = db->lookaside.pFree;
        db->lookaside.pFree = pBuf;
        return;
      }
    }
    if( db->pnBytesFreed ){
      measureAllocationSize(db, p);
      return;
    }
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
                                         ;
  sqlite3_free(p);
}
static void sqlite3DbNNFreeNN(sqlite3 *db, void *p){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){

    if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){
      LookasideSlot *pBuf = (LookasideSlot*)p;
      ((void) (0));



      pBuf->pNext = db->lookaside.pSmallFree;
      db->lookaside.pSmallFree = pBuf;
      return;
    }

    if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){
      LookasideSlot *pBuf = (LookasideSlot*)p;
      ((void) (0));



      pBuf->pNext = db->lookaside.pFree;
      db->lookaside.pFree = pBuf;
      return;
    }
  }
  if( db->pnBytesFreed ){
    measureAllocationSize(db, p);
    return;
  }
  ((void) (0));
  ((void) (0));
                                         ;
  sqlite3_free(p);
}
static void sqlite3DbFree(sqlite3 *db, void *p){
  ((void) (0));
  if( p ) sqlite3DbFreeNN(db, p);
}




static void *sqlite3Realloc(void *pOld, u64 nBytes){
  int nOld, nNew, nDiff;
  void *pNew;
  ((void) (0));
  ((void) (0));
  if( pOld==0 ){
    return sqlite3Malloc(nBytes);
  }
  if( nBytes==0 ){
    sqlite3_free(pOld);
    return 0;
  }
  if( nBytes>=0x7fffff00 ){

    return 0;
  }
  nOld = sqlite3MallocSize(pOld);



  nNew = sqlite3Config.m.xRoundup((int)nBytes);
  if( nOld==nNew ){
    pNew = pOld;
  }else if( sqlite3Config.bMemstat ){
    sqlite3_int64 nUsed;
    sqlite3_mutex_enter(mem0.mutex);
    sqlite3StatusHighwater(5, (int)nBytes);
    nDiff = nNew - nOld;
    if( nDiff>0 && (nUsed = sqlite3StatusValue(0)) >=
          mem0.alarmThreshold-nDiff ){
      sqlite3MallocAlarm(nDiff);
      if( mem0.hardLimit>0 && nUsed >= mem0.hardLimit - nDiff ){
        sqlite3_mutex_leave(mem0.mutex);
                              ;
        return 0;
      }
    }
    pNew = sqlite3Config.m.xRealloc(pOld, nNew);






    if( pNew ){
      nNew = sqlite3MallocSize(pNew);
      sqlite3StatusUp(0, nNew-nOld);
    }
    sqlite3_mutex_leave(mem0.mutex);
  }else{
    pNew = sqlite3Config.m.xRealloc(pOld, nNew);
  }
  ((void) (0));
  return pNew;
}





           void *sqlite3_realloc(void *pOld, int n){

  if( sqlite3_initialize() ) return 0;

  if( n<0 ) n = 0;
  return sqlite3Realloc(pOld, n);
}
           void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n){

  if( sqlite3_initialize() ) return 0;

  return sqlite3Realloc(pOld, n);
}





static void *sqlite3MallocZero(u64 n){
  void *p = sqlite3Malloc(n);
  if( p ){
    memset(p, 0, (size_t)n);
  }
  return p;
}





static void *sqlite3DbMallocZero(sqlite3 *db, u64 n){
  void *p;
                   ;
  p = sqlite3DbMallocRaw(db, n);
  if( p ) memset(p, 0, (size_t)n);
  return p;
}





static __attribute__((noinline)) void *dbMallocRawFinish(sqlite3 *db, u64 n){
  void *p;
  ((void) (0));
  p = sqlite3Malloc(n);
  if( !p ) sqlite3OomFault(db);

                                                                        ;
  return p;
}
# 31679 "c_tests/sqlite3.c"
static void *sqlite3DbMallocRaw(sqlite3 *db, u64 n){
  void *p;
  if( db ) return sqlite3DbMallocRawNN(db, n);
  p = sqlite3Malloc(n);
                                         ;
  return p;
}
static void *sqlite3DbMallocRawNN(sqlite3 *db, u64 n){

  LookasideSlot *pBuf;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( n>db->lookaside.sz ){
    if( !db->lookaside.bDisable ){
      db->lookaside.anStat[1]++;
    }else if( db->mallocFailed ){
      return 0;
    }
    return dbMallocRawFinish(db, n);
  }

  if( n<=128 ){
    if( (pBuf = db->lookaside.pSmallFree)!=0 ){
      db->lookaside.pSmallFree = pBuf->pNext;
      db->lookaside.anStat[0]++;
      return (void*)pBuf;
    }else if( (pBuf = db->lookaside.pSmallInit)!=0 ){
      db->lookaside.pSmallInit = pBuf->pNext;
      db->lookaside.anStat[0]++;
      return (void*)pBuf;
    }
  }

  if( (pBuf = db->lookaside.pFree)!=0 ){
    db->lookaside.pFree = pBuf->pNext;
    db->lookaside.anStat[0]++;
    return (void*)pBuf;
  }else if( (pBuf = db->lookaside.pInit)!=0 ){
    db->lookaside.pInit = pBuf->pNext;
    db->lookaside.anStat[0]++;
    return (void*)pBuf;
  }else{
    db->lookaside.anStat[2]++;
  }
# 31732 "c_tests/sqlite3.c"
  return dbMallocRawFinish(db, n);
}


static __attribute__((noinline)) void *dbReallocFinish(sqlite3 *db, void *p, u64 n);





static void *sqlite3DbRealloc(sqlite3 *db, void *p, u64 n){
  ((void) (0));
  if( p==0 ) return sqlite3DbMallocRawNN(db, n);
  ((void) (0));
  if( ((uptr)p)<(uptr)db->lookaside.pEnd ){

    if( ((uptr)p)>=(uptr)db->lookaside.pMiddle ){
      if( n<=128 ) return p;
    }else

    if( ((uptr)p)>=(uptr)db->lookaside.pStart ){
      if( n<=db->lookaside.szTrue ) return p;
    }
  }
  return dbReallocFinish(db, p, n);
}
static __attribute__((noinline)) void *dbReallocFinish(sqlite3 *db, void *p, u64 n){
  void *pNew = 0;
  ((void) (0));
  ((void) (0));
  if( db->mallocFailed==0 ){
    if( isLookaside(db, p) ){
      pNew = sqlite3DbMallocRawNN(db, n);
      if( pNew ){
        memcpy(pNew, p, lookasideMallocSize(db, p));
        sqlite3DbFree(db, p);
      }
    }else{
      ((void) (0));
      ((void) (0));
                                             ;
      pNew = sqlite3Realloc(p, n);
      if( !pNew ){
        sqlite3OomFault(db);
      }

                                                                           ;
    }
  }
  return pNew;
}





static void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, u64 n){
  void *pNew;
  pNew = sqlite3DbRealloc(db, p, n);
  if( !pNew ){
    sqlite3DbFree(db, p);
  }
  return pNew;
}
# 31804 "c_tests/sqlite3.c"
static char *sqlite3DbStrDup(sqlite3 *db, const char *z){
  char *zNew;
  size_t n;
  if( z==0 ){
    return 0;
  }
  n = strlen(z) + 1;
  zNew = sqlite3DbMallocRaw(db, n);
  if( zNew ){
    memcpy(zNew, z, n);
  }
  return zNew;
}
static char *sqlite3DbStrNDup(sqlite3 *db, const char *z, u64 n){
  char *zNew;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  zNew = z ? sqlite3DbMallocRawNN(db, n+1) : 0;
  if( zNew ){
    memcpy(zNew, z, (size_t)n);
    zNew[n] = 0;
  }
  return zNew;
}






static char *sqlite3DbSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){
  int n;





  while( (sqlite3CtypeMap[(unsigned char)(zStart[0])]&0x01) ) zStart++;
  n = (int)(zEnd - zStart);
  while( (sqlite3CtypeMap[(unsigned char)(zStart[n-1])]&0x01) ) n--;
  return sqlite3DbStrNDup(db, zStart, n);
}




static void sqlite3SetString(char **pz, sqlite3 *db, const char *zNew){
  char *z = sqlite3DbStrDup(db, zNew);
  sqlite3DbFree(db, *pz);
  *pz = z;
}
# 31870 "c_tests/sqlite3.c"
static void *sqlite3OomFault(sqlite3 *db){
  if( db->mallocFailed==0 && db->bBenignMalloc==0 ){
    db->mallocFailed = 1;
    if( db->nVdbeExec>0 ){
      __atomic_store_n((&db->u1.isInterrupted),(1),0);
    }
    db->lookaside.bDisable++;db->lookaside.sz=0;
    if( db->pParse ){
      Parse *pParse;
      sqlite3ErrorMsg(db->pParse, "out of memory");
      db->pParse->rc = 7;
      for(pParse=db->pParse->pOuterParse; pParse; pParse = pParse->pOuterParse){
        pParse->nErr++;
        pParse->rc = 7;
      }
    }
  }
  return 0;
}
# 31897 "c_tests/sqlite3.c"
static void sqlite3OomClear(sqlite3 *db){
  if( db->mallocFailed && db->nVdbeExec==0 ){
    db->mallocFailed = 0;
    __atomic_store_n((&db->u1.isInterrupted),(0),0);
    ((void) (0));
    db->lookaside.bDisable--; db->lookaside.sz=db->lookaside.bDisable?0:db->lookaside.szTrue;
  }
}




static __attribute__((noinline)) int apiHandleError(sqlite3 *db, int rc){
  if( db->mallocFailed || rc==(10 | (12<<8)) ){
    sqlite3OomClear(db);
    sqlite3Error(db, 7);
    return 7;
  }
  return rc & db->errMask;
}
# 31930 "c_tests/sqlite3.c"
static int sqlite3ApiExit(sqlite3* db, int rc){




  ((void) (0));
  ((void) (0));
  if( db->mallocFailed || rc ){
    return apiHandleError(db, rc);
  }
  return 0;
}
# 31988 "c_tests/sqlite3.c"
typedef unsigned char etByte;





typedef struct et_info {
  char fmttype;
  etByte base;
  etByte flags;
  etByte type;
  etByte charset;
  etByte prefix;
  char iNxt;
} et_info;
# 32036 "c_tests/sqlite3.c"
static const char aDigits[] = "0123456789ABCDEF0123456789abcdef";
static const char aPrefix[] = "-x0\000X0";
static const et_info fmtinfo[23] = {
            { 's', 0, 4, 5, 0, 0, 1 },
            { 'E', 0, 1, 2, 14, 0, 0 },
            { 'u', 10, 0, 16, 0, 0, 3 },
            { 'G', 0, 1, 3, 14, 0, 0 },
            { 'w', 0, 4, 14, 0, 0, 0 },
            { 'x', 16, 0, 0, 16, 1, 0 },
            { 'c', 0, 0, 8, 0, 0, 0 },
            { 'z', 0, 4, 6, 0, 0, 6 },
            { 'd', 10, 1, 16, 0, 0, 0 },
            { 'e', 0, 1, 2, 30, 0, 0 },
            { 'f', 0, 1, 1, 0, 0, 0 },
            { 'g', 0, 1, 3, 30, 0, 0 },
            { 'Q', 0, 4, 10, 0, 0, 0 },
            { 'i', 10, 1, 16, 0, 0, 0 },
            { '%', 0, 0, 7, 0, 0, 16 },
            { 'T', 0, 0, 11, 0, 0, 0 },
            { 'S', 0, 0, 12, 0, 0, 0 },
            { 'X', 16, 0, 0, 0, 4, 0 },
            { 'n', 0, 0, 4, 0, 0, 0 },
            { 'o', 8, 0, 0, 0, 2, 17 },
            { 'p', 16, 0, 13, 0, 1, 0 },
            { 'q', 0, 4, 9, 0, 0, 0 },
            { 'r', 10, 1, 15, 0, 0, 0 }
};
# 32073 "c_tests/sqlite3.c"
static void sqlite3StrAccumSetError(StrAccum *p, u8 eError){
  ((void) (0));
  p->accError = eError;
  if( p->mxAlloc ) sqlite3_str_reset(p);
  if( eError==18 ) sqlite3ErrorToParser(p->db, eError);
}




static sqlite3_int64 getIntArg(PrintfArguments *p){
  if( p->nArg<=p->nUsed ) return 0;
  return sqlite3_value_int64(p->apArg[p->nUsed++]);
}
static double getDoubleArg(PrintfArguments *p){
  if( p->nArg<=p->nUsed ) return 0.0;
  return sqlite3_value_double(p->apArg[p->nUsed++]);
}
static char *getTextArg(PrintfArguments *p){
  if( p->nArg<=p->nUsed ) return 0;
  return (char*)sqlite3_value_text(p->apArg[p->nUsed++]);
}
# 32105 "c_tests/sqlite3.c"
static char *printfTempBuf(sqlite3_str *pAccum, sqlite3_int64 n){
  char *z;
  if( pAccum->accError ) return 0;
  if( n>pAccum->nAlloc && n>pAccum->mxAlloc ){
    sqlite3StrAccumSetError(pAccum, 18);
    return 0;
  }
  z = sqlite3DbMallocRaw(pAccum->db, n);
  if( z==0 ){
    sqlite3StrAccumSetError(pAccum, 7);
  }
  return z;
}
# 32138 "c_tests/sqlite3.c"
           void sqlite3_str_vappendf(
  sqlite3_str *pAccum,
  const char *fmt,
  va_list ap
){
  int c;
  char *bufpt;
  int precision;
  int length;
  int idx;
  int width;
  etByte flag_leftjustify;
  etByte flag_prefix;
  etByte flag_alternateform;
  etByte flag_altform2;
  etByte flag_zeropad;
  etByte flag_long;
  etByte done;
  etByte cThousand;
  etByte xtype = 17;
  u8 bArgList;
  char prefix;
  sqlite_uint64 longvalue;
  double realvalue;
  const et_info *infop;
  char *zOut;
  int nOut;
  char *zExtra = 0;
  int exp, e2;
  etByte flag_dp;
  etByte flag_rtz;

  PrintfArguments *pArgList = 0;
  char buf[70];




  ((void) (0));

  bufpt = 0;
  if( (pAccum->printfFlags & 0x02)!=0 ){
    pArgList = __builtin_va_arg(ap, PrintfArguments*);
    bArgList = 1;
  }else{
    bArgList = 0;
  }
  for(; (c=(*fmt))!=0; ++fmt){
    if( c!='%' ){
      bufpt = (char *)fmt;



      fmt = strchr(fmt, '%');
      if( fmt==0 ){
        fmt = bufpt + strlen(bufpt);
      }

      sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));
      if( *fmt==0 ) break;
    }
    if( (c=(*++fmt))==0 ){
      sqlite3_str_append(pAccum, "%", 1);
      break;
    }

    flag_leftjustify = flag_prefix = cThousand =
     flag_alternateform = flag_altform2 = flag_zeropad = 0;
    done = 0;
    width = 0;
    flag_long = 0;
    precision = -1;
    do{
      switch( c ){
        case '-': flag_leftjustify = 1; break;
        case '+': flag_prefix = '+'; break;
        case ' ': flag_prefix = ' '; break;
        case '#': flag_alternateform = 1; break;
        case '!': flag_altform2 = 1; break;
        case '0': flag_zeropad = 1; break;
        case ',': cThousand = ','; break;
        default: done = 1; break;
        case 'l': {
          flag_long = 1;
          c = *++fmt;
          if( c=='l' ){
            c = *++fmt;
            flag_long = 2;
          }
          done = 1;
          break;
        }
        case '1': case '2': case '3': case '4': case '5':
        case '6': case '7': case '8': case '9': {
          unsigned wx = c - '0';
          while( (c = *++fmt)>='0' && c<='9' ){
            wx = wx*10 + c - '0';
          }
                                   ;
          width = wx & 0x7fffffff;





          if( c!='.' && c!='l' ){
            done = 1;
          }else{
            fmt--;
          }
          break;
        }
        case '*': {
          if( bArgList ){
            width = (int)getIntArg(pArgList);
          }else{
            width = __builtin_va_arg(ap, int);
          }
          if( width<0 ){
            flag_leftjustify = 1;
            width = width >= -2147483647 ? -width : 0;
          }





          if( (c = fmt[1])!='.' && c!='l' ){
            c = *++fmt;
            done = 1;
          }
          break;
        }
        case '.': {
          c = *++fmt;
          if( c=='*' ){
            if( bArgList ){
              precision = (int)getIntArg(pArgList);
            }else{
              precision = __builtin_va_arg(ap, int);
            }
            if( precision<0 ){
              precision = precision >= -2147483647 ? -precision : -1;
            }
            c = *++fmt;
          }else{
            unsigned px = 0;
            while( c>='0' && c<='9' ){
              px = px*10 + c - '0';
              c = *++fmt;
            }
                                     ;
            precision = px & 0x7fffffff;
          }





          if( c=='l' ){
            --fmt;
          }else{
            done = 1;
          }
          break;
        }
      }
    }while( !done && (c=(*++fmt))!=0 );
# 32322 "c_tests/sqlite3.c"
    ((void) (0));
    idx = ((unsigned)c) % 23;
    if( fmtinfo[idx].fmttype==c
     || fmtinfo[idx = fmtinfo[idx].iNxt].fmttype==c
    ){
      infop = &fmtinfo[idx];
      xtype = infop->type;
    }else{
      infop = &fmtinfo[0];
      xtype = 17;
    }
# 32352 "c_tests/sqlite3.c"
    ((void) (0));
    ((void) (0));
    switch( xtype ){
      case 13:
        flag_long = sizeof(char*)==sizeof(i64) ? 2 :
                     sizeof(char*)==sizeof(long int) ? 1 : 0;
                       __attribute__((fallthrough));
      case 15:
      case 0:
        cThousand = 0;
                       __attribute__((fallthrough));
      case 16:
        if( infop->flags & 1 ){
          i64 v;
          if( bArgList ){
            v = getIntArg(pArgList);
          }else if( flag_long ){
            if( flag_long==2 ){
              v = __builtin_va_arg(ap, i64) ;
            }else{
              v = __builtin_va_arg(ap, long int);
            }
          }else{
            v = __builtin_va_arg(ap, int);
          }
          if( v<0 ){
                                         ;
                               ;
            longvalue = ~v;
            longvalue++;
            prefix = '-';
          }else{
            longvalue = v;
            prefix = flag_prefix;
          }
        }else{
          if( bArgList ){
            longvalue = (u64)getIntArg(pArgList);
          }else if( flag_long ){
            if( flag_long==2 ){
              longvalue = __builtin_va_arg(ap, u64);
            }else{
              longvalue = __builtin_va_arg(ap, unsigned long int);
            }
          }else{
            longvalue = __builtin_va_arg(ap, unsigned int);
          }
          prefix = 0;
        }
# 32409 "c_tests/sqlite3.c"
        if( longvalue==0 ) flag_alternateform = 0;
        if( flag_zeropad && precision<width-(prefix!=0) ){
          precision = width-(prefix!=0);
        }
        if( precision<70 -10-70/3 ){
          nOut = 70;
          zOut = buf;
        }else{
          u64 n;
          n = (u64)precision + 10;
          if( cThousand ) n += precision/3;
          zOut = zExtra = printfTempBuf(pAccum, n);
          if( zOut==0 ) return;
          nOut = (int)n;
        }
        bufpt = &zOut[nOut-1];
        if( xtype==15 ){
          static const char zOrd[] = "thstndrd";
          int x = (int)(longvalue % 10);
          if( x>=4 || (longvalue/10)%10==1 ){
            x = 0;
          }
          *(--bufpt) = zOrd[x*2+1];
          *(--bufpt) = zOrd[x*2];
        }
        {
          const char *cset = &aDigits[infop->charset];
          u8 base = infop->base;
          do{
            *(--bufpt) = cset[longvalue%base];
            longvalue = longvalue/base;
          }while( longvalue>0 );
        }
        length = (int)(&zOut[nOut-1]-bufpt);
        while( precision>length ){
          *(--bufpt) = '0';
          length++;
        }
        if( cThousand ){
          int nn = (length - 1)/3;
          int ix = (length - 1)%3 + 1;
          bufpt -= nn;
          for(idx=0; nn>0; idx++){
            bufpt[idx] = bufpt[idx+nn];
            ix--;
            if( ix==0 ){
              bufpt[++idx] = cThousand;
              nn--;
              ix = 3;
            }
          }
        }
        if( prefix ) *(--bufpt) = prefix;
        if( flag_alternateform && infop->prefix ){
          const char *pre;
          char x;
          pre = &aPrefix[infop->prefix];
          for(; (x=(*pre))!=0; pre++) *(--bufpt) = x;
        }
        length = (int)(&zOut[nOut-1]-bufpt);
        break;
      case 1:
      case 2:
      case 3: {
        FpDecode s;
        int iRound;
        int j;

        if( bArgList ){
          realvalue = getDoubleArg(pArgList);
        }else{
          realvalue = __builtin_va_arg(ap, double);
        }
        if( precision<0 ) precision = 6;

        if( precision>100000000 ){
          precision = 100000000;
        }

        if( xtype==1 ){
          iRound = -precision;
        }else if( xtype==3 ){
          if( precision==0 ) precision = 1;
          iRound = precision;
        }else{
          iRound = precision+1;
        }
        sqlite3FpDecode(&s, realvalue, iRound, flag_altform2 ? 26 : 16);
        if( s.isSpecial ){
          if( s.isSpecial==2 ){
            bufpt = flag_zeropad ? "null" : "NaN";
            length = sqlite3Strlen30(bufpt);
            break;
          }else if( flag_zeropad ){
            s.z[0] = '9';
            s.iDP = 1000;
            s.n = 1;
          }else{
            memcpy(buf, "-Inf", 5);
            bufpt = buf;
            if( s.sign=='-' ){

            }else if( flag_prefix ){
              buf[0] = flag_prefix;
            }else{
              bufpt++;
            }
            length = sqlite3Strlen30(bufpt);
            break;
          }
        }
        if( s.sign=='-' ){
          if( flag_alternateform
           && !flag_prefix
           && xtype==1
           && s.iDP<=iRound
          ){






            prefix = 0;
          }else{
            prefix = '-';
          }
        }else{
          prefix = flag_prefix;
        }

        exp = s.iDP-1;





        if( xtype==3 ){
          ((void) (0));
          precision--;
          flag_rtz = !flag_alternateform;
          if( exp<-4 || exp>precision ){
            xtype = 2;
          }else{
            precision = precision - exp;
            xtype = 1;
          }
        }else{
          flag_rtz = flag_altform2;
        }
        if( xtype==2 ){
          e2 = 0;
        }else{
          e2 = s.iDP - 1;
        }
        bufpt = buf;
        {
          i64 szBufNeeded;
          szBufNeeded = ((e2)>(0)?(e2):(0))+(i64)precision+(i64)width+15;
          if( cThousand && e2>0 ) szBufNeeded += (e2+2)/3;
          if( szBufNeeded > 70 ){
            bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);
            if( bufpt==0 ) return;
          }
        }
        zOut = bufpt;
        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;

        if( prefix ){
          *(bufpt++) = prefix;
        }

        j = 0;
        if( e2<0 ){
          *(bufpt++) = '0';
        }else{
          for(; e2>=0; e2--){
            *(bufpt++) = j<s.n ? s.z[j++] : '0';
            if( cThousand && (e2%3)==0 && e2>1 ) *(bufpt++) = ',';
          }
        }

        if( flag_dp ){
          *(bufpt++) = '.';
        }


        for(e2++; e2<0 && precision>0; precision--, e2++){
          *(bufpt++) = '0';
        }

        while( (precision--)>0 ){
          *(bufpt++) = j<s.n ? s.z[j++] : '0';
        }

        if( flag_rtz && flag_dp ){
          while( bufpt[-1]=='0' ) *(--bufpt) = 0;
          ((void) (0));
          if( bufpt[-1]=='.' ){
            if( flag_altform2 ){
              *(bufpt++) = '0';
            }else{
              *(--bufpt) = 0;
            }
          }
        }

        if( xtype==2 ){
          exp = s.iDP - 1;
          *(bufpt++) = aDigits[infop->charset];
          if( exp<0 ){
            *(bufpt++) = '-'; exp = -exp;
          }else{
            *(bufpt++) = '+';
          }
          if( exp>=100 ){
            *(bufpt++) = (char)((exp/100)+'0');
            exp %= 100;
          }
          *(bufpt++) = (char)(exp/10+'0');
          *(bufpt++) = (char)(exp%10+'0');
        }
        *bufpt = 0;




        length = (int)(bufpt-zOut);
        bufpt = zOut;



        if( flag_zeropad && !flag_leftjustify && length < width){
          int i;
          int nPad = width - length;
          for(i=width; i>=nPad; i--){
            bufpt[i] = bufpt[i-nPad];
          }
          i = prefix!=0;
          while( nPad-- ) bufpt[i++] = '0';
          length = width;
        }
        break;
      }
      case 4:
        if( !bArgList ){
          *(__builtin_va_arg(ap, int*)) = pAccum->nChar;
        }
        length = width = 0;
        break;
      case 7:
        buf[0] = '%';
        bufpt = buf;
        length = 1;
        break;
      case 8:
        if( bArgList ){
          bufpt = getTextArg(pArgList);
          length = 1;
          if( bufpt ){
            buf[0] = c = *(bufpt++);
            if( (c&0xc0)==0xc0 ){
              while( length<4 && (bufpt[0]&0xc0)==0x80 ){
                buf[length++] = *(bufpt++);
              }
            }
          }else{
            buf[0] = 0;
          }
        }else{
          unsigned int ch = __builtin_va_arg(ap, unsigned int);
          length = sqlite3AppendOneUtf8Character(buf, ch);
        }
        if( precision>1 ){
          i64 nPrior = 1;
          width -= precision-1;
          if( width>1 && !flag_leftjustify ){
            sqlite3_str_appendchar(pAccum, width-1, ' ');
            width = 0;
          }
          sqlite3_str_append(pAccum, buf, length);
          precision--;
          while( precision > 1 ){
            i64 nCopyBytes;
            if( nPrior > precision-1 ) nPrior = precision - 1;
            nCopyBytes = length*nPrior;
            if( nCopyBytes + pAccum->nChar >= pAccum->nAlloc ){
              sqlite3StrAccumEnlarge(pAccum, nCopyBytes);
            }
            if( pAccum->accError ) break;
            sqlite3_str_append(pAccum,
                 &pAccum->zText[pAccum->nChar-nCopyBytes], nCopyBytes);
            precision -= nPrior;
            nPrior *= 2;
          }
        }
        bufpt = buf;
        flag_altform2 = 1;
        goto adjust_width_for_utf8;
      case 5:
      case 6:
        if( bArgList ){
          bufpt = getTextArg(pArgList);
          xtype = 5;
        }else{
          bufpt = __builtin_va_arg(ap, char*);
        }
        if( bufpt==0 ){
          bufpt = "";
        }else if( xtype==6 ){
          if( pAccum->nChar==0
           && pAccum->mxAlloc
           && width==0
           && precision<0
           && pAccum->accError==0
          ){



            ((void) (0));
            pAccum->zText = bufpt;
            pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);
            pAccum->nChar = 0x7fffffff & (int)strlen(bufpt);
            pAccum->printfFlags |= 0x04;
            length = 0;
            break;
          }
          zExtra = bufpt;
        }
        if( precision>=0 ){
          if( flag_altform2 ){


            unsigned char *z = (unsigned char*)bufpt;
            while( precision-- > 0 && z[0] ){
              { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
            }
            length = (int)(z - (unsigned char*)bufpt);
          }else{
            for(length=0; length<precision && bufpt[length]; length++){}
          }
        }else{
          length = 0x7fffffff & (int)strlen(bufpt);
        }
      adjust_width_for_utf8:
        if( flag_altform2 && width>0 ){

          int ii = length - 1;
          while( ii>=0 ) if( (bufpt[ii--] & 0xc0)==0x80 ) width++;
        }
        break;
      case 9:
      case 10:
      case 14: {
        i64 i, j, k, n;
        int needQuote = 0;
        char ch;
        char *escarg;
        char q;

        if( bArgList ){
          escarg = getTextArg(pArgList);
        }else{
          escarg = __builtin_va_arg(ap, char*);
        }
        if( escarg==0 ){
          escarg = (xtype==10 ? "NULL" : "(NULL)");
        }else if( xtype==10 ){
          needQuote = 1;
        }
        if( xtype==14 ){
          q = '"';
          flag_alternateform = 0;
        }else{
          q = '\'';
        }





        k = precision;
        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){
          if( ch==q ) n++;
          if( flag_altform2 && (ch&0xc0)==0xc0 ){
            while( (escarg[i+1]&0xc0)==0x80 ){ i++; }
          }
        }
        if( flag_alternateform ){




          u32 nBack = 0;
          u32 nCtrl = 0;
          for(k=0; k<i; k++){
            if( escarg[k]=='\\' ){
              nBack++;
            }else if( ((u8*)escarg)[k]<=0x1f ){
              nCtrl++;
            }
          }
          if( nCtrl || xtype==9 ){
            n += nBack + 5*nCtrl;
            if( xtype==10 ){
              n += 10;
              needQuote = 2;
            }
          }else{
            flag_alternateform = 0;
          }
        }
        n += i + 3;
        if( n>70 ){
          bufpt = zExtra = printfTempBuf(pAccum, n);
          if( bufpt==0 ) return;
        }else{
          bufpt = buf;
        }
        j = 0;
        if( needQuote ){
          if( needQuote==2 ){
            memcpy(&bufpt[j], "unistr('", 8);
            j += 8;
          }else{
            bufpt[j++] = '\'';
          }
        }
        k = i;
        if( flag_alternateform ){
          for(i=0; i<k; i++){
            bufpt[j++] = ch = escarg[i];
            if( ch==q ){
              bufpt[j++] = ch;
            }else if( ch=='\\' ){
              bufpt[j++] = '\\';
            }else if( ((unsigned char)ch)<=0x1f ){
              bufpt[j-1] = '\\';
              bufpt[j++] = 'u';
              bufpt[j++] = '0';
              bufpt[j++] = '0';
              bufpt[j++] = ch>=0x10 ? '1' : '0';
              bufpt[j++] = "0123456789abcdef"[ch&0xf];
            }
          }
        }else{
          for(i=0; i<k; i++){
            bufpt[j++] = ch = escarg[i];
            if( ch==q ) bufpt[j++] = ch;
          }
        }
        if( needQuote ){
          bufpt[j++] = '\'';
          if( needQuote==2 ) bufpt[j++] = ')';
        }
        bufpt[j] = 0;
        length = j;
        goto adjust_width_for_utf8;
      }
      case 11: {
        if( (pAccum->printfFlags & 0x01)==0 ) return;
        if( flag_alternateform ){

          Expr *pExpr = __builtin_va_arg(ap, Expr*);
          if( (pExpr) && (!(((pExpr)->flags&(u32)(0x000800))!=0)) ){
            sqlite3_str_appendall(pAccum, (const char*)pExpr->u.zToken);
            sqlite3RecordErrorOffsetOfExpr(pAccum->db, pExpr);
          }
        }else{

          Token *pToken = __builtin_va_arg(ap, Token*);
          ((void) (0));
          if( pToken && pToken->n ){
            sqlite3_str_append(pAccum, (const char*)pToken->z, pToken->n);
            sqlite3RecordErrorByteOffset(pAccum->db, pToken->z);
          }
        }
        length = width = 0;
        break;
      }
      case 12: {
        SrcItem *pItem;
        if( (pAccum->printfFlags & 0x01)==0 ) return;
        pItem = __builtin_va_arg(ap, SrcItem*);
        ((void) (0));
        if( pItem->zAlias && !flag_altform2 ){
          sqlite3_str_appendall(pAccum, pItem->zAlias);
        }else if( pItem->zName ){
          if( pItem->fg.fixedSchema==0
           && pItem->fg.isSubquery==0
           && pItem->u4.zDatabase!=0
          ){
            sqlite3_str_appendall(pAccum, pItem->u4.zDatabase);
            sqlite3_str_append(pAccum, ".", 1);
          }
          sqlite3_str_appendall(pAccum, pItem->zName);
        }else if( pItem->zAlias ){
          sqlite3_str_appendall(pAccum, pItem->zAlias);
        }else if( (pItem->fg.isSubquery) ){
          Select *pSel = pItem->u4.pSubq->pSelect;
          ((void) (0));
          if( pSel->selFlags & 0x0000800 ){
            sqlite3_str_appendf(pAccum, "(join-%u)", pSel->selId);
          }else if( pSel->selFlags & 0x0000400 ){
            ((void) (0));
            sqlite3_str_appendf(pAccum, "%u-ROW VALUES CLAUSE",
                                pItem->u1.nRow);
          }else{
            sqlite3_str_appendf(pAccum, "(subquery-%u)", pSel->selId);
          }
        }
        length = width = 0;
        break;
      }
      default: {
        ((void) (0));
        return;
      }
    }
# 32936 "c_tests/sqlite3.c"
    width -= length;
    if( width>0 ){
      if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');
      sqlite3_str_append(pAccum, bufpt, length);
      if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');
    }else{
      sqlite3_str_append(pAccum, bufpt, length);
    }

    if( zExtra ){
      sqlite3DbFree(pAccum->db, zExtra);
      zExtra = 0;
    }
  }
}
# 32959 "c_tests/sqlite3.c"
static void sqlite3RecordErrorByteOffset(sqlite3 *db, const char *z){
  const Parse *pParse;
  const char *zText;
  const char *zEnd;
  ((void) (0));
  if( (db==0) ) return;
  if( db->errByteOffset!=(-2) ) return;
  pParse = db->pParse;
  if( (pParse==0) ) return;
  zText =pParse->zTail;
  if( (zText==0) ) return;
  zEnd = &zText[strlen(zText)];
  if( (((uptr)(z)>=(uptr)(zText))&&((uptr)(z)<(uptr)(zEnd))) ){
    db->errByteOffset = (int)(z-zText);
  }
}





static void sqlite3RecordErrorOffsetOfExpr(sqlite3 *db, const Expr *pExpr){
  while( pExpr
     && ((((pExpr)->flags&(u32)(0x000001|0x000002))!=0) || pExpr->w.iOfst<=0)
  ){
    pExpr = pExpr->pLeft;
  }
  if( pExpr==0 ) return;
  if( (((pExpr)->flags&(u32)(0x40000000))!=0) ) return;
  db->errByteOffset = pExpr->w.iOfst;
}
# 32998 "c_tests/sqlite3.c"
static int sqlite3StrAccumEnlarge(StrAccum *p, i64 N){
  char *zNew;
  ((void) (0));
  if( p->accError ){
                                        ;
                                       ;
    return 0;
  }
  if( p->mxAlloc==0 ){
    sqlite3StrAccumSetError(p, 18);
    return p->nAlloc - p->nChar - 1;
  }else{
    char *zOld = (((p)->printfFlags & 0x04)!=0) ? p->zText : 0;
    i64 szNew = p->nChar + N + 1;
    if( szNew+p->nChar<=p->mxAlloc ){


      szNew += p->nChar;
    }
    if( szNew > p->mxAlloc ){
      sqlite3_str_reset(p);
      sqlite3StrAccumSetError(p, 18);
      return 0;
    }else{
      p->nAlloc = (int)szNew;
    }
    if( p->db ){
      zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);
    }else{
      zNew = sqlite3Realloc(zOld, p->nAlloc);
    }
    if( zNew ){
      ((void) (0));
      if( !(((p)->printfFlags & 0x04)!=0) && p->nChar>0 ) memcpy(zNew, p->zText, p->nChar);
      p->zText = zNew;
      p->nAlloc = sqlite3DbMallocSize(p->db, zNew);
      p->printfFlags |= 0x04;
    }else{
      sqlite3_str_reset(p);
      sqlite3StrAccumSetError(p, 7);
      return 0;
    }
  }
  ((void) (0));
  return (int)N;
}




           void sqlite3_str_appendchar(sqlite3_str *p, int N, char c){
                                            ;
  if( p->nChar+(i64)N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N))<=0 ){
    return;
  }
  while( (N--)>0 ) p->zText[p->nChar++] = c;
}
# 33064 "c_tests/sqlite3.c"
static void __attribute__((noinline)) enlargeAndAppend(StrAccum *p, const char *z, int N){
  N = sqlite3StrAccumEnlarge(p, N);
  if( N>0 ){
    memcpy(&p->zText[p->nChar], z, N);
    p->nChar += N;
  }
}





           void sqlite3_str_append(sqlite3_str *p, const char *z, int N){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( p->nChar+N >= p->nAlloc ){
    enlargeAndAppend(p,z,N);
  }else if( N ){
    ((void) (0));
    p->nChar += N;
    memcpy(&p->zText[p->nChar-N], z, N);
  }
}




           void sqlite3_str_appendall(sqlite3_str *p, const char *z){
  sqlite3_str_append(p, z, sqlite3Strlen30(z));
}







static __attribute__((noinline)) char *strAccumFinishRealloc(StrAccum *p){
  char *zText;
  ((void) (0));
  zText = sqlite3DbMallocRaw(p->db, 1+(u64)p->nChar );
  if( zText ){
    memcpy(zText, p->zText, p->nChar+1);
    p->printfFlags |= 0x04;
  }else{
    sqlite3StrAccumSetError(p, 7);
  }
  p->zText = zText;
  return zText;
}
static char *sqlite3StrAccumFinish(StrAccum *p){
  if( p->zText ){
    p->zText[p->nChar] = 0;
    if( p->mxAlloc>0 && !(((p)->printfFlags & 0x04)!=0) ){
      return strAccumFinishRealloc(p);
    }
  }
  return p->zText;
}





static void sqlite3ResultStrAccum(sqlite3_context *pCtx, StrAccum *p){
  if( p->accError ){
    sqlite3_result_error_code(pCtx, p->accError);
    sqlite3_str_reset(p);
  }else if( (((p)->printfFlags & 0x04)!=0) ){
    sqlite3_result_text(pCtx, p->zText, p->nChar, ((sqlite3_destructor_type)sqlite3RowSetClear));
  }else{
    sqlite3_result_text(pCtx, "", 0, ((sqlite3_destructor_type)0));
    sqlite3_str_reset(p);
  }
}







static sqlite3_str sqlite3OomStr = {
   0, 0, 0, 0, 0, 7, 0
};



           char *sqlite3_str_finish(sqlite3_str *p){
  char *z;
  if( p!=0 && p!=&sqlite3OomStr ){
    z = sqlite3StrAccumFinish(p);
    sqlite3_free(p);
  }else{
    z = 0;
  }
  return z;
}


           int sqlite3_str_errcode(sqlite3_str *p){
  return p ? p->accError : 7;
}


           int sqlite3_str_length(sqlite3_str *p){
  return p ? p->nChar : 0;
}


           char *sqlite3_str_value(sqlite3_str *p){
  if( p==0 || p->nChar==0 ) return 0;
  p->zText[p->nChar] = 0;
  return p->zText;
}




           void sqlite3_str_reset(StrAccum *p){
  if( (((p)->printfFlags & 0x04)!=0) ){
    sqlite3DbFree(p->db, p->zText);
    p->printfFlags &= ~0x04;
  }
  p->nAlloc = 0;
  p->nChar = 0;
  p->zText = 0;
}
# 33209 "c_tests/sqlite3.c"
static void sqlite3StrAccumInit(StrAccum *p, sqlite3 *db, char *zBase, int n, int mx){
  p->zText = zBase;
  p->db = db;
  p->nAlloc = n;
  p->mxAlloc = mx;
  p->nChar = 0;
  p->accError = 0;
  p->printfFlags = 0;
}


           sqlite3_str *sqlite3_str_new(sqlite3 *db){
  sqlite3_str *p = sqlite3_malloc64(sizeof(*p));
  if( p ){
    sqlite3StrAccumInit(p, 0, 0, 0,
            db ? db->aLimit[0] : 1000000000);
  }else{
    p = &sqlite3OomStr;
  }
  return p;
}





static char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){
  char *z;
  char zBase[70];
  StrAccum acc;
  ((void) (0));
  sqlite3StrAccumInit(&acc, db, zBase, sizeof(zBase),
                      db->aLimit[0]);
  acc.printfFlags = 0x01;
  sqlite3_str_vappendf(&acc, zFormat, ap);
  z = sqlite3StrAccumFinish(&acc);
  if( acc.accError==7 ){
    sqlite3OomFault(db);
  }
  return z;
}





static char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){
  va_list ap;
  char *z;
  __builtin_va_start(ap, zFormat);
  z = sqlite3VMPrintf(db, zFormat, ap);
  __builtin_va_end(ap);
  return z;
}





           char *sqlite3_vmprintf(const char *zFormat, va_list ap){
  char *z;
  char zBase[70];
  StrAccum acc;
# 33280 "c_tests/sqlite3.c"
  if( sqlite3_initialize() ) return 0;

  sqlite3StrAccumInit(&acc, 0, zBase, sizeof(zBase), 1000000000);
  sqlite3_str_vappendf(&acc, zFormat, ap);
  z = sqlite3StrAccumFinish(&acc);
  return z;
}





           char *sqlite3_mprintf(const char *zFormat, ...){
  va_list ap;
  char *z;

  if( sqlite3_initialize() ) return 0;

  __builtin_va_start(ap, zFormat);
  z = sqlite3_vmprintf(zFormat, ap);
  __builtin_va_end(ap);
  return z;
}
# 33317 "c_tests/sqlite3.c"
           char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){
  StrAccum acc;
  if( n<=0 ) return zBuf;







  sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);
  sqlite3_str_vappendf(&acc, zFormat, ap);
  zBuf[acc.nChar] = 0;
  return zBuf;
}
           char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){
  StrAccum acc;
  va_list ap;
  if( n<=0 ) return zBuf;







  sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);
  __builtin_va_start(ap, zFormat);
  sqlite3_str_vappendf(&acc, zFormat, ap);
  __builtin_va_end(ap);
  zBuf[acc.nChar] = 0;
  return zBuf;
}
# 33374 "c_tests/sqlite3.c"
static void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){
  StrAccum acc;
  char zMsg[(70*10)];

  sqlite3StrAccumInit(&acc, 0, zMsg, sizeof(zMsg), 0);
  sqlite3_str_vappendf(&acc, zFormat, ap);
  sqlite3Config.xLog(sqlite3Config.pLogArg, iErrCode,
                           sqlite3StrAccumFinish(&acc));
}




           void sqlite3_log(int iErrCode, const char *zFormat, ...){
  va_list ap;
  if( sqlite3Config.xLog ){
    __builtin_va_start(ap, zFormat);
    renderLogMsg(iErrCode, zFormat, ap);
    __builtin_va_end(ap);
  }
}
# 33428 "c_tests/sqlite3.c"
           void sqlite3_str_appendf(StrAccum *p, const char *zFormat, ...){
  va_list ap;
  __builtin_va_start(ap, zFormat);
  sqlite3_str_vappendf(p, zFormat, ap);
  __builtin_va_end(ap);
}
# 33445 "c_tests/sqlite3.c"
static char *sqlite3RCStrRef(char *z){
  RCStr *p = (RCStr*)z;
  ((void) (0));
  p--;
  p->nRCRef++;
  return z;
}





static void sqlite3RCStrUnref(void *z){
  RCStr *p = (RCStr*)z;
  ((void) (0));
  p--;
  ((void) (0));
  if( p->nRCRef>=2 ){
    p->nRCRef--;
  }else{
    sqlite3_free(p);
  }
}
# 33478 "c_tests/sqlite3.c"
static char *sqlite3RCStrNew(u64 N){
  RCStr *p = sqlite3_malloc64( N + sizeof(*p) + 1 );
  if( p==0 ) return 0;
  p->nRCRef = 1;
  return (char*)&p[1];
}





static char *sqlite3RCStrResize(char *z, u64 N){
  RCStr *p = (RCStr*)z;
  RCStr *pNew;
  ((void) (0));
  p--;
  ((void) (0));
  pNew = sqlite3_realloc64(p, N+sizeof(RCStr)+1);
  if( pNew==0 ){
    sqlite3_free(p);
    return 0;
  }else{
    return (char*)&pNew[1];
  }
}
# 34854 "c_tests/sqlite3.c"
static struct sqlite3PrngType {
  u32 s[16];
  u8 out[64];
  u8 n;
} sqlite3Prng;
# 34869 "c_tests/sqlite3.c"
static void chacha_block(u32 *out, const u32 *in){
  int i;
  u32 x[16];
  memcpy(x, in, 64);
  for(i=0; i<10; i++){
    ( x[0] += x[4], x[12] ^= x[0], x[12] = (((x[12]) << (16)) | ((x[12]) >> (32 - (16)))), x[ 8] += x[12], x[4] ^= x[ 8], x[4] = (((x[4]) << (12)) | ((x[4]) >> (32 - (12)))), x[0] += x[4], x[12] ^= x[0], x[12] = (((x[12]) << (8)) | ((x[12]) >> (32 - (8)))), x[ 8] += x[12], x[4] ^= x[ 8], x[4] = (((x[4]) << (7)) | ((x[4]) >> (32 - (7)))));
    ( x[1] += x[5], x[13] ^= x[1], x[13] = (((x[13]) << (16)) | ((x[13]) >> (32 - (16)))), x[ 9] += x[13], x[5] ^= x[ 9], x[5] = (((x[5]) << (12)) | ((x[5]) >> (32 - (12)))), x[1] += x[5], x[13] ^= x[1], x[13] = (((x[13]) << (8)) | ((x[13]) >> (32 - (8)))), x[ 9] += x[13], x[5] ^= x[ 9], x[5] = (((x[5]) << (7)) | ((x[5]) >> (32 - (7)))));
    ( x[2] += x[6], x[14] ^= x[2], x[14] = (((x[14]) << (16)) | ((x[14]) >> (32 - (16)))), x[10] += x[14], x[6] ^= x[10], x[6] = (((x[6]) << (12)) | ((x[6]) >> (32 - (12)))), x[2] += x[6], x[14] ^= x[2], x[14] = (((x[14]) << (8)) | ((x[14]) >> (32 - (8)))), x[10] += x[14], x[6] ^= x[10], x[6] = (((x[6]) << (7)) | ((x[6]) >> (32 - (7)))));
    ( x[3] += x[7], x[15] ^= x[3], x[15] = (((x[15]) << (16)) | ((x[15]) >> (32 - (16)))), x[11] += x[15], x[7] ^= x[11], x[7] = (((x[7]) << (12)) | ((x[7]) >> (32 - (12)))), x[3] += x[7], x[15] ^= x[3], x[15] = (((x[15]) << (8)) | ((x[15]) >> (32 - (8)))), x[11] += x[15], x[7] ^= x[11], x[7] = (((x[7]) << (7)) | ((x[7]) >> (32 - (7)))));
    ( x[0] += x[5], x[15] ^= x[0], x[15] = (((x[15]) << (16)) | ((x[15]) >> (32 - (16)))), x[10] += x[15], x[5] ^= x[10], x[5] = (((x[5]) << (12)) | ((x[5]) >> (32 - (12)))), x[0] += x[5], x[15] ^= x[0], x[15] = (((x[15]) << (8)) | ((x[15]) >> (32 - (8)))), x[10] += x[15], x[5] ^= x[10], x[5] = (((x[5]) << (7)) | ((x[5]) >> (32 - (7)))));
    ( x[1] += x[6], x[12] ^= x[1], x[12] = (((x[12]) << (16)) | ((x[12]) >> (32 - (16)))), x[11] += x[12], x[6] ^= x[11], x[6] = (((x[6]) << (12)) | ((x[6]) >> (32 - (12)))), x[1] += x[6], x[12] ^= x[1], x[12] = (((x[12]) << (8)) | ((x[12]) >> (32 - (8)))), x[11] += x[12], x[6] ^= x[11], x[6] = (((x[6]) << (7)) | ((x[6]) >> (32 - (7)))));
    ( x[2] += x[7], x[13] ^= x[2], x[13] = (((x[13]) << (16)) | ((x[13]) >> (32 - (16)))), x[ 8] += x[13], x[7] ^= x[ 8], x[7] = (((x[7]) << (12)) | ((x[7]) >> (32 - (12)))), x[2] += x[7], x[13] ^= x[2], x[13] = (((x[13]) << (8)) | ((x[13]) >> (32 - (8)))), x[ 8] += x[13], x[7] ^= x[ 8], x[7] = (((x[7]) << (7)) | ((x[7]) >> (32 - (7)))));
    ( x[3] += x[4], x[14] ^= x[3], x[14] = (((x[14]) << (16)) | ((x[14]) >> (32 - (16)))), x[ 9] += x[14], x[4] ^= x[ 9], x[4] = (((x[4]) << (12)) | ((x[4]) >> (32 - (12)))), x[3] += x[4], x[14] ^= x[3], x[14] = (((x[14]) << (8)) | ((x[14]) >> (32 - (8)))), x[ 9] += x[14], x[4] ^= x[ 9], x[4] = (((x[4]) << (7)) | ((x[4]) >> (32 - (7)))));
  }
  for(i=0; i<16; i++) out[i] = x[i]+in[i];
}




           void sqlite3_randomness(int N, void *pBuf){
  unsigned char *zBuf = pBuf;
# 34906 "c_tests/sqlite3.c"
  sqlite3_mutex *mutex;



  if( sqlite3_initialize() ) return;



  mutex = sqlite3MutexAlloc(5);


  sqlite3_mutex_enter(mutex);
  if( N<=0 || pBuf==0 ){
    sqlite3Prng.s[0] = 0;
    sqlite3_mutex_leave(mutex);
    return;
  }




  if( sqlite3Prng.s[0]==0 ){
    sqlite3_vfs *pVfs = sqlite3_vfs_find(0);
    static const u32 chacha20_init[] = {
      0x61707865, 0x3320646e, 0x79622d32, 0x6b206574
    };
    memcpy(&sqlite3Prng.s[0], chacha20_init, 16);
    if( (pVfs==0) ){
      memset(&sqlite3Prng.s[4], 0, 44);
    }else{
      sqlite3OsRandomness(pVfs, 44, (char*)&sqlite3Prng.s[4]);
    }
    sqlite3Prng.s[15] = sqlite3Prng.s[12];
    sqlite3Prng.s[12] = 0;
    sqlite3Prng.n = 0;
  }

  ((void) (0));
  while( 1 ){
    if( N<=sqlite3Prng.n ){
      memcpy(zBuf, &sqlite3Prng.out[sqlite3Prng.n-N], N);
      sqlite3Prng.n -= N;
      break;
    }
    if( sqlite3Prng.n>0 ){
      memcpy(zBuf, sqlite3Prng.out, sqlite3Prng.n);
      N -= sqlite3Prng.n;
      zBuf += sqlite3Prng.n;
    }
    sqlite3Prng.s[12]++;
    chacha_block((u32*)sqlite3Prng.out, sqlite3Prng.s);
    sqlite3Prng.n = 64;
  }
  sqlite3_mutex_leave(mutex);
}
# 34972 "c_tests/sqlite3.c"
static struct sqlite3PrngType sqlite3SavedPrng;
static void sqlite3PrngSaveState(void){
  memcpy(
    &sqlite3SavedPrng,
    &sqlite3Prng,
    sizeof(sqlite3Prng)
  );
}
static void sqlite3PrngRestoreState(void){
  memcpy(
    &sqlite3Prng,
    &sqlite3SavedPrng,
    sizeof(sqlite3Prng)
  );
}
# 35032 "c_tests/sqlite3.c"
struct SQLiteThread {
  pthread_t tid;
  int done;
  void *pOut;
  void *(*xTask)(void*);
  void *pIn;
};


static int sqlite3ThreadCreate(
  SQLiteThread **ppThread,
  void *(*xTask)(void*),
  void *pIn
){
  SQLiteThread *p;
  int rc;

  ((void) (0));
  ((void) (0));

  ((void) (0));

  *ppThread = 0;
  p = sqlite3Malloc(sizeof(*p));
  if( p==0 ) return 7;
  memset(p, 0, sizeof(*p));
  p->xTask = xTask;
  p->pIn = pIn;




  if( sqlite3FaultSim(200) ){
    rc = 1;
  }else{
    rc = pthread_create(&p->tid, 0, xTask, pIn);
  }
  if( rc ){
    p->done = 1;
    p->pOut = xTask(pIn);
  }
  *ppThread = p;
  return 0;
}


static int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){
  int rc;

  ((void) (0));
  if( (p==0) ) return 7;
  if( p->done ){
    *ppOut = p->pOut;
    rc = 0;
  }else{
    rc = pthread_join(p->tid, ppOut) ? 1 : 0;
  }
  sqlite3_free(p);
  return rc;
}
# 35319 "c_tests/sqlite3.c"
static const unsigned char sqlite3Utf8Trans1[] = {
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
};
# 35381 "c_tests/sqlite3.c"
static int sqlite3AppendOneUtf8Character(char *zOut, u32 v){
  if( v<0x00080 ){
    zOut[0] = (u8)(v & 0xff);
    return 1;
  }
  if( v<0x00800 ){
    zOut[0] = 0xc0 + (u8)((v>>6) & 0x1f);
    zOut[1] = 0x80 + (u8)(v & 0x3f);
    return 2;
  }
  if( v<0x10000 ){
    zOut[0] = 0xe0 + (u8)((v>>12) & 0x0f);
    zOut[1] = 0x80 + (u8)((v>>6) & 0x3f);
    zOut[2] = 0x80 + (u8)(v & 0x3f);
    return 3;
  }
  zOut[0] = 0xf0 + (u8)((v>>18) & 0x07);
  zOut[1] = 0x80 + (u8)((v>>12) & 0x3f);
  zOut[2] = 0x80 + (u8)((v>>6) & 0x3f);
  zOut[3] = 0x80 + (u8)(v & 0x3f);
  return 4;
}
# 35442 "c_tests/sqlite3.c"
static u32 sqlite3Utf8Read(
  const unsigned char **pz
){
  unsigned int c;




  c = *((*pz)++);
  if( c>=0xc0 ){
    c = sqlite3Utf8Trans1[c-0xc0];
    while( (*(*pz) & 0xc0)==0x80 ){
      c = (c<<6) + (0x3f & *((*pz)++));
    }
    if( c<0x80
        || (c&0xFFFFF800)==0xD800
        || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; }
  }
  return c;
}
# 35475 "c_tests/sqlite3.c"
static int sqlite3Utf8ReadLimited(
  const u8 *z,
  int n,
  u32 *piOut
){
  u32 c;
  int i = 1;
  ((void) (0));
  c = z[0];
  if( c>=0xc0 ){
    c = sqlite3Utf8Trans1[c-0xc0];
    if( n>4 ) n = 4;
    while( i<n && (z[i] & 0xc0)==0x80 ){
      c = (c<<6) + (0x3f & z[i]);
      i++;
    }
  }
  *piOut = c;
  return i;
}
# 35509 "c_tests/sqlite3.c"
static __attribute__((noinline)) int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){
  sqlite3_int64 len;
  unsigned char *zOut;
  unsigned char *zIn;
  unsigned char *zTerm;
  unsigned char *z;
  unsigned int c;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
# 35537 "c_tests/sqlite3.c"
  if( pMem->enc!=1 && desiredEnc!=1 ){
    u8 temp;
    int rc;
    rc = sqlite3VdbeMemMakeWriteable(pMem);
    if( rc!=0 ){
      ((void) (0));
      return 7;
    }
    zIn = (u8*)pMem->z;
    zTerm = &zIn[pMem->n&~1];
    while( zIn<zTerm ){
      temp = *zIn;
      *zIn = *(zIn+1);
      zIn++;
      *zIn++ = temp;
    }
    pMem->enc = desiredEnc;
    goto translate_out;
  }


  if( desiredEnc==1 ){





    pMem->n &= ~1;
    len = 2 * (sqlite3_int64)pMem->n + 1;
  }else{





    len = 2 * (sqlite3_int64)pMem->n + 2;
  }







  zIn = (u8*)pMem->z;
  zTerm = &zIn[pMem->n];
  zOut = sqlite3DbMallocRaw(pMem->db, len);
  if( !zOut ){
    return 7;
  }
  z = zOut;

  if( pMem->enc==1 ){
    if( desiredEnc==2 ){

      while( zIn<zTerm ){
        c = *(zIn++); if( c>=0xc0 ){ c = sqlite3Utf8Trans1[c-0xc0]; while( zIn<zTerm && (*zIn & 0xc0)==0x80 ){ c = (c<<6) + (0x3f & *(zIn++)); } if( c<0x80 || (c&0xFFFFF800)==0xD800 || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; } };
        { if( c<=0xFFFF ){ *z++ = (u8)(c&0x00FF); *z++ = (u8)((c>>8)&0x00FF); }else{ *z++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *z++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03)); *z++ = (u8)(c&0x00FF); *z++ = (u8)(0x00DC + ((c>>8)&0x03)); } };
      }
    }else{
      ((void) (0));

      while( zIn<zTerm ){
        c = *(zIn++); if( c>=0xc0 ){ c = sqlite3Utf8Trans1[c-0xc0]; while( zIn<zTerm && (*zIn & 0xc0)==0x80 ){ c = (c<<6) + (0x3f & *(zIn++)); } if( c<0x80 || (c&0xFFFFF800)==0xD800 || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; } };
        { if( c<=0xFFFF ){ *z++ = (u8)((c>>8)&0x00FF); *z++ = (u8)(c&0x00FF); }else{ *z++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03)); *z++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *z++ = (u8)(0x00DC + ((c>>8)&0x03)); *z++ = (u8)(c&0x00FF); } };
      }
    }
    pMem->n = (int)(z - zOut);
    *z++ = 0;
  }else{
    ((void) (0));
    if( pMem->enc==2 ){

      while( zIn<zTerm ){
        c = *(zIn++);
        c += (*(zIn++))<<8;
        if( c>=0xd800 && c<0xe000 ){
# 35628 "c_tests/sqlite3.c"
          if( zIn<zTerm ){
            int c2 = (*zIn++);
            c2 += ((*zIn++)<<8);
            c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);
          }

        }
        { if( c<0x00080 ){ *z++ = (u8)(c&0xFF); } else if( c<0x00800 ){ *z++ = 0xC0 + (u8)((c>>6)&0x1F); *z++ = 0x80 + (u8)(c & 0x3F); } else if( c<0x10000 ){ *z++ = 0xE0 + (u8)((c>>12)&0x0F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); }else{ *z++ = 0xF0 + (u8)((c>>18) & 0x07); *z++ = 0x80 + (u8)((c>>12) & 0x3F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); } };
      }
    }else{

      while( zIn<zTerm ){
        c = (*(zIn++))<<8;
        c += *(zIn++);
        if( c>=0xd800 && c<0xe000 ){
# 35657 "c_tests/sqlite3.c"
          if( zIn<zTerm ){
            int c2 = ((*zIn++)<<8);
            c2 += (*zIn++);
            c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);
          }

        }
        { if( c<0x00080 ){ *z++ = (u8)(c&0xFF); } else if( c<0x00800 ){ *z++ = 0xC0 + (u8)((c>>6)&0x1F); *z++ = 0x80 + (u8)(c & 0x3F); } else if( c<0x10000 ){ *z++ = 0xE0 + (u8)((c>>12)&0x0F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); }else{ *z++ = 0xF0 + (u8)((c>>18) & 0x07); *z++ = 0x80 + (u8)((c>>12) & 0x3F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); } };
      }
    }
    pMem->n = (int)(z - zOut);
  }
  *z = 0;
  ((void) (0));

  c = 0x0002|0x0200|(pMem->flags&(0x003f|0x0800));
  sqlite3VdbeMemRelease(pMem);
  pMem->flags = c;
  pMem->enc = desiredEnc;
  pMem->z = (char*)zOut;
  pMem->zMalloc = pMem->z;
  pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->z);

translate_out:
# 35690 "c_tests/sqlite3.c"
  return 0;
}
# 35704 "c_tests/sqlite3.c"
static int sqlite3VdbeMemHandleBom(Mem *pMem){
  int rc = 0;
  u8 bom = 0;

  ((void) (0));
  if( pMem->n>1 ){
    u8 b1 = *(u8 *)pMem->z;
    u8 b2 = *(((u8 *)pMem->z) + 1);
    if( b1==0xFE && b2==0xFF ){
      bom = 3;
    }
    if( b1==0xFF && b2==0xFE ){
      bom = 2;
    }
  }

  if( bom ){
    rc = sqlite3VdbeMemMakeWriteable(pMem);
    if( rc==0 ){
      pMem->n -= 2;
      memmove(pMem->z, &pMem->z[2], pMem->n);
      pMem->z[pMem->n] = '\0';
      pMem->z[pMem->n+1] = '\0';
      pMem->flags |= 0x0200;
      pMem->enc = bom;
    }
  }
  return rc;
}
# 35742 "c_tests/sqlite3.c"
static int sqlite3Utf8CharLen(const char *zIn, int nByte){
  int r = 0;
  const u8 *z = (const u8*)zIn;
  const u8 *zTerm;
  if( nByte>=0 ){
    zTerm = &z[nByte];
  }else{
    zTerm = (const u8*)(-1);
  }
  ((void) (0));
  while( *z!=0 && z<zTerm ){
    { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
    r++;
  }
  return r;
}
# 35796 "c_tests/sqlite3.c"
static char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte, u8 enc){
  Mem m;
  memset(&m, 0, sizeof(m));
  m.db = db;
  sqlite3VdbeMemSetStr(&m, z, nByte, enc, ((sqlite3_destructor_type)0));
  sqlite3VdbeChangeEncoding(&m, 1);
  if( db->mallocFailed ){
    sqlite3VdbeMemRelease(&m);
    m.z = 0;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return m.z;
}







static int sqlite3Utf16ByteLen(const void *zIn, int nByte, int nChar){
  int c;
  unsigned char const *z = zIn;
  unsigned char const *zEnd = &z[nByte-1];
  int n = 0;

  if( 2==2 ) z++;
  while( n<nChar && z<=zEnd ){
    c = z[0];
    z += 2;
    if( c>=0xd8 && c<0xdc && z<=zEnd && z[0]>=0xdc && z[0]<0xe0 ) z += 2;
    n++;
  }
  return (int)(z-(unsigned char const *)zIn)
              - (2==2);
}
# 35888 "c_tests/sqlite3.c"
# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4
# 40 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 156 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 157 "/usr/include/math.h" 2 3 4
# 167 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 208 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 209 "/usr/include/math.h" 2 3 4
# 251 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 252 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-macros.h" 1 3 4
# 276 "/usr/include/math.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));



extern int __isinf (double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __isnan (double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) __attribute__ ((__nothrow__ ));


extern int __issignaling (double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));
# 282 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern double acos (double __x) __attribute__ ((__nothrow__ )); extern double __acos (double __x) __attribute__ ((__nothrow__ ));

 extern double asin (double __x) __attribute__ ((__nothrow__ )); extern double __asin (double __x) __attribute__ ((__nothrow__ ));

 extern double atan (double __x) __attribute__ ((__nothrow__ )); extern double __atan (double __x) __attribute__ ((__nothrow__ ));

 extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ )); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ ));


 extern double cos (double __x) __attribute__ ((__nothrow__ )); extern double __cos (double __x) __attribute__ ((__nothrow__ ));

 extern double sin (double __x) __attribute__ ((__nothrow__ )); extern double __sin (double __x) __attribute__ ((__nothrow__ ));

 extern double tan (double __x) __attribute__ ((__nothrow__ )); extern double __tan (double __x) __attribute__ ((__nothrow__ ));



extern double acospi (double __x) __attribute__ ((__nothrow__ )); extern double __acospi (double __x) __attribute__ ((__nothrow__ ));

extern double asinpi (double __x) __attribute__ ((__nothrow__ )); extern double __asinpi (double __x) __attribute__ ((__nothrow__ ));

extern double atanpi (double __x) __attribute__ ((__nothrow__ )); extern double __atanpi (double __x) __attribute__ ((__nothrow__ ));

extern double atan2pi (double __y, double __x) __attribute__ ((__nothrow__ )); extern double __atan2pi (double __y, double __x) __attribute__ ((__nothrow__ ));


 extern double cospi (double __x) __attribute__ ((__nothrow__ )); extern double __cospi (double __x) __attribute__ ((__nothrow__ ));

 extern double sinpi (double __x) __attribute__ ((__nothrow__ )); extern double __sinpi (double __x) __attribute__ ((__nothrow__ ));

 extern double tanpi (double __x) __attribute__ ((__nothrow__ )); extern double __tanpi (double __x) __attribute__ ((__nothrow__ ));





 extern double cosh (double __x) __attribute__ ((__nothrow__ )); extern double __cosh (double __x) __attribute__ ((__nothrow__ ));

 extern double sinh (double __x) __attribute__ ((__nothrow__ )); extern double __sinh (double __x) __attribute__ ((__nothrow__ ));

 extern double tanh (double __x) __attribute__ ((__nothrow__ )); extern double __tanh (double __x) __attribute__ ((__nothrow__ ));



 extern void sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ )); extern void __sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ ));





 extern double acosh (double __x) __attribute__ ((__nothrow__ )); extern double __acosh (double __x) __attribute__ ((__nothrow__ ));

 extern double asinh (double __x) __attribute__ ((__nothrow__ )); extern double __asinh (double __x) __attribute__ ((__nothrow__ ));

 extern double atanh (double __x) __attribute__ ((__nothrow__ )); extern double __atanh (double __x) __attribute__ ((__nothrow__ ));





 extern double exp (double __x) __attribute__ ((__nothrow__ )); extern double __exp (double __x) __attribute__ ((__nothrow__ ));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ )); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ ));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ )); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ ));


 extern double log (double __x) __attribute__ ((__nothrow__ )); extern double __log (double __x) __attribute__ ((__nothrow__ ));


 extern double log10 (double __x) __attribute__ ((__nothrow__ )); extern double __log10 (double __x) __attribute__ ((__nothrow__ ));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ )); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



 extern double exp10 (double __x) __attribute__ ((__nothrow__ )); extern double __exp10 (double __x) __attribute__ ((__nothrow__ ));


extern double exp2m1 (double __x) __attribute__ ((__nothrow__ )); extern double __exp2m1 (double __x) __attribute__ ((__nothrow__ ));


extern double exp10m1 (double __x) __attribute__ ((__nothrow__ )); extern double __exp10m1 (double __x) __attribute__ ((__nothrow__ ));


extern double log2p1 (double __x) __attribute__ ((__nothrow__ )); extern double __log2p1 (double __x) __attribute__ ((__nothrow__ ));


extern double log10p1 (double __x) __attribute__ ((__nothrow__ )); extern double __log10p1 (double __x) __attribute__ ((__nothrow__ ));


 extern double logp1 (double __x) __attribute__ ((__nothrow__ )); extern double __logp1 (double __x) __attribute__ ((__nothrow__ ));




 extern double expm1 (double __x) __attribute__ ((__nothrow__ )); extern double __expm1 (double __x) __attribute__ ((__nothrow__ ));


 extern double log1p (double __x) __attribute__ ((__nothrow__ )); extern double __log1p (double __x) __attribute__ ((__nothrow__ ));


extern double logb (double __x) __attribute__ ((__nothrow__ )); extern double __logb (double __x) __attribute__ ((__nothrow__ ));




 extern double exp2 (double __x) __attribute__ ((__nothrow__ )); extern double __exp2 (double __x) __attribute__ ((__nothrow__ ));


 extern double log2 (double __x) __attribute__ ((__nothrow__ )); extern double __log2 (double __x) __attribute__ ((__nothrow__ ));






 extern double pow (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ ));


extern double sqrt (double __x) __attribute__ ((__nothrow__ )); extern double __sqrt (double __x) __attribute__ ((__nothrow__ ));



 extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ ));




 extern double cbrt (double __x) __attribute__ ((__nothrow__ )); extern double __cbrt (double __x) __attribute__ ((__nothrow__ ));






extern double ceil (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ ));
# 210 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinf (double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));




extern int finite (double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ ));



extern double significand (double __x) __attribute__ ((__nothrow__ )); extern double __significand (double __x) __attribute__ ((__nothrow__ ));






extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern double nan (const char *__tagb) __attribute__ ((__nothrow__ )); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ ));
# 246 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnan (double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));





extern double j0 (double) __attribute__ ((__nothrow__ )); extern double __j0 (double) __attribute__ ((__nothrow__ ));
extern double j1 (double) __attribute__ ((__nothrow__ )); extern double __j1 (double) __attribute__ ((__nothrow__ ));
extern double jn (int, double) __attribute__ ((__nothrow__ )); extern double __jn (int, double) __attribute__ ((__nothrow__ ));
extern double y0 (double) __attribute__ ((__nothrow__ )); extern double __y0 (double) __attribute__ ((__nothrow__ ));
extern double y1 (double) __attribute__ ((__nothrow__ )); extern double __y1 (double) __attribute__ ((__nothrow__ ));
extern double yn (int, double) __attribute__ ((__nothrow__ )); extern double __yn (int, double) __attribute__ ((__nothrow__ ));





 extern double erf (double) __attribute__ ((__nothrow__ )); extern double __erf (double) __attribute__ ((__nothrow__ ));
 extern double erfc (double) __attribute__ ((__nothrow__ )); extern double __erfc (double) __attribute__ ((__nothrow__ ));
extern double lgamma (double) __attribute__ ((__nothrow__ )); extern double __lgamma (double) __attribute__ ((__nothrow__ ));




extern double tgamma (double) __attribute__ ((__nothrow__ )); extern double __tgamma (double) __attribute__ ((__nothrow__ ));





extern double gamma (double) __attribute__ ((__nothrow__ )); extern double __gamma (double) __attribute__ ((__nothrow__ ));







extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ )); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ ));






extern double rint (double __x) __attribute__ ((__nothrow__ )); extern double __rint (double __x) __attribute__ ((__nothrow__ ));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ ));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ )); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ ));




extern double nextdown (double __x) __attribute__ ((__nothrow__ )); extern double __nextdown (double __x) __attribute__ ((__nothrow__ ));

extern double nextup (double __x) __attribute__ ((__nothrow__ )); extern double __nextup (double __x) __attribute__ ((__nothrow__ ));



extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ ));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ )); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ ));



extern int ilogb (double __x) __attribute__ ((__nothrow__ )); extern int __ilogb (double __x) __attribute__ ((__nothrow__ ));




extern long int llogb (double __x) __attribute__ ((__nothrow__ )); extern long int __llogb (double __x) __attribute__ ((__nothrow__ ));




extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ )); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ ));



extern double nearbyint (double __x) __attribute__ ((__nothrow__ )); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ ));



extern double round (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ )); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ ));






extern long int lrint (double __x) __attribute__ ((__nothrow__ )); extern long int __lrint (double __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llrint (double __x) __attribute__ ((__nothrow__ )); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ ));



extern long int lround (double __x) __attribute__ ((__nothrow__ )); extern long int __lround (double __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llround (double __x) __attribute__ ((__nothrow__ )); extern long long int __llround (double __x) __attribute__ ((__nothrow__ ));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ )); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ ));



extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ )); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ ));




extern double roundeven (double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));




extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));



extern int canonicalize (double *__cx, const double *__x) __attribute__ ((__nothrow__ ));






extern double fmaxmag (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern double fmaximum (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fminimum (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fmaximum_num (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fminimum_num (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fmaximum_mag (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fminimum_mag (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fmaximum_mag_num (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern double fminimum_mag_num (double __x, double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int totalorder (const double *__x, const double *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) __attribute__ ((__nothrow__ )); extern double __getpayload (const double *__x) __attribute__ ((__nothrow__ ));


extern int setpayload (double *__x, double __payload) __attribute__ ((__nothrow__ ));


extern int setpayloadsig (double *__x, double __payload) __attribute__ ((__nothrow__ ));







extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ )); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ ));
# 283 "/usr/include/math.h" 2 3 4
# 298 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));



extern int __isinff (float __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __isnanf (float __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) __attribute__ ((__nothrow__ ));


extern int __issignalingf (float __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));
# 299 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern float acosf (float __x) __attribute__ ((__nothrow__ )); extern float __acosf (float __x) __attribute__ ((__nothrow__ ));

 extern float asinf (float __x) __attribute__ ((__nothrow__ )); extern float __asinf (float __x) __attribute__ ((__nothrow__ ));

 extern float atanf (float __x) __attribute__ ((__nothrow__ )); extern float __atanf (float __x) __attribute__ ((__nothrow__ ));

 extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ )); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ ));


 extern float cosf (float __x) __attribute__ ((__nothrow__ )); extern float __cosf (float __x) __attribute__ ((__nothrow__ ));

 extern float sinf (float __x) __attribute__ ((__nothrow__ )); extern float __sinf (float __x) __attribute__ ((__nothrow__ ));

 extern float tanf (float __x) __attribute__ ((__nothrow__ )); extern float __tanf (float __x) __attribute__ ((__nothrow__ ));



extern float acospif (float __x) __attribute__ ((__nothrow__ )); extern float __acospif (float __x) __attribute__ ((__nothrow__ ));

extern float asinpif (float __x) __attribute__ ((__nothrow__ )); extern float __asinpif (float __x) __attribute__ ((__nothrow__ ));

extern float atanpif (float __x) __attribute__ ((__nothrow__ )); extern float __atanpif (float __x) __attribute__ ((__nothrow__ ));

extern float atan2pif (float __y, float __x) __attribute__ ((__nothrow__ )); extern float __atan2pif (float __y, float __x) __attribute__ ((__nothrow__ ));


 extern float cospif (float __x) __attribute__ ((__nothrow__ )); extern float __cospif (float __x) __attribute__ ((__nothrow__ ));

 extern float sinpif (float __x) __attribute__ ((__nothrow__ )); extern float __sinpif (float __x) __attribute__ ((__nothrow__ ));

 extern float tanpif (float __x) __attribute__ ((__nothrow__ )); extern float __tanpif (float __x) __attribute__ ((__nothrow__ ));





 extern float coshf (float __x) __attribute__ ((__nothrow__ )); extern float __coshf (float __x) __attribute__ ((__nothrow__ ));

 extern float sinhf (float __x) __attribute__ ((__nothrow__ )); extern float __sinhf (float __x) __attribute__ ((__nothrow__ ));

 extern float tanhf (float __x) __attribute__ ((__nothrow__ )); extern float __tanhf (float __x) __attribute__ ((__nothrow__ ));



 extern void sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ )); extern void __sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ ));





 extern float acoshf (float __x) __attribute__ ((__nothrow__ )); extern float __acoshf (float __x) __attribute__ ((__nothrow__ ));

 extern float asinhf (float __x) __attribute__ ((__nothrow__ )); extern float __asinhf (float __x) __attribute__ ((__nothrow__ ));

 extern float atanhf (float __x) __attribute__ ((__nothrow__ )); extern float __atanhf (float __x) __attribute__ ((__nothrow__ ));





 extern float expf (float __x) __attribute__ ((__nothrow__ )); extern float __expf (float __x) __attribute__ ((__nothrow__ ));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ )); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ ));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ )); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ ));


 extern float logf (float __x) __attribute__ ((__nothrow__ )); extern float __logf (float __x) __attribute__ ((__nothrow__ ));


 extern float log10f (float __x) __attribute__ ((__nothrow__ )); extern float __log10f (float __x) __attribute__ ((__nothrow__ ));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ )); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



 extern float exp10f (float __x) __attribute__ ((__nothrow__ )); extern float __exp10f (float __x) __attribute__ ((__nothrow__ ));


extern float exp2m1f (float __x) __attribute__ ((__nothrow__ )); extern float __exp2m1f (float __x) __attribute__ ((__nothrow__ ));


extern float exp10m1f (float __x) __attribute__ ((__nothrow__ )); extern float __exp10m1f (float __x) __attribute__ ((__nothrow__ ));


extern float log2p1f (float __x) __attribute__ ((__nothrow__ )); extern float __log2p1f (float __x) __attribute__ ((__nothrow__ ));


extern float log10p1f (float __x) __attribute__ ((__nothrow__ )); extern float __log10p1f (float __x) __attribute__ ((__nothrow__ ));


 extern float logp1f (float __x) __attribute__ ((__nothrow__ )); extern float __logp1f (float __x) __attribute__ ((__nothrow__ ));




 extern float expm1f (float __x) __attribute__ ((__nothrow__ )); extern float __expm1f (float __x) __attribute__ ((__nothrow__ ));


 extern float log1pf (float __x) __attribute__ ((__nothrow__ )); extern float __log1pf (float __x) __attribute__ ((__nothrow__ ));


extern float logbf (float __x) __attribute__ ((__nothrow__ )); extern float __logbf (float __x) __attribute__ ((__nothrow__ ));




 extern float exp2f (float __x) __attribute__ ((__nothrow__ )); extern float __exp2f (float __x) __attribute__ ((__nothrow__ ));


 extern float log2f (float __x) __attribute__ ((__nothrow__ )); extern float __log2f (float __x) __attribute__ ((__nothrow__ ));






 extern float powf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ ));


extern float sqrtf (float __x) __attribute__ ((__nothrow__ )); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ ));



 extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ ));




 extern float cbrtf (float __x) __attribute__ ((__nothrow__ )); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ ));






extern float ceilf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ ));
# 210 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));




extern int finitef (float __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ ));



extern float significandf (float __x) __attribute__ ((__nothrow__ )); extern float __significandf (float __x) __attribute__ ((__nothrow__ ));






extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ )); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ ));
# 246 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));





extern float j0f (float) __attribute__ ((__nothrow__ )); extern float __j0f (float) __attribute__ ((__nothrow__ ));
extern float j1f (float) __attribute__ ((__nothrow__ )); extern float __j1f (float) __attribute__ ((__nothrow__ ));
extern float jnf (int, float) __attribute__ ((__nothrow__ )); extern float __jnf (int, float) __attribute__ ((__nothrow__ ));
extern float y0f (float) __attribute__ ((__nothrow__ )); extern float __y0f (float) __attribute__ ((__nothrow__ ));
extern float y1f (float) __attribute__ ((__nothrow__ )); extern float __y1f (float) __attribute__ ((__nothrow__ ));
extern float ynf (int, float) __attribute__ ((__nothrow__ )); extern float __ynf (int, float) __attribute__ ((__nothrow__ ));





 extern float erff (float) __attribute__ ((__nothrow__ )); extern float __erff (float) __attribute__ ((__nothrow__ ));
 extern float erfcf (float) __attribute__ ((__nothrow__ )); extern float __erfcf (float) __attribute__ ((__nothrow__ ));
extern float lgammaf (float) __attribute__ ((__nothrow__ )); extern float __lgammaf (float) __attribute__ ((__nothrow__ ));




extern float tgammaf (float) __attribute__ ((__nothrow__ )); extern float __tgammaf (float) __attribute__ ((__nothrow__ ));





extern float gammaf (float) __attribute__ ((__nothrow__ )); extern float __gammaf (float) __attribute__ ((__nothrow__ ));







extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ )); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ ));






extern float rintf (float __x) __attribute__ ((__nothrow__ )); extern float __rintf (float __x) __attribute__ ((__nothrow__ ));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ ));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ )); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ ));




extern float nextdownf (float __x) __attribute__ ((__nothrow__ )); extern float __nextdownf (float __x) __attribute__ ((__nothrow__ ));

extern float nextupf (float __x) __attribute__ ((__nothrow__ )); extern float __nextupf (float __x) __attribute__ ((__nothrow__ ));



extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ ));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ )); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ ));



extern int ilogbf (float __x) __attribute__ ((__nothrow__ )); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ ));




extern long int llogbf (float __x) __attribute__ ((__nothrow__ )); extern long int __llogbf (float __x) __attribute__ ((__nothrow__ ));




extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ )); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ ));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__ )); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ ));



extern float roundf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ )); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ ));






extern long int lrintf (float __x) __attribute__ ((__nothrow__ )); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ )); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ ));



extern long int lroundf (float __x) __attribute__ ((__nothrow__ )); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ )); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ ));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ )); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ ));



extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ )); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ ));




extern float roundevenf (float __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));




extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));



extern int canonicalizef (float *__cx, const float *__x) __attribute__ ((__nothrow__ ));






extern float fmaxmagf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern float fmaximumf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fminimumf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fmaximum_numf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fminimum_numf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fmaximum_magf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fminimum_magf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fmaximum_mag_numf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern float fminimum_mag_numf (float __x, float __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int totalorderf (const float *__x, const float *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) __attribute__ ((__nothrow__ )); extern float __getpayloadf (const float *__x) __attribute__ ((__nothrow__ ));


extern int setpayloadf (float *__x, float __payload) __attribute__ ((__nothrow__ ));


extern int setpayloadsigf (float *__x, float __payload) __attribute__ ((__nothrow__ ));







extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ )); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ ));
# 300 "/usr/include/math.h" 2 3 4
# 367 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));



extern int __isinfl (long double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __isnanl (long double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) __attribute__ ((__nothrow__ ));


extern int __issignalingl (long double __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));
# 368 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern long double acosl (long double __x) __attribute__ ((__nothrow__ )); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ ));

 extern long double asinl (long double __x) __attribute__ ((__nothrow__ )); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ ));

 extern long double atanl (long double __x) __attribute__ ((__nothrow__ )); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ ));

 extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ )); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ ));


 extern long double cosl (long double __x) __attribute__ ((__nothrow__ )); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ ));

 extern long double sinl (long double __x) __attribute__ ((__nothrow__ )); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ ));

 extern long double tanl (long double __x) __attribute__ ((__nothrow__ )); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ ));



extern long double acospil (long double __x) __attribute__ ((__nothrow__ )); extern long double __acospil (long double __x) __attribute__ ((__nothrow__ ));

extern long double asinpil (long double __x) __attribute__ ((__nothrow__ )); extern long double __asinpil (long double __x) __attribute__ ((__nothrow__ ));

extern long double atanpil (long double __x) __attribute__ ((__nothrow__ )); extern long double __atanpil (long double __x) __attribute__ ((__nothrow__ ));

extern long double atan2pil (long double __y, long double __x) __attribute__ ((__nothrow__ )); extern long double __atan2pil (long double __y, long double __x) __attribute__ ((__nothrow__ ));


 extern long double cospil (long double __x) __attribute__ ((__nothrow__ )); extern long double __cospil (long double __x) __attribute__ ((__nothrow__ ));

 extern long double sinpil (long double __x) __attribute__ ((__nothrow__ )); extern long double __sinpil (long double __x) __attribute__ ((__nothrow__ ));

 extern long double tanpil (long double __x) __attribute__ ((__nothrow__ )); extern long double __tanpil (long double __x) __attribute__ ((__nothrow__ ));





 extern long double coshl (long double __x) __attribute__ ((__nothrow__ )); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ ));

 extern long double sinhl (long double __x) __attribute__ ((__nothrow__ )); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ ));

 extern long double tanhl (long double __x) __attribute__ ((__nothrow__ )); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ ));



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ )); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ ));





 extern long double acoshl (long double __x) __attribute__ ((__nothrow__ )); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ ));

 extern long double asinhl (long double __x) __attribute__ ((__nothrow__ )); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ ));

 extern long double atanhl (long double __x) __attribute__ ((__nothrow__ )); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ ));





 extern long double expl (long double __x) __attribute__ ((__nothrow__ )); extern long double __expl (long double __x) __attribute__ ((__nothrow__ ));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ )); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ ));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ )); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ ));


 extern long double logl (long double __x) __attribute__ ((__nothrow__ )); extern long double __logl (long double __x) __attribute__ ((__nothrow__ ));


 extern long double log10l (long double __x) __attribute__ ((__nothrow__ )); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ ));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ )); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



 extern long double exp10l (long double __x) __attribute__ ((__nothrow__ )); extern long double __exp10l (long double __x) __attribute__ ((__nothrow__ ));


extern long double exp2m1l (long double __x) __attribute__ ((__nothrow__ )); extern long double __exp2m1l (long double __x) __attribute__ ((__nothrow__ ));


extern long double exp10m1l (long double __x) __attribute__ ((__nothrow__ )); extern long double __exp10m1l (long double __x) __attribute__ ((__nothrow__ ));


extern long double log2p1l (long double __x) __attribute__ ((__nothrow__ )); extern long double __log2p1l (long double __x) __attribute__ ((__nothrow__ ));


extern long double log10p1l (long double __x) __attribute__ ((__nothrow__ )); extern long double __log10p1l (long double __x) __attribute__ ((__nothrow__ ));


 extern long double logp1l (long double __x) __attribute__ ((__nothrow__ )); extern long double __logp1l (long double __x) __attribute__ ((__nothrow__ ));




 extern long double expm1l (long double __x) __attribute__ ((__nothrow__ )); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ ));


 extern long double log1pl (long double __x) __attribute__ ((__nothrow__ )); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ ));


extern long double logbl (long double __x) __attribute__ ((__nothrow__ )); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ ));




 extern long double exp2l (long double __x) __attribute__ ((__nothrow__ )); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ ));


 extern long double log2l (long double __x) __attribute__ ((__nothrow__ )); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ ));






 extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ ));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ )); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ ));



 extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ ));




 extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ )); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ ));






extern long double ceill (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ ));
# 210 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));




extern int finitel (long double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ ));



extern long double significandl (long double __x) __attribute__ ((__nothrow__ )); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ ));






extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ )); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ ));
# 246 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));





extern long double j0l (long double) __attribute__ ((__nothrow__ )); extern long double __j0l (long double) __attribute__ ((__nothrow__ ));
extern long double j1l (long double) __attribute__ ((__nothrow__ )); extern long double __j1l (long double) __attribute__ ((__nothrow__ ));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ )); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ ));
extern long double y0l (long double) __attribute__ ((__nothrow__ )); extern long double __y0l (long double) __attribute__ ((__nothrow__ ));
extern long double y1l (long double) __attribute__ ((__nothrow__ )); extern long double __y1l (long double) __attribute__ ((__nothrow__ ));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ )); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ ));





 extern long double erfl (long double) __attribute__ ((__nothrow__ )); extern long double __erfl (long double) __attribute__ ((__nothrow__ ));
 extern long double erfcl (long double) __attribute__ ((__nothrow__ )); extern long double __erfcl (long double) __attribute__ ((__nothrow__ ));
extern long double lgammal (long double) __attribute__ ((__nothrow__ )); extern long double __lgammal (long double) __attribute__ ((__nothrow__ ));




extern long double tgammal (long double) __attribute__ ((__nothrow__ )); extern long double __tgammal (long double) __attribute__ ((__nothrow__ ));





extern long double gammal (long double) __attribute__ ((__nothrow__ )); extern long double __gammal (long double) __attribute__ ((__nothrow__ ));







extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ )); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ ));






extern long double rintl (long double __x) __attribute__ ((__nothrow__ )); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ ));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ ));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ ));




extern long double nextdownl (long double __x) __attribute__ ((__nothrow__ )); extern long double __nextdownl (long double __x) __attribute__ ((__nothrow__ ));

extern long double nextupl (long double __x) __attribute__ ((__nothrow__ )); extern long double __nextupl (long double __x) __attribute__ ((__nothrow__ ));



extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ ));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ )); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ ));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__ )); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ ));




extern long int llogbl (long double __x) __attribute__ ((__nothrow__ )); extern long int __llogbl (long double __x) __attribute__ ((__nothrow__ ));




extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ )); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ ));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ )); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ ));



extern long double roundl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ )); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ ));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__ )); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ )); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ ));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__ )); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ )); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ ));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ )); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ ));



extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ )); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ ));




extern long double roundevenl (long double __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));




extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));



extern int canonicalizel (long double *__cx, const long double *__x) __attribute__ ((__nothrow__ ));






extern long double fmaxmagl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern long double fmaximuml (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fminimuml (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fmaximum_numl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fminimum_numl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fmaximum_magl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fminimum_magl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fmaximum_mag_numl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern long double fminimum_mag_numl (long double __x, long double __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int totalorderl (const long double *__x, const long double *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) __attribute__ ((__nothrow__ )); extern long double __getpayloadl (const long double *__x) __attribute__ ((__nothrow__ ));


extern int setpayloadl (long double *__x, long double __payload) __attribute__ ((__nothrow__ ));


extern int setpayloadsigl (long double *__x, long double __payload) __attribute__ ((__nothrow__ ));







extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ )); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ ));
# 369 "/usr/include/math.h" 2 3 4
# 419 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32 acosf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __acosf32 (_Float32 __x) __attribute__ ((__nothrow__ ));

 extern _Float32 asinf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __asinf32 (_Float32 __x) __attribute__ ((__nothrow__ ));

 extern _Float32 atanf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __atanf32 (_Float32 __x) __attribute__ ((__nothrow__ ));

 extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) __attribute__ ((__nothrow__ ));


 extern _Float32 cosf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __cosf32 (_Float32 __x) __attribute__ ((__nothrow__ ));

 extern _Float32 sinf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __sinf32 (_Float32 __x) __attribute__ ((__nothrow__ ));

 extern _Float32 tanf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __tanf32 (_Float32 __x) __attribute__ ((__nothrow__ ));



extern _Float32 acospif32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __acospif32 (_Float32 __x) __attribute__ ((__nothrow__ ));

extern _Float32 asinpif32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __asinpif32 (_Float32 __x) __attribute__ ((__nothrow__ ));

extern _Float32 atanpif32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __atanpif32 (_Float32 __x) __attribute__ ((__nothrow__ ));

extern _Float32 atan2pif32 (_Float32 __y, _Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __atan2pif32 (_Float32 __y, _Float32 __x) __attribute__ ((__nothrow__ ));


 extern _Float32 cospif32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __cospif32 (_Float32 __x) __attribute__ ((__nothrow__ ));

 extern _Float32 sinpif32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __sinpif32 (_Float32 __x) __attribute__ ((__nothrow__ ));

 extern _Float32 tanpif32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __tanpif32 (_Float32 __x) __attribute__ ((__nothrow__ ));





 extern _Float32 coshf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __coshf32 (_Float32 __x) __attribute__ ((__nothrow__ ));

 extern _Float32 sinhf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __sinhf32 (_Float32 __x) __attribute__ ((__nothrow__ ));

 extern _Float32 tanhf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __tanhf32 (_Float32 __x) __attribute__ ((__nothrow__ ));



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) __attribute__ ((__nothrow__ )); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) __attribute__ ((__nothrow__ ));





 extern _Float32 acoshf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __acoshf32 (_Float32 __x) __attribute__ ((__nothrow__ ));

 extern _Float32 asinhf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __asinhf32 (_Float32 __x) __attribute__ ((__nothrow__ ));

 extern _Float32 atanhf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __atanhf32 (_Float32 __x) __attribute__ ((__nothrow__ ));





 extern _Float32 expf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __expf32 (_Float32 __x) __attribute__ ((__nothrow__ ));


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) __attribute__ ((__nothrow__ )); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) __attribute__ ((__nothrow__ ));


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) __attribute__ ((__nothrow__ )); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) __attribute__ ((__nothrow__ ));


 extern _Float32 logf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __logf32 (_Float32 __x) __attribute__ ((__nothrow__ ));


 extern _Float32 log10f32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __log10f32 (_Float32 __x) __attribute__ ((__nothrow__ ));


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) __attribute__ ((__nothrow__ )); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



 extern _Float32 exp10f32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __exp10f32 (_Float32 __x) __attribute__ ((__nothrow__ ));


extern _Float32 exp2m1f32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __exp2m1f32 (_Float32 __x) __attribute__ ((__nothrow__ ));


extern _Float32 exp10m1f32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __exp10m1f32 (_Float32 __x) __attribute__ ((__nothrow__ ));


extern _Float32 log2p1f32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __log2p1f32 (_Float32 __x) __attribute__ ((__nothrow__ ));


extern _Float32 log10p1f32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __log10p1f32 (_Float32 __x) __attribute__ ((__nothrow__ ));


 extern _Float32 logp1f32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __logp1f32 (_Float32 __x) __attribute__ ((__nothrow__ ));




 extern _Float32 expm1f32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __expm1f32 (_Float32 __x) __attribute__ ((__nothrow__ ));


 extern _Float32 log1pf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __log1pf32 (_Float32 __x) __attribute__ ((__nothrow__ ));


extern _Float32 logbf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __logbf32 (_Float32 __x) __attribute__ ((__nothrow__ ));




 extern _Float32 exp2f32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __exp2f32 (_Float32 __x) __attribute__ ((__nothrow__ ));


 extern _Float32 log2f32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __log2f32 (_Float32 __x) __attribute__ ((__nothrow__ ));






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ ));


extern _Float32 sqrtf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __sqrtf32 (_Float32 __x) __attribute__ ((__nothrow__ ));



 extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ ));




 extern _Float32 cbrtf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __cbrtf32 (_Float32 __x) __attribute__ ((__nothrow__ ));






extern _Float32 ceilf32 (_Float32 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ ));
# 231 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) __attribute__ ((__nothrow__ )); extern _Float32 __nanf32 (const char *__tagb) __attribute__ ((__nothrow__ ));
# 253 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) __attribute__ ((__nothrow__ )); extern _Float32 __j0f32 (_Float32) __attribute__ ((__nothrow__ ));
extern _Float32 j1f32 (_Float32) __attribute__ ((__nothrow__ )); extern _Float32 __j1f32 (_Float32) __attribute__ ((__nothrow__ ));
extern _Float32 jnf32 (int, _Float32) __attribute__ ((__nothrow__ )); extern _Float32 __jnf32 (int, _Float32) __attribute__ ((__nothrow__ ));
extern _Float32 y0f32 (_Float32) __attribute__ ((__nothrow__ )); extern _Float32 __y0f32 (_Float32) __attribute__ ((__nothrow__ ));
extern _Float32 y1f32 (_Float32) __attribute__ ((__nothrow__ )); extern _Float32 __y1f32 (_Float32) __attribute__ ((__nothrow__ ));
extern _Float32 ynf32 (int, _Float32) __attribute__ ((__nothrow__ )); extern _Float32 __ynf32 (int, _Float32) __attribute__ ((__nothrow__ ));





 extern _Float32 erff32 (_Float32) __attribute__ ((__nothrow__ )); extern _Float32 __erff32 (_Float32) __attribute__ ((__nothrow__ ));
 extern _Float32 erfcf32 (_Float32) __attribute__ ((__nothrow__ )); extern _Float32 __erfcf32 (_Float32) __attribute__ ((__nothrow__ ));
extern _Float32 lgammaf32 (_Float32) __attribute__ ((__nothrow__ )); extern _Float32 __lgammaf32 (_Float32) __attribute__ ((__nothrow__ ));




extern _Float32 tgammaf32 (_Float32) __attribute__ ((__nothrow__ )); extern _Float32 __tgammaf32 (_Float32) __attribute__ ((__nothrow__ ));
# 285 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) __attribute__ ((__nothrow__ )); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) __attribute__ ((__nothrow__ ));






extern _Float32 rintf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __rintf32 (_Float32 __x) __attribute__ ((__nothrow__ ));


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ ));






extern _Float32 nextdownf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __nextdownf32 (_Float32 __x) __attribute__ ((__nothrow__ ));

extern _Float32 nextupf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __nextupf32 (_Float32 __x) __attribute__ ((__nothrow__ ));



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ ));



extern _Float32 scalbnf32 (_Float32 __x, int __n) __attribute__ ((__nothrow__ )); extern _Float32 __scalbnf32 (_Float32 __x, int __n) __attribute__ ((__nothrow__ ));



extern int ilogbf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern int __ilogbf32 (_Float32 __x) __attribute__ ((__nothrow__ ));




extern long int llogbf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern long int __llogbf32 (_Float32 __x) __attribute__ ((__nothrow__ ));




extern _Float32 scalblnf32 (_Float32 __x, long int __n) __attribute__ ((__nothrow__ )); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) __attribute__ ((__nothrow__ ));



extern _Float32 nearbyintf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern _Float32 __nearbyintf32 (_Float32 __x) __attribute__ ((__nothrow__ ));



extern _Float32 roundf32 (_Float32 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) __attribute__ ((__nothrow__ )); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) __attribute__ ((__nothrow__ ));






extern long int lrintf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern long int __lrintf32 (_Float32 __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llrintf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern long long int __llrintf32 (_Float32 __x) __attribute__ ((__nothrow__ ));



extern long int lroundf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern long int __lroundf32 (_Float32 __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llroundf32 (_Float32 __x) __attribute__ ((__nothrow__ )); extern long long int __llroundf32 (_Float32 __x) __attribute__ ((__nothrow__ ));



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ ));



extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) __attribute__ ((__nothrow__ )); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) __attribute__ ((__nothrow__ ));




extern _Float32 roundevenf32 (_Float32 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));




extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));



extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) __attribute__ ((__nothrow__ ));






extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float32 fmaximumf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 fminimumf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 fmaximum_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 fminimum_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 fmaximum_magf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 fminimum_magf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32 fminimum_mag_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) __attribute__ ((__nothrow__ )); extern _Float32 __getpayloadf32 (const _Float32 *__x) __attribute__ ((__nothrow__ ));


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) __attribute__ ((__nothrow__ ));


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) __attribute__ ((__nothrow__ ));
# 420 "/usr/include/math.h" 2 3 4
# 436 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64 acosf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __acosf64 (_Float64 __x) __attribute__ ((__nothrow__ ));

 extern _Float64 asinf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __asinf64 (_Float64 __x) __attribute__ ((__nothrow__ ));

 extern _Float64 atanf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __atanf64 (_Float64 __x) __attribute__ ((__nothrow__ ));

 extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) __attribute__ ((__nothrow__ ));


 extern _Float64 cosf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __cosf64 (_Float64 __x) __attribute__ ((__nothrow__ ));

 extern _Float64 sinf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __sinf64 (_Float64 __x) __attribute__ ((__nothrow__ ));

 extern _Float64 tanf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __tanf64 (_Float64 __x) __attribute__ ((__nothrow__ ));



extern _Float64 acospif64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __acospif64 (_Float64 __x) __attribute__ ((__nothrow__ ));

extern _Float64 asinpif64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __asinpif64 (_Float64 __x) __attribute__ ((__nothrow__ ));

extern _Float64 atanpif64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __atanpif64 (_Float64 __x) __attribute__ ((__nothrow__ ));

extern _Float64 atan2pif64 (_Float64 __y, _Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __atan2pif64 (_Float64 __y, _Float64 __x) __attribute__ ((__nothrow__ ));


 extern _Float64 cospif64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __cospif64 (_Float64 __x) __attribute__ ((__nothrow__ ));

 extern _Float64 sinpif64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __sinpif64 (_Float64 __x) __attribute__ ((__nothrow__ ));

 extern _Float64 tanpif64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __tanpif64 (_Float64 __x) __attribute__ ((__nothrow__ ));





 extern _Float64 coshf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __coshf64 (_Float64 __x) __attribute__ ((__nothrow__ ));

 extern _Float64 sinhf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __sinhf64 (_Float64 __x) __attribute__ ((__nothrow__ ));

 extern _Float64 tanhf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __tanhf64 (_Float64 __x) __attribute__ ((__nothrow__ ));



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) __attribute__ ((__nothrow__ )); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) __attribute__ ((__nothrow__ ));





 extern _Float64 acoshf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __acoshf64 (_Float64 __x) __attribute__ ((__nothrow__ ));

 extern _Float64 asinhf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __asinhf64 (_Float64 __x) __attribute__ ((__nothrow__ ));

 extern _Float64 atanhf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __atanhf64 (_Float64 __x) __attribute__ ((__nothrow__ ));





 extern _Float64 expf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __expf64 (_Float64 __x) __attribute__ ((__nothrow__ ));


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) __attribute__ ((__nothrow__ )); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) __attribute__ ((__nothrow__ ));


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) __attribute__ ((__nothrow__ )); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) __attribute__ ((__nothrow__ ));


 extern _Float64 logf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __logf64 (_Float64 __x) __attribute__ ((__nothrow__ ));


 extern _Float64 log10f64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __log10f64 (_Float64 __x) __attribute__ ((__nothrow__ ));


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) __attribute__ ((__nothrow__ )); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



 extern _Float64 exp10f64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __exp10f64 (_Float64 __x) __attribute__ ((__nothrow__ ));


extern _Float64 exp2m1f64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __exp2m1f64 (_Float64 __x) __attribute__ ((__nothrow__ ));


extern _Float64 exp10m1f64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __exp10m1f64 (_Float64 __x) __attribute__ ((__nothrow__ ));


extern _Float64 log2p1f64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __log2p1f64 (_Float64 __x) __attribute__ ((__nothrow__ ));


extern _Float64 log10p1f64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __log10p1f64 (_Float64 __x) __attribute__ ((__nothrow__ ));


 extern _Float64 logp1f64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __logp1f64 (_Float64 __x) __attribute__ ((__nothrow__ ));




 extern _Float64 expm1f64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __expm1f64 (_Float64 __x) __attribute__ ((__nothrow__ ));


 extern _Float64 log1pf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __log1pf64 (_Float64 __x) __attribute__ ((__nothrow__ ));


extern _Float64 logbf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __logbf64 (_Float64 __x) __attribute__ ((__nothrow__ ));




 extern _Float64 exp2f64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __exp2f64 (_Float64 __x) __attribute__ ((__nothrow__ ));


 extern _Float64 log2f64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __log2f64 (_Float64 __x) __attribute__ ((__nothrow__ ));






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));


extern _Float64 sqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __sqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ ));



 extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));




 extern _Float64 cbrtf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __cbrtf64 (_Float64 __x) __attribute__ ((__nothrow__ ));






extern _Float64 ceilf64 (_Float64 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));
# 231 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) __attribute__ ((__nothrow__ )); extern _Float64 __nanf64 (const char *__tagb) __attribute__ ((__nothrow__ ));
# 253 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) __attribute__ ((__nothrow__ )); extern _Float64 __j0f64 (_Float64) __attribute__ ((__nothrow__ ));
extern _Float64 j1f64 (_Float64) __attribute__ ((__nothrow__ )); extern _Float64 __j1f64 (_Float64) __attribute__ ((__nothrow__ ));
extern _Float64 jnf64 (int, _Float64) __attribute__ ((__nothrow__ )); extern _Float64 __jnf64 (int, _Float64) __attribute__ ((__nothrow__ ));
extern _Float64 y0f64 (_Float64) __attribute__ ((__nothrow__ )); extern _Float64 __y0f64 (_Float64) __attribute__ ((__nothrow__ ));
extern _Float64 y1f64 (_Float64) __attribute__ ((__nothrow__ )); extern _Float64 __y1f64 (_Float64) __attribute__ ((__nothrow__ ));
extern _Float64 ynf64 (int, _Float64) __attribute__ ((__nothrow__ )); extern _Float64 __ynf64 (int, _Float64) __attribute__ ((__nothrow__ ));





 extern _Float64 erff64 (_Float64) __attribute__ ((__nothrow__ )); extern _Float64 __erff64 (_Float64) __attribute__ ((__nothrow__ ));
 extern _Float64 erfcf64 (_Float64) __attribute__ ((__nothrow__ )); extern _Float64 __erfcf64 (_Float64) __attribute__ ((__nothrow__ ));
extern _Float64 lgammaf64 (_Float64) __attribute__ ((__nothrow__ )); extern _Float64 __lgammaf64 (_Float64) __attribute__ ((__nothrow__ ));




extern _Float64 tgammaf64 (_Float64) __attribute__ ((__nothrow__ )); extern _Float64 __tgammaf64 (_Float64) __attribute__ ((__nothrow__ ));
# 285 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) __attribute__ ((__nothrow__ )); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) __attribute__ ((__nothrow__ ));






extern _Float64 rintf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __rintf64 (_Float64 __x) __attribute__ ((__nothrow__ ));


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));






extern _Float64 nextdownf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __nextdownf64 (_Float64 __x) __attribute__ ((__nothrow__ ));

extern _Float64 nextupf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __nextupf64 (_Float64 __x) __attribute__ ((__nothrow__ ));



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));



extern _Float64 scalbnf64 (_Float64 __x, int __n) __attribute__ ((__nothrow__ )); extern _Float64 __scalbnf64 (_Float64 __x, int __n) __attribute__ ((__nothrow__ ));



extern int ilogbf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern int __ilogbf64 (_Float64 __x) __attribute__ ((__nothrow__ ));




extern long int llogbf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern long int __llogbf64 (_Float64 __x) __attribute__ ((__nothrow__ ));




extern _Float64 scalblnf64 (_Float64 __x, long int __n) __attribute__ ((__nothrow__ )); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) __attribute__ ((__nothrow__ ));



extern _Float64 nearbyintf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern _Float64 __nearbyintf64 (_Float64 __x) __attribute__ ((__nothrow__ ));



extern _Float64 roundf64 (_Float64 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) __attribute__ ((__nothrow__ )); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) __attribute__ ((__nothrow__ ));






extern long int lrintf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern long int __lrintf64 (_Float64 __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llrintf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern long long int __llrintf64 (_Float64 __x) __attribute__ ((__nothrow__ ));



extern long int lroundf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern long int __lroundf64 (_Float64 __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llroundf64 (_Float64 __x) __attribute__ ((__nothrow__ )); extern long long int __llroundf64 (_Float64 __x) __attribute__ ((__nothrow__ ));



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));



extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ )); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ ));




extern _Float64 roundevenf64 (_Float64 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));




extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));



extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) __attribute__ ((__nothrow__ ));






extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float64 fmaximumf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 fminimumf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 fmaximum_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 fminimum_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 fmaximum_magf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 fminimum_magf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64 fminimum_mag_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) __attribute__ ((__nothrow__ )); extern _Float64 __getpayloadf64 (const _Float64 *__x) __attribute__ ((__nothrow__ ));


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) __attribute__ ((__nothrow__ ));


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) __attribute__ ((__nothrow__ ));
# 437 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) __attribute__ ((__nothrow__ ))
  __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern int __issignalingf128 (_Float128 __value) __attribute__ ((__nothrow__ ))
     __attribute__ ((__const__));
# 451 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float128 acosf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __acosf128 (_Float128 __x) __attribute__ ((__nothrow__ ));

 extern _Float128 asinf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __asinf128 (_Float128 __x) __attribute__ ((__nothrow__ ));

 extern _Float128 atanf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __atanf128 (_Float128 __x) __attribute__ ((__nothrow__ ));

 extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) __attribute__ ((__nothrow__ ));


 extern _Float128 cosf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __cosf128 (_Float128 __x) __attribute__ ((__nothrow__ ));

 extern _Float128 sinf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __sinf128 (_Float128 __x) __attribute__ ((__nothrow__ ));

 extern _Float128 tanf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __tanf128 (_Float128 __x) __attribute__ ((__nothrow__ ));



extern _Float128 acospif128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __acospif128 (_Float128 __x) __attribute__ ((__nothrow__ ));

extern _Float128 asinpif128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __asinpif128 (_Float128 __x) __attribute__ ((__nothrow__ ));

extern _Float128 atanpif128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __atanpif128 (_Float128 __x) __attribute__ ((__nothrow__ ));

extern _Float128 atan2pif128 (_Float128 __y, _Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __atan2pif128 (_Float128 __y, _Float128 __x) __attribute__ ((__nothrow__ ));


 extern _Float128 cospif128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __cospif128 (_Float128 __x) __attribute__ ((__nothrow__ ));

 extern _Float128 sinpif128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __sinpif128 (_Float128 __x) __attribute__ ((__nothrow__ ));

 extern _Float128 tanpif128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __tanpif128 (_Float128 __x) __attribute__ ((__nothrow__ ));





 extern _Float128 coshf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __coshf128 (_Float128 __x) __attribute__ ((__nothrow__ ));

 extern _Float128 sinhf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __sinhf128 (_Float128 __x) __attribute__ ((__nothrow__ ));

 extern _Float128 tanhf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __tanhf128 (_Float128 __x) __attribute__ ((__nothrow__ ));



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) __attribute__ ((__nothrow__ )); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) __attribute__ ((__nothrow__ ));





 extern _Float128 acoshf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __acoshf128 (_Float128 __x) __attribute__ ((__nothrow__ ));

 extern _Float128 asinhf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __asinhf128 (_Float128 __x) __attribute__ ((__nothrow__ ));

 extern _Float128 atanhf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __atanhf128 (_Float128 __x) __attribute__ ((__nothrow__ ));





 extern _Float128 expf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __expf128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) __attribute__ ((__nothrow__ )); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) __attribute__ ((__nothrow__ ));


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) __attribute__ ((__nothrow__ )); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) __attribute__ ((__nothrow__ ));


 extern _Float128 logf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __logf128 (_Float128 __x) __attribute__ ((__nothrow__ ));


 extern _Float128 log10f128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __log10f128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) __attribute__ ((__nothrow__ )); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



 extern _Float128 exp10f128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __exp10f128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float128 exp2m1f128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __exp2m1f128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float128 exp10m1f128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __exp10m1f128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float128 log2p1f128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __log2p1f128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float128 log10p1f128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __log10p1f128 (_Float128 __x) __attribute__ ((__nothrow__ ));


 extern _Float128 logp1f128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __logp1f128 (_Float128 __x) __attribute__ ((__nothrow__ ));




 extern _Float128 expm1f128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __expm1f128 (_Float128 __x) __attribute__ ((__nothrow__ ));


 extern _Float128 log1pf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __log1pf128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float128 logbf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __logbf128 (_Float128 __x) __attribute__ ((__nothrow__ ));




 extern _Float128 exp2f128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __exp2f128 (_Float128 __x) __attribute__ ((__nothrow__ ));


 extern _Float128 log2f128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __log2f128 (_Float128 __x) __attribute__ ((__nothrow__ ));






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float128 sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ ));



 extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));




 extern _Float128 cbrtf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __cbrtf128 (_Float128 __x) __attribute__ ((__nothrow__ ));






extern _Float128 ceilf128 (_Float128 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));
# 231 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) __attribute__ ((__nothrow__ )); extern _Float128 __nanf128 (const char *__tagb) __attribute__ ((__nothrow__ ));
# 253 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) __attribute__ ((__nothrow__ )); extern _Float128 __j0f128 (_Float128) __attribute__ ((__nothrow__ ));
extern _Float128 j1f128 (_Float128) __attribute__ ((__nothrow__ )); extern _Float128 __j1f128 (_Float128) __attribute__ ((__nothrow__ ));
extern _Float128 jnf128 (int, _Float128) __attribute__ ((__nothrow__ )); extern _Float128 __jnf128 (int, _Float128) __attribute__ ((__nothrow__ ));
extern _Float128 y0f128 (_Float128) __attribute__ ((__nothrow__ )); extern _Float128 __y0f128 (_Float128) __attribute__ ((__nothrow__ ));
extern _Float128 y1f128 (_Float128) __attribute__ ((__nothrow__ )); extern _Float128 __y1f128 (_Float128) __attribute__ ((__nothrow__ ));
extern _Float128 ynf128 (int, _Float128) __attribute__ ((__nothrow__ )); extern _Float128 __ynf128 (int, _Float128) __attribute__ ((__nothrow__ ));





 extern _Float128 erff128 (_Float128) __attribute__ ((__nothrow__ )); extern _Float128 __erff128 (_Float128) __attribute__ ((__nothrow__ ));
 extern _Float128 erfcf128 (_Float128) __attribute__ ((__nothrow__ )); extern _Float128 __erfcf128 (_Float128) __attribute__ ((__nothrow__ ));
extern _Float128 lgammaf128 (_Float128) __attribute__ ((__nothrow__ )); extern _Float128 __lgammaf128 (_Float128) __attribute__ ((__nothrow__ ));




extern _Float128 tgammaf128 (_Float128) __attribute__ ((__nothrow__ )); extern _Float128 __tgammaf128 (_Float128) __attribute__ ((__nothrow__ ));
# 285 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) __attribute__ ((__nothrow__ )); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) __attribute__ ((__nothrow__ ));






extern _Float128 rintf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __rintf128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));






extern _Float128 nextdownf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __nextdownf128 (_Float128 __x) __attribute__ ((__nothrow__ ));

extern _Float128 nextupf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __nextupf128 (_Float128 __x) __attribute__ ((__nothrow__ ));



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));



extern _Float128 scalbnf128 (_Float128 __x, int __n) __attribute__ ((__nothrow__ )); extern _Float128 __scalbnf128 (_Float128 __x, int __n) __attribute__ ((__nothrow__ ));



extern int ilogbf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern int __ilogbf128 (_Float128 __x) __attribute__ ((__nothrow__ ));




extern long int llogbf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern long int __llogbf128 (_Float128 __x) __attribute__ ((__nothrow__ ));




extern _Float128 scalblnf128 (_Float128 __x, long int __n) __attribute__ ((__nothrow__ )); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) __attribute__ ((__nothrow__ ));



extern _Float128 nearbyintf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern _Float128 __nearbyintf128 (_Float128 __x) __attribute__ ((__nothrow__ ));



extern _Float128 roundf128 (_Float128 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) __attribute__ ((__nothrow__ )); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) __attribute__ ((__nothrow__ ));






extern long int lrintf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern long int __lrintf128 (_Float128 __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llrintf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern long long int __llrintf128 (_Float128 __x) __attribute__ ((__nothrow__ ));



extern long int lroundf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern long int __lroundf128 (_Float128 __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llroundf128 (_Float128 __x) __attribute__ ((__nothrow__ )); extern long long int __llroundf128 (_Float128 __x) __attribute__ ((__nothrow__ ));



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));



extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ )); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ ));




extern _Float128 roundevenf128 (_Float128 __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));




extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));



extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) __attribute__ ((__nothrow__ ));






extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float128 fmaximumf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 fminimumf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 fmaximum_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 fminimum_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 fmaximum_magf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 fminimum_magf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float128 fminimum_mag_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) __attribute__ ((__nothrow__ )); extern _Float128 __getpayloadf128 (const _Float128 *__x) __attribute__ ((__nothrow__ ));


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) __attribute__ ((__nothrow__ ));


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) __attribute__ ((__nothrow__ ));
# 454 "/usr/include/math.h" 2 3 4
# 470 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32x acosf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __acosf32x (_Float32x __x) __attribute__ ((__nothrow__ ));

 extern _Float32x asinf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __asinf32x (_Float32x __x) __attribute__ ((__nothrow__ ));

 extern _Float32x atanf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __atanf32x (_Float32x __x) __attribute__ ((__nothrow__ ));

 extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) __attribute__ ((__nothrow__ ));


 extern _Float32x cosf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __cosf32x (_Float32x __x) __attribute__ ((__nothrow__ ));

 extern _Float32x sinf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __sinf32x (_Float32x __x) __attribute__ ((__nothrow__ ));

 extern _Float32x tanf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __tanf32x (_Float32x __x) __attribute__ ((__nothrow__ ));



extern _Float32x acospif32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __acospif32x (_Float32x __x) __attribute__ ((__nothrow__ ));

extern _Float32x asinpif32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __asinpif32x (_Float32x __x) __attribute__ ((__nothrow__ ));

extern _Float32x atanpif32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __atanpif32x (_Float32x __x) __attribute__ ((__nothrow__ ));

extern _Float32x atan2pif32x (_Float32x __y, _Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __atan2pif32x (_Float32x __y, _Float32x __x) __attribute__ ((__nothrow__ ));


 extern _Float32x cospif32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __cospif32x (_Float32x __x) __attribute__ ((__nothrow__ ));

 extern _Float32x sinpif32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __sinpif32x (_Float32x __x) __attribute__ ((__nothrow__ ));

 extern _Float32x tanpif32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __tanpif32x (_Float32x __x) __attribute__ ((__nothrow__ ));





 extern _Float32x coshf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __coshf32x (_Float32x __x) __attribute__ ((__nothrow__ ));

 extern _Float32x sinhf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __sinhf32x (_Float32x __x) __attribute__ ((__nothrow__ ));

 extern _Float32x tanhf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __tanhf32x (_Float32x __x) __attribute__ ((__nothrow__ ));



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) __attribute__ ((__nothrow__ )); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) __attribute__ ((__nothrow__ ));





 extern _Float32x acoshf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __acoshf32x (_Float32x __x) __attribute__ ((__nothrow__ ));

 extern _Float32x asinhf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __asinhf32x (_Float32x __x) __attribute__ ((__nothrow__ ));

 extern _Float32x atanhf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __atanhf32x (_Float32x __x) __attribute__ ((__nothrow__ ));





 extern _Float32x expf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __expf32x (_Float32x __x) __attribute__ ((__nothrow__ ));


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) __attribute__ ((__nothrow__ )); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) __attribute__ ((__nothrow__ ));


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) __attribute__ ((__nothrow__ )); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) __attribute__ ((__nothrow__ ));


 extern _Float32x logf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __logf32x (_Float32x __x) __attribute__ ((__nothrow__ ));


 extern _Float32x log10f32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __log10f32x (_Float32x __x) __attribute__ ((__nothrow__ ));


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) __attribute__ ((__nothrow__ )); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



 extern _Float32x exp10f32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __exp10f32x (_Float32x __x) __attribute__ ((__nothrow__ ));


extern _Float32x exp2m1f32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __exp2m1f32x (_Float32x __x) __attribute__ ((__nothrow__ ));


extern _Float32x exp10m1f32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __exp10m1f32x (_Float32x __x) __attribute__ ((__nothrow__ ));


extern _Float32x log2p1f32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __log2p1f32x (_Float32x __x) __attribute__ ((__nothrow__ ));


extern _Float32x log10p1f32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __log10p1f32x (_Float32x __x) __attribute__ ((__nothrow__ ));


 extern _Float32x logp1f32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __logp1f32x (_Float32x __x) __attribute__ ((__nothrow__ ));




 extern _Float32x expm1f32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __expm1f32x (_Float32x __x) __attribute__ ((__nothrow__ ));


 extern _Float32x log1pf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __log1pf32x (_Float32x __x) __attribute__ ((__nothrow__ ));


extern _Float32x logbf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __logbf32x (_Float32x __x) __attribute__ ((__nothrow__ ));




 extern _Float32x exp2f32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __exp2f32x (_Float32x __x) __attribute__ ((__nothrow__ ));


 extern _Float32x log2f32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __log2f32x (_Float32x __x) __attribute__ ((__nothrow__ ));






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ ));


extern _Float32x sqrtf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __sqrtf32x (_Float32x __x) __attribute__ ((__nothrow__ ));



 extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ ));




 extern _Float32x cbrtf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __cbrtf32x (_Float32x __x) __attribute__ ((__nothrow__ ));






extern _Float32x ceilf32x (_Float32x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ ));
# 231 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) __attribute__ ((__nothrow__ )); extern _Float32x __nanf32x (const char *__tagb) __attribute__ ((__nothrow__ ));
# 253 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) __attribute__ ((__nothrow__ )); extern _Float32x __j0f32x (_Float32x) __attribute__ ((__nothrow__ ));
extern _Float32x j1f32x (_Float32x) __attribute__ ((__nothrow__ )); extern _Float32x __j1f32x (_Float32x) __attribute__ ((__nothrow__ ));
extern _Float32x jnf32x (int, _Float32x) __attribute__ ((__nothrow__ )); extern _Float32x __jnf32x (int, _Float32x) __attribute__ ((__nothrow__ ));
extern _Float32x y0f32x (_Float32x) __attribute__ ((__nothrow__ )); extern _Float32x __y0f32x (_Float32x) __attribute__ ((__nothrow__ ));
extern _Float32x y1f32x (_Float32x) __attribute__ ((__nothrow__ )); extern _Float32x __y1f32x (_Float32x) __attribute__ ((__nothrow__ ));
extern _Float32x ynf32x (int, _Float32x) __attribute__ ((__nothrow__ )); extern _Float32x __ynf32x (int, _Float32x) __attribute__ ((__nothrow__ ));





 extern _Float32x erff32x (_Float32x) __attribute__ ((__nothrow__ )); extern _Float32x __erff32x (_Float32x) __attribute__ ((__nothrow__ ));
 extern _Float32x erfcf32x (_Float32x) __attribute__ ((__nothrow__ )); extern _Float32x __erfcf32x (_Float32x) __attribute__ ((__nothrow__ ));
extern _Float32x lgammaf32x (_Float32x) __attribute__ ((__nothrow__ )); extern _Float32x __lgammaf32x (_Float32x) __attribute__ ((__nothrow__ ));




extern _Float32x tgammaf32x (_Float32x) __attribute__ ((__nothrow__ )); extern _Float32x __tgammaf32x (_Float32x) __attribute__ ((__nothrow__ ));
# 285 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) __attribute__ ((__nothrow__ )); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) __attribute__ ((__nothrow__ ));






extern _Float32x rintf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __rintf32x (_Float32x __x) __attribute__ ((__nothrow__ ));


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ ));






extern _Float32x nextdownf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __nextdownf32x (_Float32x __x) __attribute__ ((__nothrow__ ));

extern _Float32x nextupf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __nextupf32x (_Float32x __x) __attribute__ ((__nothrow__ ));



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ ));



extern _Float32x scalbnf32x (_Float32x __x, int __n) __attribute__ ((__nothrow__ )); extern _Float32x __scalbnf32x (_Float32x __x, int __n) __attribute__ ((__nothrow__ ));



extern int ilogbf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern int __ilogbf32x (_Float32x __x) __attribute__ ((__nothrow__ ));




extern long int llogbf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern long int __llogbf32x (_Float32x __x) __attribute__ ((__nothrow__ ));




extern _Float32x scalblnf32x (_Float32x __x, long int __n) __attribute__ ((__nothrow__ )); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) __attribute__ ((__nothrow__ ));



extern _Float32x nearbyintf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern _Float32x __nearbyintf32x (_Float32x __x) __attribute__ ((__nothrow__ ));



extern _Float32x roundf32x (_Float32x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) __attribute__ ((__nothrow__ )); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) __attribute__ ((__nothrow__ ));






extern long int lrintf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern long int __lrintf32x (_Float32x __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llrintf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern long long int __llrintf32x (_Float32x __x) __attribute__ ((__nothrow__ ));



extern long int lroundf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern long int __lroundf32x (_Float32x __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llroundf32x (_Float32x __x) __attribute__ ((__nothrow__ )); extern long long int __llroundf32x (_Float32x __x) __attribute__ ((__nothrow__ ));



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ ));



extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) __attribute__ ((__nothrow__ )); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) __attribute__ ((__nothrow__ ));




extern _Float32x roundevenf32x (_Float32x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));




extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));



extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) __attribute__ ((__nothrow__ ));






extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float32x fmaximumf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x fminimumf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x fmaximum_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x fminimum_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x fmaximum_magf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x fminimum_magf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float32x fminimum_mag_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) __attribute__ ((__nothrow__ )); extern _Float32x __getpayloadf32x (const _Float32x *__x) __attribute__ ((__nothrow__ ));


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) __attribute__ ((__nothrow__ ));


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) __attribute__ ((__nothrow__ ));
# 471 "/usr/include/math.h" 2 3 4
# 487 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64x acosf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __acosf64x (_Float64x __x) __attribute__ ((__nothrow__ ));

 extern _Float64x asinf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __asinf64x (_Float64x __x) __attribute__ ((__nothrow__ ));

 extern _Float64x atanf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __atanf64x (_Float64x __x) __attribute__ ((__nothrow__ ));

 extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) __attribute__ ((__nothrow__ ));


 extern _Float64x cosf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __cosf64x (_Float64x __x) __attribute__ ((__nothrow__ ));

 extern _Float64x sinf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __sinf64x (_Float64x __x) __attribute__ ((__nothrow__ ));

 extern _Float64x tanf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __tanf64x (_Float64x __x) __attribute__ ((__nothrow__ ));



extern _Float64x acospif64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __acospif64x (_Float64x __x) __attribute__ ((__nothrow__ ));

extern _Float64x asinpif64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __asinpif64x (_Float64x __x) __attribute__ ((__nothrow__ ));

extern _Float64x atanpif64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __atanpif64x (_Float64x __x) __attribute__ ((__nothrow__ ));

extern _Float64x atan2pif64x (_Float64x __y, _Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __atan2pif64x (_Float64x __y, _Float64x __x) __attribute__ ((__nothrow__ ));


 extern _Float64x cospif64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __cospif64x (_Float64x __x) __attribute__ ((__nothrow__ ));

 extern _Float64x sinpif64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __sinpif64x (_Float64x __x) __attribute__ ((__nothrow__ ));

 extern _Float64x tanpif64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __tanpif64x (_Float64x __x) __attribute__ ((__nothrow__ ));





 extern _Float64x coshf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __coshf64x (_Float64x __x) __attribute__ ((__nothrow__ ));

 extern _Float64x sinhf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __sinhf64x (_Float64x __x) __attribute__ ((__nothrow__ ));

 extern _Float64x tanhf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __tanhf64x (_Float64x __x) __attribute__ ((__nothrow__ ));



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) __attribute__ ((__nothrow__ )); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) __attribute__ ((__nothrow__ ));





 extern _Float64x acoshf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __acoshf64x (_Float64x __x) __attribute__ ((__nothrow__ ));

 extern _Float64x asinhf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __asinhf64x (_Float64x __x) __attribute__ ((__nothrow__ ));

 extern _Float64x atanhf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __atanhf64x (_Float64x __x) __attribute__ ((__nothrow__ ));





 extern _Float64x expf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __expf64x (_Float64x __x) __attribute__ ((__nothrow__ ));


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) __attribute__ ((__nothrow__ )); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) __attribute__ ((__nothrow__ ));


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) __attribute__ ((__nothrow__ )); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) __attribute__ ((__nothrow__ ));


 extern _Float64x logf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __logf64x (_Float64x __x) __attribute__ ((__nothrow__ ));


 extern _Float64x log10f64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __log10f64x (_Float64x __x) __attribute__ ((__nothrow__ ));


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) __attribute__ ((__nothrow__ )); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



 extern _Float64x exp10f64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __exp10f64x (_Float64x __x) __attribute__ ((__nothrow__ ));


extern _Float64x exp2m1f64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __exp2m1f64x (_Float64x __x) __attribute__ ((__nothrow__ ));


extern _Float64x exp10m1f64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __exp10m1f64x (_Float64x __x) __attribute__ ((__nothrow__ ));


extern _Float64x log2p1f64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __log2p1f64x (_Float64x __x) __attribute__ ((__nothrow__ ));


extern _Float64x log10p1f64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __log10p1f64x (_Float64x __x) __attribute__ ((__nothrow__ ));


 extern _Float64x logp1f64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __logp1f64x (_Float64x __x) __attribute__ ((__nothrow__ ));




 extern _Float64x expm1f64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __expm1f64x (_Float64x __x) __attribute__ ((__nothrow__ ));


 extern _Float64x log1pf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __log1pf64x (_Float64x __x) __attribute__ ((__nothrow__ ));


extern _Float64x logbf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __logbf64x (_Float64x __x) __attribute__ ((__nothrow__ ));




 extern _Float64x exp2f64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __exp2f64x (_Float64x __x) __attribute__ ((__nothrow__ ));


 extern _Float64x log2f64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __log2f64x (_Float64x __x) __attribute__ ((__nothrow__ ));






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));


extern _Float64x sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ ));



 extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));




 extern _Float64x cbrtf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __cbrtf64x (_Float64x __x) __attribute__ ((__nothrow__ ));






extern _Float64x ceilf64x (_Float64x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));
# 231 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) __attribute__ ((__nothrow__ )); extern _Float64x __nanf64x (const char *__tagb) __attribute__ ((__nothrow__ ));
# 253 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) __attribute__ ((__nothrow__ )); extern _Float64x __j0f64x (_Float64x) __attribute__ ((__nothrow__ ));
extern _Float64x j1f64x (_Float64x) __attribute__ ((__nothrow__ )); extern _Float64x __j1f64x (_Float64x) __attribute__ ((__nothrow__ ));
extern _Float64x jnf64x (int, _Float64x) __attribute__ ((__nothrow__ )); extern _Float64x __jnf64x (int, _Float64x) __attribute__ ((__nothrow__ ));
extern _Float64x y0f64x (_Float64x) __attribute__ ((__nothrow__ )); extern _Float64x __y0f64x (_Float64x) __attribute__ ((__nothrow__ ));
extern _Float64x y1f64x (_Float64x) __attribute__ ((__nothrow__ )); extern _Float64x __y1f64x (_Float64x) __attribute__ ((__nothrow__ ));
extern _Float64x ynf64x (int, _Float64x) __attribute__ ((__nothrow__ )); extern _Float64x __ynf64x (int, _Float64x) __attribute__ ((__nothrow__ ));





 extern _Float64x erff64x (_Float64x) __attribute__ ((__nothrow__ )); extern _Float64x __erff64x (_Float64x) __attribute__ ((__nothrow__ ));
 extern _Float64x erfcf64x (_Float64x) __attribute__ ((__nothrow__ )); extern _Float64x __erfcf64x (_Float64x) __attribute__ ((__nothrow__ ));
extern _Float64x lgammaf64x (_Float64x) __attribute__ ((__nothrow__ )); extern _Float64x __lgammaf64x (_Float64x) __attribute__ ((__nothrow__ ));




extern _Float64x tgammaf64x (_Float64x) __attribute__ ((__nothrow__ )); extern _Float64x __tgammaf64x (_Float64x) __attribute__ ((__nothrow__ ));
# 285 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) __attribute__ ((__nothrow__ )); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) __attribute__ ((__nothrow__ ));






extern _Float64x rintf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __rintf64x (_Float64x __x) __attribute__ ((__nothrow__ ));


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));






extern _Float64x nextdownf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __nextdownf64x (_Float64x __x) __attribute__ ((__nothrow__ ));

extern _Float64x nextupf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __nextupf64x (_Float64x __x) __attribute__ ((__nothrow__ ));



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));



extern _Float64x scalbnf64x (_Float64x __x, int __n) __attribute__ ((__nothrow__ )); extern _Float64x __scalbnf64x (_Float64x __x, int __n) __attribute__ ((__nothrow__ ));



extern int ilogbf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern int __ilogbf64x (_Float64x __x) __attribute__ ((__nothrow__ ));




extern long int llogbf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern long int __llogbf64x (_Float64x __x) __attribute__ ((__nothrow__ ));




extern _Float64x scalblnf64x (_Float64x __x, long int __n) __attribute__ ((__nothrow__ )); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) __attribute__ ((__nothrow__ ));



extern _Float64x nearbyintf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern _Float64x __nearbyintf64x (_Float64x __x) __attribute__ ((__nothrow__ ));



extern _Float64x roundf64x (_Float64x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) __attribute__ ((__nothrow__ )); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) __attribute__ ((__nothrow__ ));






extern long int lrintf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern long int __lrintf64x (_Float64x __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llrintf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern long long int __llrintf64x (_Float64x __x) __attribute__ ((__nothrow__ ));



extern long int lroundf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern long int __lroundf64x (_Float64x __x) __attribute__ ((__nothrow__ ));
__extension__
extern long long int llroundf64x (_Float64x __x) __attribute__ ((__nothrow__ )); extern long long int __llroundf64x (_Float64x __x) __attribute__ ((__nothrow__ ));



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));



extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ )); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ ));




extern _Float64x roundevenf64x (_Float64x __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));




extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));





extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ )); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ ));



extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) __attribute__ ((__nothrow__ ));






extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern _Float64x fmaximumf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x fminimumf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x fmaximum_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x fminimum_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x fmaximum_magf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x fminimum_magf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern _Float64x fminimum_mag_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) __attribute__ ((__nothrow__ ))

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) __attribute__ ((__nothrow__ )); extern _Float64x __getpayloadf64x (const _Float64x *__x) __attribute__ ((__nothrow__ ));


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) __attribute__ ((__nothrow__ ));


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) __attribute__ ((__nothrow__ ));
# 488 "/usr/include/math.h" 2 3 4
# 535 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) __attribute__ ((__nothrow__ ));


extern float fdiv (double __x, double __y) __attribute__ ((__nothrow__ ));


extern float ffma (double __x, double __y, double __z) __attribute__ ((__nothrow__ ));


extern float fmul (double __x, double __y) __attribute__ ((__nothrow__ ));


extern float fsqrt (double __x) __attribute__ ((__nothrow__ ));


extern float fsub (double __x, double __y) __attribute__ ((__nothrow__ ));
# 536 "/usr/include/math.h" 2 3 4
# 556 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) __attribute__ ((__nothrow__ ));


extern float fdivl (long double __x, long double __y) __attribute__ ((__nothrow__ ));


extern float ffmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ ));


extern float fmull (long double __x, long double __y) __attribute__ ((__nothrow__ ));


extern float fsqrtl (long double __x) __attribute__ ((__nothrow__ ));


extern float fsubl (long double __x, long double __y) __attribute__ ((__nothrow__ ));
# 557 "/usr/include/math.h" 2 3 4
# 585 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) __attribute__ ((__nothrow__ ));


extern double ddivl (long double __x, long double __y) __attribute__ ((__nothrow__ ));


extern double dfmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ ));


extern double dmull (long double __x, long double __y) __attribute__ ((__nothrow__ ));


extern double dsqrtl (long double __x) __attribute__ ((__nothrow__ ));


extern double dsubl (long double __x, long double __y) __attribute__ ((__nothrow__ ));
# 586 "/usr/include/math.h" 2 3 4
# 666 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) __attribute__ ((__nothrow__ ));


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32sqrtf32x (_Float32x __x) __attribute__ ((__nothrow__ ));


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ ));
# 667 "/usr/include/math.h" 2 3 4
# 676 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ ));


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32sqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ ));


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));
# 677 "/usr/include/math.h" 2 3 4
# 686 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ ));


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ ));


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));
# 687 "/usr/include/math.h" 2 3 4
# 696 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ ));


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float32 f32sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));
# 697 "/usr/include/math.h" 2 3 4
# 716 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));


extern _Float32x f32xfmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ ));


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));


extern _Float32x f32xsqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ ));


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ ));
# 717 "/usr/include/math.h" 2 3 4
# 726 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));


extern _Float32x f32xfmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ ));


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));


extern _Float32x f32xsqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ ));


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));
# 727 "/usr/include/math.h" 2 3 4
# 736 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float32x f32xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ ));


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float32x f32xsqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));
# 737 "/usr/include/math.h" 2 3 4
# 756 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));


extern _Float64 f64fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ ));


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));


extern _Float64 f64sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ ));


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ ));
# 757 "/usr/include/math.h" 2 3 4
# 766 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float64 f64fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ ));


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float64 f64sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));
# 767 "/usr/include/math.h" 2 3 4
# 786 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float64x f64xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ ));


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));


extern _Float64x f64xsqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ ));


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ ));
# 787 "/usr/include/math.h" 2 3 4
# 823 "/usr/include/math.h" 3 4
extern int signgam;
# 903 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1024 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 1025 "/usr/include/math.h" 2 3 4
# 35889 "c_tests/sqlite3.c" 2
# 35911 "c_tests/sqlite3.c"
static int sqlite3FaultSim(int iTest){
  int (*xCallback)(int) = sqlite3Config.xTestCallback;
  return xCallback ? xCallback(iTest) : 0;
}
# 35924 "c_tests/sqlite3.c"
static int sqlite3IsNaN(double x){
  int rc;

  u64 y;
  memcpy(&y,&x,sizeof(y));
  rc = (((y)&(((u64)0x7ff)<<52))==(((u64)0x7ff)<<52) && ((y)&((((u64)1)<<52)-1))!=0);



                ;
  return rc;
}






static int sqlite3IsOverflow(double x){
  int rc;
  u64 y;
  memcpy(&y,&x,sizeof(y));
  rc = (((y)&(((u64)0x7ff)<<52))==(((u64)0x7ff)<<52));
  return rc;
}
# 35959 "c_tests/sqlite3.c"
static int sqlite3Strlen30(const char *z){
  if( z==0 ) return 0;
  return 0x3fffffff & (int)strlen(z);
}
# 35971 "c_tests/sqlite3.c"
static char *sqlite3ColumnType(Column *pCol, char *zDflt){
  if( pCol->colFlags & 0x0004 ){
    return pCol->zCnName + strlen(pCol->zCnName) + 1;
  }else if( pCol->eCType ){
    ((void) (0));
    return (char*)sqlite3StdType[pCol->eCType-1];
  }else{
    return zDflt;
  }
}






static __attribute__((noinline)) void sqlite3ErrorFinish(sqlite3 *db, int err_code){
  if( db->pErr ) sqlite3ValueSetNull(db->pErr);
  sqlite3SystemError(db, err_code);
}






static void sqlite3Error(sqlite3 *db, int err_code){
  ((void) (0));
  db->errCode = err_code;
  if( err_code || db->pErr ){
    sqlite3ErrorFinish(db, err_code);
  }else{
    db->errByteOffset = -1;
  }
}





static void sqlite3ErrorClear(sqlite3 *db){
  ((void) (0));
  db->errCode = 0;
  db->errByteOffset = -1;
  if( db->pErr ) sqlite3ValueSetNull(db->pErr);
}





static void sqlite3SystemError(sqlite3 *db, int rc){
  if( rc==(10 | (12<<8)) ) return;
# 36041 "c_tests/sqlite3.c"
  rc &= 0xff;
  if( rc==14 || rc==10 ){
    db->iSysErrno = sqlite3OsGetLastError(db->pVfs);
  }
}
# 36059 "c_tests/sqlite3.c"
static void sqlite3ErrorWithMsg(sqlite3 *db, int err_code, const char *zFormat, ...){
  ((void) (0));
  db->errCode = err_code;
  sqlite3SystemError(db, err_code);
  if( zFormat==0 ){
    sqlite3Error(db, err_code);
  }else if( db->pErr || (db->pErr = sqlite3ValueNew(db))!=0 ){
    char *z;
    va_list ap;
    __builtin_va_start(ap, zFormat);
    z = sqlite3VMPrintf(db, zFormat, ap);
    __builtin_va_end(ap);
    sqlite3ValueSetStr(db->pErr, -1, z, 1, ((sqlite3_destructor_type)sqlite3RowSetClear));
  }
}




static void sqlite3ProgressCheck(Parse *p){
  sqlite3 *db = p->db;
  if( __atomic_load_n((&db->u1.isInterrupted),0) ){
    p->nErr++;
    p->rc = 9;
  }

  if( db->xProgress ){
    if( p->rc==9 ){
      p->nProgressSteps = 0;
    }else if( (++p->nProgressSteps)>=db->nProgressOps ){
      if( db->xProgress(db->pProgressArg) ){
        p->nErr++;
        p->rc = 9;
      }
      p->nProgressSteps = 0;
    }
  }

}
# 36109 "c_tests/sqlite3.c"
static void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){
  char *zMsg;
  va_list ap;
  sqlite3 *db = pParse->db;
  ((void) (0));
  ((void) (0));
  db->errByteOffset = -2;
  __builtin_va_start(ap, zFormat);
  zMsg = sqlite3VMPrintf(db, zFormat, ap);
  __builtin_va_end(ap);
  if( db->errByteOffset<-1 ) db->errByteOffset = -1;
  if( db->suppressErr ){
    sqlite3DbFree(db, zMsg);
    if( db->mallocFailed ){
      pParse->nErr++;
      pParse->rc = 7;
    }
  }else{
    pParse->nErr++;
    sqlite3DbFree(db, pParse->zErrMsg);
    pParse->zErrMsg = zMsg;
    pParse->rc = 1;
    pParse->pWith = 0;
  }
}






static int sqlite3ErrorToParser(sqlite3 *db, int errCode){
  Parse *pParse;
  if( db==0 || (pParse = db->pParse)==0 ) return errCode;
  pParse->rc = errCode;
  pParse->nErr++;
  return errCode;
}
# 36165 "c_tests/sqlite3.c"
static void sqlite3Dequote(char *z){
  char quote;
  int i, j;
  if( z==0 ) return;
  quote = z[0];
  if( !(sqlite3CtypeMap[(unsigned char)(quote)]&0x80) ) return;
  if( quote=='[' ) quote = ']';
  for(i=1, j=0;; i++){
    ((void) (0));
    if( z[i]==quote ){
      if( z[i+1]==quote ){
        z[j++] = quote;
        i++;
      }else{
        break;
      }
    }else{
      z[j++] = z[i];
    }
  }
  z[j] = 0;
}
static void sqlite3DequoteExpr(Expr *p){
  ((void) (0));
  ((void) (0));
  p->flags |= p->u.zToken[0]=='"' ? 0x4000000|0x000080 : 0x4000000;
  sqlite3Dequote(p->u.zToken);
}






static void sqlite3DequoteNumber(Parse *pParse, Expr *p){
  ((void) (0));
  if( p ){
    const char *pIn = p->u.zToken;
    char *pOut = p->u.zToken;
    int bHex = (pIn[0]=='0' && (pIn[1]=='x' || pIn[1]=='X'));
    int iValue;
    ((void) (0));
    p->op = 156;
    do {
      if( *pIn!='_' ){
        *pOut++ = *pIn;
        if( *pIn=='e' || *pIn=='E' || *pIn=='.' ) p->op = 154;
      }else{
        if( (bHex==0 && (!(sqlite3CtypeMap[(unsigned char)(pIn[-1])]&0x04) || !(sqlite3CtypeMap[(unsigned char)(pIn[1])]&0x04)))
         || (bHex==1 && (!(sqlite3CtypeMap[(unsigned char)(pIn[-1])]&0x08) || !(sqlite3CtypeMap[(unsigned char)(pIn[1])]&0x08)))
        ){
          sqlite3ErrorMsg(pParse, "unrecognized token: \"%s\"", p->u.zToken);
        }
      }
    }while( *pIn++ );
    if( bHex ) p->op = 156;




    if( p->op==156 && sqlite3GetInt32(p->u.zToken, &iValue) ){
      p->u.iValue = iValue;
      p->flags |= 0x000800;
    }
  }
}
# 36243 "c_tests/sqlite3.c"
static void sqlite3DequoteToken(Token *p){
  unsigned int i;
  if( p->n<2 ) return;
  if( !(sqlite3CtypeMap[(unsigned char)(p->z[0])]&0x80) ) return;
  for(i=1; i<p->n-1; i++){
    if( (sqlite3CtypeMap[(unsigned char)(p->z[i])]&0x80) ) return;
  }
  p->n -= 2;
  p->z++;
}




static void sqlite3TokenInit(Token *p, char *z){
  p->z = z;
  p->n = sqlite3Strlen30(z);
}
# 36275 "c_tests/sqlite3.c"
           int sqlite3_stricmp(const char *zLeft, const char *zRight){
  if( zLeft==0 ){
    return zRight ? -1 : 0;
  }else if( zRight==0 ){
    return 1;
  }
  return sqlite3StrICmp(zLeft, zRight);
}
static int sqlite3StrICmp(const char *zLeft, const char *zRight){
  unsigned char *a, *b;
  int c, x;
  a = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  for(;;){
    c = *a;
    x = *b;
    if( c==x ){
      if( c==0 ) break;
    }else{
      c = (int)sqlite3UpperToLower[c] - (int)sqlite3UpperToLower[x];
      if( c ) break;
    }
    a++;
    b++;
  }
  return c;
}
           int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){
  register unsigned char *a, *b;
  if( zLeft==0 ){
    return zRight ? -1 : 0;
  }else if( zRight==0 ){
    return 1;
  }
  a = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  while( N-- > 0 && *a!=0 && sqlite3UpperToLower[*a]==sqlite3UpperToLower[*b]){ a++; b++; }
  return N<0 ? 0 : sqlite3UpperToLower[*a] - sqlite3UpperToLower[*b];
}




static u8 sqlite3StrIHash(const char *z){
  u8 h = 0;
  if( z==0 ) return 0;
  while( z[0] ){
    h += sqlite3UpperToLower[(unsigned char)z[0]];
    z++;
  }
  return h;
}







static void dekkerMul2(volatile double *x, double y, double yy){
# 36343 "c_tests/sqlite3.c"
  volatile double tx, ty, p, q, c, cc;
  double hx, hy;
  u64 m;
  memcpy(&m, (void*)&x[0], 8);
  m &= 0xfffffffffc000000LL;
  memcpy(&hx, &m, 8);
  tx = x[0] - hx;
  memcpy(&m, &y, 8);
  m &= 0xfffffffffc000000LL;
  memcpy(&hy, &m, 8);
  ty = y - hy;
  p = hx*hy;
  q = hx*ty + tx*hy;
  c = p+q;
  cc = p - c + q + tx*ty;
  cc = x[0]*yy + x[1]*y + cc;
  x[0] = c + cc;
  x[1] = c - x[0];
  x[1] += cc;
}
# 36396 "c_tests/sqlite3.c"
static int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc){

  int incr;
  const char *zEnd;

  int sign = 1;
  u64 s = 0;
  int d = 0;
  int esign = 1;
  int e = 0;
  int eValid = 1;
  int nDigit = 0;
  int eType = 1;
  u64 s2;
  double rr[2];

  ((void) (0));
  *pResult = 0.0;
  if( length==0 ) return 0;

  if( enc==1 ){
    incr = 1;
    zEnd = z + length;
  }else{
    int i;
    incr = 2;
    length &= ~1;
    ((void) (0));
                                   ;
                                   ;
    for(i=3-enc; i<length && z[i]==0; i+=2){}
    if( i<length ) eType = -100;
    zEnd = &z[i^1];
    z += (enc&1);
  }


  while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x01) ) z+=incr;
  if( z>=zEnd ) return 0;


  if( *z=='-' ){
    sign = -1;
    z+=incr;
  }else if( *z=='+' ){
    z+=incr;
  }


  while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){
    s = s*10 + (*z - '0');
    z+=incr; nDigit++;
    if( s>=(((0xffffffff|(((u64)0xffffffff)<<32))-9)/10) ){


      while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){ z+=incr; d++; }
    }
  }
  if( z>=zEnd ) goto do_atof_calc;


  if( *z=='.' ){
    z+=incr;
    eType++;


    while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){
      if( s<(((0xffffffff|(((u64)0xffffffff)<<32))-9)/10) ){
        s = s*10 + (*z - '0');
        d--;
        nDigit++;
      }
      z+=incr;
    }
  }
  if( z>=zEnd ) goto do_atof_calc;


  if( *z=='e' || *z=='E' ){
    z+=incr;
    eValid = 0;
    eType++;




    if( z>=zEnd ) goto do_atof_calc;


    if( *z=='-' ){
      esign = -1;
      z+=incr;
    }else if( *z=='+' ){
      z+=incr;
    }

    while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){
      e = e<10000 ? (e*10 + (*z - '0')) : 10000;
      z+=incr;
      eValid = 1;
    }
  }


  while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x01) ) z+=incr;

do_atof_calc:

  if( s==0 ){
    *pResult = sign<0 ? -0.0 : +0.0;
    goto atof_return;
  }


  e = (e*esign) + d;


  while( e>0 && s<(((0xffffffff|(((u64)0xffffffff)<<32))-0x7ff)/10) ){
    s *= 10;
    e--;
  }
  while( e<0 && (s%10)==0 ){
    s /= 10;
    e++;
  }

  rr[0] = (double)s;
  ((void) (0));







  if( rr[0]<=18446744073709549568.0 ){
    s2 = (u64)rr[0];
    rr[1] = s>=s2 ? (double)(s - s2) : -(double)(s2 - s);
  }else{
    rr[1] = 0.0;
  }
  ((void) (0));

  if( e>0 ){
    while( e>=100 ){
      e -= 100;
      dekkerMul2(rr, 1.0e+100, -1.5902891109759918046e+83);
    }
    while( e>=10 ){
      e -= 10;
      dekkerMul2(rr, 1.0e+10, 0.0);
    }
    while( e>=1 ){
      e -= 1;
      dekkerMul2(rr, 1.0e+01, 0.0);
    }
  }else{
    while( e<=-100 ){
      e += 100;
      dekkerMul2(rr, 1.0e-100, -1.99918998026028836196e-117);
    }
    while( e<=-10 ){
      e += 10;
      dekkerMul2(rr, 1.0e-10, -3.6432197315497741579e-27);
    }
    while( e<=-1 ){
      e += 1;
      dekkerMul2(rr, 1.0e-01, -5.5511151231257827021e-18);
    }
  }
  *pResult = rr[0]+rr[1];
  if( sqlite3IsNaN(*pResult) ) *pResult = 1e300*1e300;
  if( sign<0 ) *pResult = -*pResult;
  ((void) (0));

atof_return:

  if( z==zEnd && nDigit>0 && eValid && eType>0 ){
    return eType;
  }else if( eType>=2 && (eType==3 || eValid) && nDigit>0 ){
    return -1;
  }else{
    return 0;
  }



}
# 36596 "c_tests/sqlite3.c"
static int sqlite3Int64ToText(i64 v, char *zOut){
  int i;
  u64 x;
  char zTemp[22];
  if( v<0 ){
    x = (v==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)))) ? ((u64)1)<<63 : (u64)-v;
  }else{
    x = v;
  }
  i = sizeof(zTemp)-2;
  zTemp[sizeof(zTemp)-1] = 0;
  while( 1 ){
    zTemp[i] = (x%10) + '0';
    x = x/10;
    if( x==0 ) break;
    i--;
  };
  if( v<0 ) zTemp[--i] = '-';
  memcpy(zOut, &zTemp[i], sizeof(zTemp)-i);
  return sizeof(zTemp)-1-i;
}
# 36632 "c_tests/sqlite3.c"
static int compare2pow63(const char *zNum, int incr){
  int c = 0;
  int i;

  const char *pow63 = "922337203685477580";
  for(i=0; c==0 && i<18; i++){
    c = (zNum[i*incr]-pow63[i])*10;
  }
  if( c==0 ){
    c = zNum[18*incr] - '8';
                       ;
                    ;
                       ;
  }
  return c;
}
# 36665 "c_tests/sqlite3.c"
static int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc){
  int incr;
  u64 u = 0;
  int neg = 0;
  int i;
  int c = 0;
  int nonNum = 0;
  int rc;
  const char *zStart;
  const char *zEnd = zNum + length;
  ((void) (0));
  if( enc==1 ){
    incr = 1;
  }else{
    incr = 2;
    length &= ~1;
    ((void) (0));
    for(i=3-enc; i<length && zNum[i]==0; i+=2){}
    nonNum = i<length;
    zEnd = &zNum[i^1];
    zNum += (enc&1);
  }
  while( zNum<zEnd && (sqlite3CtypeMap[(unsigned char)(*zNum)]&0x01) ) zNum+=incr;
  if( zNum<zEnd ){
    if( *zNum=='-' ){
      neg = 1;
      zNum+=incr;
    }else if( *zNum=='+' ){
      zNum+=incr;
    }
  }
  zStart = zNum;
  while( zNum<zEnd && zNum[0]=='0' ){ zNum+=incr; }
  for(i=0; &zNum[i]<zEnd && (c=zNum[i])>='0' && c<='9'; i+=incr){
    u = u*10 + c - '0';
  }
                        ;
                        ;
                        ;
  if( u>(0xffffffff|(((i64)0x7fffffff)<<32)) ){




    *pNum = neg ? (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) : (0xffffffff|(((i64)0x7fffffff)<<32));
  }else if( neg ){
    *pNum = -(i64)u;
  }else{
    *pNum = (i64)u;
  }
  rc = 0;
  if( i==0 && zStart==zNum ){
    rc = -1;
  }else if( nonNum ){
    rc = 1;
  }else if( &zNum[i]<zEnd ){
    int jj = i;
    do{
      if( !(sqlite3CtypeMap[(unsigned char)(zNum[jj])]&0x01) ){
        rc = 1;
        break;
      }
      jj += incr;
    }while( &zNum[jj]<zEnd );
  }
  if( i<19*incr ){

    ((void) (0));
    return rc;
  }else{

    c = i>19*incr ? 1 : compare2pow63(zNum, incr);
    if( c<0 ){

      ((void) (0));
      return rc;
    }else{
      *pNum = neg ? (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) : (0xffffffff|(((i64)0x7fffffff)<<32));
      if( c>0 ){

        return 2;
      }else{


        ((void) (0));
        return neg ? rc : 3;
      }
    }
  }
}
# 36768 "c_tests/sqlite3.c"
static int sqlite3DecOrHexToI64(const char *z, i64 *pOut){

  if( z[0]=='0'
   && (z[1]=='x' || z[1]=='X')
  ){
    u64 u = 0;
    int i, k;
    for(i=2; z[i]=='0'; i++){}
    for(k=i; (sqlite3CtypeMap[(unsigned char)(z[k])]&0x08); k++){
      u = u*16 + sqlite3HexToInt(z[k]);
    }
    memcpy(pOut, &u, 8);
    if( k-i>16 ) return 2;
    if( z[k]!=0 ) return 1;
    return 0;
  }else

  {
    int n = (int)(0x3fffffff&strspn(z,"+- \n\t0123456789"));
    if( z[n] ) n++;
    return sqlite3Atoi64(z, pOut, n, 1);
  }
}
# 36802 "c_tests/sqlite3.c"
static int sqlite3GetInt32(const char *zNum, int *pValue){
  sqlite_int64 v = 0;
  int i, c;
  int neg = 0;
  if( zNum[0]=='-' ){
    neg = 1;
    zNum++;
  }else if( zNum[0]=='+' ){
    zNum++;
  }

  else if( zNum[0]=='0'
        && (zNum[1]=='x' || zNum[1]=='X')
        && (sqlite3CtypeMap[(unsigned char)(zNum[2])]&0x08)
  ){
    u32 u = 0;
    zNum += 2;
    while( zNum[0]=='0' ) zNum++;
    for(i=0; i<8 && (sqlite3CtypeMap[(unsigned char)(zNum[i])]&0x08); i++){
      u = u*16 + sqlite3HexToInt(zNum[i]);
    }
    if( (u&0x80000000)==0 && (sqlite3CtypeMap[(unsigned char)(zNum[i])]&0x08)==0 ){
      memcpy(pValue, &u, 4);
      return 1;
    }else{
      return 0;
    }
  }

  if( !(sqlite3CtypeMap[(unsigned char)(zNum[0])]&0x04) ) return 0;
  while( zNum[0]=='0' ) zNum++;
  for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){
    v = v*10 + c;
  }






                   ;
  if( i>10 ){
    return 0;
  }
                               ;
  if( v-neg>2147483647 ){
    return 0;
  }
  if( neg ){
    v = -v;
  }
  *pValue = (int)v;
  return 1;
}





static int sqlite3Atoi(const char *z){
  int x = 0;
  sqlite3GetInt32(z, &x);
  return x;
}
# 36884 "c_tests/sqlite3.c"
static void sqlite3FpDecode(FpDecode *p, double r, int iRound, int mxRound){
  int i;
  u64 v;
  int e, exp = 0;
  double rr[2];

  p->isSpecial = 0;
  p->z = p->zBuf;
  ((void) (0));



  if( r<0.0 ){
    p->sign = '-';
    r = -r;
  }else if( r==0.0 ){
    p->sign = '+';
    p->n = 1;
    p->iDP = 1;
    p->z = "0";
    return;
  }else{
    p->sign = '+';
  }
  memcpy(&v,&r,8);
  e = v>>52;
  if( (e&0x7ff)==0x7ff ){
    p->isSpecial = 1 + (v!=0x7ff0000000000000LL);
    p->n = 0;
    p->iDP = 0;
    return;
  }
# 36928 "c_tests/sqlite3.c"
  rr[0] = r;
  rr[1] = 0.0;
  if( rr[0]>9.223372036854774784e+18 ){
    while( rr[0]>9.223372036854774784e+118 ){
      exp += 100;
      dekkerMul2(rr, 1.0e-100, -1.99918998026028836196e-117);
    }
    while( rr[0]>9.223372036854774784e+28 ){
      exp += 10;
      dekkerMul2(rr, 1.0e-10, -3.6432197315497741579e-27);
    }
    while( rr[0]>9.223372036854774784e+18 ){
      exp += 1;
      dekkerMul2(rr, 1.0e-01, -5.5511151231257827021e-18);
    }
  }else{
    while( rr[0]<9.223372036854774784e-83 ){
      exp -= 100;
      dekkerMul2(rr, 1.0e+100, -1.5902891109759918046e+83);
    }
    while( rr[0]<9.223372036854774784e+07 ){
      exp -= 10;
      dekkerMul2(rr, 1.0e+10, 0.0);
    }
    while( rr[0]<9.22337203685477478e+17 ){
      exp -= 1;
      dekkerMul2(rr, 1.0e+01, 0.0);
    }
  }
  v = rr[1]<0.0 ? (u64)rr[0]-(u64)(-rr[1]) : (u64)rr[0]+(u64)rr[1];


  i = sizeof(p->zBuf)-1;
  ((void) (0));
  while( v ){ p->zBuf[i--] = (v%10) + '0'; v /= 10; }
  ((void) (0));
  p->n = sizeof(p->zBuf) - 1 - i;
  ((void) (0));
  ((void) (0));
  p->iDP = p->n + exp;
  if( iRound<=0 ){
    iRound = p->iDP - iRound;
    if( iRound==0 && p->zBuf[i+1]>='5' ){
      iRound = 1;
      p->zBuf[i--] = '0';
      p->n++;
      p->iDP++;
    }
  }
  if( iRound>0 && (iRound<p->n || p->n>mxRound) ){
    char *z = &p->zBuf[i+1];
    if( iRound>mxRound ) iRound = mxRound;
    p->n = iRound;
    if( z[iRound]>='5' ){
      int j = iRound-1;
      while( 1 ){
        z[j]++;
        if( z[j]<='9' ) break;
        z[j] = '0';
        if( j==0 ){
          p->z[i--] = '1';
          p->n++;
          p->iDP++;
          break;
        }else{
          j--;
        }
      }
    }
  }
  p->z = &p->zBuf[i+1];
  ((void) (0));
  ((void) (0));
  while( p->z[p->n-1]=='0' ){
    p->n--;
    ((void) (0));
  }
}







static int sqlite3GetUInt32(const char *z, u32 *pI){
  u64 v = 0;
  int i;
  for(i=0; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04); i++){
    v = v*10 + z[i] - '0';
    if( v>4294967296LL ){ *pI = 0; return 0; }
  }
  if( i==0 || z[i]!=0 ){ *pI = 0; return 0; }
  *pI = (u32)v;
  return 1;
}
# 37054 "c_tests/sqlite3.c"
static int __attribute__((noinline)) putVarint64(unsigned char *p, u64 v){
  int i, j, n;
  u8 buf[10];
  if( v & (((u64)0xff000000)<<32) ){
    p[8] = (u8)v;
    v >>= 8;
    for(i=7; i>=0; i--){
      p[i] = (u8)((v & 0x7f) | 0x80);
      v >>= 7;
    }
    return 9;
  }
  n = 0;
  do{
    buf[n++] = (u8)((v & 0x7f) | 0x80);
    v >>= 7;
  }while( v!=0 );
  buf[0] &= 0x7f;
  ((void) (0));
  for(i=0, j=n-1; j>=0; j--, i++){
    p[i] = buf[j];
  }
  return n;
}
static int sqlite3PutVarint(unsigned char *p, u64 v){
  if( v<=0x7f ){
    p[0] = v&0x7f;
    return 1;
  }
  if( v<=0x3fff ){
    p[0] = ((v>>7)&0x7f)|0x80;
    p[1] = v&0x7f;
    return 2;
  }
  return putVarint64(p,v);
}
# 37108 "c_tests/sqlite3.c"
static u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
  u32 a,b,s;

  if( ((signed char*)p)[0]>=0 ){
    *v = *p;
    return 1;
  }
  if( ((signed char*)p)[1]>=0 ){
    *v = ((u32)(p[0]&0x7f)<<7) | p[1];
    return 2;
  }


  ((void) (0));
  ((void) (0));

  a = ((u32)p[0])<<14;
  b = p[1];
  p += 2;
  a |= *p;

  if (!(a&0x80))
  {
    a &= 0x001fc07f;
    b &= 0x7f;
    b = b<<7;
    a |= b;
    *v = a;
    return 3;
  }


  a &= 0x001fc07f;
  p++;
  b = b<<14;
  b |= *p;

  if (!(b&0x80))
  {
    b &= 0x001fc07f;


    a = a<<7;
    a |= b;
    *v = a;
    return 4;
  }






  b &= 0x001fc07f;
  s = a;


  p++;
  a = a<<14;
  a |= *p;

  if (!(a&0x80))
  {




    b = b<<7;
    a |= b;
    s = s>>18;
    *v = ((u64)s)<<32 | a;
    return 5;
  }


  s = s<<7;
  s |= b;


  p++;
  b = b<<14;
  b |= *p;

  if (!(b&0x80))
  {


    a &= 0x001fc07f;
    a = a<<7;
    a |= b;
    s = s>>18;
    *v = ((u64)s)<<32 | a;
    return 6;
  }

  p++;
  a = a<<14;
  a |= *p;

  if (!(a&0x80))
  {
    a &= 0xf01fc07f;
    b &= 0x001fc07f;
    b = b<<7;
    a |= b;
    s = s>>11;
    *v = ((u64)s)<<32 | a;
    return 7;
  }


  a &= 0x001fc07f;
  p++;
  b = b<<14;
  b |= *p;

  if (!(b&0x80))
  {
    b &= 0xf01fc07f;


    a = a<<7;
    a |= b;
    s = s>>4;
    *v = ((u64)s)<<32 | a;
    return 8;
  }

  p++;
  a = a<<15;
  a |= *p;




  b &= 0x001fc07f;
  b = b<<8;
  a |= b;

  s = s<<4;
  b = p[-4];
  b &= 0x7f;
  b = b>>3;
  s |= b;

  *v = ((u64)s)<<32 | a;

  return 9;
}
# 37269 "c_tests/sqlite3.c"
static u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){
  u64 v64;
  u8 n;



  ((void) (0));

  if( (p[1] & 0x80)==0 ){

    *v = ((p[0]&0x7f)<<7) | p[1];
    return 2;
  }
  if( (p[2] & 0x80)==0 ){

    *v = ((p[0]&0x7f)<<14) | ((p[1]&0x7f)<<7) | p[2];
    return 3;
  }

  n = sqlite3GetVarint(p, &v64);
  ((void) (0));
  if( (v64 & ((((u64)1)<<32)-1))!=v64 ){
    *v = 0xffffffff;
  }else{
    *v = (u32)v64;
  }
  return n;
}





static int sqlite3VarintLen(u64 v){
  int i;
  for(i=1; (v >>= 7)!=0; i++){ ((void) (0)); }
  return i;
}





static u32 sqlite3Get4byte(const u8 *p){
# 37326 "c_tests/sqlite3.c"
                       ;
  return ((unsigned)p[0]<<24) | (p[1]<<16) | (p[2]<<8) | p[3];

}
static void sqlite3Put4byte(unsigned char *p, u32 v){
# 37340 "c_tests/sqlite3.c"
  p[0] = (u8)(v>>24);
  p[1] = (u8)(v>>16);
  p[2] = (u8)(v>>8);
  p[3] = (u8)v;

}
# 37354 "c_tests/sqlite3.c"
static u8 sqlite3HexToInt(int h){
  ((void) (0));

  h += 9*(1&(h>>6));




  return (u8)(h & 0xf);
}
# 37372 "c_tests/sqlite3.c"
static void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){
  char *zBlob;
  int i;

  zBlob = (char *)sqlite3DbMallocRawNN(db, n/2 + 1);
  n--;
  if( zBlob ){
    for(i=0; i<n; i+=2){
      zBlob[i/2] = (sqlite3HexToInt(z[i])<<4) | sqlite3HexToInt(z[i+1]);
    }
    zBlob[i/2] = 0;
  }
  return zBlob;
}







static void logBadConnection(const char *zType){
  sqlite3_log(21,
     "API call with %s database connection pointer",
     zType
  );
}
# 37414 "c_tests/sqlite3.c"
static int sqlite3SafetyCheckOk(sqlite3 *db){
  u8 eOpenState;
  if( db==0 ){
    logBadConnection("NULL");
    return 0;
  }
  eOpenState = db->eOpenState;
  if( eOpenState!=0x76 ){
    if( sqlite3SafetyCheckSickOrOk(db) ){
                                             ;
      logBadConnection("unopened");
    }
    return 0;
  }else{
    return 1;
  }
}
static int sqlite3SafetyCheckSickOrOk(sqlite3 *db){
  u8 eOpenState;
  eOpenState = db->eOpenState;
  if( eOpenState!=0xba &&
      eOpenState!=0x76 &&
      eOpenState!=0x6d ){
                                           ;
    logBadConnection("invalid");
    return 0;
  }else{
    return 1;
  }
}







static int sqlite3AddInt64(i64 *pA, i64 iB){



  i64 iA = *pA;
                   ; ;
                    ; ;
  if( iB>=0 ){
                                                ;
                                                    ;
    if( iA>0 && (0xffffffff|(((i64)0x7fffffff)<<32)) - iA < iB ) return 1;
  }else{
                                                       ;
                                                       ;
    if( iA<0 && -(iA + (0xffffffff|(((i64)0x7fffffff)<<32))) > iB + 1 ) return 1;
  }
  *pA += iB;
  return 0;

}
static int sqlite3SubInt64(i64 *pA, i64 iB){



                                  ;
  if( iB==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ){
                           ; ;
    if( (*pA)>=0 ) return 1;
    *pA -= iB;
    return 0;
  }else{
    return sqlite3AddInt64(pA, -iB);
  }

}
static int sqlite3MulInt64(i64 *pA, i64 iB){



  i64 iA = *pA;
  if( iB>0 ){
    if( iA>(0xffffffff|(((i64)0x7fffffff)<<32))/iB ) return 1;
    if( iA<(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)))/iB ) return 1;
  }else if( iB<0 ){
    if( iA>0 ){
      if( iB<(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)))/iA ) return 1;
    }else if( iA<0 ){
      if( iB==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ) return 1;
      if( iA==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ) return 1;
      if( -iA>(0xffffffff|(((i64)0x7fffffff)<<32))/-iB ) return 1;
    }
  }
  *pA = iA*iB;
  return 0;

}





static int sqlite3AbsInt32(int x){
  if( x>=0 ) return x;
  if( x==(int)0x80000000 ) return 0x7fffffff;
  return -x;
}
# 37555 "c_tests/sqlite3.c"
static LogEst sqlite3LogEstAdd(LogEst a, LogEst b){
  static const unsigned char x[] = {
     10, 10,
      9, 9,
      8, 8,
      7, 7, 7,
      6, 6, 6,
      5, 5, 5,
      4, 4, 4, 4,
      3, 3, 3, 3, 3, 3,
      2, 2, 2, 2, 2, 2, 2,
  };
  if( a>=b ){
    if( a>b+49 ) return a;
    if( a>b+31 ) return a+1;
    return a+x[a-b];
  }else{
    if( b>a+49 ) return b;
    if( b>a+31 ) return b+1;
    return b+x[b-a];
  }
}





static LogEst sqlite3LogEst(u64 x){
  static LogEst a[] = { 0, 2, 3, 5, 6, 7, 8, 9 };
  LogEst y = 40;
  if( x<8 ){
    if( x<2 ) return 0;
    while( x<8 ){ y -= 10; x <<= 1; }
  }else{





    while( x>255 ){ y += 40; x >>= 4; }
    while( x>15 ){ y += 10; x >>= 1; }

  }
  return a[x&7] + y - 10;
}





static LogEst sqlite3LogEstFromDouble(double x){
  u64 a;
  LogEst e;
  ((void) (0));
  if( x<=1 ) return 0;
  if( x<=2000000000 ) return sqlite3LogEst((u64)x);
  memcpy(&a, &x, 8);
  e = (a>>52) - 1022;
  return e*10;
}




static u64 sqlite3LogEstToInt(LogEst x){
  u64 n;
  n = x%10;
  x /= 10;
  if( n>=5 ) n -= 2;
  else if( n>=1 ) n -= 1;
  if( x>60 ) return (u64)(0xffffffff|(((i64)0x7fffffff)<<32));
  return x>=3 ? (n+8)<<(x-3) : (n+8)>>(3-x);
}
# 37665 "c_tests/sqlite3.c"
static VList *sqlite3VListAdd(
  sqlite3 *db,
  VList *pIn,
  const char *zName,
  int nName,
  int iVal
){
  int nInt;
  char *z;
  int i;

  nInt = nName/4 + 3;
  ((void) (0));
  if( pIn==0 || pIn[1]+nInt > pIn[0] ){

    sqlite3_int64 nAlloc = (pIn ? 2*(sqlite3_int64)pIn[0] : 10) + nInt;
    VList *pOut = sqlite3DbRealloc(db, pIn, nAlloc*sizeof(int));
    if( pOut==0 ) return pIn;
    if( pIn==0 ) pOut[1] = 2;
    pIn = pOut;
    pIn[0] = nAlloc;
  }
  i = pIn[1];
  pIn[i] = iVal;
  pIn[i+1] = nInt;
  z = (char*)&pIn[i+2];
  pIn[1] = i+nInt;
  ((void) (0));
  memcpy(z, zName, nName);
  z[nName] = 0;
  return pIn;
}






static const char *sqlite3VListNumToName(VList *pIn, int iVal){
  int i, mx;
  if( pIn==0 ) return 0;
  mx = pIn[1];
  i = 2;
  do{
    if( pIn[i]==iVal ) return (char*)&pIn[i+2];
    i += pIn[i+1];
  }while( i<mx );
  return 0;
}





static int sqlite3VListNameToNum(VList *pIn, const char *zName, int nName){
  int i, mx;
  if( pIn==0 ) return 0;
  mx = pIn[1];
  i = 2;
  do{
    const char *z = (const char*)&pIn[i+2];
    if( strncmp(z,zName,nName)==0 && z[nName]==0 ) return pIn[i];
    i += pIn[i+1];
  }while( i<mx );
  return 0;
}
# 37756 "c_tests/sqlite3.c"
static void sqlite3HashInit(Hash *pNew){
  ((void) (0));
  pNew->first = 0;
  pNew->count = 0;
  pNew->htsize = 0;
  pNew->ht = 0;
}





static void sqlite3HashClear(Hash *pH){
  HashElem *elem;

  ((void) (0));
  elem = pH->first;
  pH->first = 0;
  sqlite3_free(pH->ht);
  pH->ht = 0;
  pH->htsize = 0;
  while( elem ){
    HashElem *next_elem = elem->next;
    sqlite3_free(elem);
    elem = next_elem;
  }
  pH->count = 0;
}




static unsigned int strHash(const char *z){
  unsigned int h = 0;
  while( z[0] ){
# 37801 "c_tests/sqlite3.c"
    h += 0xdf & (unsigned char)*(z++);

    h *= 0x9e3779b1;
  }
  return h;
}





static void insertElement(
  Hash *pH,
  struct _ht *pEntry,
  HashElem *pNew
){
  HashElem *pHead;
  if( pEntry ){
    pHead = pEntry->count ? pEntry->chain : 0;
    pEntry->count++;
    pEntry->chain = pNew;
  }else{
    pHead = 0;
  }
  if( pHead ){
    pNew->next = pHead;
    pNew->prev = pHead->prev;
    if( pHead->prev ){ pHead->prev->next = pNew; }
    else { pH->first = pNew; }
    pHead->prev = pNew;
  }else{
    pNew->next = pH->first;
    if( pH->first ){ pH->first->prev = pNew; }
    pNew->prev = 0;
    pH->first = pNew;
  }
}
# 37846 "c_tests/sqlite3.c"
static int rehash(Hash *pH, unsigned int new_size){
  struct _ht *new_ht;
  HashElem *elem, *next_elem;


  if( new_size*sizeof(struct _ht)>1024 ){
    new_size = 1024/sizeof(struct _ht);
  }
  if( new_size==pH->htsize ) return 0;
# 37865 "c_tests/sqlite3.c"
  sqlite3BeginBenignMalloc();
  new_ht = (struct _ht *)sqlite3Malloc( new_size*sizeof(struct _ht) );
  sqlite3EndBenignMalloc();

  if( new_ht==0 ) return 0;
  sqlite3_free(pH->ht);
  pH->ht = new_ht;
  pH->htsize = new_size = sqlite3MallocSize(new_ht)/sizeof(struct _ht);
  memset(new_ht, 0, new_size*sizeof(struct _ht));
  for(elem=pH->first, pH->first=0; elem; elem = next_elem){
    next_elem = elem->next;
    insertElement(pH, &new_ht[elem->h % new_size], elem);
  }
  return 1;
}






static HashElem *findElementWithHash(
  const Hash *pH,
  const char *pKey,
  unsigned int *pHash
){
  HashElem *elem;
  unsigned int count;
  unsigned int h;
  static HashElem nullElement = { 0, 0, 0, 0, 0 };

  h = strHash(pKey);
  if( pH->ht ){
    struct _ht *pEntry;
    pEntry = &pH->ht[h % pH->htsize];
    elem = pEntry->chain;
    count = pEntry->count;
  }else{
    elem = pH->first;
    count = pH->count;
  }
  if( pHash ) *pHash = h;
  while( count ){
    ((void) (0));
    if( h==elem->h && sqlite3StrICmp(elem->pKey,pKey)==0 ){
      return elem;
    }
    elem = elem->next;
    count--;
  }
  return &nullElement;
}




static void removeElement(
  Hash *pH,
  HashElem *elem
){
  struct _ht *pEntry;
  if( elem->prev ){
    elem->prev->next = elem->next;
  }else{
    pH->first = elem->next;
  }
  if( elem->next ){
    elem->next->prev = elem->prev;
  }
  if( pH->ht ){
    pEntry = &pH->ht[elem->h % pH->htsize];
    if( pEntry->chain==elem ){
      pEntry->chain = elem->next;
    }
    ((void) (0));
    pEntry->count--;
  }
  sqlite3_free( elem );
  pH->count--;
  if( pH->count==0 ){
    ((void) (0));
    ((void) (0));
    sqlite3HashClear(pH);
  }
}





static void *sqlite3HashFind(const Hash *pH, const char *pKey){
  ((void) (0));
  ((void) (0));
  return findElementWithHash(pH, pKey, 0)->data;
}
# 37975 "c_tests/sqlite3.c"
static void *sqlite3HashInsert(Hash *pH, const char *pKey, void *data){
  unsigned int h;
  HashElem *elem;
  HashElem *new_elem;

  ((void) (0));
  ((void) (0));
  elem = findElementWithHash(pH,pKey,&h);
  if( elem->data ){
    void *old_data = elem->data;
    if( data==0 ){
      removeElement(pH,elem);
    }else{
      elem->data = data;
      elem->pKey = pKey;
    }
    return old_data;
  }
  if( data==0 ) return 0;
  new_elem = (HashElem*)sqlite3Malloc( sizeof(HashElem) );
  if( new_elem==0 ) return data;
  new_elem->pKey = pKey;
  new_elem->h = h;
  new_elem->data = data;
  pH->count++;
  if( pH->count>=5 && pH->count > 2*pH->htsize ){
    rehash(pH, pH->count*3);
  }
  insertElement(pH, pH->ht ? &pH->ht[new_elem->h % pH->htsize] : 0, new_elem);
  return 0;
}
# 38020 "c_tests/sqlite3.c"
static const char *sqlite3OpcodeName(int i){
 static const char *const azName[] = {
              "Savepoint" ,
              "AutoCommit" ,
              "Transaction" ,
              "Checkpoint" ,
              "JournalMode" ,
              "Vacuum" ,
              "VFilter" ,
              "VUpdate" ,
              "Init" ,
              "Goto" ,
              "Gosub" ,
              "InitCoroutine" ,
              "Yield" ,
              "MustBeInt" ,
              "Jump" ,
              "Once" ,
              "If" ,
              "IfNot" ,
              "IsType" ,
              "Not" ,
              "IfNullRow" ,
              "SeekLT" ,
              "SeekLE" ,
              "SeekGE" ,
              "SeekGT" ,
              "IfNotOpen" ,
              "IfNoHope" ,
              "NoConflict" ,
              "NotFound" ,
              "Found" ,
              "SeekRowid" ,
              "NotExists" ,
              "Last" ,
              "IfSizeBetween" ,
              "SorterSort" ,
              "Sort" ,
              "Rewind" ,
              "IfEmpty" ,
              "SorterNext" ,
              "Prev" ,
              "Next" ,
              "IdxLE" ,
              "IdxGT" ,
              "Or" ,
              "And" ,
              "IdxLT" ,
              "IdxGE" ,
              "RowSetRead" ,
              "RowSetTest" ,
              "Program" ,
              "FkIfZero" ,
              "IsNull" ,
              "NotNull" ,
              "Ne" ,
              "Eq" ,
              "Gt" ,
              "Le" ,
              "Lt" ,
              "Ge" ,
              "ElseEq" ,
              "IfPos" ,
              "IfNotZero" ,
              "DecrJumpZero" ,
              "IncrVacuum" ,
              "VNext" ,
              "Filter" ,
              "PureFunc" ,
              "Function" ,
              "Return" ,
              "EndCoroutine" ,
              "HaltIfNull" ,
              "Halt" ,
              "Integer" ,
              "Int64" ,
              "String" ,
              "BeginSubrtn" ,
              "Null" ,
              "SoftNull" ,
              "Blob" ,
              "Variable" ,
              "Move" ,
              "Copy" ,
              "SCopy" ,
              "IntCopy" ,
              "FkCheck" ,
              "ResultRow" ,
              "CollSeq" ,
              "AddImm" ,
              "RealAffinity" ,
              "Cast" ,
              "Permutation" ,
              "Compare" ,
              "IsTrue" ,
              "ZeroOrNull" ,
              "Offset" ,
              "Column" ,
              "TypeCheck" ,
              "Affinity" ,
              "MakeRecord" ,
              "Count" ,
              "ReadCookie" ,
              "SetCookie" ,
              "ReopenIdx" ,
              "BitAnd" ,
              "BitOr" ,
              "ShiftLeft" ,
              "ShiftRight" ,
              "Add" ,
              "Subtract" ,
              "Multiply" ,
              "Divide" ,
              "Remainder" ,
              "Concat" ,
              "OpenRead" ,
              "OpenWrite" ,
              "BitNot" ,
              "OpenDup" ,
              "OpenAutoindex" ,
              "String8" ,
              "OpenEphemeral" ,
              "SorterOpen" ,
              "SequenceTest" ,
              "OpenPseudo" ,
              "Close" ,
              "ColumnsUsed" ,
              "SeekScan" ,
              "SeekHit" ,
              "Sequence" ,
              "NewRowid" ,
              "Insert" ,
              "RowCell" ,
              "Delete" ,
              "ResetCount" ,
              "SorterCompare" ,
              "SorterData" ,
              "RowData" ,
              "Rowid" ,
              "NullRow" ,
              "SeekEnd" ,
              "IdxInsert" ,
              "SorterInsert" ,
              "IdxDelete" ,
              "DeferredSeek" ,
              "IdxRowid" ,
              "FinishSeek" ,
              "Destroy" ,
              "Clear" ,
              "ResetSorter" ,
              "CreateBtree" ,
              "SqlExec" ,
              "ParseSchema" ,
              "LoadAnalysis" ,
              "DropTable" ,
              "DropIndex" ,
              "Real" ,
              "DropTrigger" ,
              "IntegrityCk" ,
              "RowSetAdd" ,
              "Param" ,
              "FkCounter" ,
              "MemMax" ,
              "OffsetLimit" ,
              "AggInverse" ,
              "AggStep" ,
              "AggStep1" ,
              "AggValue" ,
              "AggFinal" ,
              "Expire" ,
              "CursorLock" ,
              "CursorUnlock" ,
              "TableLock" ,
              "VBegin" ,
              "VCreate" ,
              "VDestroy" ,
              "VOpen" ,
              "VCheck" ,
              "VInitIn" ,
              "VColumn" ,
              "VRename" ,
              "Pagecount" ,
              "MaxPgcnt" ,
              "ClrSubtype" ,
              "GetSubtype" ,
              "SetSubtype" ,
              "FilterAdd" ,
              "Trace" ,
              "CursorHint" ,
              "ReleaseReg" ,
              "Noop" ,
              "Explain" ,
              "Abortable" ,
  };
  return azName[i];
}
# 39292 "c_tests/sqlite3.c"
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 101 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
struct stat
  {



    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 74 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 89 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 99 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
  };



struct stat64
  {



    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 151 "/usr/include/x86_64-linux-gnu/bits/struct_stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];




  };
# 26 "/usr/include/x86_64-linux-gnu/bits/stat.h" 2 3 4
# 102 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 227 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file, struct stat *__restrict __buf) __asm__ ("" "stat64") __attribute__ ((__nothrow__ ))

     __attribute__ ((__nonnull__ (1, 2)));
extern int fstat (int __fd, struct stat *__buf) __asm__ ("" "fstat64") __attribute__ ((__nothrow__ ))
     __attribute__ ((__nonnull__ (2)));
# 240 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 279 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file, struct stat *__restrict __buf, int __flag) __asm__ ("" "fstatat64") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));
# 291 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));
# 327 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file, struct stat *__restrict __buf) __asm__ ("" "lstat64") __attribute__ ((__nothrow__ ))


     __attribute__ ((__nonnull__ (1, 2)));







extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 352 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ ));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ ));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ ));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));






extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ ));
# 452 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ ));
# 465 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {


 __u32 stx_mask;


 __u32 stx_blksize;


 __u64 stx_attributes;



 __u32 stx_nlink;


 __u32 stx_uid;


 __u32 stx_gid;


 __u16 stx_mode;
 __u16 __spare0[1];



 __u64 stx_ino;


 __u64 stx_size;


 __u64 stx_blocks;


 __u64 stx_attributes_mask;



 struct statx_timestamp stx_atime;


 struct statx_timestamp stx_btime;


 struct statx_timestamp stx_ctime;


 struct statx_timestamp stx_mtime;



 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;


 __u32 stx_dev_major;
 __u32 stx_dev_minor;


 __u64 stx_mnt_id;


 __u32 stx_dio_mem_align;


 __u32 stx_dio_offset_align;



 __u64 stx_subvol;


 __u32 stx_atomic_write_unit_min;


 __u32 stx_atomic_write_unit_max;



 __u32 stx_atomic_write_segments_max;


 __u32 stx_dio_read_offset_align;


 __u64 __spare3[9];


};
# 32 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/statx-generic.h" 3 4
int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (5)));
# 40 "/usr/include/x86_64-linux-gnu/bits/statx.h" 2 3 4
# 466 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 39293 "c_tests/sqlite3.c" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 35 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;




    __off64_t l_start;
    __off64_t l_len;

    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 267 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 357 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 358 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 389 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ ));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);
# 431 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate (int __fd, int __mode, __off64_t __offset, __off64_t __len) __asm__ ("" "fallocate64");







extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ ));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);
# 62 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 79 "/usr/include/fcntl.h" 2 3 4
# 180 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...) __asm__ ("" "fcntl64");





extern int fcntl64 (int __fd, int __cmd, ...);
# 212 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __asm__ ("" "open64")
     __attribute__ ((__nonnull__ (1)));





extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 237 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...) __asm__ ("" "openat64") __attribute__ ((__nonnull__ (2)));






extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 258 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __asm__ ("" "creat64") __attribute__ ((__nonnull__ (1)));






extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 287 "/usr/include/fcntl.h" 3 4
extern int lockf (int __fd, int __cmd, __off64_t __len) __asm__ ("" "lockf64");





extern int lockf64 (int __fd, int __cmd, off64_t __len);
# 305 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, __off64_t __offset, __off64_t __len, int __advise) __asm__ ("" "posix_fadvise64") __attribute__ ((__nothrow__ ));







extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ ));
# 326 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, __off64_t __offset, __off64_t __len) __asm__ ("" "posix_fallocate64");







extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 39294 "c_tests/sqlite3.c" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctls.h" 1 3 4




# 1 "/usr/include/linux/ioctl.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/ioctl.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctl.h" 1 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/ioctl.h" 2 3 4
# 6 "/usr/include/linux/ioctl.h" 2 3 4
# 6 "/usr/include/asm-generic/ioctls.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 2 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 2 3 4


struct winsize
  {
    unsigned short int ws_row;
    unsigned short int ws_col;
    unsigned short int ws_xpixel;
    unsigned short int ws_ypixel;
  };


struct termio
  {
    unsigned short int c_iflag;
    unsigned short int c_oflag;
    unsigned short int c_cflag;
    unsigned short int c_lflag;
    unsigned char c_line;
    unsigned char c_cc[8];
};
# 30 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/sys/ttydefaults.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4





extern int ioctl (int __fd, unsigned long int __request, ...) __attribute__ ((__nothrow__ ));
# 39295 "c_tests/sqlite3.c" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 108 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_null.h" 1 3 4
# 109 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int execveat (int __fd, const char *__path, char *const __argv[],
                     char *const __envp[], int __flags)
    __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;
# 342 "/usr/include/unistd.h" 3 4
extern __off64_t lseek (int __fd, __off64_t __offset, int __whence) __asm__ ("" "lseek64") __attribute__ ((__nothrow__ ));







extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ ));






extern int close (int __fd);




extern void closefrom (int __lowfd) __attribute__ ((__nothrow__ ));







extern ssize_t read (int __fd, void *__buf, size_t __nbytes)
                                                  ;





extern ssize_t write (int __fd, const void *__buf, size_t __n)
                                         ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64")


                                                  ;
extern ssize_t pwrite (int __fd, const void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pwrite64")


                                         ;
# 422 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset)
                                                  ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset)
                                         ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ )) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ )) ;
# 452 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ ));
# 464 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ ));






extern int usleep (__useconds_t __useconds);
# 489 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ )) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ )) ;
# 531 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ )) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ ));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__))
                                       ;




extern int dup (int __fd) __attribute__ ((__nothrow__ )) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ ));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ ));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ )) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT,


    _SC_MINSIGSTKSZ,


    _SC_SIGSTKSZ

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 631 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ ));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ ));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ ))
                                                  ;




extern __pid_t getpid (void) __attribute__ ((__nothrow__ ));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ ));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ ));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ ));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ ));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ ));
# 682 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ ));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ ));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ ));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ ));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ ));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ ));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ ));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ ))
                                                  ;


extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ ));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ )) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ )) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ )) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ )) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ )) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ )) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ ));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ ));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ )) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ )) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ ));






extern __pid_t _Fork (void) __attribute__ ((__nothrow__ ));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ ));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)))
                                                   ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ ));




extern int ttyslot (void) __attribute__ ((__nothrow__ ));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)))
                                                   ;





extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)))
                                                   ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ ));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ ));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)))
                                                  ;




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4
# 904 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)))
                                                  ;






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ )) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)))
                                                   ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;




extern int vhangup (void) __attribute__ ((__nothrow__ ));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ ));



extern char *getusershell (void) __attribute__ ((__nothrow__ ));
extern void endusershell (void) __attribute__ ((__nothrow__ ));
extern void setusershell (void) __attribute__ ((__nothrow__ ));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ )) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ ));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ ));





extern int getpagesize (void) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ ));
# 1030 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off64_t __length) __asm__ ("" "truncate64") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;







extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 1052 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off64_t __length) __asm__ ("" "ftruncate64") __attribute__ ((__nothrow__ )) ;






extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ )) ;
# 1070 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ )) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ ));
# 1091 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ ));
# 1142 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1162 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)))

                                          ;
# 1201 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length)
                                          ;
# 1211 "/usr/include/unistd.h" 3 4
extern int close_range (unsigned int __fd, unsigned int __max_fd,
   int __flags) __attribute__ ((__nothrow__ ));
# 1221 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ ));



# 1 "/usr/include/linux/close_range.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 2 3 4
# 1222 "/usr/include/unistd.h" 2 3 4
# 39296 "c_tests/sqlite3.c" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 52 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };
# 67 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    void *__restrict __tz) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 86 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ ));





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ ));
# 114 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;







extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ ));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ ));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 189 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ ));
# 214 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) __attribute__ ((__nothrow__ ));
# 39298 "c_tests/sqlite3.c" 2
# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4








extern int *__errno_location (void) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4
# 39299 "c_tests/sqlite3.c" 2


# 1 "/usr/include/x86_64-linux-gnu/sys/mman.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman-map-flags-generic.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/mman.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 1 3 4
# 136 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman-shared.h" 1 3 4
# 55 "/usr/include/x86_64-linux-gnu/bits/mman-shared.h" 3 4
int memfd_create (const char *__name, unsigned int __flags) __attribute__ ((__nothrow__ ));



int mlock2 (const void *__addr, size_t __length, unsigned int __flags) __attribute__ ((__nothrow__ ))
                          ;





int pkey_alloc (unsigned int __flags, unsigned int __access_restrictions) __attribute__ ((__nothrow__ ));



int pkey_set (int __key, unsigned int __access_restrictions) __attribute__ ((__nothrow__ ));



int pkey_get (int __key) __attribute__ ((__nothrow__ ));



int pkey_free (int __key) __attribute__ ((__nothrow__ ));



int pkey_mprotect (void *__addr, size_t __len, int __prot, int __pkey) __attribute__ ((__nothrow__ ));
# 137 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 2 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/mman.h" 2 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4
# 61 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void * mmap (void *__addr, size_t __len, int __prot, int __flags, int __fd, __off64_t __offset) __asm__ ("" "mmap64") __attribute__ ((__nothrow__ ));
# 70 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) __attribute__ ((__nothrow__ ));




extern int munmap (void *__addr, size_t __len) __attribute__ ((__nothrow__ ));




extern int mprotect (void *__addr, size_t __len, int __prot) __attribute__ ((__nothrow__ ));







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ ));



extern int posix_madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ ));




extern int mlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ ))
                          ;


extern int munlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ ))
                          ;




extern int mlockall (int __flags) __attribute__ ((__nothrow__ ));



extern int munlockall (void) __attribute__ ((__nothrow__ ));







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     __attribute__ ((__nothrow__ ));
# 135 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) __attribute__ ((__nothrow__ ));



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) __attribute__ ((__nothrow__ ));




extern int shm_open (const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (const char *__name);


# 1 "/usr/include/x86_64-linux-gnu/bits/mman_ext.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mman_ext.h" 3 4
struct iovec;
extern __ssize_t process_madvise (int __pid_fd, const struct iovec *__iov,
      size_t __count, int __advice,
      unsigned __flags)
  __attribute__ ((__nothrow__ ));

extern int process_mrelease (int pidfd, unsigned int flags) __attribute__ ((__nothrow__ ));
# 153 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4
# 39302 "c_tests/sqlite3.c" 2
# 39436 "c_tests/sqlite3.c"
typedef struct unixShm unixShm;
typedef struct unixShmNode unixShmNode;
typedef struct unixInodeInfo unixInodeInfo;
typedef struct UnixUnusedFd UnixUnusedFd;







struct UnixUnusedFd {
  int fd;
  int flags;
  UnixUnusedFd *pNext;
};





typedef struct unixFile unixFile;
struct unixFile {
  sqlite3_io_methods const *pMethod;
  sqlite3_vfs *pVfs;
  unixInodeInfo *pInode;
  int h;
  unsigned char eFileLock;
  unsigned short int ctrlFlags;
  int lastErrno;
  void *lockingContext;
  UnixUnusedFd *pPreallocatedUnused;
  const char *zPath;
  unixShm *pShm;
  int szChunk;

  int nFetchOut;
  sqlite3_int64 mmapSize;
  sqlite3_int64 mmapSizeActual;
  sqlite3_int64 mmapSizeMax;
  void *pMapRegion;

  int sectorSize;
  int deviceCharacteristics;
# 39513 "c_tests/sqlite3.c"
};





static pid_t randomnessPid = 0;
# 39610 "c_tests/sqlite3.c"
static int posixOpen(const char *zFile, int flags, int mode){
  return open(zFile, flags, mode);
}


static int openDirectory(const char*, int*);
static int unixGetpagesize(void);







static struct unix_syscall {
  const char *zName;
  sqlite3_syscall_ptr pCurrent;
  sqlite3_syscall_ptr pDefault;
} aSyscall[] = {
  { "open", (sqlite3_syscall_ptr)posixOpen, 0 },


  { "close", (sqlite3_syscall_ptr)close, 0 },


  { "access", (sqlite3_syscall_ptr)access, 0 },


  { "getcwd", (sqlite3_syscall_ptr)getcwd, 0 },


  { "stat", (sqlite3_syscall_ptr)stat, 0 },
# 39654 "c_tests/sqlite3.c"
  { "fstat", (sqlite3_syscall_ptr)fstat, 0 },



  { "ftruncate", (sqlite3_syscall_ptr)ftruncate, 0 },


  { "fcntl", (sqlite3_syscall_ptr)fcntl, 0 },


  { "read", (sqlite3_syscall_ptr)read, 0 },



  { "pread", (sqlite3_syscall_ptr)pread, 0 },
# 39677 "c_tests/sqlite3.c"
  { "pread64", (sqlite3_syscall_ptr)0, 0 },



  { "write", (sqlite3_syscall_ptr)write, 0 },



  { "pwrite", (sqlite3_syscall_ptr)pwrite, 0 },
# 39695 "c_tests/sqlite3.c"
  { "pwrite64", (sqlite3_syscall_ptr)0, 0 },





  { "fchmod", (sqlite3_syscall_ptr)fchmod, 0 },
# 39711 "c_tests/sqlite3.c"
  { "fallocate", (sqlite3_syscall_ptr)0, 0 },



  { "unlink", (sqlite3_syscall_ptr)unlink, 0 },


  { "openDirectory", (sqlite3_syscall_ptr)openDirectory, 0 },


  { "mkdir", (sqlite3_syscall_ptr)mkdir, 0 },


  { "rmdir", (sqlite3_syscall_ptr)rmdir, 0 },



  { "fchown", (sqlite3_syscall_ptr)fchown, 0 },






  { "geteuid", (sqlite3_syscall_ptr)geteuid, 0 },







  { "mmap", (sqlite3_syscall_ptr)mmap, 0 },







  { "munmap", (sqlite3_syscall_ptr)munmap, 0 },






  { "mremap", (sqlite3_syscall_ptr)mremap, 0 },






  { "getpagesize", (sqlite3_syscall_ptr)unixGetpagesize, 0 },






  { "readlink", (sqlite3_syscall_ptr)readlink, 0 },






  { "lstat", (sqlite3_syscall_ptr)lstat, 0 },
# 39794 "c_tests/sqlite3.c"
  { "ioctl", (sqlite3_syscall_ptr)0, 0 },


};
# 39918 "c_tests/sqlite3.c"
static int robustFchown(int fd, uid_t uid, gid_t gid){

  return ((uid_t(*)(void))aSyscall[21].pCurrent)() ? 0 : ((int(*)(int,uid_t,gid_t))aSyscall[20].pCurrent)(fd,uid,gid);



}







static int unixSetSystemCall(
  sqlite3_vfs *pNotUsed,
  const char *zName,
  sqlite3_syscall_ptr pNewFunc
){
  unsigned int i;
  int rc = 12;

  (void)(pNotUsed);
  if( zName==0 ){



    rc = 0;
    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      if( aSyscall[i].pDefault ){
        aSyscall[i].pCurrent = aSyscall[i].pDefault;
      }
    }
  }else{



    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      if( strcmp(zName, aSyscall[i].zName)==0 ){
        if( aSyscall[i].pDefault==0 ){
          aSyscall[i].pDefault = aSyscall[i].pCurrent;
        }
        rc = 0;
        if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;
        aSyscall[i].pCurrent = pNewFunc;
        break;
      }
    }
  }
  return rc;
}






static sqlite3_syscall_ptr unixGetSystemCall(
  sqlite3_vfs *pNotUsed,
  const char *zName
){
  unsigned int i;

  (void)(pNotUsed);
  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
    if( strcmp(zName, aSyscall[i].zName)==0 ) return aSyscall[i].pCurrent;
  }
  return 0;
}







static const char *unixNextSystemCall(sqlite3_vfs *p, const char *zName){
  int i = -1;

  (void)(p);
  if( zName ){
    for(i=0; i<((int)(sizeof(aSyscall)/sizeof(aSyscall[0])))-1; i++){
      if( strcmp(zName, aSyscall[i].zName)==0 ) break;
    }
  }
  for(i++; i<((int)(sizeof(aSyscall)/sizeof(aSyscall[0]))); i++){
    if( aSyscall[i].pCurrent!=0 ) return aSyscall[i].zName;
  }
  return 0;
}
# 40035 "c_tests/sqlite3.c"
static int robust_open(const char *z, int f, mode_t m){
  int fd;
  mode_t m2 = m ? m : 0644;
  while(1){

    fd = ((int(*)(const char*,int,int))aSyscall[0].pCurrent)(z,f|02000000,m2);



    if( fd<0 ){
      if( (*__errno_location ())==4 ) continue;
      break;
    }
    if( fd>=3 ) break;
    if( (f & (0200|0100))==(0200|0100) ){
      (void)((int(*)(const char*))aSyscall[16].pCurrent)(z);
    }
    ((int(*)(int))aSyscall[1].pCurrent)(fd);
    sqlite3_log(28,
                "attempt to open \"%s\" as file descriptor %d", z, fd);
    fd = -1;
    if( ((int(*)(const char*,int,int))aSyscall[0].pCurrent)("/dev/null", 00, m)<0 ) break;
  }
  if( fd>=0 ){
    if( m!=0 ){
      struct stat statbuf;
      if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(fd, &statbuf)==0
       && statbuf.st_size==0
       && (statbuf.st_mode&0777)!=m
      ){
        ((int(*)(int,mode_t))aSyscall[14].pCurrent)(fd, m);
      }
    }



  }
  return fd;
}
# 40099 "c_tests/sqlite3.c"
static sqlite3_mutex *unixBigLock = 0;
static void unixEnterMutex(void){
  ((void) (0));
  sqlite3_mutex_enter(unixBigLock);
}
static void unixLeaveMutex(void){
  ((void) (0));
  sqlite3_mutex_leave(unixBigLock);
}
# 40200 "c_tests/sqlite3.c"
static int robust_ftruncate(int h, sqlite3_int64 sz){
  int rc;
# 40211 "c_tests/sqlite3.c"
  do{ rc = ((int(*)(int,off_t))aSyscall[6].pCurrent)(h,sz); }while( rc<0 && (*__errno_location ())==4 );
  return rc;
}
# 40225 "c_tests/sqlite3.c"
static int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {
  ((void) (0));



  switch (posixError) {
  case 13:
  case 11:
  case 110:
  case 16:
  case 4:
  case 37:


    return 5;

  case 1:
    return 3;

  default:
    return sqliteIOErr;
  }
}
# 40267 "c_tests/sqlite3.c"
struct vxworksFileId {
  struct vxworksFileId *pNext;
  int nRef;
  int nName;
  char *zCanonicalName;
};
# 40483 "c_tests/sqlite3.c"
struct unixFileId {
  dev_t dev;
# 40495 "c_tests/sqlite3.c"
  u64 ino;

};
# 40524 "c_tests/sqlite3.c"
struct unixInodeInfo {
  struct unixFileId fileId;
  sqlite3_mutex *pLockMutex;
  int nShared;
  int nLock;
  unsigned char eFileLock;
  unsigned char bProcessLock;
  UnixUnusedFd *pUnused;
  int nRef;
  unixShmNode *pShmNode;
  unixInodeInfo *pNext;
  unixInodeInfo *pPrev;







};






static unixInodeInfo *inodeList = 0;
# 40585 "c_tests/sqlite3.c"
static int unixLogErrorAtLine(
  int errcode,
  const char *zFunc,
  const char *zPath,
  int iLine
){
  char *zErr;
  int iErrno = (*__errno_location ());
# 40626 "c_tests/sqlite3.c"
  zErr = "";





  if( zPath==0 ) zPath = "";
  sqlite3_log(errcode,
      "os_unix.c:%d: (%d) %s(%s) - %s",
      iLine, iErrno, zFunc, zPath, zErr
  );

  return errcode;
}
# 40654 "c_tests/sqlite3.c"
static void robust_close(unixFile *pFile, int h, int lineno){
  if( ((int(*)(int))aSyscall[1].pCurrent)(h) ){
    unixLogErrorAtLine((10 | (16<<8)), "close",
                       pFile ? pFile->zPath : 0, lineno);
  }
}





static void storeLastErrno(unixFile *pFile, int error){
  pFile->lastErrno = error;
}




static void closePendingFds(unixFile *pFile){
  unixInodeInfo *pInode = pFile->pInode;
  UnixUnusedFd *p;
  UnixUnusedFd *pNext;
  ((void) (0));
  for(p=pInode->pUnused; p; p=pNext){
    pNext = p->pNext;
    robust_close(pFile, p->fd, 40679);
    sqlite3_free(p);
  }
  pInode->pUnused = 0;
}







static void releaseInodeInfo(unixFile *pFile){
  unixInodeInfo *pInode = pFile->pInode;
  ((void) (0));
  ((void) (0));
  if( (pInode) ){
    pInode->nRef--;
    if( pInode->nRef==0 ){
      ((void) (0));
      sqlite3_mutex_enter(pInode->pLockMutex);
      closePendingFds(pFile);
      sqlite3_mutex_leave(pInode->pLockMutex);
      if( pInode->pPrev ){
        ((void) (0));
        pInode->pPrev->pNext = pInode->pNext;
      }else{
        ((void) (0));
        inodeList = pInode->pNext;
      }
      if( pInode->pNext ){
        ((void) (0));
        pInode->pNext->pPrev = pInode->pPrev;
      }
      sqlite3_mutex_free(pInode->pLockMutex);
      sqlite3_free(pInode);
    }
  }
}
# 40728 "c_tests/sqlite3.c"
static int findInodeInfo(
  unixFile *pFile,
  unixInodeInfo **ppInode
){
  int rc;
  int fd;
  struct unixFileId fileId;
  struct stat statbuf;
  unixInodeInfo *pInode = 0;

  ((void) (0));




  fd = pFile->h;
  rc = ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(fd, &statbuf);
  if( rc!=0 ){
    storeLastErrno(pFile, (*__errno_location ()));



    return 10;
  }
# 40782 "c_tests/sqlite3.c"
  memset(&fileId, 0, sizeof(fileId));
  fileId.dev = statbuf.st_dev;



  fileId.ino = (u64)statbuf.st_ino;

  ((void) (0));
  pInode = inodeList;
  while( pInode && memcmp(&fileId, &pInode->fileId, sizeof(fileId)) ){
    pInode = pInode->pNext;
  }
  if( pInode==0 ){
    pInode = sqlite3_malloc64( sizeof(*pInode) );
    if( pInode==0 ){
      return 7;
    }
    memset(pInode, 0, sizeof(*pInode));
    memcpy(&pInode->fileId, &fileId, sizeof(fileId));
    if( sqlite3Config.bCoreMutex ){
      pInode->pLockMutex = sqlite3_mutex_alloc(0);
      if( pInode->pLockMutex==0 ){
        sqlite3_free(pInode);
        return 7;
      }
    }
    pInode->nRef = 1;
    ((void) (0));
    pInode->pNext = inodeList;
    pInode->pPrev = 0;
    if( inodeList ) inodeList->pPrev = pInode;
    inodeList = pInode;
  }else{
    pInode->nRef++;
  }
  *ppInode = pInode;
  return 0;
}




static int fileHasMoved(unixFile *pFile){



  struct stat buf;
  return pFile->pInode!=0 &&
      (((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(pFile->zPath, &buf)!=0
         || (u64)buf.st_ino!=pFile->pInode->fileId.ino);

}
# 40845 "c_tests/sqlite3.c"
static void verifyDbFile(unixFile *pFile){
  struct stat buf;
  int rc;


  if( pFile->ctrlFlags & 0x80 ) return;

  rc = ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pFile->h, &buf);
  if( rc!=0 ){
    sqlite3_log(28, "cannot fstat db file %s", pFile->zPath);
    return;
  }
  if( buf.st_nlink==0 ){
    sqlite3_log(28, "file unlinked while open: %s", pFile->zPath);
    return;
  }
  if( buf.st_nlink>1 ){
    sqlite3_log(28, "multiple links to file: %s", pFile->zPath);
    return;
  }
  if( fileHasMoved(pFile) ){
    sqlite3_log(28, "file renamed while open: %s", pFile->zPath);
    return;
  }
}
# 40878 "c_tests/sqlite3.c"
static int unixCheckReservedLock(sqlite3_file *id, int *pResOut){
  int rc = 0;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;

                                                           ;

  ((void) (0));
  ((void) (0));
  sqlite3_mutex_enter(pFile->pInode->pLockMutex);


  if( pFile->pInode->eFileLock>1 ){
    reserved = 1;
  }




  if( !reserved && !pFile->pInode->bProcessLock ){
    struct flock lock;
    lock.l_whence = 0;
    lock.l_start = (sqlite3PendingByte+1);
    lock.l_len = 1;
    lock.l_type = 1;
    if( ((int(*)(int,int,...))aSyscall[7].pCurrent)(pFile->h, 5, &lock) ){
      rc = (10 | (14<<8));
      storeLastErrno(pFile, (*__errno_location ()));
    } else if( lock.l_type!=2 ){
      reserved = 1;
    }
  }


  sqlite3_mutex_leave(pFile->pInode->pLockMutex);
                                                                     ;

  *pResOut = reserved;
  return rc;
}


static int unixSleep(sqlite3_vfs*,int);
# 41003 "c_tests/sqlite3.c"
static int unixFileLock(unixFile *pFile, struct flock *pLock){
  int rc;
  unixInodeInfo *pInode = pFile->pInode;
  ((void) (0));
  ((void) (0));
  if( (pFile->ctrlFlags & (0x01|0x02))==0x01 ){
    if( pInode->bProcessLock==0 ){
      struct flock lock;

      lock.l_whence = 0;
      lock.l_start = (sqlite3PendingByte+2);
      lock.l_len = 510;
      lock.l_type = 1;
      rc = ((int(*)(int,int,...))aSyscall[7].pCurrent)(pFile->h,6,&lock);
      if( rc<0 ) return rc;
      pInode->bProcessLock = 1;
      pInode->nLock++;
    }else{
      rc = 0;
    }
  }else{







    rc = ((int(*)(int,int,...))aSyscall[7].pCurrent)(pFile->h,6,pLock);
  }
  return rc;
}



static int unixIsSharingShmNode(unixFile*);
# 41067 "c_tests/sqlite3.c"
static int unixLock(sqlite3_file *id, int eFileLock){
# 41108 "c_tests/sqlite3.c"
  int rc = 0;
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode;
  struct flock lock;
  int tErrno = 0;

  ((void) (0));



                   ;





  if( pFile->eFileLock>=eFileLock ){

                                   ;
    return 0;
  }






  ((void) (0));
  ((void) (0));
  ((void) (0));



  pInode = pFile->pInode;
  sqlite3_mutex_enter(pInode->pLockMutex);




  if( (pFile->eFileLock!=pInode->eFileLock &&
          (pInode->eFileLock>=3 || eFileLock>1))
  ){
    rc = 5;
    goto end_lock;
  }





  if( eFileLock==1 &&
      (pInode->eFileLock==1 || pInode->eFileLock==2) ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    pFile->eFileLock = 1;
    pInode->nShared++;
    pInode->nLock++;
    goto end_lock;
  }






  lock.l_len = 1L;
  lock.l_whence = 0;
  if( eFileLock==1
   || (eFileLock==4 && pFile->eFileLock==2)
  ){
    lock.l_type = (eFileLock==1?0:1);
    lock.l_start = sqlite3PendingByte;
    if( unixFileLock(pFile, &lock) ){
      tErrno = (*__errno_location ());
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
      if( rc!=5 ){
        storeLastErrno(pFile, tErrno);
      }
      goto end_lock;
    }else if( eFileLock==4 ){
      pFile->eFileLock = 3;
      pInode->eFileLock = 3;
    }
  }





  if( eFileLock==1 ){
    ((void) (0));
    ((void) (0));
    ((void) (0));


    lock.l_start = (sqlite3PendingByte+2);
    lock.l_len = 510;
    if( unixFileLock(pFile, &lock) ){
      tErrno = (*__errno_location ());
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
    }


    lock.l_start = sqlite3PendingByte;
    lock.l_len = 1L;
    lock.l_type = 2;
    if( unixFileLock(pFile, &lock) && rc==0 ){

      tErrno = (*__errno_location ());
      rc = (10 | (8<<8));
    }

    if( rc ){
      if( rc!=5 ){
        storeLastErrno(pFile, tErrno);
      }
      goto end_lock;
    }else{
      pFile->eFileLock = 1;
      pInode->nLock++;
      pInode->nShared = 1;
    }
  }else if( eFileLock==4 && pInode->nShared>1 ){


    rc = 5;
  }else if( unixIsSharingShmNode(pFile) ){






    rc = 5;
  }else{




    ((void) (0));
    lock.l_type = 1;

    ((void) (0));
    if( eFileLock==2 ){
      lock.l_start = (sqlite3PendingByte+1);
      lock.l_len = 1L;
    }else{
      lock.l_start = (sqlite3PendingByte+2);
      lock.l_len = 510;
    }

    if( unixFileLock(pFile, &lock) ){
      tErrno = (*__errno_location ());
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
      if( rc!=5 ){
        storeLastErrno(pFile, tErrno);
      }
    }
  }
# 41286 "c_tests/sqlite3.c"
  if( rc==0 ){
    pFile->eFileLock = eFileLock;
    pInode->eFileLock = eFileLock;
  }

end_lock:
  sqlite3_mutex_leave(pInode->pLockMutex);

                                       ;
  return rc;
}





static void setPendingFd(unixFile *pFile){
  unixInodeInfo *pInode = pFile->pInode;
  UnixUnusedFd *p = pFile->pPreallocatedUnused;
  ((void) (0));
  p->pNext = pInode->pUnused;
  pInode->pUnused = p;
  pFile->h = -1;
  pFile->pPreallocatedUnused = 0;
}
# 41325 "c_tests/sqlite3.c"
static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode;
  struct flock lock;
  int rc = 0;

  ((void) (0));


                   ;

  ((void) (0));
  if( pFile->eFileLock<=eFileLock ){
    return 0;
  }
  pInode = pFile->pInode;
  sqlite3_mutex_enter(pInode->pLockMutex);
  ((void) (0));
  if( pFile->eFileLock>1 ){
    ((void) (0));
# 41367 "c_tests/sqlite3.c"
    if( eFileLock==1 ){

      (void)handleNFSUnlock;
      ((void) (0));
# 41411 "c_tests/sqlite3.c"
      {
        lock.l_type = 0;
        lock.l_whence = 0;
        lock.l_start = (sqlite3PendingByte+2);
        lock.l_len = 510;
        if( unixFileLock(pFile, &lock) ){






          rc = (10 | (9<<8));
          storeLastErrno(pFile, (*__errno_location ()));
          goto end_unlock;
        }
      }
    }
    lock.l_type = 2;
    lock.l_whence = 0;
    lock.l_start = sqlite3PendingByte;
    lock.l_len = 2L; ((void) (0));
    if( unixFileLock(pFile, &lock)==0 ){
      pInode->eFileLock = 1;
    }else{
      rc = (10 | (8<<8));
      storeLastErrno(pFile, (*__errno_location ()));
      goto end_unlock;
    }
  }
  if( eFileLock==0 ){




    pInode->nShared--;
    if( pInode->nShared==0 ){
      lock.l_type = 2;
      lock.l_whence = 0;
      lock.l_start = lock.l_len = 0L;
      if( unixFileLock(pFile, &lock)==0 ){
        pInode->eFileLock = 0;
      }else{
        rc = (10 | (8<<8));
        storeLastErrno(pFile, (*__errno_location ()));
        pInode->eFileLock = 0;
        pFile->eFileLock = 0;
      }
    }





    pInode->nLock--;
    ((void) (0));
    if( pInode->nLock==0 ) closePendingFds(pFile);
  }

end_unlock:
  sqlite3_mutex_leave(pInode->pLockMutex);
  if( rc==0 ){
    pFile->eFileLock = eFileLock;
  }
  return rc;
}
# 41485 "c_tests/sqlite3.c"
static int unixUnlock(sqlite3_file *id, int eFileLock){

  ((void) (0));

  return posixUnlock(id, eFileLock, 0);
}


static int unixMapfile(unixFile *pFd, i64 nByte);
static void unixUnmapfile(unixFile *pFd);
# 41507 "c_tests/sqlite3.c"
static int closeUnixFile(sqlite3_file *id){
  unixFile *pFile = (unixFile*)id;

  unixUnmapfile(pFile);

  if( pFile->h>=0 ){
    robust_close(pFile, pFile->h, 41513);
    pFile->h = -1;
  }
# 41532 "c_tests/sqlite3.c"
                                       ;
                 ;
  sqlite3_free(pFile->pPreallocatedUnused);
  memset(pFile, 0, sizeof(unixFile));
  return 0;
}




static int unixClose(sqlite3_file *id){
  int rc = 0;
  unixFile *pFile = (unixFile *)id;
  unixInodeInfo *pInode = pFile->pInode;

  ((void) (0));
  verifyDbFile(pFile);
  unixUnlock(id, 0);
  ((void) (0));
  unixEnterMutex();




  ((void) (0));
  sqlite3_mutex_enter(pInode->pLockMutex);
  if( pInode->nLock ){





    setPendingFd(pFile);
  }
  sqlite3_mutex_leave(pInode->pLockMutex);
  releaseInodeInfo(pFile);
  ((void) (0));
  rc = closeUnixFile(id);
  unixLeaveMutex();
  return rc;
}
# 41594 "c_tests/sqlite3.c"
static int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut){
  (void)(NotUsed);
  *pResOut = 0;
  return 0;
}
static int nolockLock(sqlite3_file *NotUsed, int NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}
static int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}




static int nolockClose(sqlite3_file *id) {
  return closeUnixFile(id);
}
# 41653 "c_tests/sqlite3.c"
static int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) {
  unixFile *pFile = (unixFile*)id;
                                                           ;

  if( pFile->eFileLock>=1 ){
    *pResOut = 0;
  }else{
    *pResOut = ((int(*)(const char*,int))aSyscall[2].pCurrent)((const char*)pFile->lockingContext, 0)==0;
  }
                                                                       ;
  return 0;
}
# 41693 "c_tests/sqlite3.c"
static int dotlockLock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  char *zLockFile = (char *)pFile->lockingContext;
  int rc = 0;





  if( pFile->eFileLock > 0 ){
    pFile->eFileLock = eFileLock;




    utimes(zLockFile, ((void*)0));

    return 0;
  }


  rc = ((int(*)(const char*,mode_t))aSyscall[18].pCurrent)(zLockFile, 0777);
  if( rc<0 ){

    int tErrno = (*__errno_location ());
    if( 17 == tErrno ){
      rc = 5;
    } else {
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
      if( rc!=5 ){
        storeLastErrno(pFile, tErrno);
      }
    }
    return rc;
  }


  pFile->eFileLock = eFileLock;
  return rc;
}
# 41743 "c_tests/sqlite3.c"
static int dotlockUnlock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  char *zLockFile = (char *)pFile->lockingContext;
  int rc;

  ((void) (0));

                                          ;
  ((void) (0));


  if( pFile->eFileLock==eFileLock ){
    return 0;
  }




  if( eFileLock==1 ){
    pFile->eFileLock = 1;
    return 0;
  }


  ((void) (0));
  rc = ((int(*)(const char*))aSyscall[19].pCurrent)(zLockFile);
  if( rc<0 ){
    int tErrno = (*__errno_location ());
    if( tErrno==2 ){
      rc = 0;
    }else{
      rc = (10 | (8<<8));
      storeLastErrno(pFile, tErrno);
    }
    return rc;
  }
  pFile->eFileLock = 0;
  return 0;
}




static int dotlockClose(sqlite3_file *id) {
  unixFile *pFile = (unixFile*)id;
  ((void) (0));
  dotlockUnlock(id, 0);
  sqlite3_free(pFile->lockingContext);
  return closeUnixFile(id);
}
# 42664 "c_tests/sqlite3.c"
static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){
  int got;
  int prior = 0;



             ;
  ((void) (0));
  ((void) (0));
  do{

    got = ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)(id->h, pBuf, cnt, offset);
                               ;
# 42689 "c_tests/sqlite3.c"
    if( got==cnt ) break;
    if( got<0 ){
      if( (*__errno_location ())==4 ){ got = 1; continue; }
      prior = 0;
      storeLastErrno((unixFile*)id, (*__errno_location ()));
      break;
    }else if( got>0 ){
      cnt -= got;
      offset += got;
      prior += got;
      pBuf = (void*)(got + (char*)pBuf);
    }
  }while( got>0 );
           ;

                                                           ;
  return got+prior;
}






static int unixRead(
  sqlite3_file *id,
  void *pBuf,
  int amt,
  sqlite3_int64 offset
){
  unixFile *pFile = (unixFile *)id;
  int got;
  ((void) (0));
  ((void) (0));
  ((void) (0));
# 42737 "c_tests/sqlite3.c"
  if( offset<pFile->mmapSize ){
    if( offset+amt <= pFile->mmapSize ){
      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);
      return 0;
    }else{
      int nCopy = pFile->mmapSize - offset;
      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);
      pBuf = &((u8 *)pBuf)[nCopy];
      amt -= nCopy;
      offset += nCopy;
    }
  }


  got = seekAndRead(pFile, offset, pBuf, amt);
  if( got==amt ){
    return 0;
  }else if( got<0 ){







    switch( pFile->lastErrno ){
      case 34:
      case 5:

      case 6:




        return (10 | (33<<8));
    }
    return (10 | (1<<8));
  }else{
    storeLastErrno(pFile, 0);

    memset(&((char*)pBuf)[got], 0, amt-got);
    return (10 | (2<<8));
  }
}
# 42789 "c_tests/sqlite3.c"
static int seekAndWriteFd(
  int fd,
  i64 iOff,
  const void *pBuf,
  int nBuf,
  int *piErrno
){
  int rc = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  nBuf &= 0x1ffff;
             ;


  do{ rc = (int)((ssize_t(*)(int,const void*,size_t,off_t)) aSyscall[12].pCurrent)(fd, pBuf, nBuf, iOff); }while( rc<0 && (*__errno_location ())==4 );
# 42820 "c_tests/sqlite3.c"
           ;
                                                                         ;

  if( rc<0 ) *piErrno = (*__errno_location ());
  return rc;
}
# 42835 "c_tests/sqlite3.c"
static int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){
  return seekAndWriteFd(id->h, offset, pBuf, cnt, &id->lastErrno);
}






static int unixWrite(
  sqlite3_file *id,
  const void *pBuf,
  int amt,
  sqlite3_int64 offset
){
  unixFile *pFile = (unixFile*)id;
  int wrote = 0;
  ((void) (0));
  ((void) (0));
# 42903 "c_tests/sqlite3.c"
  while( (wrote = seekAndWrite(pFile, offset, pBuf, amt))<amt && wrote>0 ){
    amt -= wrote;
    offset += wrote;
    pBuf = &((char*)pBuf)[wrote];
  }
                                        ;
                                           ;

  if( amt>wrote ){
    if( wrote<0 && pFile->lastErrno!=28 ){

      return (10 | (3<<8));
    }else{
      storeLastErrno(pFile, 0);
      return 13;
    }
  }

  return 0;
}
# 42979 "c_tests/sqlite3.c"
static int full_fsync(int fd, int fullSync, int dataOnly){
  int rc;
# 42993 "c_tests/sqlite3.c"
  (void)(fullSync);
  (void)(dataOnly);
# 43038 "c_tests/sqlite3.c"
  rc = fsync(fd);







  if( 0 && rc!= -1 ){
    rc = 0;
  }
  return rc;
}
# 43075 "c_tests/sqlite3.c"
static int openDirectory(const char *zFilename, int *pFd){
  int ii;
  int fd = -1;
  char zDirname[512 +1];

  sqlite3_snprintf(512, zDirname, "%s", zFilename);
  for(ii=(int)strlen(zDirname); ii>0 && zDirname[ii]!='/'; ii--);
  if( ii>0 ){
    zDirname[ii] = '\0';
  }else{
    if( zDirname[0]!='/' ) zDirname[0] = '.';
    zDirname[1] = 0;
  }
  fd = robust_open(zDirname, 00|0, 0);
  if( fd>=0 ){
                                                ;
  }
  *pFd = fd;
  if( fd>=0 ) return 0;
  return unixLogErrorAtLine(sqlite3CantopenError(43094),"openDirectory",zDirname,43094);
}
# 43112 "c_tests/sqlite3.c"
static int unixSync(sqlite3_file *id, int flags){
  int rc;
  unixFile *pFile = (unixFile*)id;

  int isDataOnly = (flags&0x00010);
  int isFullsync = (flags&0x0F)==0x00003;


  ((void) (0));






                                             ;

  ((void) (0));
                                       ;
  rc = full_fsync(pFile->h, isFullsync, isDataOnly);
                         ;
  if( rc ){
    storeLastErrno(pFile, (*__errno_location ()));
    return unixLogErrorAtLine((10 | (4<<8)),"full_fsync",pFile->zPath,43135);
  }





  if( pFile->ctrlFlags & 0x08 ){
    int dirfd;

                                        ;
    rc = ((int(*)(const char*,int*))aSyscall[17].pCurrent)(pFile->zPath, &dirfd);
    if( rc==0 ){
      full_fsync(dirfd, 0, 0);
      robust_close(pFile, dirfd, 43149);
    }else{
      ((void) (0));
      rc = 0;
    }
    pFile->ctrlFlags &= ~0x08;
  }
  return rc;
}




static int unixTruncate(sqlite3_file *id, i64 nByte){
  unixFile *pFile = (unixFile *)id;
  int rc;
  ((void) (0));
                                                 ;






  if( pFile->szChunk>0 ){
    nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;
  }

  rc = robust_ftruncate(pFile->h, nByte);
  if( rc ){
    storeLastErrno(pFile, (*__errno_location ()));
    return unixLogErrorAtLine((10 | (6<<8)),"ftruncate",pFile->zPath,43180);
  }else{
# 43200 "c_tests/sqlite3.c"
    if( nByte<pFile->mmapSize ){
      pFile->mmapSize = nByte;
    }


    return 0;
  }
}




static int unixFileSize(sqlite3_file *id, i64 *pSize){
  int rc;
  struct stat buf;
  ((void) (0));
  rc = ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(((unixFile*)id)->h, &buf);
                         ;
  if( rc!=0 ){
    storeLastErrno((unixFile*)id, (*__errno_location ()));
    return (10 | (7<<8));
  }
  *pSize = buf.st_size;







  if( *pSize==1 ) *pSize = 0;


  return 0;
}
# 43250 "c_tests/sqlite3.c"
static int fcntlSizeHint(unixFile *pFile, i64 nByte){
  if( pFile->szChunk>0 ){
    i64 nSize;
    struct stat buf;

    if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pFile->h, &buf) ){
      return (10 | (7<<8));
    }

    nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;
    if( nSize>(i64)buf.st_size ){
# 43279 "c_tests/sqlite3.c"
      int nBlk = buf.st_blksize;
      int nWrite = 0;
      i64 iWrite;

      iWrite = (buf.st_size/nBlk)*nBlk + nBlk - 1;
      ((void) (0));
      ((void) (0));
      for( ; iWrite<nSize+nBlk-1; iWrite+=nBlk ){
        if( iWrite>=nSize ) iWrite = nSize - 1;
        nWrite = seekAndWrite(pFile, iWrite, "", 1);
        if( nWrite!=1 ) return (10 | (3<<8));
      }

    }
  }


  if( pFile->mmapSizeMax>0 && nByte>pFile->mmapSize ){
    int rc;
    if( pFile->szChunk<=0 ){
      if( robust_ftruncate(pFile->h, nByte) ){
        storeLastErrno(pFile, (*__errno_location ()));
        return unixLogErrorAtLine((10 | (6<<8)),"ftruncate",pFile->zPath,43301);
      }
    }

    rc = unixMapfile(pFile, nByte);
    return rc;
  }


  return 0;
}







static void unixModeBit(unixFile *pFile, unsigned char mask, int *pArg){
  if( *pArg<0 ){
    *pArg = (pFile->ctrlFlags & mask)!=0;
  }else if( (*pArg)==0 ){
    pFile->ctrlFlags &= ~mask;
  }else{
    pFile->ctrlFlags |= mask;
  }
}


static int unixGetTempname(int nBuf, char *zBuf);

 static int unixFcntlExternalReader(unixFile*, int*);
# 43342 "c_tests/sqlite3.c"
static int unixFileControl(sqlite3_file *id, int op, void *pArg){
  unixFile *pFile = (unixFile*)id;
  switch( op ){
# 43360 "c_tests/sqlite3.c"
    case 43: {
      ((int(*)(int))aSyscall[1].pCurrent)(pFile->h);
      pFile->h = -1;
      return 0;
    }
    case 1: {
      *(int*)pArg = pFile->eFileLock;
      return 0;
    }
    case 4: {
      *(int*)pArg = pFile->lastErrno;
      return 0;
    }
    case 6: {
      pFile->szChunk = *(int *)pArg;
      return 0;
    }
    case 5: {
      int rc;
                              ;
      rc = fcntlSizeHint(pFile, *(i64 *)pArg);
                              ;
      return rc;
    }
    case 10: {
      unixModeBit(pFile, 0x04, (int*)pArg);
      return 0;
    }
    case 13: {
      unixModeBit(pFile, 0x10, (int*)pArg);
      return 0;
    }
    case 12: {
      *(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);
      return 0;
    }
    case 16: {
      char *zTFile = sqlite3_malloc64( pFile->pVfs->mxPathname );
      if( zTFile ){
        unixGetTempname(pFile->pVfs->mxPathname, zTFile);
        *(char**)pArg = zTFile;
      }
      return 0;
    }
    case 20: {
      *(int*)pArg = fileHasMoved(pFile);
      return 0;
    }
# 43429 "c_tests/sqlite3.c"
    case 18: {
      i64 newLimit = *(i64*)pArg;
      int rc = 0;
      if( newLimit>sqlite3Config.mxMmap ){
        newLimit = sqlite3Config.mxMmap;
      }




      if( newLimit>0 && sizeof(size_t)<8 ){
        newLimit = (newLimit & 0x7FFFFFFF);
      }

      *(i64*)pArg = pFile->mmapSizeMax;
      if( newLimit>=0 && newLimit!=pFile->mmapSizeMax && pFile->nFetchOut==0 ){
        pFile->mmapSizeMax = newLimit;
        if( pFile->mmapSize>0 ){
          unixUnmapfile(pFile);
          rc = unixMapfile(pFile, -1);
        }
      }
      return rc;
    }
# 43472 "c_tests/sqlite3.c"
    case 40: {

      return unixFcntlExternalReader((unixFile*)id, (int*)pArg);




    }
# 43540 "c_tests/sqlite3.c"
  }
  return 12;
}
# 43554 "c_tests/sqlite3.c"
static void setDeviceCharacteristics(unixFile *pFd){
  ((void) (0));
  if( pFd->sectorSize==0 ){
# 43569 "c_tests/sqlite3.c"
    if( pFd->ctrlFlags & 0x10 ){
      pFd->deviceCharacteristics |= 0x00001000;
    }
    pFd->deviceCharacteristics |= 0x00008000;

    pFd->sectorSize = 4096;
  }
}
# 43662 "c_tests/sqlite3.c"
static int unixSectorSize(sqlite3_file *id){
  unixFile *pFd = (unixFile*)id;
  setDeviceCharacteristics(pFd);
  return pFd->sectorSize;
}
# 43681 "c_tests/sqlite3.c"
static int unixDeviceCharacteristics(sqlite3_file *id){
  unixFile *pFd = (unixFile*)id;
  setDeviceCharacteristics(pFd);
  return pFd->deviceCharacteristics;
}
# 43695 "c_tests/sqlite3.c"
static int unixGetpagesize(void){





  return (int)sysconf(_SC_PAGESIZE);

}
# 43757 "c_tests/sqlite3.c"
struct unixShmNode {
  unixInodeInfo *pInode;
  sqlite3_mutex *pShmMutex;
  char *zFilename;
  int hShm;
  int szRegion;
  u16 nRegion;
  u8 isReadonly;
  u8 isUnlocked;
  char **apRegion;
  int nRef;
  unixShm *pFirst;



  int aLock[8];



};
# 43791 "c_tests/sqlite3.c"
struct unixShm {
  unixShmNode *pShmNode;
  unixShm *pNext;
  u8 hasMutex;
  u8 id;
  u16 sharedMask;
  u16 exclMask;
};
# 43834 "c_tests/sqlite3.c"
static int unixFcntlExternalReader(unixFile *pFile, int *piOut){
  int rc = 0;
  *piOut = 0;
  if( pFile->pShm){
    unixShmNode *pShmNode = pFile->pShm->pShmNode;
    struct flock f;

    memset(&f, 0, sizeof(f));
    f.l_type = 1;
    f.l_whence = 0;
    f.l_start = ((22+8)*4) + 3;
    f.l_len = 8 - 3;

    sqlite3_mutex_enter(pShmNode->pShmMutex);
    if( ((int(*)(int,int,...))aSyscall[7].pCurrent)(pShmNode->hShm, 5, &f)<0 ){
      rc = (10 | (15<<8));
    }else{
      *piOut = (f.l_type!=2);
    }
    sqlite3_mutex_leave(pShmNode->pShmMutex);
  }

  return rc;
}
# 43880 "c_tests/sqlite3.c"
static int unixIsSharingShmNode(unixFile *pFile){
  unixShmNode *pShmNode;
  struct flock lock;
  if( pFile->pShm==0 ) return 0;
  if( pFile->ctrlFlags & 0x01 ) return 0;
  pShmNode = pFile->pShm->pShmNode;

  ((void) (0));

  memset(&lock, 0, sizeof(lock));
  lock.l_whence = 0;
  lock.l_start = (((22+8)*4)+8);
  lock.l_len = 1;
  lock.l_type = 1;
  ((int(*)(int,int,...))aSyscall[7].pCurrent)(pShmNode->hShm, 5, &lock);
  return (lock.l_type!=2);
}







static int unixShmSystemLock(
  unixFile *pFile,
  int lockType,
  int ofst,
  int n
){
  unixShmNode *pShmNode;
  struct flock f;
  int rc = 0;

  pShmNode = pFile->pInode->pShmNode;



  ((void) (0));
  ((void) (0));


  if( ofst==(((22+8)*4)+8) ){
    ((void) (0));
    ((void) (0));
  }else{






    ((void) (0));
    ((void) (0));

  }


  ((void) (0));


  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pShmNode->hShm>=0 ){
    int res;

    f.l_type = lockType;
    f.l_whence = 0;
    f.l_start = ofst;
    f.l_len = n;
    res = ((int(*)(int,int,...))aSyscall[7].pCurrent)(pShmNode->hShm,6,&f);
    if( res==-1 ){



      rc = 5;

    }
  }
# 43986 "c_tests/sqlite3.c"
  return rc;
}
# 43998 "c_tests/sqlite3.c"
static int unixShmRegionPerMap(void){
  int shmsz = 32*1024;
  int pgsz = ((int(*)(void))aSyscall[25].pCurrent)();
  ((void) (0));
  if( pgsz<shmsz ) return 1;
  return pgsz/shmsz;
}







static void unixShmPurge(unixFile *pFd){
  unixShmNode *p = pFd->pInode->pShmNode;
  ((void) (0));
  if( p && (p->nRef==0) ){
    int nShmPerMap = unixShmRegionPerMap();
    int i;
    ((void) (0));
    sqlite3_mutex_free(p->pShmMutex);





    for(i=0; i<p->nRegion; i+=nShmPerMap){
      if( p->hShm>=0 ){
        ((int(*)(void*,size_t))aSyscall[23].pCurrent)(p->apRegion[i], p->szRegion);
      }else{
        sqlite3_free(p->apRegion[i]);
      }
    }
    sqlite3_free(p->apRegion);
    if( p->hShm>=0 ){
      robust_close(pFd, p->hShm, 44034);
      p->hShm = -1;
    }
    p->pInode->pShmNode = 0;
    sqlite3_free(p);
  }
}
# 44051 "c_tests/sqlite3.c"
static int unixLockSharedMemory(unixFile *pDbFd, unixShmNode *pShmNode){
  struct flock lock;
  int rc = 0;
# 44073 "c_tests/sqlite3.c"
  lock.l_whence = 0;
  lock.l_start = (((22+8)*4)+8);
  lock.l_len = 1;
  lock.l_type = 1;
  if( ((int(*)(int,int,...))aSyscall[7].pCurrent)(pShmNode->hShm, 5, &lock)!=0 ) {
    rc = (10 | (15<<8));
  }else if( lock.l_type==2 ){
    if( pShmNode->isReadonly ){
      pShmNode->isUnlocked = 1;
      rc = (8 | (5<<8));
    }else{
# 44094 "c_tests/sqlite3.c"
      rc = unixShmSystemLock(pDbFd, 1, (((22+8)*4)+8), 1);
# 44103 "c_tests/sqlite3.c"
      if( rc==0 && robust_ftruncate(pShmNode->hShm, 3) ){
        rc = unixLogErrorAtLine((10 | (18<<8)),"ftruncate",pShmNode->zFilename,44104);
      }
    }
  }else if( lock.l_type==1 ){
    rc = 5;
  }

  if( rc==0 ){
    ((void) (0));
    rc = unixShmSystemLock(pDbFd, 0, (((22+8)*4)+8), 1);
  }
  return rc;
}
# 44153 "c_tests/sqlite3.c"
static int unixOpenSharedMemory(unixFile *pDbFd){
  struct unixShm *p = 0;
  struct unixShmNode *pShmNode;
  int rc = 0;
  unixInodeInfo *pInode;
  char *zShm;
  int nShmFilename;


  p = sqlite3_malloc64( sizeof(*p) );
  if( p==0 ) return 7;
  memset(p, 0, sizeof(*p));
  ((void) (0));




  ((void) (0));
  unixEnterMutex();
  pInode = pDbFd->pInode;
  pShmNode = pInode->pShmNode;
  if( pShmNode==0 ){
    struct stat sStat;

    const char *zBasePath = pDbFd->zPath;






    if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pDbFd->h, &sStat) ){
      rc = (10 | (7<<8));
      goto shm_open_err;
    }




    nShmFilename = 6 + (int)strlen(zBasePath);

    pShmNode = sqlite3_malloc64( sizeof(*pShmNode) + nShmFilename );
    if( pShmNode==0 ){
      rc = 7;
      goto shm_open_err;
    }
    memset(pShmNode, 0, sizeof(*pShmNode)+nShmFilename);
    zShm = pShmNode->zFilename = (char*)&pShmNode[1];





    sqlite3_snprintf(nShmFilename, zShm, "%s-shm", zBasePath);
                                          ;

    pShmNode->hShm = -1;
    pDbFd->pInode->pShmNode = pShmNode;
    pShmNode->pInode = pDbFd->pInode;
    if( sqlite3Config.bCoreMutex ){
      pShmNode->pShmMutex = sqlite3_mutex_alloc(0);
      if( pShmNode->pShmMutex==0 ){
        rc = 7;
        goto shm_open_err;
      }
# 44230 "c_tests/sqlite3.c"
    }

    if( pInode->bProcessLock==0 ){
      if( 0==sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0) ){
        pShmNode->hShm = robust_open(zShm, 02|0100|0400000,
                                     (sStat.st_mode&0777));
      }
      if( pShmNode->hShm<0 ){
        pShmNode->hShm = robust_open(zShm, 00|0400000,
                                     (sStat.st_mode&0777));
        if( pShmNode->hShm<0 ){
          rc = unixLogErrorAtLine(sqlite3CantopenError(44241),"open",zShm,44241);
          goto shm_open_err;
        }
        pShmNode->isReadonly = 1;
      }





      robustFchown(pShmNode->hShm, sStat.st_uid, sStat.st_gid);

      rc = unixLockSharedMemory(pDbFd, pShmNode);
      if( rc!=0 && rc!=(8 | (5<<8)) ) goto shm_open_err;
    }
  }


  p->pShmNode = pShmNode;



  pShmNode->nRef++;
  pDbFd->pShm = p;
  unixLeaveMutex();
# 44274 "c_tests/sqlite3.c"
  sqlite3_mutex_enter(pShmNode->pShmMutex);
  p->pNext = pShmNode->pFirst;
  pShmNode->pFirst = p;
  sqlite3_mutex_leave(pShmNode->pShmMutex);
  return rc;


shm_open_err:
  unixShmPurge(pDbFd);
  sqlite3_free(p);
  unixLeaveMutex();
  return rc;
}
# 44307 "c_tests/sqlite3.c"
static int unixShmMap(
  sqlite3_file *fd,
  int iRegion,
  int szRegion,
  int bExtend,
  void volatile **pp
){
  unixFile *pDbFd = (unixFile*)fd;
  unixShm *p;
  unixShmNode *pShmNode;
  int rc = 0;
  int nShmPerMap = unixShmRegionPerMap();
  int nReqRegion;


  if( pDbFd->pShm==0 ){
    rc = unixOpenSharedMemory(pDbFd);
    if( rc!=0 ) return rc;
  }

  p = pDbFd->pShm;
  pShmNode = p->pShmNode;
  sqlite3_mutex_enter(pShmNode->pShmMutex);
  if( pShmNode->isUnlocked ){
    rc = unixLockSharedMemory(pDbFd, pShmNode);
    if( rc!=0 ) goto shmpage_out;
    pShmNode->isUnlocked = 0;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  nReqRegion = ((iRegion+nShmPerMap) / nShmPerMap) * nShmPerMap;

  if( pShmNode->nRegion<nReqRegion ){
    char **apNew;
    int nByte = nReqRegion*szRegion;
    struct stat sStat;

    pShmNode->szRegion = szRegion;

    if( pShmNode->hShm>=0 ){




      if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pShmNode->hShm, &sStat) ){
        rc = (10 | (19<<8));
        goto shmpage_out;
      }

      if( sStat.st_size<nByte ){



        if( !bExtend ){
          goto shmpage_out;
        }
# 44375 "c_tests/sqlite3.c"
        else{
          static const int pgsz = 4096;
          int iPg;


          ((void) (0));
          for(iPg=(sStat.st_size/pgsz); iPg<(nByte/pgsz); iPg++){
            int x = 0;
            if( seekAndWriteFd(pShmNode->hShm, iPg*pgsz + pgsz-1,"",1,&x)!=1 ){
              const char *zFile = pShmNode->zFilename;
              rc = unixLogErrorAtLine((10 | (19<<8)),"write",zFile,44385);
              goto shmpage_out;
            }
          }
        }
      }
    }


    apNew = (char **)sqlite3_realloc(
        pShmNode->apRegion, nReqRegion*sizeof(char *)
    );
    if( !apNew ){
      rc = (10 | (12<<8));
      goto shmpage_out;
    }
    pShmNode->apRegion = apNew;
    while( pShmNode->nRegion<nReqRegion ){
      int nMap = szRegion*nShmPerMap;
      int i;
      void *pMem;
      if( pShmNode->hShm>=0 ){
        pMem = ((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent)(0, nMap,
            pShmNode->isReadonly ? 0x1 : 0x1|0x2,
            0x01, pShmNode->hShm, szRegion*(i64)pShmNode->nRegion
        );
        if( pMem==((void *) -1) ){
          rc = unixLogErrorAtLine((10 | (21<<8)),"mmap",pShmNode->zFilename,44412);
          goto shmpage_out;
        }
      }else{
        pMem = sqlite3_malloc64(nMap);
        if( pMem==0 ){
          rc = 7;
          goto shmpage_out;
        }
        memset(pMem, 0, nMap);
      }

      for(i=0; i<nShmPerMap; i++){
        pShmNode->apRegion[pShmNode->nRegion+i] = &((char*)pMem)[szRegion*i];
      }
      pShmNode->nRegion += nShmPerMap;
    }
  }

shmpage_out:
  if( pShmNode->nRegion>iRegion ){
    *pp = pShmNode->apRegion[iRegion];
  }else{
    *pp = 0;
  }
  if( pShmNode->isReadonly && rc==0 ) rc = 8;
  sqlite3_mutex_leave(pShmNode->pShmMutex);
  return rc;
}
# 44485 "c_tests/sqlite3.c"
static int unixShmLock(
  sqlite3_file *fd,
  int ofst,
  int n,
  int flags
){
  unixFile *pDbFd = (unixFile*)fd;
  unixShm *p;
  unixShmNode *pShmNode;
  int rc = 0;
  u16 mask = (1<<(ofst+n)) - (1<<ofst);
  int *aLock;

  p = pDbFd->pShm;
  if( p==0 ) return (10 | (20<<8));
  pShmNode = p->pShmNode;
  if( (pShmNode==0) ) return (10 | (20<<8));
  aLock = pShmNode->aLock;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));



  ((void) (0));
  ((void) (0));
  ((void) (0));
# 44549 "c_tests/sqlite3.c"
  ((void) (0));


  if( ((flags & 1) && ((p->exclMask|p->sharedMask) & mask))
   || (flags==(4|2) && 0==(p->sharedMask & mask))
   || (flags==(8|2))
  ){
# 44583 "c_tests/sqlite3.c"
    sqlite3_mutex_enter(pShmNode->pShmMutex);


    if( (rc==0) ){
      if( flags & 1 ){

        int bUnlock = 1;
        ((void) (0));
        ((void) (0));
        ((void) (0));





        if( flags & 4 ){
          ((void) (0));
          ((void) (0));
          if( aLock[ofst]>1 ){
            bUnlock = 0;
            aLock[ofst]--;
            p->sharedMask &= ~mask;
          }
        }

        if( bUnlock ){
          rc = unixShmSystemLock(pDbFd, 2, ofst+((22+8)*4), n);
          if( rc==0 ){
            memset(&aLock[ofst], 0, sizeof(int)*n);
            p->sharedMask &= ~mask;
            p->exclMask &= ~mask;
          }
        }
      }else if( flags & 4 ){


        if( aLock[ofst]<0 ){

          rc = 5;
        }else if( aLock[ofst]==0 ){
          rc = unixShmSystemLock(pDbFd, 0, ofst+((22+8)*4), n);
        }


        if( rc==0 ){
          p->sharedMask |= mask;
          aLock[ofst]++;
        }
      }else{

        int ii;

        ((void) (0));
        ((void) (0));
        ((void) (0));



        for(ii=ofst; ii<ofst+n; ii++){
          if( aLock[ii] ){
            rc = 5;
            break;
          }
        }



        if( rc==0 ){
          rc = unixShmSystemLock(pDbFd, 1, ofst+((22+8)*4), n);
          if( rc==0 ){
            p->exclMask |= mask;
            for(ii=ofst; ii<ofst+n; ii++){
              aLock[ii] = -1;
            }
          }
        }
      }
      ((void) (0));
    }
# 44670 "c_tests/sqlite3.c"
    sqlite3_mutex_leave(pShmNode->pShmMutex);

  }


                                                           ;
  return rc;
}







static void unixShmBarrier(
  sqlite3_file *fd
){
  (void)(fd);
  sqlite3MemoryBarrier();
  ((void) (0));


  unixEnterMutex();
  unixLeaveMutex();
}
# 44704 "c_tests/sqlite3.c"
static int unixShmUnmap(
  sqlite3_file *fd,
  int deleteFlag
){
  unixShm *p;
  unixShmNode *pShmNode;
  unixShm **pp;
  unixFile *pDbFd;

  pDbFd = (unixFile*)fd;
  p = pDbFd->pShm;
  if( p==0 ) return 0;
  pShmNode = p->pShmNode;

  ((void) (0));
  ((void) (0));



  sqlite3_mutex_enter(pShmNode->pShmMutex);
  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}
  *pp = p->pNext;


  sqlite3_free(p);
  pDbFd->pShm = 0;
  sqlite3_mutex_leave(pShmNode->pShmMutex);



  ((void) (0));
  unixEnterMutex();
  ((void) (0));
  pShmNode->nRef--;
  if( pShmNode->nRef==0 ){
    if( deleteFlag && pShmNode->hShm>=0 ){
      ((int(*)(const char*))aSyscall[16].pCurrent)(pShmNode->zFilename);
    }
    unixShmPurge(pDbFd);
  }
  unixLeaveMutex();

  return 0;
}
# 44761 "c_tests/sqlite3.c"
static void unixUnmapfile(unixFile *pFd){
  ((void) (0));
  if( pFd->pMapRegion ){
    ((int(*)(void*,size_t))aSyscall[23].pCurrent)(pFd->pMapRegion, pFd->mmapSizeActual);
    pFd->pMapRegion = 0;
    pFd->mmapSize = 0;
    pFd->mmapSizeActual = 0;
  }
}
# 44786 "c_tests/sqlite3.c"
static void unixRemapfile(
  unixFile *pFd,
  i64 nNew
){
  const char *zErr = "mmap";
  int h = pFd->h;
  u8 *pOrig = (u8 *)pFd->pMapRegion;
  i64 nOrig = pFd->mmapSizeActual;
  u8 *pNew = 0;
  int flags = 0x1;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  if( pOrig ){

    i64 nReuse = pFd->mmapSize;




    u8 *pReq = &pOrig[nReuse];


    if( nReuse!=nOrig ){
      ((int(*)(void*,size_t))aSyscall[23].pCurrent)(pReq, nOrig-nReuse);
    }


    pNew = ((void*(*)(void*,size_t,size_t,int,...))aSyscall[24].pCurrent)(pOrig, nReuse, nNew, 1);
    zErr = "mremap";
# 44838 "c_tests/sqlite3.c"
    if( pNew==((void *) -1) || pNew==0 ){
      ((int(*)(void*,size_t))aSyscall[23].pCurrent)(pOrig, nReuse);
    }
  }


  if( pNew==0 ){
    pNew = ((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent)(0, nNew, flags, 0x01, h, 0);
  }

  if( pNew==((void *) -1) ){
    pNew = 0;
    nNew = 0;
    unixLogErrorAtLine(0,zErr,pFd->zPath,44851);




    pFd->mmapSizeMax = 0;
  }
  pFd->pMapRegion = (void *)pNew;
  pFd->mmapSize = pFd->mmapSizeActual = nNew;
}
# 44878 "c_tests/sqlite3.c"
static int unixMapfile(unixFile *pFd, i64 nMap){
  ((void) (0));
  ((void) (0));
  if( pFd->nFetchOut>0 ) return 0;

  if( nMap<0 ){
    struct stat statbuf;
    if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pFd->h, &statbuf) ){
      return (10 | (7<<8));
    }
    nMap = statbuf.st_size;
  }
  if( nMap>pFd->mmapSizeMax ){
    nMap = pFd->mmapSizeMax;
  }

  ((void) (0));
  if( nMap!=pFd->mmapSize ){
    unixRemapfile(pFd, nMap);
  }

  return 0;
}
# 44915 "c_tests/sqlite3.c"
static int unixFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){

  unixFile *pFd = (unixFile *)fd;

  *pp = 0;


  if( pFd->mmapSizeMax>0 ){




    const int nEofBuffer = 256;
    if( pFd->pMapRegion==0 ){
      int rc = unixMapfile(pFd, -1);
      if( rc!=0 ) return rc;
    }
    if( pFd->mmapSize >= (iOff+nAmt+nEofBuffer) ){
      *pp = &((u8 *)pFd->pMapRegion)[iOff];
      pFd->nFetchOut++;
    }
  }

  return 0;
}
# 44951 "c_tests/sqlite3.c"
static int unixUnfetch(sqlite3_file *fd, i64 iOff, void *p){

  unixFile *pFd = (unixFile *)fd;
  (void)(iOff);




  ((void) (0));


  ((void) (0));

  if( p ){
    pFd->nFetchOut--;
  }else{
    unixUnmapfile(pFd);
  }

  ((void) (0));





  return 0;
}
# 45053 "c_tests/sqlite3.c"
static const sqlite3_io_methods posixIoMethods = { 3, unixClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, unixLock, unixUnlock, unixCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, unixShmMap, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, }; static const sqlite3_io_methods *posixIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &posixIoMethods; } static const sqlite3_io_methods *(*const posixIoFinder)(const char*,unixFile *p) = posixIoFinderImpl;
# 45063 "c_tests/sqlite3.c"
static const sqlite3_io_methods nolockIoMethods = { 3, nolockClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, nolockLock, nolockUnlock, nolockCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, 0, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, }; static const sqlite3_io_methods *nolockIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &nolockIoMethods; } static const sqlite3_io_methods *(*const nolockIoFinder)(const char*,unixFile *p) = nolockIoFinderImpl;
# 45073 "c_tests/sqlite3.c"
static const sqlite3_io_methods dotlockIoMethods = { 1, dotlockClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, dotlockLock, dotlockUnlock, dotlockCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, 0, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, }; static const sqlite3_io_methods *dotlockIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &dotlockIoMethods; } static const sqlite3_io_methods *(*const dotlockIoFinder)(const char*,unixFile *p) = dotlockIoFinderImpl;
# 45268 "c_tests/sqlite3.c"
typedef const sqlite3_io_methods *(*finder_type)(const char*,unixFile*);
# 45281 "c_tests/sqlite3.c"
static int fillInUnixFile(
  sqlite3_vfs *pVfs,
  int h,
  sqlite3_file *pId,
  const char *zFilename,
  int ctrlFlags
){
  const sqlite3_io_methods *pLockingStyle;
  unixFile *pNew = (unixFile *)pId;
  int rc = 0;

  ((void) (0));


  ((void) (0));

                                              ;
  pNew->h = h;
  pNew->pVfs = pVfs;
  pNew->zPath = zFilename;
  pNew->ctrlFlags = (u8)ctrlFlags;

  pNew->mmapSizeMax = sqlite3Config.szMmap;

  if( sqlite3_uri_boolean(((ctrlFlags & 0x40) ? zFilename : 0),
                           "psow", 1) ){
    pNew->ctrlFlags |= 0x10;
  }
  if( strcmp(pVfs->zName,"unix-excl")==0 ){
    pNew->ctrlFlags |= 0x01;
  }
# 45321 "c_tests/sqlite3.c"
  if( ctrlFlags & 0x80 ){
    pLockingStyle = &nolockIoMethods;
  }else{
    pLockingStyle = (**(finder_type*)pVfs->pAppData)(zFilename, pNew);






  }

  if( pLockingStyle == &posixIoMethods



  ){
    unixEnterMutex();
    rc = findInodeInfo(pNew, &pNew->pInode);
    if( rc!=0 ){
# 45359 "c_tests/sqlite3.c"
      robust_close(pNew, h, 45359);
      h = -1;
    }
    unixLeaveMutex();
  }
# 45393 "c_tests/sqlite3.c"
  else if( pLockingStyle == &dotlockIoMethods ){



    char *zLockFile;
    int nFilename;
    ((void) (0));
    nFilename = (int)strlen(zFilename) + 6;
    zLockFile = (char *)sqlite3_malloc64(nFilename);
    if( zLockFile==0 ){
      rc = 7;
    }else{
      sqlite3_snprintf(nFilename, zLockFile, "%s" ".lock", zFilename);
    }
    pNew->lockingContext = zLockFile;
  }
# 45434 "c_tests/sqlite3.c"
  storeLastErrno(pNew, 0);
# 45450 "c_tests/sqlite3.c"
  if( rc!=0 ){
    if( h>=0 ) robust_close(pNew, h, 45451);
  }else{
    pId->pMethods = pLockingStyle;
                   ;
    verifyDbFile(pNew);
  }
  return rc;
}




static const char *azTempDirs[] = {
  0,
  0,
  "/var/tmp",
  "/usr/tmp",
  "/tmp",
  "."
};




static void unixTempFileInit(void){
  azTempDirs[0] = getenv("SQLITE_TMPDIR");
  azTempDirs[1] = getenv("TMPDIR");
}





static const char *unixTempFileDir(void){
  unsigned int i = 0;
  struct stat buf;
  const char *zDir = sqlite3_temp_directory;

  while(1){
    if( zDir!=0



     && ((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(zDir, &buf)==0
     && ((((buf.st_mode)) & 0170000) == (0040000))
     && ((int(*)(const char*,int))aSyscall[2].pCurrent)(zDir, 03)==0
    ){
      return zDir;
    }
    if( i>=sizeof(azTempDirs)/sizeof(azTempDirs[0]) ) break;
    zDir = azTempDirs[i++];
  }
  return 0;
}






static int unixGetTempname(int nBuf, char *zBuf){
  const char *zDir;
  int iLimit = 0;
  int rc = 0;





  zBuf[0] = 0;
                                        ;

  sqlite3_mutex_enter(sqlite3MutexAlloc(11));
  zDir = unixTempFileDir();
  if( zDir==0 ){
    rc = (10 | (25<<8));
  }else{
    do{
      u64 r;
      sqlite3_randomness(sizeof(r), &r);
      ((void) (0));
      zBuf[nBuf-2] = 0;
      sqlite3_snprintf(nBuf, zBuf, "%s/""etilqs_""%llx%c",
                       zDir, r, 0);
      if( zBuf[nBuf-2]!=0 || (iLimit++)>10 ){
        rc = 1;
        break;
      }
    }while( ((int(*)(const char*,int))aSyscall[2].pCurrent)(zBuf,0)==0 );
  }
  sqlite3_mutex_leave(sqlite3MutexAlloc(11));
  return rc;
}
# 45570 "c_tests/sqlite3.c"
static UnixUnusedFd *findReusableFd(const char *zPath, int flags){
  UnixUnusedFd *pUnused = 0;







  struct stat sStat;

  unixEnterMutex();
# 45591 "c_tests/sqlite3.c"
  if( inodeList!=0 && 0==((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(zPath, &sStat) ){
    unixInodeInfo *pInode;

    pInode = inodeList;
    while( pInode && (pInode->fileId.dev!=sStat.st_dev
                     || pInode->fileId.ino!=(u64)sStat.st_ino) ){
       pInode = pInode->pNext;
    }
    if( pInode ){
      UnixUnusedFd **pp;
      ((void) (0));
      sqlite3_mutex_enter(pInode->pLockMutex);
      flags &= (0x00000001|0x00000002);
      for(pp=&pInode->pUnused; *pp && (*pp)->flags!=flags; pp=&((*pp)->pNext));
      pUnused = *pp;
      if( pUnused ){
        *pp = pUnused->pNext;
      }
      sqlite3_mutex_leave(pInode->pLockMutex);
    }
  }
  unixLeaveMutex();

  return pUnused;
}




static int getFileMode(
  const char *zFile,
  mode_t *pMode,
  uid_t *pUid,
  gid_t *pGid
){
  struct stat sStat;
  int rc = 0;
  if( 0==((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(zFile, &sStat) ){
    *pMode = sStat.st_mode & 0777;
    *pUid = sStat.st_uid;
    *pGid = sStat.st_gid;
  }else{
    rc = (10 | (7<<8));
  }
  return rc;
}
# 45659 "c_tests/sqlite3.c"
static int findCreateFileMode(
  const char *zPath,
  int flags,
  mode_t *pMode,
  uid_t *pUid,
  gid_t *pGid
){
  int rc = 0;
  *pMode = 0;
  *pUid = 0;
  *pGid = 0;
  if( flags & (0x00080000|0x00000800) ){
    char zDb[512 +1];
    int nDb;
# 45692 "c_tests/sqlite3.c"
    nDb = sqlite3Strlen30(zPath) - 1;
    while( nDb>0 && zPath[nDb]!='.' ){
      if( zPath[nDb]=='-' ){
        memcpy(zDb, zPath, nDb);
        zDb[nDb] = '\0';
        rc = getFileMode(zDb, pMode, pUid, pGid);
        break;
      }
      nDb--;
    }
  }else if( flags & 0x00000008 ){
    *pMode = 0600;
  }else if( flags & 0x00000040 ){




    const char *z = sqlite3_uri_parameter(zPath, "modeof");
    if( z ){
      rc = getFileMode(z, pMode, pUid, pGid);
    }
  }
  return rc;
}
# 45739 "c_tests/sqlite3.c"
static int unixOpen(
  sqlite3_vfs *pVfs,
  const char *zPath,
  sqlite3_file *pFile,
  int flags,
  int *pOutFlags
){
  unixFile *p = (unixFile *)pFile;
  int fd = -1;
  int openFlags = 0;
  int eType = flags&0x0FFF00;
  int noLock;
  int rc = 0;
  int ctrlFlags = 0;

  int isExclusive = (flags & 0x00000010);
  int isDelete = (flags & 0x00000008);
  int isCreate = (flags & 0x00000004);
  int isReadonly = (flags & 0x00000001);
  int isReadWrite = (flags & 0x00000002);
# 45770 "c_tests/sqlite3.c"
  int isNewJrnl = (isCreate && (
        eType==0x00004000
     || eType==0x00000800
     || eType==0x00080000
  ));




  char zTmpname[512 +2];
  const char *zName = zPath;
# 45789 "c_tests/sqlite3.c"
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));



  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  ((void) (0));
# 45819 "c_tests/sqlite3.c"
  if( randomnessPid!=(pid_t)getpid() ){
    randomnessPid = (pid_t)getpid();
    sqlite3_randomness(0,0);
  }
  memset(p, 0, sizeof(unixFile));






  if( eType==0x00000100 ){
    UnixUnusedFd *pUnused;
    pUnused = findReusableFd(zName, flags);
    if( pUnused ){
      fd = pUnused->fd;
    }else{
      pUnused = sqlite3_malloc64(sizeof(*pUnused));
      if( !pUnused ){
        return 7;
      }
    }
    p->pPreallocatedUnused = pUnused;




    ((void) (0));

  }else if( !zName ){

    ((void) (0));
    rc = unixGetTempname(pVfs->mxPathname, zTmpname);
    if( rc!=0 ){
      return rc;
    }
    zName = zTmpname;



    ((void) (0));
  }





  if( isReadonly ) openFlags |= 00;
  if( isReadWrite ) openFlags |= 02;
  if( isCreate ) openFlags |= 0100;
  if( isExclusive ) openFlags |= (0200|0400000);
  openFlags |= (0|0|0400000);

  if( fd<0 ){
    mode_t openMode;
    uid_t uid;
    gid_t gid;
    rc = findCreateFileMode(zName, flags, &openMode, &uid, &gid);
    if( rc!=0 ){
      ((void) (0));
      ((void) (0));
      return rc;
    }
    fd = robust_open(zName, openFlags, openMode);
                                                            ;
    ((void) (0));
    if( fd<0 ){
      if( isNewJrnl && (*__errno_location ())==13 && ((int(*)(const char*,int))aSyscall[2].pCurrent)(zName, 0) ){


        rc = (8 | (6<<8));
      }else if( (*__errno_location ())!=21 && isReadWrite ){

        UnixUnusedFd *pReadonly = 0;
        flags &= ~(0x00000002|0x00000004);
        openFlags &= ~(02|0100);
        flags |= 0x00000001;
        openFlags |= 00;
        isReadonly = 1;
        pReadonly = findReusableFd(zName, flags);
        if( pReadonly ){
          fd = pReadonly->fd;
          sqlite3_free(pReadonly);
        }else{
          fd = robust_open(zName, openFlags, openMode);
        }
      }
    }
    if( fd<0 ){
      int rc2 = unixLogErrorAtLine(sqlite3CantopenError(45908),"open",zName,45908);
      if( rc==0 ) rc = rc2;
      goto open_finished;
    }
# 45925 "c_tests/sqlite3.c"
    if( openMode && (flags & (0x00080000|0x00000800))!=0 ){
      robustFchown(fd, uid, gid);
    }
  }
  ((void) (0));
  if( pOutFlags ){
    *pOutFlags = flags;
  }

  if( p->pPreallocatedUnused ){
    p->pPreallocatedUnused->fd = fd;
    p->pPreallocatedUnused->flags =
                          flags & (0x00000001|0x00000002);
  }

  if( isDelete ){
# 45950 "c_tests/sqlite3.c"
    ((int(*)(const char*))aSyscall[16].pCurrent)(zName);

  }
# 45974 "c_tests/sqlite3.c"
  if( isDelete ) ctrlFlags |= 0x20;
  if( isReadonly ) ctrlFlags |= 0x02;
  noLock = eType!=0x00000100;
  if( noLock ) ctrlFlags |= 0x80;
  if( isNewJrnl ) ctrlFlags |= 0x08;
  if( flags & 0x00000040 ) ctrlFlags |= 0x40;
# 46014 "c_tests/sqlite3.c"
  ((void) (0));





  rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);

open_finished:
  if( rc!=0 ){
    sqlite3_free(p->pPreallocatedUnused);
  }
  return rc;
}






static int unixDelete(
  sqlite3_vfs *NotUsed,
  const char *zPath,
  int dirSync
){
  int rc = 0;
  (void)(NotUsed);
                                             ;
  if( ((int(*)(const char*))aSyscall[16].pCurrent)(zPath)==(-1) ){
    if( (*__errno_location ())==2



    ){
      rc = (10 | (23<<8));
    }else{
      rc = unixLogErrorAtLine((10 | (10<<8)),"unlink",zPath,46050);
    }
    return rc;
  }

  if( (dirSync & 1)!=0 ){
    int fd;
    rc = ((int(*)(const char*,int*))aSyscall[17].pCurrent)(zPath, &fd);
    if( rc==0 ){
      if( full_fsync(fd,0,0) ){
        rc = unixLogErrorAtLine((10 | (5<<8)),"fsync",zPath,46060);
      }
      robust_close(0, fd, 46062);
    }else{
      ((void) (0));
      rc = 0;
    }
  }

  return rc;
}
# 46082 "c_tests/sqlite3.c"
static int unixAccess(
  sqlite3_vfs *NotUsed,
  const char *zPath,
  int flags,
  int *pResOut
){
  (void)(NotUsed);
                                                ;
  ((void) (0));



  ((void) (0));

  if( flags==0 ){
    struct stat buf;
    *pResOut = 0==((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(zPath, &buf) &&
                (!((((buf.st_mode)) & 0170000) == (0100000)) || buf.st_size>0);
  }else{
    *pResOut = ((int(*)(const char*,int))aSyscall[2].pCurrent)(zPath, 2|4)==0;
  }
  return 0;
}




typedef struct DbPath DbPath;
struct DbPath {
  int rc;
  int nSymlink;
  char *zOut;
  int nOut;
  int nUsed;
};


static void appendAllPathElements(DbPath*,const char*);




static void appendOnePathElement(
  DbPath *pPath,
  const char *zName,
  int nName
){
  ((void) (0));
  ((void) (0));
  if( zName[0]=='.' ){
    if( nName==1 ) return;
    if( zName[1]=='.' && nName==2 ){
      if( pPath->nUsed>1 ){
        ((void) (0));
        while( pPath->zOut[--pPath->nUsed]!='/' ){}
      }
      return;
    }
  }
  if( pPath->nUsed + nName + 2 >= pPath->nOut ){
    pPath->rc = 1;
    return;
  }
  pPath->zOut[pPath->nUsed++] = '/';
  memcpy(&pPath->zOut[pPath->nUsed], zName, nName);
  pPath->nUsed += nName;

  if( pPath->rc==0 ){
    const char *zIn;
    struct stat buf;
    pPath->zOut[pPath->nUsed] = 0;
    zIn = pPath->zOut;
    if( ((int(*)(const char*,struct stat*))aSyscall[27].pCurrent)(zIn, &buf)!=0 ){
      if( (*__errno_location ())!=2 ){
        pPath->rc = unixLogErrorAtLine(sqlite3CantopenError(46156),"lstat",zIn,46156);
      }
    }else if( ((((buf.st_mode)) & 0170000) == (0120000)) ){
      ssize_t got;
      char zLnk[4096 +2];
      if( pPath->nSymlink++ > 200 ){
        pPath->rc = sqlite3CantopenError(46162);
        return;
      }
      got = ((ssize_t(*)(const char*,char*,size_t))aSyscall[26].pCurrent)(zIn, zLnk, sizeof(zLnk)-2);
      if( got<=0 || got>=(ssize_t)sizeof(zLnk)-2 ){
        pPath->rc = unixLogErrorAtLine(sqlite3CantopenError(46167),"readlink",zIn,46167);
        return;
      }
      zLnk[got] = 0;
      if( zLnk[0]=='/' ){
        pPath->nUsed = 0;
      }else{
        pPath->nUsed -= nName + 1;
      }
      appendAllPathElements(pPath, zLnk);
    }
  }

}




static void appendAllPathElements(
  DbPath *pPath,
  const char *zPath
){
  int i = 0;
  int j = 0;
  do{
    while( zPath[i] && zPath[i]!='/' ){ i++; }
    if( i>j ){
      appendOnePathElement(pPath, &zPath[j], i-j);
    }
    j = i+1;
  }while( zPath[i++] );
}
# 46209 "c_tests/sqlite3.c"
static int unixFullPathname(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int nOut,
  char *zOut
){
  DbPath path;
  (void)(pVfs);
  path.rc = 0;
  path.nUsed = 0;
  path.nSymlink = 0;
  path.nOut = nOut;
  path.zOut = zOut;
  if( zPath[0]!='/' ){
    char zPwd[4096 +2];
    if( ((char*(*)(char*,size_t))aSyscall[3].pCurrent)(zPwd, sizeof(zPwd)-2)==0 ){
      return unixLogErrorAtLine(sqlite3CantopenError(46225),"getcwd",zPath,46225);
    }
    appendAllPathElements(&path, zPwd);
  }
  appendAllPathElements(&path, zPath);
  zOut[path.nUsed] = 0;
  if( path.rc || path.nUsed<2 ) return sqlite3CantopenError(46231);
  if( path.nSymlink ) return (0 | (2<<8));
  return 0;
}






# 1 "/usr/include/dlfcn.h" 1 3 4
# 24 "/usr/include/dlfcn.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 1 3 4
# 93 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 3 4
# 1 "/usr/lib/llvm-20/lib/clang/20/include/__stddef_size_t.h" 1 3 4
# 94 "/usr/lib/llvm-20/lib/clang/20/include/stddef.h" 2 3 4
# 25 "/usr/include/dlfcn.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 1 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 3 4
extern void _dl_mcount_wrapper_check (void *__selfpc) __attribute__ ((__nothrow__ ));
# 28 "/usr/include/dlfcn.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/dl_find_object.h" 1 3 4
# 32 "/usr/include/dlfcn.h" 2 3 4


typedef long int Lmid_t;
# 56 "/usr/include/dlfcn.h" 3 4
extern void *dlopen (const char *__file, int __mode) __attribute__ ((__nothrow__));



extern int dlclose (void *__handle) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      const char *__restrict __name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern void *dlmopen (Lmid_t __nsid, const char *__file, int __mode) __attribute__ ((__nothrow__));



extern void *dlvsym (void *__restrict __handle,
       const char *__restrict __name,
       const char *__restrict __version)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));





extern char *dlerror (void) __attribute__ ((__nothrow__ ));





typedef struct
{
  const char *dli_fname;
  void *dli_fbase;
  const char *dli_sname;
  void *dli_saddr;
} Dl_info;



extern int dladdr (const void *__address, Dl_info *__info)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));


extern int dladdr1 (const void *__address, Dl_info *__info,
      void **__extra_info, int __flags) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




enum
  {

    RTLD_DL_SYMENT = 1,


    RTLD_DL_LINKMAP = 2
  };







extern int dlinfo (void *__restrict __handle,
     int __request, void *__restrict __arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));


enum
  {

    RTLD_DI_LMID = 1,



    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3,






    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,



    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,




    RTLD_DI_TLS_MODID = 9,





    RTLD_DI_TLS_DATA = 10,




    RTLD_DI_PHDR = 11,

    RTLD_DI_MAX = 11
  };




typedef struct
{
  char *dls_name;
  unsigned int dls_flags;
} Dl_serpath;



typedef struct
{
  size_t dls_size;
  unsigned int dls_cnt;





  __extension__ union
  {
    Dl_serpath dls_serpath[0];
    Dl_serpath __dls_serpath_pad[1];
  };



} Dl_serinfo;

struct dl_find_object
{
  __extension__ unsigned long long int dlfo_flags;
  void *dlfo_map_start;
  void *dlfo_map_end;
  struct link_map *dlfo_link_map;
  void *dlfo_eh_frame;
# 220 "/usr/include/dlfcn.h" 3 4
  __extension__ unsigned long long int __dflo_reserved[7];
};



int _dl_find_object (void *__address, struct dl_find_object *__result) __attribute__ ((__nothrow__ ));
# 46242 "c_tests/sqlite3.c" 2
static void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename){
  (void)(NotUsed);
  return dlopen(zFilename, 0x00002 | 0x00100);
}
# 46254 "c_tests/sqlite3.c"
static void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){
  const char *zErr;
  (void)(NotUsed);
  unixEnterMutex();
  zErr = dlerror();
  if( zErr ){
    sqlite3_snprintf(nBuf, zBufOut, "%s", zErr);
  }
  unixLeaveMutex();
}
static void (*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym))(void){
# 46282 "c_tests/sqlite3.c"
  void (*(*x)(void*,const char*))(void);
  (void)(NotUsed);
  x = (void(*(*)(void*,const char*))(void))dlsym;
  return (*x)(p, zSym);
}
static void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle){
  (void)(NotUsed);
  dlclose(pHandle);
}
# 46301 "c_tests/sqlite3.c"
static int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){
  (void)(NotUsed);
  ((void) (0));
# 46317 "c_tests/sqlite3.c"
  memset(zBuf, 0, nBuf);
  randomnessPid = (pid_t)getpid();

  {
    int fd, got;
    fd = robust_open("/dev/urandom", 00, 0);
    if( fd<0 ){
      time_t t;
      time(&t);
      memcpy(zBuf, &t, sizeof(t));
      memcpy(&zBuf[sizeof(t)], &randomnessPid, sizeof(randomnessPid));
      ((void) (0));
      nBuf = sizeof(t) + sizeof(randomnessPid);
    }else{
      do{ got = ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)(fd, zBuf, nBuf); }while( got<0 && (*__errno_location ())==4 );
      robust_close(0, fd, 46332);
    }
  }

  return nBuf;
}
# 46348 "c_tests/sqlite3.c"
static int unixSleep(sqlite3_vfs *NotUsed, int microseconds){

  struct timespec sp;
  sp.tv_sec = microseconds / 1000000;
  sp.tv_nsec = (microseconds % 1000000) * 1000;





  nanosleep(&sp, ((void*)0));

  (void)(NotUsed);
  return microseconds;
# 46373 "c_tests/sqlite3.c"
}
# 46394 "c_tests/sqlite3.c"
static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow){
  static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;
  int rc = 0;
# 46406 "c_tests/sqlite3.c"
  struct timeval sNow;
  (void)gettimeofday(&sNow, 0);
  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_usec/1000;







  (void)(NotUsed);
  return rc;
}







static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){
  sqlite3_int64 i = 0;
  int rc;
  (void)(NotUsed);
  rc = unixCurrentTimeInt64(0, &i);
  *prNow = i/86400000.0;
  return rc;
}
# 46444 "c_tests/sqlite3.c"
static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){
  (void)(NotUsed);
  (void)(NotUsed2);
  (void)(NotUsed3);
  return (*__errno_location ());
}
# 47649 "c_tests/sqlite3.c"
           int sqlite3_os_init(void){
# 47702 "c_tests/sqlite3.c"
  static sqlite3_vfs aVfs[] = {





    { 3, sizeof(unixFile), 512, 0, "unix", (void*)&posixIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },

    { 3, sizeof(unixFile), 512, 0, "unix-none", (void*)&nolockIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },
    { 3, sizeof(unixFile), 512, 0, "unix-dotfile", (void*)&dotlockIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },
    { 3, sizeof(unixFile), 512, 0, "unix-excl", (void*)&posixIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },
# 47727 "c_tests/sqlite3.c"
  };
  unsigned int i;



  ((void) (0));


  for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){




    sqlite3_vfs_register(&aVfs[i], i==0);

  }



  unixBigLock = sqlite3MutexAlloc(11);






  ((void) (0));
  ((void) (0));
# 47766 "c_tests/sqlite3.c"
  ((void) (0));



  unixTempFileInit();

  return 0;
}
# 47782 "c_tests/sqlite3.c"
           int sqlite3_os_end(void){
  unixBigLock = 0;



  return 0;
}
# 54622 "c_tests/sqlite3.c"
typedef struct sqlite3_vfs MemVfs;
typedef struct MemFile MemFile;
typedef struct MemStore MemStore;
# 54667 "c_tests/sqlite3.c"
struct MemStore {
  sqlite3_int64 sz;
  sqlite3_int64 szAlloc;
  sqlite3_int64 szMax;
  unsigned char *aData;
  sqlite3_mutex *pMutex;
  int nMmap;
  unsigned mFlags;
  int nRdLock;
  int nWrLock;
  int nRef;
  char *zFName;
};


struct MemFile {
  sqlite3_file base;
  MemStore *pStore;
  int eLock;
};







static struct MemFS {
  int nMemStore;
  MemStore **apMemStore;
} memdb_g;




static int memdbClose(sqlite3_file*);
static int memdbRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
static int memdbWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);
static int memdbTruncate(sqlite3_file*, sqlite3_int64 size);
static int memdbSync(sqlite3_file*, int flags);
static int memdbFileSize(sqlite3_file*, sqlite3_int64 *pSize);
static int memdbLock(sqlite3_file*, int);
static int memdbUnlock(sqlite3_file*, int);

static int memdbFileControl(sqlite3_file*, int op, void *pArg);

static int memdbDeviceCharacteristics(sqlite3_file*);
static int memdbFetch(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);
static int memdbUnfetch(sqlite3_file*, sqlite3_int64 iOfst, void *p);




static int memdbOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);

static int memdbAccess(sqlite3_vfs*, const char *zName, int flags, int *);
static int memdbFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);
static void *memdbDlOpen(sqlite3_vfs*, const char *zFilename);
static void memdbDlError(sqlite3_vfs*, int nByte, char *zErrMsg);
static void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char*zSym))(void);
static void memdbDlClose(sqlite3_vfs*, void*);
static int memdbRandomness(sqlite3_vfs*, int nByte, char *zOut);
static int memdbSleep(sqlite3_vfs*, int microseconds);

static int memdbGetLastError(sqlite3_vfs*, int, char *);
static int memdbCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);

static sqlite3_vfs memdb_vfs = {
  2,
  0,
  1024,
  0,
  "memdb",
  0,
  memdbOpen,
  0,
  memdbAccess,
  memdbFullPathname,
  memdbDlOpen,
  memdbDlError,
  memdbDlSym,
  memdbDlClose,
  memdbRandomness,
  memdbSleep,
  0,
  memdbGetLastError,
  memdbCurrentTimeInt64,
  0,
  0,
  0,
};

static const sqlite3_io_methods memdb_io_methods = {
  3,
  memdbClose,
  memdbRead,
  memdbWrite,
  memdbTruncate,
  memdbSync,
  memdbFileSize,
  memdbLock,
  memdbUnlock,
  0,
  memdbFileControl,
  0,
  memdbDeviceCharacteristics,
  0,
  0,
  0,
  0,
  memdbFetch,
  memdbUnfetch
};
# 54792 "c_tests/sqlite3.c"
static void memdbEnter(MemStore *p){
  sqlite3_mutex_enter(p->pMutex);
}
static void memdbLeave(MemStore *p){
  sqlite3_mutex_leave(p->pMutex);
}
# 54807 "c_tests/sqlite3.c"
static int memdbClose(sqlite3_file *pFile){
  MemStore *p = ((MemFile*)pFile)->pStore;
  if( p->zFName ){
    int i;

    sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(11);

    sqlite3_mutex_enter(pVfsMutex);
    for(i=0; (i<memdb_g.nMemStore); i++){
      if( memdb_g.apMemStore[i]==p ){
        memdbEnter(p);
        if( p->nRef==1 ){
          memdb_g.apMemStore[i] = memdb_g.apMemStore[--memdb_g.nMemStore];
          if( memdb_g.nMemStore==0 ){
            sqlite3_free(memdb_g.apMemStore);
            memdb_g.apMemStore = 0;
          }
        }
        break;
      }
    }
    sqlite3_mutex_leave(pVfsMutex);
  }else{
    memdbEnter(p);
  }
  p->nRef--;
  if( p->nRef<=0 ){
    if( p->mFlags & 1 ){
      sqlite3_free(p->aData);
    }
    memdbLeave(p);
    sqlite3_mutex_free(p->pMutex);
    sqlite3_free(p);
  }else{
    memdbLeave(p);
  }
  return 0;
}




static int memdbRead(
  sqlite3_file *pFile,
  void *zBuf,
  int iAmt,
  sqlite_int64 iOfst
){
  MemStore *p = ((MemFile*)pFile)->pStore;
  memdbEnter(p);
  if( iOfst+iAmt>p->sz ){
    memset(zBuf, 0, iAmt);
    if( iOfst<p->sz ) memcpy(zBuf, p->aData+iOfst, p->sz - iOfst);
    memdbLeave(p);
    return (10 | (2<<8));
  }
  memcpy(zBuf, p->aData+iOfst, iAmt);
  memdbLeave(p);
  return 0;
}




static int memdbEnlarge(MemStore *p, sqlite3_int64 newSz){
  unsigned char *pNew;
  if( (p->mFlags & 2)==0 || (p->nMmap>0) ){
    return 13;
  }
  if( newSz>p->szMax ){
    return 13;
  }
  newSz *= 2;
  if( newSz>p->szMax ) newSz = p->szMax;
  pNew = sqlite3Realloc(p->aData, newSz);
  if( pNew==0 ) return (10 | (12<<8));
  p->aData = pNew;
  p->szAlloc = newSz;
  return 0;
}




static int memdbWrite(
  sqlite3_file *pFile,
  const void *z,
  int iAmt,
  sqlite_int64 iOfst
){
  MemStore *p = ((MemFile*)pFile)->pStore;
  memdbEnter(p);
  if( (p->mFlags & 4) ){


    memdbLeave(p);
    return (10 | (3<<8));
  }
  if( iOfst+iAmt>p->sz ){
    int rc;
    if( iOfst+iAmt>p->szAlloc
     && (rc = memdbEnlarge(p, iOfst+iAmt))!=0
    ){
      memdbLeave(p);
      return rc;
    }
    if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);
    p->sz = iOfst+iAmt;
  }
  memcpy(p->aData+iOfst, z, iAmt);
  memdbLeave(p);
  return 0;
}
# 54928 "c_tests/sqlite3.c"
static int memdbTruncate(sqlite3_file *pFile, sqlite_int64 size){
  MemStore *p = ((MemFile*)pFile)->pStore;
  int rc = 0;
  memdbEnter(p);
  if( size>p->sz ){

    rc = 11;
  }else{
    p->sz = size;
  }
  memdbLeave(p);
  return rc;
}




static int memdbSync(sqlite3_file *pFile, int flags){
  (void)(pFile);
  (void)(flags);
  return 0;
}




static int memdbFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){
  MemStore *p = ((MemFile*)pFile)->pStore;
  memdbEnter(p);
  *pSize = p->sz;
  memdbLeave(p);
  return 0;
}




static int memdbLock(sqlite3_file *pFile, int eLock){
  MemFile *pThis = (MemFile*)pFile;
  MemStore *p = pThis->pStore;
  int rc = 0;
  if( eLock<=pThis->eLock ) return 0;
  memdbEnter(p);

  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( eLock>1 && (p->mFlags & 4) ){
    rc = 8;
  }else{
    switch( eLock ){
      case 1: {
        ((void) (0));
        if( p->nWrLock>0 ){
          rc = 5;
        }else{
          p->nRdLock++;
        }
        break;
      };

      case 2:
      case 3: {
        ((void) (0));
        if( (pThis->eLock==1) ){
          if( p->nWrLock>0 ){
            rc = 5;
          }else{
            p->nWrLock = 1;
          }
        }
        break;
      }

      default: {
        ((void) (0));
        ((void) (0));
        if( p->nRdLock>1 ){
          rc = 5;
        }else if( pThis->eLock==1 ){
          p->nWrLock = 1;
        }
        break;
      }
    }
  }
  if( rc==0 ) pThis->eLock = eLock;
  memdbLeave(p);
  return rc;
}




static int memdbUnlock(sqlite3_file *pFile, int eLock){
  MemFile *pThis = (MemFile*)pFile;
  MemStore *p = pThis->pStore;
  if( eLock>=pThis->eLock ) return 0;
  memdbEnter(p);

  ((void) (0));
  if( eLock==1 ){
    if( (pThis->eLock>1) ){
      p->nWrLock--;
    }
  }else{
    if( pThis->eLock>1 ){
      p->nWrLock--;
    }
    p->nRdLock--;
  }

  pThis->eLock = eLock;
  memdbLeave(p);
  return 0;
}
# 55061 "c_tests/sqlite3.c"
static int memdbFileControl(sqlite3_file *pFile, int op, void *pArg){
  MemStore *p = ((MemFile*)pFile)->pStore;
  int rc = 12;
  memdbEnter(p);
  if( op==12 ){
    *(char**)pArg = sqlite3_mprintf("memdb(%p,%lld)", p->aData, p->sz);
    rc = 0;
  }
  if( op==36 ){
    sqlite3_int64 iLimit = *(sqlite3_int64*)pArg;
    if( iLimit<p->sz ){
      if( iLimit<0 ){
        iLimit = p->szMax;
      }else{
        iLimit = p->sz;
      }
    }
    p->szMax = iLimit;
    *(sqlite3_int64*)pArg = iLimit;
    rc = 0;
  }
  memdbLeave(p);
  return rc;
}
# 55098 "c_tests/sqlite3.c"
static int memdbDeviceCharacteristics(sqlite3_file *pFile){
  (void)(pFile);
  return 0x00000001 |
         0x00001000 |
         0x00000200 |
         0x00000400;
}


static int memdbFetch(
  sqlite3_file *pFile,
  sqlite3_int64 iOfst,
  int iAmt,
  void **pp
){
  MemStore *p = ((MemFile*)pFile)->pStore;
  memdbEnter(p);
  if( iOfst+iAmt>p->sz || (p->mFlags & 2)!=0 ){
    *pp = 0;
  }else{
    p->nMmap++;
    *pp = (void*)(p->aData + iOfst);
  }
  memdbLeave(p);
  return 0;
}


static int memdbUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){
  MemStore *p = ((MemFile*)pFile)->pStore;
  (void)(iOfst);
  (void)(pPage);
  memdbEnter(p);
  p->nMmap--;
  memdbLeave(p);
  return 0;
}




static int memdbOpen(
  sqlite3_vfs *pVfs,
  const char *zName,
  sqlite3_file *pFd,
  int flags,
  int *pOutFlags
){
  MemFile *pFile = (MemFile*)pFd;
  MemStore *p = 0;
  int szName;
  (void)(pVfs);

  memset(pFile, 0, sizeof(*pFile));
  szName = sqlite3Strlen30(zName);
  if( szName>1 && (zName[0]=='/' || zName[0]=='\\') ){
    int i;

    sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(11);

    sqlite3_mutex_enter(pVfsMutex);
    for(i=0; i<memdb_g.nMemStore; i++){
      if( strcmp(memdb_g.apMemStore[i]->zFName,zName)==0 ){
        p = memdb_g.apMemStore[i];
        break;
      }
    }
    if( p==0 ){
      MemStore **apNew;
      p = sqlite3Malloc( sizeof(*p) + (i64)szName + 3 );
      if( p==0 ){
        sqlite3_mutex_leave(pVfsMutex);
        return 7;
      }
      apNew = sqlite3Realloc(memdb_g.apMemStore,
                             sizeof(apNew[0])*(1+(i64)memdb_g.nMemStore) );
      if( apNew==0 ){
        sqlite3_free(p);
        sqlite3_mutex_leave(pVfsMutex);
        return 7;
      }
      apNew[memdb_g.nMemStore++] = p;
      memdb_g.apMemStore = apNew;
      memset(p, 0, sizeof(*p));
      p->mFlags = 2|1;
      p->szMax = sqlite3Config.mxMemdbSize;
      p->zFName = (char*)&p[1];
      memcpy(p->zFName, zName, szName+1);
      p->pMutex = sqlite3_mutex_alloc(0);
      if( p->pMutex==0 ){
        memdb_g.nMemStore--;
        sqlite3_free(p);
        sqlite3_mutex_leave(pVfsMutex);
        return 7;
      }
      p->nRef = 1;
      memdbEnter(p);
    }else{
      memdbEnter(p);
      p->nRef++;
    }
    sqlite3_mutex_leave(pVfsMutex);
  }else{
    p = sqlite3Malloc( sizeof(*p) );
    if( p==0 ){
      return 7;
    }
    memset(p, 0, sizeof(*p));
    p->mFlags = 2 | 1;
    p->szMax = sqlite3Config.mxMemdbSize;
  }
  pFile->pStore = p;
  if( pOutFlags!=0 ){
    *pOutFlags = flags | 0x00000080;
  }
  pFd->pMethods = &memdb_io_methods;
  memdbLeave(p);
  return 0;
}
# 55236 "c_tests/sqlite3.c"
static int memdbAccess(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int flags,
  int *pResOut
){
  (void)(pVfs);
  (void)(zPath);
  (void)(flags);
  *pResOut = 0;
  return 0;
}






static int memdbFullPathname(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int nOut,
  char *zOut
){
  (void)(pVfs);
  sqlite3_snprintf(nOut, zOut, "%s", zPath);
  return 0;
}




static void *memdbDlOpen(sqlite3_vfs *pVfs, const char *zPath){
  return ((sqlite3_vfs*)((pVfs)->pAppData))->xDlOpen(((sqlite3_vfs*)((pVfs)->pAppData)), zPath);
}






static void memdbDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){
  ((sqlite3_vfs*)((pVfs)->pAppData))->xDlError(((sqlite3_vfs*)((pVfs)->pAppData)), nByte, zErrMsg);
}




static void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){
  return ((sqlite3_vfs*)((pVfs)->pAppData))->xDlSym(((sqlite3_vfs*)((pVfs)->pAppData)), p, zSym);
}




static void memdbDlClose(sqlite3_vfs *pVfs, void *pHandle){
  ((sqlite3_vfs*)((pVfs)->pAppData))->xDlClose(((sqlite3_vfs*)((pVfs)->pAppData)), pHandle);
}





static int memdbRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
  return ((sqlite3_vfs*)((pVfs)->pAppData))->xRandomness(((sqlite3_vfs*)((pVfs)->pAppData)), nByte, zBufOut);
}





static int memdbSleep(sqlite3_vfs *pVfs, int nMicro){
  return ((sqlite3_vfs*)((pVfs)->pAppData))->xSleep(((sqlite3_vfs*)((pVfs)->pAppData)), nMicro);
}
# 55320 "c_tests/sqlite3.c"
static int memdbGetLastError(sqlite3_vfs *pVfs, int a, char *b){
  return ((sqlite3_vfs*)((pVfs)->pAppData))->xGetLastError(((sqlite3_vfs*)((pVfs)->pAppData)), a, b);
}
static int memdbCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){
  return ((sqlite3_vfs*)((pVfs)->pAppData))->xCurrentTimeInt64(((sqlite3_vfs*)((pVfs)->pAppData)), p);
}





static MemFile *memdbFromDbSchema(sqlite3 *db, const char *zSchema){
  MemFile *p = 0;
  MemStore *pStore;
  int rc = sqlite3_file_control(db, zSchema, 7, &p);
  if( rc ) return 0;
  if( p->base.pMethods!=&memdb_io_methods ) return 0;
  pStore = p->pStore;
  memdbEnter(pStore);
  if( pStore->zFName!=0 ) p = 0;
  memdbLeave(pStore);
  return p;
}




           unsigned char *sqlite3_serialize(
  sqlite3 *db,
  const char *zSchema,
  sqlite3_int64 *piSize,
  unsigned int mFlags
){
  MemFile *p;
  int iDb;
  Btree *pBt;
  sqlite3_int64 sz;
  int szPage = 0;
  sqlite3_stmt *pStmt = 0;
  unsigned char *pOut;
  char *zSql;
  int rc;
# 55370 "c_tests/sqlite3.c"
  if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;
  p = memdbFromDbSchema(db, zSchema);
  iDb = sqlite3FindDbName(db, zSchema);
  if( piSize ) *piSize = -1;
  if( iDb<0 ) return 0;
  if( p ){
    MemStore *pStore = p->pStore;
    ((void) (0));
    if( piSize ) *piSize = pStore->sz;
    if( mFlags & 0x001 ){
      pOut = pStore->aData;
    }else{
      pOut = sqlite3_malloc64( pStore->sz );
      if( pOut ) memcpy(pOut, pStore->aData, pStore->sz);
    }
    return pOut;
  }
  pBt = db->aDb[iDb].pBt;
  if( pBt==0 ) return 0;
  szPage = sqlite3BtreeGetPageSize(pBt);
  zSql = sqlite3_mprintf("PRAGMA \"%w\".page_count", zSchema);
  rc = zSql ? sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0) : 7;
  sqlite3_free(zSql);
  if( rc ) return 0;
  rc = sqlite3_step(pStmt);
  if( rc!=100 ){
    pOut = 0;
  }else{
    sz = sqlite3_column_int64(pStmt, 0)*szPage;
    if( sz==0 ){
      sqlite3_reset(pStmt);
      sqlite3_exec(db, "BEGIN IMMEDIATE; COMMIT;", 0, 0, 0);
      rc = sqlite3_step(pStmt);
      if( rc==100 ){
        sz = sqlite3_column_int64(pStmt, 0)*szPage;
      }
    }
    if( piSize ) *piSize = sz;
    if( mFlags & 0x001 ){
      pOut = 0;
    }else{
      pOut = sqlite3_malloc64( sz );
      if( pOut ){
        int nPage = sqlite3_column_int(pStmt, 0);
        Pager *pPager = sqlite3BtreePager(pBt);
        int pgno;
        for(pgno=1; pgno<=nPage; pgno++){
          DbPage *pPage = 0;
          unsigned char *pTo = pOut + szPage*(sqlite3_int64)(pgno-1);
          rc = sqlite3PagerGet(pPager, pgno, (DbPage**)&pPage, 0);
          if( rc==0 ){
            memcpy(pTo, sqlite3PagerGetData(pPage), szPage);
          }else{
            memset(pTo, 0, szPage);
          }
          sqlite3PagerUnref(pPage);
        }
      }
    }
  }
  sqlite3_finalize(pStmt);
  return pOut;
}



           int sqlite3_deserialize(
  sqlite3 *db,
  const char *zSchema,
  unsigned char *pData,
  sqlite3_int64 szDb,
  sqlite3_int64 szBuf,
  unsigned mFlags
){
  MemFile *p;
  char *zSql;
  sqlite3_stmt *pStmt = 0;
  int rc;
  int iDb;
# 55458 "c_tests/sqlite3.c"
  sqlite3_mutex_enter(db->mutex);
  if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;
  iDb = sqlite3FindDbName(db, zSchema);
                    ;
  if( iDb<2 && iDb!=0 ){
    rc = 1;
    goto end_deserialize;
  }
  zSql = sqlite3_mprintf("ATTACH x AS %Q", zSchema);
  if( zSql==0 ){
    rc = 7;
  }else{
    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
    sqlite3_free(zSql);
  }
  if( rc ) goto end_deserialize;
  db->init.iDb = (u8)iDb;
  db->init.reopenMemdb = 1;
  rc = sqlite3_step(pStmt);
  db->init.reopenMemdb = 0;
  if( rc!=101 ){
    rc = 1;
    goto end_deserialize;
  }
  p = memdbFromDbSchema(db, zSchema);
  if( p==0 ){
    rc = 1;
  }else{
    MemStore *pStore = p->pStore;
    pStore->aData = pData;
    pData = 0;
    pStore->sz = szDb;
    pStore->szAlloc = szBuf;
    pStore->szMax = szBuf;
    if( pStore->szMax<sqlite3Config.mxMemdbSize ){
      pStore->szMax = sqlite3Config.mxMemdbSize;
    }
    pStore->mFlags = mFlags;
    rc = 0;
  }

end_deserialize:
  sqlite3_finalize(pStmt);
  if( pData && (mFlags & 1)!=0 ){
    sqlite3_free(pData);
  }
  sqlite3_mutex_leave(db->mutex);
  return rc;
}




static int sqlite3IsMemdb(const sqlite3_vfs *pVfs){
  return pVfs==&memdb_vfs;
}





static int sqlite3MemdbInit(void){
  sqlite3_vfs *pLower = sqlite3_vfs_find(0);
  unsigned int sz;
  if( (pLower==0) ) return 1;
  sz = pLower->szOsFile;
  memdb_vfs.pAppData = pLower;




  if( sz<sizeof(MemFile) ) sz = sizeof(MemFile);
  memdb_vfs.szOsFile = sz;
  return sqlite3_vfs_register(&memdb_vfs, 0);
}
# 55630 "c_tests/sqlite3.c"
struct Bitvec {
  u32 iSize;
  u32 nSet;


  u32 iDivisor;



  union {
    u8 aBitmap[((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))];
    u32 aHash[((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32))];
    Bitvec *apSub[((u32)((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *)))];
  } u;
};







static Bitvec *sqlite3BitvecCreate(u32 iSize){
  Bitvec *p;
  ((void) (0));
  p = sqlite3MallocZero( sizeof(*p) );
  if( p ){
    p->iSize = iSize;
  }
  return p;
}






static int sqlite3BitvecTestNotNull(Bitvec *p, u32 i){
  ((void) (0));
  i--;
  if( i>=p->iSize ) return 0;
  while( p->iDivisor ){
    u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    p = p->u.apSub[bin];
    if (!p) {
      return 0;
    }
  }
  if( p->iSize<=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8) ){
    return (p->u.aBitmap[i/8] & (1<<(i&(8 -1))))!=0;
  } else{
    u32 h = (((i++)*1)%((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)));
    while( p->u.aHash[h] ){
      if( p->u.aHash[h]==i ) return 1;
      h = (h+1) % ((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32));
    }
    return 0;
  }
}
static int sqlite3BitvecTest(Bitvec *p, u32 i){
  return p!=0 && sqlite3BitvecTestNotNull(p,i);
}
# 55706 "c_tests/sqlite3.c"
static int sqlite3BitvecSet(Bitvec *p, u32 i){
  u32 h;
  if( p==0 ) return 0;
  ((void) (0));
  ((void) (0));
  i--;
  while((p->iSize > (((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8)) && p->iDivisor) {
    u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    if( p->u.apSub[bin]==0 ){
      p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor );
      if( p->u.apSub[bin]==0 ) return 7;
    }
    p = p->u.apSub[bin];
  }
  if( p->iSize<=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8) ){
    p->u.aBitmap[i/8] |= 1 << (i&(8 -1));
    return 0;
  }
  h = (((i++)*1)%((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)));



  if( !p->u.aHash[h] ){
    if (p->nSet<(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32))-1)) {
      goto bitvec_set_end;
    } else {
      goto bitvec_set_rehash;
    }
  }


  do {
    if( p->u.aHash[h]==i ) return 0;
    h++;
    if( h>=((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)) ) h = 0;
  } while( p->u.aHash[h] );



bitvec_set_rehash:
  if( p->nSet>=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32))/2) ){
    unsigned int j;
    int rc;
    u32 *aiValues = sqlite3DbMallocRaw(0,sizeof(p->u.aHash));
    if( aiValues==0 ){
      return 7;
    }else{
      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
      memset(p->u.apSub, 0, sizeof(p->u.apSub));
      p->iDivisor = p->iSize/((u32)((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *)));
      if( (p->iSize%((u32)((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *))))!=0 ) p->iDivisor++;
      if( p->iDivisor<(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8) ) p->iDivisor = (((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8);
      rc = sqlite3BitvecSet(p, i);
      for(j=0; j<((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)); j++){
        if( aiValues[j] ) rc |= sqlite3BitvecSet(p, aiValues[j]);
      }
      sqlite3DbFree(0,aiValues);
      return rc;
    }
  }
bitvec_set_end:
  p->nSet++;
  p->u.aHash[h] = i;
  return 0;
}







static void sqlite3BitvecClear(Bitvec *p, u32 i, void *pBuf){
  if( p==0 ) return;
  ((void) (0));
  i--;
  while( p->iDivisor ){
    u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    p = p->u.apSub[bin];
    if (!p) {
      return;
    }
  }
  if( p->iSize<=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8) ){
    p->u.aBitmap[i/8] &= ~(u8)(1<<(i&(8 -1)));
  }else{
    unsigned int j;
    u32 *aiValues = pBuf;
    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
    memset(p->u.aHash, 0, sizeof(p->u.aHash));
    p->nSet = 0;
    for(j=0; j<((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)); j++){
      if( aiValues[j] && aiValues[j]!=(i+1) ){
        u32 h = (((aiValues[j]-1)*1)%((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)));
        p->nSet++;
        while( p->u.aHash[h] ){
          h++;
          if( h>=((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)) ) h = 0;
        }
        p->u.aHash[h] = aiValues[j];
      }
    }
  }
}




static void sqlite3BitvecDestroy(Bitvec *p){
  if( p==0 ) return;
  if( p->iDivisor ){
    unsigned int i;
    for(i=0; i<((u32)((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *))); i++){
      sqlite3BitvecDestroy(p->u.apSub[i]);
    }
  }
  sqlite3_free(p);
}





static u32 sqlite3BitvecSize(Bitvec *p){
  return p->iSize;
}
# 55930 "c_tests/sqlite3.c"
static int sqlite3BitvecBuiltinTest(int sz, int *aOp){
  Bitvec *pBitvec = 0;
  unsigned char *pV = 0;
  int rc = -1;
  int i, nx, pc, op;
  void *pTmpSpace;



  if( sz<=0 ){
    pBitvec = sqlite3BitvecCreate( 2*(unsigned)(-sz) );
    pV = 0;
  }else{
    pBitvec = sqlite3BitvecCreate( sz );
    pV = sqlite3MallocZero( (7+(i64)sz)/8 + 1 );
  }
  pTmpSpace = sqlite3_malloc64(512);
  if( pBitvec==0 || pTmpSpace==0 || (pV==0 && sz>0) ) goto bitvec_end;


  sqlite3BitvecSet(0, 1);
  sqlite3BitvecClear(0, 1, pTmpSpace);


  pc = i = 0;
  while( (op = aOp[pc])!=0 ){
    if( op>=6 ){
# 55971 "c_tests/sqlite3.c"
      pc++;
      continue;
    }
    switch( op ){
      case 1:
      case 2:
      case 5: {
        nx = 4;
        i = aOp[pc+2] - 1;
        aOp[pc+2] += aOp[pc+3];
        break;
      }
      case 3:
      case 4:
      default: {
        nx = 2;
        sqlite3_randomness(sizeof(i), &i);
        break;
      }
    }
    if( (--aOp[pc+1]) > 0 ) nx = 0;
    pc += nx;
    i = (i & 0x7fffffff)%sz;
    if( (op & 1)!=0 ){
      if( pV ) pV[(i+1)>>3] |= (1<<((i+1)&7));
      if( op!=5 ){
        if( sqlite3BitvecSet(pBitvec, i+1) ) goto bitvec_end;
      }
    }else{
      if( pV ) pV[(i+1)>>3] &= ~(u8)(1<<((i+1)&7));
      sqlite3BitvecClear(pBitvec, i+1, pTmpSpace);
    }
  }






  if( pV ){
    rc = sqlite3BitvecTest(0,0) + sqlite3BitvecTest(pBitvec, sz+1)
            + sqlite3BitvecTest(pBitvec, 0)
            + (sqlite3BitvecSize(pBitvec) - sz);
    for(i=1; i<=sz; i++){
      if( ((pV[i>>3]&(1<<(i&7)))!=0)!=sqlite3BitvecTest(pBitvec,i) ){
        rc = i;
        break;
      }
    }
  }else{
    rc = 0;
  }


bitvec_end:
  sqlite3_free(pTmpSpace);
  sqlite3_free(pV);
  sqlite3BitvecDestroy(pBitvec);
  return rc;
}
# 56075 "c_tests/sqlite3.c"
struct PCache {
  PgHdr *pDirty, *pDirtyTail;
  PgHdr *pSynced;
  i64 nRefSum;
  int szCache;
  int szSpill;
  int szPage;
  int szExtra;
  u8 bPurgeable;
  u8 eCreate;
  int (*xStress)(void*,PgHdr*);
  void *pStress;
  sqlite3_pcache *pCache;
};
# 56229 "c_tests/sqlite3.c"
static void pcacheManageDirtyList(PgHdr *pPage, u8 addRemove){
  PCache *p = pPage->pCache;



                             ;
  if( addRemove & 1 ){
    ((void) (0));
    ((void) (0));


    if( p->pSynced==pPage ){
      p->pSynced = pPage->pDirtyPrev;
    }

    if( pPage->pDirtyNext ){
      pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev;
    }else{
      ((void) (0));
      p->pDirtyTail = pPage->pDirtyPrev;
    }
    if( pPage->pDirtyPrev ){
      pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext;
    }else{




      ((void) (0));
      p->pDirty = pPage->pDirtyNext;
      ((void) (0));
      if( p->pDirty==0 ){
        ((void) (0));
        p->eCreate = 2;
      }
    }
  }
  if( addRemove & 2 ){
    pPage->pDirtyPrev = 0;
    pPage->pDirtyNext = p->pDirty;
    if( pPage->pDirtyNext ){
      ((void) (0));
      pPage->pDirtyNext->pDirtyPrev = pPage;
    }else{
      p->pDirtyTail = pPage;
      if( p->bPurgeable ){
        ((void) (0));
        p->eCreate = 1;
      }
    }
    p->pDirty = pPage;






    if( !p->pSynced
     && 0==(pPage->flags&0x008)
    ){
      p->pSynced = pPage;
    }
  }
               ;
}





static void pcacheUnpin(PgHdr *p){
  if( p->pCache->bPurgeable ){
                                                      ;
    sqlite3Config.pcache2.xUnpin(p->pCache->pCache, p->pPage, 0);
                         ;
  }
}





static int numberOfCachePages(PCache *p){
  if( p->szCache>=0 ){


    return p->szCache;
  }else{
    i64 n;




    n = ((-1024*(i64)p->szCache)/(p->szPage+p->szExtra));
    if( n>1000000000 ) n = 1000000000;
    return (int)n;
  }
}






static int sqlite3PcacheInitialize(void){
  if( sqlite3Config.pcache2.xInit==0 ){



    sqlite3PCacheSetDefault();
    ((void) (0));
  }
  return sqlite3Config.pcache2.xInit(sqlite3Config.pcache2.pArg);
}
static void sqlite3PcacheShutdown(void){
  if( sqlite3Config.pcache2.xShutdown ){

    sqlite3Config.pcache2.xShutdown(sqlite3Config.pcache2.pArg);
  }
}




static int sqlite3PcacheSize(void){ return sizeof(PCache); }
# 56367 "c_tests/sqlite3.c"
static int sqlite3PcacheOpen(
  int szPage,
  int szExtra,
  int bPurgeable,
  int (*xStress)(void*,PgHdr*),
  void *pStress,
  PCache *p
){
  memset(p, 0, sizeof(PCache));
  p->szPage = 1;
  p->szExtra = szExtra;
  ((void) (0));
  p->bPurgeable = bPurgeable;
  p->eCreate = 2;
  p->xStress = xStress;
  p->pStress = pStress;
  p->szCache = 100;
  p->szSpill = 1;
                                                                        ;
  return sqlite3PcacheSetPageSize(p, szPage);
}





static int sqlite3PcacheSetPageSize(PCache *pCache, int szPage){
  ((void) (0));
  if( pCache->szPage ){
    sqlite3_pcache *pNew;
    pNew = sqlite3Config.pcache2.xCreate(
                szPage, pCache->szExtra + (((sizeof(PgHdr))+7)&~7),
                pCache->bPurgeable
    );
    if( pNew==0 ) return 7;
    sqlite3Config.pcache2.xCachesize(pNew, numberOfCachePages(pCache));
    if( pCache->pCache ){
      sqlite3Config.pcache2.xDestroy(pCache->pCache);
    }
    pCache->pCache = pNew;
    pCache->szPage = szPage;
                                                   ;
  }
  return 0;
}
# 56437 "c_tests/sqlite3.c"
static sqlite3_pcache_page *sqlite3PcacheFetch(
  PCache *pCache,
  Pgno pgno,
  int createFlag
){
  int eCreate;
  sqlite3_pcache_page *pRes;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
# 56457 "c_tests/sqlite3.c"
  eCreate = createFlag & pCache->eCreate;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pRes = sqlite3Config.pcache2.xFetch(pCache->pCache, pgno, eCreate);

                                             ;
                             ;
  return pRes;
}
# 56479 "c_tests/sqlite3.c"
static int sqlite3PcacheFetchStress(
  PCache *pCache,
  Pgno pgno,
  sqlite3_pcache_page **ppPage
){
  PgHdr *pPg;
  if( pCache->eCreate==2 ) return 0;

  if( sqlite3PcachePagecount(pCache)>pCache->szSpill ){
# 56497 "c_tests/sqlite3.c"
    for(pPg=pCache->pSynced;
        pPg && (pPg->nRef || (pPg->flags&0x008));
        pPg=pPg->pDirtyPrev
    );
    pCache->pSynced = pPg;
    if( !pPg ){
      for(pPg=pCache->pDirtyTail; pPg && pPg->nRef; pPg=pPg->pDirtyPrev);
    }
    if( pPg ){
      int rc;







                                                     ;
      rc = pCache->xStress(pCache->pStress, pPg);
                        ;
      if( rc!=0 && rc!=5 ){
        return rc;
      }
    }
  }
  *ppPage = sqlite3Config.pcache2.xFetch(pCache->pCache, pgno, 2);
  return *ppPage==0 ? 7 : 0;
}
# 56535 "c_tests/sqlite3.c"
static __attribute__((noinline)) PgHdr *pcacheFetchFinishWithInit(
  PCache *pCache,
  Pgno pgno,
  sqlite3_pcache_page *pPage
){
  PgHdr *pPgHdr;
  ((void) (0));
  pPgHdr = (PgHdr*)pPage->pExtra;
  ((void) (0));
  memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - __builtin_offsetof(PgHdr, pDirty));
  pPgHdr->pPage = pPage;
  pPgHdr->pData = pPage->pBuf;
  pPgHdr->pExtra = (void *)&pPgHdr[1];
  memset(pPgHdr->pExtra, 0, 8);
  ((void) (0));
  pPgHdr->pCache = pCache;
  pPgHdr->pgno = pgno;
  pPgHdr->flags = 0x001;
  return sqlite3PcacheFetchFinish(pCache,pgno,pPage);
}







static PgHdr *sqlite3PcacheFetchFinish(
  PCache *pCache,
  Pgno pgno,
  sqlite3_pcache_page *pPage
){
  PgHdr *pPgHdr;

  ((void) (0));
  pPgHdr = (PgHdr *)pPage->pExtra;

  if( !pPgHdr->pPage ){
    return pcacheFetchFinishWithInit(pCache, pgno, pPage);
  }
  pCache->nRefSum++;
  pPgHdr->nRef++;
  ((void) (0));
  return pPgHdr;
}





static void __attribute__((noinline)) sqlite3PcacheRelease(PgHdr *p){
  ((void) (0));
  p->pCache->nRefSum--;
  if( (--p->nRef)==0 ){
    if( p->flags&0x001 ){
      pcacheUnpin(p);
    }else{
      pcacheManageDirtyList(p, 3);
      ((void) (0));
    }
  }
}




static void sqlite3PcacheRef(PgHdr *p){
  ((void) (0));
  ((void) (0));
  p->nRef++;
  p->pCache->nRefSum++;
}






static void sqlite3PcacheDrop(PgHdr *p){
  ((void) (0));
  ((void) (0));
  if( p->flags&0x002 ){
    pcacheManageDirtyList(p, 1);
  }
  p->pCache->nRefSum--;
  sqlite3Config.pcache2.xUnpin(p->pCache->pCache, p->pPage, 1);
}





static void sqlite3PcacheMakeDirty(PgHdr *p){
  ((void) (0));
  ((void) (0));
  if( p->flags & (0x001|0x010) ){
    p->flags &= ~0x010;
    if( p->flags & 0x001 ){
      p->flags ^= (0x002|0x001);
                                                      ;
      ((void) (0));
      pcacheManageDirtyList(p, 2);
      ((void) (0));
    }
    ((void) (0));
  }
}





static void sqlite3PcacheMakeClean(PgHdr *p){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pcacheManageDirtyList(p, 1);
  p->flags &= ~(0x002|0x008|0x004);
  p->flags |= 0x001;
                                                  ;
  ((void) (0));
  if( p->nRef==0 ){
    pcacheUnpin(p);
  }
}




static void sqlite3PcacheCleanAll(PCache *pCache){
  PgHdr *p;
                                        ;
  while( (p = pCache->pDirty)!=0 ){
    sqlite3PcacheMakeClean(p);
  }
}




static void sqlite3PcacheClearWritable(PCache *pCache){
  PgHdr *p;
                                              ;
  for(p=pCache->pDirty; p; p=p->pDirtyNext){
    p->flags &= ~(0x008|0x004);
  }
  pCache->pSynced = pCache->pDirtyTail;
}




static void sqlite3PcacheClearSyncFlags(PCache *pCache){
  PgHdr *p;
  for(p=pCache->pDirty; p; p=p->pDirtyNext){
    p->flags &= ~0x008;
  }
  pCache->pSynced = pCache->pDirtyTail;
}




static void sqlite3PcacheMove(PgHdr *p, Pgno newPgno){
  PCache *pCache = p->pCache;
  sqlite3_pcache_page *pOther;
  ((void) (0));
  ((void) (0));
  ((void) (0));
                                                            ;
  pOther = sqlite3Config.pcache2.xFetch(pCache->pCache, newPgno, 0);
  if( pOther ){
    PgHdr *pXPage = (PgHdr*)pOther->pExtra;
    ((void) (0));
    pXPage->nRef++;
    pCache->nRefSum++;
    sqlite3PcacheDrop(pXPage);
  }
  sqlite3Config.pcache2.xRekey(pCache->pCache, p->pPage, p->pgno,newPgno);
  p->pgno = newPgno;
  if( (p->flags&0x002) && (p->flags&0x008) ){
    pcacheManageDirtyList(p, 3);
    ((void) (0));
  }
}
# 56730 "c_tests/sqlite3.c"
static void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){
  if( pCache->pCache ){
    PgHdr *p;
    PgHdr *pNext;
                                                 ;
    for(p=pCache->pDirty; p; p=pNext){
      pNext = p->pDirtyNext;




      ((void) (0));
      if( p->pgno>pgno ){
        ((void) (0));
        sqlite3PcacheMakeClean(p);
      }
    }
    if( pgno==0 && pCache->nRefSum ){
      sqlite3_pcache_page *pPage1;
      pPage1 = sqlite3Config.pcache2.xFetch(pCache->pCache,1,0);
      if( (pPage1) ){

        memset(pPage1->pBuf, 0, pCache->szPage);
        pgno = 1;
      }
    }
    sqlite3Config.pcache2.xTruncate(pCache->pCache, pgno+1);
  }
}




static void sqlite3PcacheClose(PCache *pCache){
  ((void) (0));
                                    ;
  sqlite3Config.pcache2.xDestroy(pCache->pCache);
}




static void sqlite3PcacheClear(PCache *pCache){
  sqlite3PcacheTruncate(pCache, 0);
}





static PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){
  PgHdr result, *pTail;
  pTail = &result;
  ((void) (0));
  for(;;){
    if( pA->pgno<pB->pgno ){
      pTail->pDirty = pA;
      pTail = pA;
      pA = pA->pDirty;
      if( pA==0 ){
        pTail->pDirty = pB;
        break;
      }
    }else{
      pTail->pDirty = pB;
      pTail = pB;
      pB = pB->pDirty;
      if( pB==0 ){
        pTail->pDirty = pA;
        break;
      }
    }
  }
  return result.pDirty;
}
# 56817 "c_tests/sqlite3.c"
static PgHdr *pcacheSortDirtyList(PgHdr *pIn){
  PgHdr *a[32], *p;
  int i;
  memset(a, 0, sizeof(a));
  while( pIn ){
    p = pIn;
    pIn = p->pDirty;
    p->pDirty = 0;
    for(i=0; (i<32 -1); i++){
      if( a[i]==0 ){
        a[i] = p;
        break;
      }else{
        p = pcacheMergeDirtyList(a[i], p);
        a[i] = 0;
      }
    }
    if( (i==32 -1) ){



      a[i] = pcacheMergeDirtyList(a[i], p);
    }
  }
  p = a[0];
  for(i=1; i<32; i++){
    if( a[i]==0 ) continue;
    p = p ? pcacheMergeDirtyList(p, a[i]) : a[i];
  }
  return p;
}




static PgHdr *sqlite3PcacheDirtyList(PCache *pCache){
  PgHdr *p;
  for(p=pCache->pDirty; p; p=p->pDirtyNext){
    p->pDirty = p->pDirtyNext;
  }
  return pcacheSortDirtyList(pCache->pDirty);
}







static i64 sqlite3PcacheRefCount(PCache *pCache){
  return pCache->nRefSum;
}




static i64 sqlite3PcachePageRefcount(PgHdr *p){
  return p->nRef;
}




static int sqlite3PcachePagecount(PCache *pCache){
  ((void) (0));
  return sqlite3Config.pcache2.xPagecount(pCache->pCache);
}
# 56897 "c_tests/sqlite3.c"
static void sqlite3PcacheSetCachesize(PCache *pCache, int mxPage){
  ((void) (0));
  pCache->szCache = mxPage;
  sqlite3Config.pcache2.xCachesize(pCache->pCache,
                                         numberOfCachePages(pCache));
}






static int sqlite3PcacheSetSpillsize(PCache *p, int mxPage){
  int res;
  ((void) (0));
  if( mxPage ){
    if( mxPage<0 ){
      mxPage = (int)((-1024*(i64)mxPage)/(p->szPage+p->szExtra));
    }
    p->szSpill = mxPage;
  }
  res = numberOfCachePages(p);
  if( res<p->szSpill ) res = p->szSpill;
  return res;
}




static void sqlite3PcacheShrink(PCache *pCache){
  ((void) (0));
  sqlite3Config.pcache2.xShrink(pCache->pCache);
}





static int sqlite3HeaderSizePcache(void){ return (((sizeof(PgHdr))+7)&~7); }





static int sqlite3PCachePercentDirty(PCache *pCache){
  PgHdr *pDirty;
  int nDirty = 0;
  int nCache = numberOfCachePages(pCache);
  for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext) nDirty++;
  return nCache ? (int)(((i64)nDirty * 100) / nCache) : 0;
}





static int sqlite3PCacheIsDirty(PCache *pCache){
  return (pCache->pDirty!=0);
}
# 57059 "c_tests/sqlite3.c"
typedef struct PCache1 PCache1;
typedef struct PgHdr1 PgHdr1;
typedef struct PgFreeslot PgFreeslot;
typedef struct PGroup PGroup;
# 57090 "c_tests/sqlite3.c"
struct PgHdr1 {
  sqlite3_pcache_page page;
  unsigned int iKey;
  u16 isBulkLocal;
  u16 isAnchor;
  PgHdr1 *pNext;
  PCache1 *pCache;
  PgHdr1 *pLruNext;
  PgHdr1 *pLruPrev;

};
# 57131 "c_tests/sqlite3.c"
struct PGroup {
  sqlite3_mutex *mutex;
  unsigned int nMaxPage;
  unsigned int nMinPage;
  unsigned int mxPinned;
  unsigned int nPurgeable;
  PgHdr1 lru;
};
# 57148 "c_tests/sqlite3.c"
struct PCache1 {






  PGroup *pGroup;
  unsigned int *pnPurgeable;
  int szPage;
  int szExtra;
  int szAlloc;
  int bPurgeable;
  unsigned int nMin;
  unsigned int nMax;
  unsigned int n90pct;
  unsigned int iMaxKey;
  unsigned int nPurgeableDummy;




  unsigned int nRecyclable;
  unsigned int nPage;
  unsigned int nHash;
  PgHdr1 **apHash;
  PgHdr1 *pFree;
  void *pBulk;
};





struct PgFreeslot {
  PgFreeslot *pNext;
};




static struct PCacheGlobal {
  PGroup grp;






  int isInit;
  int separateCache;
  int nInitPage;
  int szSlot;
  int nSlot;
  int nReserve;
  void *pStart, *pEnd;

  sqlite3_mutex *mutex;
  PgFreeslot *pFree;
  int nFreeSlot;
  int bUnderPressure;
} pcache1_g;
# 57244 "c_tests/sqlite3.c"
static void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){
  if( (pcache1_g).isInit ){
    PgFreeslot *p;
    if( pBuf==0 ) sz = n = 0;
    if( n==0 ) sz = 0;
    sz = ((sz)&~7);
    (pcache1_g).szSlot = sz;
    (pcache1_g).nSlot = (pcache1_g).nFreeSlot = n;
    (pcache1_g).nReserve = n>90 ? 10 : (n/10 + 1);
    (pcache1_g).pStart = pBuf;
    (pcache1_g).pFree = 0;
    __atomic_store_n((&(pcache1_g).bUnderPressure),(0),0);
    while( n-- ){
      p = (PgFreeslot*)pBuf;
      p->pNext = (pcache1_g).pFree;
      (pcache1_g).pFree = p;
      pBuf = (void*)&((char*)pBuf)[sz];
    }
    (pcache1_g).pEnd = pBuf;
  }
}





static int pcache1InitBulk(PCache1 *pCache){
  i64 szBulk;
  char *zBulk;
  if( (pcache1_g).nInitPage==0 ) return 0;

  if( pCache->nMax<3 ) return 0;
  sqlite3BeginBenignMalloc();
  if( (pcache1_g).nInitPage>0 ){
    szBulk = pCache->szAlloc * (i64)(pcache1_g).nInitPage;
  }else{
    szBulk = -1024 * (i64)(pcache1_g).nInitPage;
  }
  if( szBulk > pCache->szAlloc*(i64)pCache->nMax ){
    szBulk = pCache->szAlloc*(i64)pCache->nMax;
  }
  zBulk = pCache->pBulk = sqlite3Malloc( szBulk );
  sqlite3EndBenignMalloc();
  if( zBulk ){
    int nBulk = sqlite3MallocSize(zBulk)/pCache->szAlloc;
    do{
      PgHdr1 *pX = (PgHdr1*)&zBulk[pCache->szPage];
      pX->page.pBuf = zBulk;
      pX->page.pExtra = (u8*)pX + (((sizeof(*pX))+7)&~7);
      ((void) (0));
      pX->isBulkLocal = 1;
      pX->isAnchor = 0;
      pX->pNext = pCache->pFree;
      pX->pLruPrev = 0;
      pCache->pFree = pX;
      zBulk += pCache->szAlloc;
    }while( --nBulk );
  }
  return pCache->pFree!=0;
}
# 57314 "c_tests/sqlite3.c"
static void *pcache1Alloc(int nByte){
  void *p = 0;
  ((void) (0));
  if( nByte<=(pcache1_g).szSlot ){
    sqlite3_mutex_enter((pcache1_g).mutex);
    p = (PgHdr1 *)(pcache1_g).pFree;
    if( p ){
      (pcache1_g).pFree = (pcache1_g).pFree->pNext;
      (pcache1_g).nFreeSlot--;
      __atomic_store_n((&(pcache1_g).bUnderPressure),((pcache1_g).nFreeSlot<(pcache1_g).nReserve),0);
      ((void) (0));
      sqlite3StatusHighwater(7, nByte);
      sqlite3StatusUp(1, 1);
    }
    sqlite3_mutex_leave((pcache1_g).mutex);
  }
  if( p==0 ){



    p = sqlite3Malloc(nByte);

    if( p ){
      int sz = sqlite3MallocSize(p);
      sqlite3_mutex_enter((pcache1_g).mutex);
      sqlite3StatusHighwater(7, nByte);
      sqlite3StatusUp(2, sz);
      sqlite3_mutex_leave((pcache1_g).mutex);
    }

                                             ;
  }
  return p;
}




static void pcache1Free(void *p){
  if( p==0 ) return;
  if( (((uptr)(p)>=(uptr)((pcache1_g).pStart))&&((uptr)(p)<(uptr)((pcache1_g).pEnd))) ){
    PgFreeslot *pSlot;
    sqlite3_mutex_enter((pcache1_g).mutex);
    sqlite3StatusDown(1, 1);
    pSlot = (PgFreeslot*)p;
    pSlot->pNext = (pcache1_g).pFree;
    (pcache1_g).pFree = pSlot;
    (pcache1_g).nFreeSlot++;
    __atomic_store_n((&(pcache1_g).bUnderPressure),((pcache1_g).nFreeSlot<(pcache1_g).nReserve),0);
    ((void) (0));
    sqlite3_mutex_leave((pcache1_g).mutex);
  }else{
    ((void) (0));
                                           ;

    {
      int nFreed = 0;
      nFreed = sqlite3MallocSize(p);
      sqlite3_mutex_enter((pcache1_g).mutex);
      sqlite3StatusDown(2, nFreed);
      sqlite3_mutex_leave((pcache1_g).mutex);
    }

    sqlite3_free(p);
  }
}
# 57402 "c_tests/sqlite3.c"
static PgHdr1 *pcache1AllocPage(PCache1 *pCache, int benignMalloc){
  PgHdr1 *p = 0;
  void *pPg;

  ((void) (0));
  if( pCache->pFree || (pCache->nPage==0 && pcache1InitBulk(pCache)) ){
    ((void) (0));
    p = pCache->pFree;
    pCache->pFree = p->pNext;
    p->pNext = 0;
  }else{
# 57421 "c_tests/sqlite3.c"
    if( benignMalloc ){ sqlite3BeginBenignMalloc(); }
    pPg = pcache1Alloc(pCache->szAlloc);
    if( benignMalloc ){ sqlite3EndBenignMalloc(); }



    if( pPg==0 ) return 0;
    p = (PgHdr1 *)&((u8 *)pPg)[pCache->szPage];
    p->page.pBuf = pPg;
    p->page.pExtra = (u8*)p + (((sizeof(*p))+7)&~7);
    ((void) (0));
    p->isBulkLocal = 0;
    p->isAnchor = 0;
    p->pLruPrev = 0;
  }
  (*pCache->pnPurgeable)++;
  return p;
}




static void pcache1FreePage(PgHdr1 *p){
  PCache1 *pCache;
  ((void) (0));
  pCache = p->pCache;
  ((void) (0));
  if( p->isBulkLocal ){
    p->pNext = pCache->pFree;
    pCache->pFree = p;
  }else{
    pcache1Free(p->page.pBuf);
  }
  (*pCache->pnPurgeable)--;
}






static void *sqlite3PageMalloc(int sz){
  ((void) (0));
  return pcache1Alloc(sz);
}




static void sqlite3PageFree(void *p){
  pcache1Free(p);
}
# 57491 "c_tests/sqlite3.c"
static int pcache1UnderMemoryPressure(PCache1 *pCache){
  if( (pcache1_g).nSlot && (pCache->szPage+pCache->szExtra)<=(pcache1_g).szSlot ){
    return __atomic_load_n((&(pcache1_g).bUnderPressure),0);
  }else{
    return sqlite3HeapNearlyFull();
  }
}
# 57508 "c_tests/sqlite3.c"
static void pcache1ResizeHash(PCache1 *p){
  PgHdr1 **apNew;
  u64 nNew;
  u32 i;

  ((void) (0));

  nNew = 2*(u64)p->nHash;
  if( nNew<256 ){
    nNew = 256;
  }

  ((void) (0));
  if( p->nHash ){ sqlite3BeginBenignMalloc(); }
  apNew = (PgHdr1 **)sqlite3MallocZero(sizeof(PgHdr1 *)*nNew);
  if( p->nHash ){ sqlite3EndBenignMalloc(); }
  ((void) (0));
  if( apNew ){
    for(i=0; i<p->nHash; i++){
      PgHdr1 *pPage;
      PgHdr1 *pNext = p->apHash[i];
      while( (pPage = pNext)!=0 ){
        unsigned int h = pPage->iKey % nNew;
        pNext = pPage->pNext;
        pPage->pNext = apNew[h];
        apNew[h] = pPage;
      }
    }
    sqlite3_free(p->apHash);
    p->apHash = apNew;
    p->nHash = nNew;
  }
}
# 57549 "c_tests/sqlite3.c"
static PgHdr1 *pcache1PinPage(PgHdr1 *pPage){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pPage->pLruPrev->pLruNext = pPage->pLruNext;
  pPage->pLruNext->pLruPrev = pPage->pLruPrev;
  pPage->pLruNext = 0;


  ((void) (0));
  ((void) (0));
  pPage->pCache->nRecyclable--;
  return pPage;
}
# 57574 "c_tests/sqlite3.c"
static void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag){
  unsigned int h;
  PCache1 *pCache = pPage->pCache;
  PgHdr1 **pp;

  ((void) (0));
  h = pPage->iKey % pCache->nHash;
  for(pp=&pCache->apHash[h]; (*pp)!=pPage; pp=&(*pp)->pNext);
  *pp = (*pp)->pNext;

  pCache->nPage--;
  if( freeFlag ) pcache1FreePage(pPage);
}





static void pcache1EnforceMaxPage(PCache1 *pCache){
  PGroup *pGroup = pCache->pGroup;
  PgHdr1 *p;
  ((void) (0));
  while( pGroup->nPurgeable>pGroup->nMaxPage
      && (p=pGroup->lru.pLruPrev)->isAnchor==0
  ){
    ((void) (0));
    ((void) (0));
    pcache1PinPage(p);
    pcache1RemoveFromHash(p, 1);
  }
  if( pCache->nPage==0 && pCache->pBulk ){
    sqlite3_free(pCache->pBulk);
    pCache->pBulk = pCache->pFree = 0;
  }
}
# 57617 "c_tests/sqlite3.c"
static void pcache1TruncateUnsafe(
  PCache1 *pCache,
  unsigned int iLimit
){

  unsigned int h, iStop;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pCache->iMaxKey - iLimit < pCache->nHash ){




    h = iLimit % pCache->nHash;
    iStop = pCache->iMaxKey % pCache->nHash;

  }else{


    h = pCache->nHash/2;
    iStop = h - 1;
  }
  for(;;){
    PgHdr1 **pp;
    PgHdr1 *pPage;
    ((void) (0));
    pp = &pCache->apHash[h];
    while( (pPage = *pp)!=0 ){
      if( pPage->iKey>=iLimit ){
        pCache->nPage--;
        *pp = pPage->pNext;
        if( ((pPage)->pLruNext!=0) ) pcache1PinPage(pPage);
        pcache1FreePage(pPage);
      }else{
        pp = &pPage->pNext;

      }
    }
    if( h==iStop ) break;
    h = (h+1) % pCache->nHash;
  }
  ((void) (0));
}







static int pcache1Init(void *NotUsed){
  (void)(NotUsed);
  ((void) (0));
  memset(&(pcache1_g), 0, sizeof((pcache1_g)));
# 57691 "c_tests/sqlite3.c"
  (pcache1_g).separateCache = sqlite3Config.pPage==0
                          || sqlite3Config.bCoreMutex>0;





  if( sqlite3Config.bCoreMutex ){
    (pcache1_g).grp.mutex = sqlite3MutexAlloc(6);
    (pcache1_g).mutex = sqlite3MutexAlloc(7);
  }

  if( (pcache1_g).separateCache
   && sqlite3Config.nPage!=0
   && sqlite3Config.pPage==0
  ){
    (pcache1_g).nInitPage = sqlite3Config.nPage;
  }else{
    (pcache1_g).nInitPage = 0;
  }
  (pcache1_g).grp.mxPinned = 10;
  (pcache1_g).isInit = 1;
  return 0;
}






static void pcache1Shutdown(void *NotUsed){
  (void)(NotUsed);
  ((void) (0));
  memset(&(pcache1_g), 0, sizeof((pcache1_g)));
}


static void pcache1Destroy(sqlite3_pcache *p);






static sqlite3_pcache *pcache1Create(int szPage, int szExtra, int bPurgeable){
  PCache1 *pCache;
  PGroup *pGroup;
  i64 sz;

  ((void) (0));
  ((void) (0));

  sz = sizeof(PCache1) + sizeof(PGroup)*(pcache1_g).separateCache;
  pCache = (PCache1 *)sqlite3MallocZero(sz);
  if( pCache ){
    if( (pcache1_g).separateCache ){
      pGroup = (PGroup*)&pCache[1];
      pGroup->mxPinned = 10;
    }else{
      pGroup = &(pcache1_g).grp;
    }
    ((void) (0));
    if( pGroup->lru.isAnchor==0 ){
      pGroup->lru.isAnchor = 1;
      pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;
    }
    pCache->pGroup = pGroup;
    pCache->szPage = szPage;
    pCache->szExtra = szExtra;
    pCache->szAlloc = szPage + szExtra + (((sizeof(PgHdr1))+7)&~7);
    pCache->bPurgeable = (bPurgeable ? 1 : 0);
    pcache1ResizeHash(pCache);
    if( bPurgeable ){
      pCache->nMin = 10;
      pGroup->nMinPage += pCache->nMin;
      pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
      pCache->pnPurgeable = &pGroup->nPurgeable;
    }else{
      pCache->pnPurgeable = &pCache->nPurgeableDummy;
    }
    ((void) (0));
    if( pCache->nHash==0 ){
      pcache1Destroy((sqlite3_pcache*)pCache);
      pCache = 0;
    }
  }
  return (sqlite3_pcache *)pCache;
}






static void pcache1Cachesize(sqlite3_pcache *p, int nMax){
  PCache1 *pCache = (PCache1 *)p;
  u32 n;
  ((void) (0));
  if( pCache->bPurgeable ){
    PGroup *pGroup = pCache->pGroup;
    ((void) (0));
    n = (u32)nMax;
    if( n > 0x7fff0000 - pGroup->nMaxPage + pCache->nMax ){
      n = 0x7fff0000 - pGroup->nMaxPage + pCache->nMax;
    }
    pGroup->nMaxPage += (n - pCache->nMax);
    pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
    pCache->nMax = n;
    pCache->n90pct = pCache->nMax*9/10;
    pcache1EnforceMaxPage(pCache);
    ((void) (0));
  }
}






static void pcache1Shrink(sqlite3_pcache *p){
  PCache1 *pCache = (PCache1*)p;
  if( pCache->bPurgeable ){
    PGroup *pGroup = pCache->pGroup;
    unsigned int savedMaxPage;
    ((void) (0));
    savedMaxPage = pGroup->nMaxPage;
    pGroup->nMaxPage = 0;
    pcache1EnforceMaxPage(pCache);
    pGroup->nMaxPage = savedMaxPage;
    ((void) (0));
  }
}




static int pcache1Pagecount(sqlite3_pcache *p){
  int n;
  PCache1 *pCache = (PCache1*)p;
  ((void) (0));
  n = pCache->nPage;
  ((void) (0));
  return n;
}
# 57845 "c_tests/sqlite3.c"
static __attribute__((noinline)) PgHdr1 *pcache1FetchStage2(
  PCache1 *pCache,
  unsigned int iKey,
  int createFlag
){
  unsigned int nPinned;
  PGroup *pGroup = pCache->pGroup;
  PgHdr1 *pPage = 0;


  ((void) (0));
  nPinned = pCache->nPage - pCache->nRecyclable;
  ((void) (0));
  ((void) (0));
  if( createFlag==1 && (
        nPinned>=pGroup->mxPinned
     || nPinned>=pCache->n90pct
     || (pcache1UnderMemoryPressure(pCache) && pCache->nRecyclable<nPinned)
  )){
    return 0;
  }

  if( pCache->nPage>=pCache->nHash ) pcache1ResizeHash(pCache);
  ((void) (0));


  if( pCache->bPurgeable
   && !pGroup->lru.pLruPrev->isAnchor
   && ((pCache->nPage+1>=pCache->nMax) || pcache1UnderMemoryPressure(pCache))
  ){
    PCache1 *pOther;
    pPage = pGroup->lru.pLruPrev;
    ((void) (0));
    pcache1RemoveFromHash(pPage, 0);
    pcache1PinPage(pPage);
    pOther = pPage->pCache;
    if( pOther->szAlloc != pCache->szAlloc ){
      pcache1FreePage(pPage);
      pPage = 0;
    }else{
      pGroup->nPurgeable -= (pOther->bPurgeable - pCache->bPurgeable);
    }
  }




  if( !pPage ){
    pPage = pcache1AllocPage(pCache, createFlag==1);
  }

  if( pPage ){
    unsigned int h = iKey % pCache->nHash;
    pCache->nPage++;
    pPage->iKey = iKey;
    pPage->pNext = pCache->apHash[h];
    pPage->pCache = pCache;
    pPage->pLruNext = 0;


    *(void **)pPage->page.pExtra = 0;
    pCache->apHash[h] = pPage;
    if( iKey>pCache->iMaxKey ){
      pCache->iMaxKey = iKey;
    }
  }
  return pPage;
}
# 57973 "c_tests/sqlite3.c"
static PgHdr1 *pcache1FetchNoMutex(
  sqlite3_pcache *p,
  unsigned int iKey,
  int createFlag
){
  PCache1 *pCache = (PCache1 *)p;
  PgHdr1 *pPage = 0;


  pPage = pCache->apHash[iKey % pCache->nHash];
  while( pPage && pPage->iKey!=iKey ){ pPage = pPage->pNext; }





  if( pPage ){
    if( ((pPage)->pLruNext!=0) ){
      return pcache1PinPage(pPage);
    }else{
      return pPage;
    }
  }else if( createFlag ){

    return pcache1FetchStage2(pCache, iKey, createFlag);
  }else{
    return 0;
  }
}
# 58018 "c_tests/sqlite3.c"
static sqlite3_pcache_page *pcache1Fetch(
  sqlite3_pcache *p,
  unsigned int iKey,
  int createFlag
){




  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  {
    return (sqlite3_pcache_page*)pcache1FetchNoMutex(p, iKey, createFlag);
  }
}







static void pcache1Unpin(
  sqlite3_pcache *p,
  sqlite3_pcache_page *pPg,
  int reuseUnlikely
){
  PCache1 *pCache = (PCache1 *)p;
  PgHdr1 *pPage = (PgHdr1 *)pPg;
  PGroup *pGroup = pCache->pGroup;

  ((void) (0));
  ((void) (0));




  ((void) (0));
  ((void) (0));

  if( reuseUnlikely || pGroup->nPurgeable>pGroup->nMaxPage ){
    pcache1RemoveFromHash(pPage, 1);
  }else{

    PgHdr1 **ppFirst = &pGroup->lru.pLruNext;
    pPage->pLruPrev = &pGroup->lru;
    (pPage->pLruNext = *ppFirst)->pLruPrev = pPage;
    *ppFirst = pPage;
    pCache->nRecyclable++;
  }

  ((void) (0));
}




static void pcache1Rekey(
  sqlite3_pcache *p,
  sqlite3_pcache_page *pPg,
  unsigned int iOld,
  unsigned int iNew
){
  PCache1 *pCache = (PCache1 *)p;
  PgHdr1 *pPage = (PgHdr1 *)pPg;
  PgHdr1 **pp;
  unsigned int hOld, hNew;
  ((void) (0));
  ((void) (0));
  ((void) (0));

  ((void) (0));

  ((void) (0));
  hOld = iOld%pCache->nHash;
  pp = &pCache->apHash[hOld];
  while( (*pp)!=pPage ){
    pp = &(*pp)->pNext;
  }
  *pp = pPage->pNext;

  ((void) (0));
  hNew = iNew%pCache->nHash;
  pPage->iKey = iNew;
  pPage->pNext = pCache->apHash[hNew];
  pCache->apHash[hNew] = pPage;
  if( iNew>pCache->iMaxKey ){
    pCache->iMaxKey = iNew;
  }

  ((void) (0));
}
# 58127 "c_tests/sqlite3.c"
static void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit){
  PCache1 *pCache = (PCache1 *)p;
  ((void) (0));
  if( iLimit<=pCache->iMaxKey ){
    pcache1TruncateUnsafe(pCache, iLimit);
    pCache->iMaxKey = iLimit-1;
  }
  ((void) (0));
}






static void pcache1Destroy(sqlite3_pcache *p){
  PCache1 *pCache = (PCache1 *)p;
  PGroup *pGroup = pCache->pGroup;
  ((void) (0));
  ((void) (0));
  if( pCache->nPage ) pcache1TruncateUnsafe(pCache, 0);
  ((void) (0));
  pGroup->nMaxPage -= pCache->nMax;
  ((void) (0));
  pGroup->nMinPage -= pCache->nMin;
  pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
  pcache1EnforceMaxPage(pCache);
  ((void) (0));
  sqlite3_free(pCache->pBulk);
  sqlite3_free(pCache->apHash);
  sqlite3_free(pCache);
}






static void sqlite3PCacheSetDefault(void){
  static const sqlite3_pcache_methods2 defaultMethods = {
    1,
    0,
    pcache1Init,
    pcache1Shutdown,
    pcache1Create,
    pcache1Cachesize,
    pcache1Pagecount,
    pcache1Fetch,
    pcache1Unpin,
    pcache1Rekey,
    pcache1Truncate,
    pcache1Destroy,
    pcache1Shrink
  };
  sqlite3_config(18, &defaultMethods);
}




static int sqlite3HeaderSizePcache1(void){ return (((sizeof(PgHdr1))+7)&~7); }





static sqlite3_mutex *sqlite3Pcache1Mutex(void){
  return (pcache1_g).mutex;
}
# 58340 "c_tests/sqlite3.c"
struct RowSetEntry {
  i64 v;
  struct RowSetEntry *pRight;
  struct RowSetEntry *pLeft;
};







struct RowSetChunk {
  struct RowSetChunk *pNextChunk;
  struct RowSetEntry aEntry[((1024 -8)/sizeof(struct RowSetEntry))];
};






struct RowSet {
  struct RowSetChunk *pChunk;
  sqlite3 *db;
  struct RowSetEntry *pEntry;
  struct RowSetEntry *pLast;
  struct RowSetEntry *pFresh;
  struct RowSetEntry *pForest;
  u16 nFresh;
  u16 rsFlags;
  int iBatch;
};
# 58384 "c_tests/sqlite3.c"
static RowSet *sqlite3RowSetInit(sqlite3 *db){
  RowSet *p = sqlite3DbMallocRawNN(db, sizeof(*p));
  if( p ){
    int N = sqlite3DbMallocSize(db, p);
    p->pChunk = 0;
    p->db = db;
    p->pEntry = 0;
    p->pLast = 0;
    p->pForest = 0;
    p->pFresh = (struct RowSetEntry*)((((sizeof(*p))+7)&~7) + (char*)p);
    p->nFresh = (u16)((N - (((sizeof(*p))+7)&~7))/sizeof(struct RowSetEntry));
    p->rsFlags = 0x01;
    p->iBatch = 0;
  }
  return p;
}






static void sqlite3RowSetClear(void *pArg){
  RowSet *p = (RowSet*)pArg;
  struct RowSetChunk *pChunk, *pNextChunk;
  for(pChunk=p->pChunk; pChunk; pChunk = pNextChunk){
    pNextChunk = pChunk->pNextChunk;
    sqlite3DbFree(p->db, pChunk);
  }
  p->pChunk = 0;
  p->nFresh = 0;
  p->pEntry = 0;
  p->pLast = 0;
  p->pForest = 0;
  p->rsFlags = 0x01;
}






static void sqlite3RowSetDelete(void *pArg){
  sqlite3RowSetClear(pArg);
  sqlite3DbFree(((RowSet*)pArg)->db, pArg);
}
# 58439 "c_tests/sqlite3.c"
static struct RowSetEntry *rowSetEntryAlloc(RowSet *p){
  ((void) (0));
  if( p->nFresh==0 ){


    struct RowSetChunk *pNew;
    pNew = sqlite3DbMallocRawNN(p->db, sizeof(*pNew));
    if( pNew==0 ){
      return 0;
    }
    pNew->pNextChunk = p->pChunk;
    p->pChunk = pNew;
    p->pFresh = pNew->aEntry;
    p->nFresh = ((1024 -8)/sizeof(struct RowSetEntry));
  }
  p->nFresh--;
  return p->pFresh++;
}







static void sqlite3RowSetInsert(RowSet *p, i64 rowid){
  struct RowSetEntry *pEntry;
  struct RowSetEntry *pLast;


  ((void) (0));

  pEntry = rowSetEntryAlloc(p);
  if( pEntry==0 ) return;
  pEntry->v = rowid;
  pEntry->pRight = 0;
  pLast = p->pLast;
  if( pLast ){
    if( rowid<=pLast->v ){


      p->rsFlags &= ~0x01;
    }
    pLast->pRight = pEntry;
  }else{
    p->pEntry = pEntry;
  }
  p->pLast = pEntry;
}







static struct RowSetEntry *rowSetEntryMerge(
  struct RowSetEntry *pA,
  struct RowSetEntry *pB
){
  struct RowSetEntry head;
  struct RowSetEntry *pTail;

  pTail = &head;
  ((void) (0));
  for(;;){
    ((void) (0));
    ((void) (0));
    if( pA->v<=pB->v ){
      if( pA->v<pB->v ) pTail = pTail->pRight = pA;
      pA = pA->pRight;
      if( pA==0 ){
        pTail->pRight = pB;
        break;
      }
    }else{
      pTail = pTail->pRight = pB;
      pB = pB->pRight;
      if( pB==0 ){
        pTail->pRight = pA;
        break;
      }
    }
  }
  return head.pRight;
}





static struct RowSetEntry *rowSetEntrySort(struct RowSetEntry *pIn){
  unsigned int i;
  struct RowSetEntry *pNext, *aBucket[40];

  memset(aBucket, 0, sizeof(aBucket));
  while( pIn ){
    pNext = pIn->pRight;
    pIn->pRight = 0;
    for(i=0; aBucket[i]; i++){
      pIn = rowSetEntryMerge(aBucket[i], pIn);
      aBucket[i] = 0;
    }
    aBucket[i] = pIn;
    pIn = pNext;
  }
  pIn = aBucket[0];
  for(i=1; i<sizeof(aBucket)/sizeof(aBucket[0]); i++){
    if( aBucket[i]==0 ) continue;
    pIn = pIn ? rowSetEntryMerge(pIn, aBucket[i]) : aBucket[i];
  }
  return pIn;
}







static void rowSetTreeToList(
  struct RowSetEntry *pIn,
  struct RowSetEntry **ppFirst,
  struct RowSetEntry **ppLast
){
  ((void) (0));
  if( pIn->pLeft ){
    struct RowSetEntry *p;
    rowSetTreeToList(pIn->pLeft, ppFirst, &p);
    p->pRight = pIn;
  }else{
    *ppFirst = pIn;
  }
  if( pIn->pRight ){
    rowSetTreeToList(pIn->pRight, &pIn->pRight, ppLast);
  }else{
    *ppLast = pIn;
  }
  ((void) (0));
}
# 58594 "c_tests/sqlite3.c"
static struct RowSetEntry *rowSetNDeepTree(
  struct RowSetEntry **ppList,
  int iDepth
){
  struct RowSetEntry *p;
  struct RowSetEntry *pLeft;
  if( *ppList==0 ){

    return 0;
  }
  if( iDepth>1 ){



    pLeft = rowSetNDeepTree(ppList, iDepth-1);
    p = *ppList;
    if( p==0 ){


      return pLeft;
    }
    p->pLeft = pLeft;
    *ppList = p->pRight;
    p->pRight = rowSetNDeepTree(ppList, iDepth-1);
  }else{
    p = *ppList;
    *ppList = p->pRight;
    p->pLeft = p->pRight = 0;
  }
  return p;
}





static struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList){
  int iDepth;
  struct RowSetEntry *p;
  struct RowSetEntry *pLeft;

  ((void) (0));
  p = pList;
  pList = p->pRight;
  p->pLeft = p->pRight = 0;
  for(iDepth=1; pList; iDepth++){
    pLeft = p;
    p = pList;
    pList = p->pRight;
    p->pLeft = pLeft;
    p->pRight = rowSetNDeepTree(&pList, iDepth);
  }
  return p;
}
# 58662 "c_tests/sqlite3.c"
static int sqlite3RowSetNext(RowSet *p, i64 *pRowid){
  ((void) (0));
  ((void) (0));


  if( (p->rsFlags & 0x02)==0 ){
    if( (p->rsFlags & 0x01)==0 ){
      p->pEntry = rowSetEntrySort(p->pEntry);
    }
    p->rsFlags |= 0x01|0x02;
  }


  if( p->pEntry ){
    *pRowid = p->pEntry->v;
    p->pEntry = p->pEntry->pRight;
    if( p->pEntry==0 ){

      sqlite3RowSetClear(p);
    }
    return 1;
  }else{
    return 0;
  }
}
# 58696 "c_tests/sqlite3.c"
static int sqlite3RowSetTest(RowSet *pRowSet, int iBatch, sqlite3_int64 iRowid){
  struct RowSetEntry *p, *pTree;


  ((void) (0));




  if( iBatch!=pRowSet->iBatch ){
    p = pRowSet->pEntry;
    if( p ){
      struct RowSetEntry **ppPrevTree = &pRowSet->pForest;
      if( (pRowSet->rsFlags & 0x01)==0 ){

        p = rowSetEntrySort(p);
      }
      for(pTree = pRowSet->pForest; pTree; pTree=pTree->pRight){
        ppPrevTree = &pTree->pRight;
        if( pTree->pLeft==0 ){
          pTree->pLeft = rowSetListToTree(p);
          break;
        }else{
          struct RowSetEntry *pAux, *pTail;
          rowSetTreeToList(pTree->pLeft, &pAux, &pTail);
          pTree->pLeft = 0;
          p = rowSetEntryMerge(pAux, p);
        }
      }
      if( pTree==0 ){
        *ppPrevTree = pTree = rowSetEntryAlloc(pRowSet);
        if( pTree ){
          pTree->v = 0;
          pTree->pRight = 0;
          pTree->pLeft = rowSetListToTree(p);
        }
      }
      pRowSet->pEntry = 0;
      pRowSet->pLast = 0;
      pRowSet->rsFlags |= 0x01;
    }
    pRowSet->iBatch = iBatch;
  }




  for(pTree = pRowSet->pForest; pTree; pTree=pTree->pRight){
    p = pTree->pLeft;
    while( p ){
      if( p->v<iRowid ){
        p = p->pRight;
      }else if( p->v>iRowid ){
        p = p->pLeft;
      }else{
        return 1;
      }
    }
  }
  return 0;
}
# 58839 "c_tests/sqlite3.c"
typedef struct Wal Wal;


static int sqlite3WalOpen(sqlite3_vfs*, sqlite3_file*, const char *, int, i64, Wal**);
static int sqlite3WalClose(Wal *pWal, sqlite3*, int sync_flags, int, u8 *);


static void sqlite3WalLimit(Wal*, i64);
# 58855 "c_tests/sqlite3.c"
static int sqlite3WalBeginReadTransaction(Wal *pWal, int *);
static void sqlite3WalEndReadTransaction(Wal *pWal);


static int sqlite3WalFindFrame(Wal *, Pgno, u32 *);
static int sqlite3WalReadFrame(Wal *, u32, int, u8 *);


static Pgno sqlite3WalDbsize(Wal *pWal);


static int sqlite3WalBeginWriteTransaction(Wal *pWal);
static int sqlite3WalEndWriteTransaction(Wal *pWal);


static int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx);



static void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData);



static int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData);


static int sqlite3WalFrames(Wal *pWal, int, PgHdr *, Pgno, int, int);


static int sqlite3WalCheckpoint(
  Wal *pWal,
  sqlite3 *db,
  int eMode,
  int (*xBusy)(void*),
  void *pBusyArg,
  int sync_flags,
  int nBuf,
  u8 *zBuf,
  int *pnLog,
  int *pnCkpt
);






static int sqlite3WalCallback(Wal *pWal);




static int sqlite3WalExclusiveMode(Wal *pWal, int op);





static int sqlite3WalHeapMemory(Wal *pWal);
# 58931 "c_tests/sqlite3.c"
static sqlite3_file *sqlite3WalFile(Wal *pWal);
# 59354 "c_tests/sqlite3.c"
typedef struct PagerSavepoint PagerSavepoint;
struct PagerSavepoint {
  i64 iOffset;
  i64 iHdrOffset;
  Bitvec *pInSavepoint;
  Pgno nOrig;
  Pgno iSubRec;
  int bTruncateOnRelease;

  u32 aWalData[4];

};
# 59542 "c_tests/sqlite3.c"
struct Pager {
  sqlite3_vfs *pVfs;
  u8 exclusiveMode;
  u8 journalMode;
  u8 useJournal;
  u8 noSync;
  u8 fullSync;
  u8 extraSync;
  u8 syncFlags;
  u8 walSyncFlags;
  u8 tempFile;
  u8 noLock;
  u8 readOnly;
  u8 memDb;
  u8 memVfs;
# 59567 "c_tests/sqlite3.c"
  u8 eState;
  u8 eLock;
  u8 changeCountDone;
  u8 setSuper;
  u8 doNotSpill;
  u8 subjInMemory;
  u8 bUseFetch;
  u8 hasHeldSharedLock;
  Pgno dbSize;
  Pgno dbOrigSize;
  Pgno dbFileSize;
  Pgno dbHintSize;
  int errCode;
  int nRec;
  u32 cksumInit;
  u32 nSubRec;
  Bitvec *pInJournal;
  sqlite3_file *fd;
  sqlite3_file *jfd;
  sqlite3_file *sjfd;
  i64 journalOff;
  i64 journalHdr;
  sqlite3_backup *pBackup;
  PagerSavepoint *aSavepoint;
  int nSavepoint;
  u32 iDataVersion;
  char dbFileVers[16];

  int nMmapOut;
  sqlite3_int64 szMmap;
  PgHdr *pMmapFreelist;




  u16 nExtra;
  i16 nReserve;
  u32 vfsFlags;
  u32 sectorSize;
  Pgno mxPgno;
  Pgno lckPgno;
  i64 pageSize;
  i64 journalSizeLimit;
  char *zFilename;
  char *zJournal;
  int (*xBusyHandler)(void*);
  void *pBusyHandlerArg;
  u32 aStat[4];



  void (*xReiniter)(DbPage*);
  int (*xGet)(Pager*,Pgno,DbPage**,int);
  char *pTmpSpace;
  PCache *pPCache;

  Wal *pWal;
  char *zWal;




};
# 59680 "c_tests/sqlite3.c"
static const unsigned char aJournalMagic[] = {
  0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7,
};
# 59728 "c_tests/sqlite3.c"
static int sqlite3PagerDirectReadOk(Pager *pPager, Pgno pgno){
  ((void) (0));
  ((void) (0));
  if( pPager->fd->pMethods==0 ) return 0;
  if( sqlite3PCacheIsDirty(pPager->pPCache) ) return 0;

  if( pPager->pWal ){
    u32 iRead = 0;
    (void)sqlite3WalFindFrame(pPager->pWal, pgno, &iRead);
    if( iRead ) return 0;
  }

  ((void) (0));
  if( (pPager->fd->pMethods->xDeviceCharacteristics(pPager->fd)
        & 0x00008000)==0 ){
    return 0;
  }
  return 1;
}
# 59956 "c_tests/sqlite3.c"
static int getPageNormal(Pager*,Pgno,DbPage**,int);
static int getPageError(Pager*,Pgno,DbPage**,int);

static int getPageMMap(Pager*,Pgno,DbPage**,int);






static void setGetterMethod(Pager *pPager){
  if( pPager->errCode ){
    pPager->xGet = getPageError;

  }else if( ((pPager)->bUseFetch) ){
    pPager->xGet = getPageMMap;

  }else{
    pPager->xGet = getPageNormal;
  }
}
# 59987 "c_tests/sqlite3.c"
static int subjRequiresPage(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  PagerSavepoint *p;
  Pgno pgno = pPg->pgno;
  int i;
  for(i=0; i<pPager->nSavepoint; i++){
    p = &pPager->aSavepoint[i];
    if( p->nOrig>=pgno && 0==sqlite3BitvecTestNotNull(p->pInSavepoint, pgno) ){
      for(i=i+1; i<pPager->nSavepoint; i++){
        pPager->aSavepoint[i].bTruncateOnRelease = 0;
      }
      return 1;
    }
  }
  return 0;
}
# 60020 "c_tests/sqlite3.c"
static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){
  unsigned char ac[4];
  int rc = sqlite3OsRead(fd, ac, sizeof(ac), offset);
  if( rc==0 ){
    *pRes = sqlite3Get4byte(ac);
  }
  return rc;
}
# 60039 "c_tests/sqlite3.c"
static int write32bits(sqlite3_file *fd, i64 offset, u32 val){
  char ac[4];
  sqlite3Put4byte((u8*)ac,val);
  return sqlite3OsWrite(fd, ac, 4, offset);
}
# 60054 "c_tests/sqlite3.c"
static int pagerUnlockDb(Pager *pPager, int eLock){
  int rc = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( ((pPager->fd)->pMethods!=0) ){
    ((void) (0));
    rc = pPager->noLock ? 0 : sqlite3OsUnlock(pPager->fd, eLock);
    if( pPager->eLock!=(4 +1) ){
      pPager->eLock = (u8)eLock;
    }

  }
  pPager->changeCountDone = pPager->tempFile;
  return rc;
}
# 60082 "c_tests/sqlite3.c"
static int pagerLockDb(Pager *pPager, int eLock){
  int rc = 0;

  ((void) (0));
  if( pPager->eLock<eLock || pPager->eLock==(4 +1) ){
    rc = pPager->noLock ? 0 : sqlite3OsLock(pPager->fd, eLock);
    if( rc==0 && (pPager->eLock!=(4 +1)||eLock==4) ){
      pPager->eLock = (u8)eLock;

    }
  }
  return rc;
}
# 60115 "c_tests/sqlite3.c"
static int jrnlBufferSize(Pager *pPager){
  ((void) (0));
# 60125 "c_tests/sqlite3.c"
  (void)(pPager);
# 60149 "c_tests/sqlite3.c"
  return 0;
}
# 60220 "c_tests/sqlite3.c"
static int readSuperJournal(sqlite3_file *pJrnl, char *zSuper, u64 nSuper){
  int rc;
  u32 len;
  i64 szJ;
  u32 cksum;
  u32 u;
  unsigned char aMagic[8];
  zSuper[0] = '\0';

  if( 0!=(rc = sqlite3OsFileSize(pJrnl, &szJ))
   || szJ<16
   || 0!=(rc = read32bits(pJrnl, szJ-16, &len))
   || len>=nSuper
   || len>szJ-16
   || len==0
   || 0!=(rc = read32bits(pJrnl, szJ-12, &cksum))
   || 0!=(rc = sqlite3OsRead(pJrnl, aMagic, 8, szJ-8))
   || memcmp(aMagic, aJournalMagic, 8)
   || 0!=(rc = sqlite3OsRead(pJrnl, zSuper, len, szJ-16-len))
  ){
    return rc;
  }


  for(u=0; u<len; u++){
    cksum -= zSuper[u];
  }
  if( cksum ){





    len = 0;
  }
  zSuper[len] = '\0';
  zSuper[len+1] = '\0';

  return 0;
}
# 60276 "c_tests/sqlite3.c"
static i64 journalHdrOffset(Pager *pPager){
  i64 offset = 0;
  i64 c = pPager->journalOff;
  if( c ){
    offset = ((c-1)/(pPager->sectorSize) + 1) * (pPager->sectorSize);
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return offset;
}
# 60309 "c_tests/sqlite3.c"
static int zeroJournalHdr(Pager *pPager, int doTruncate){
  int rc = 0;
  ((void) (0));
  ((void) (0));
  if( pPager->journalOff ){
    const i64 iLimit = pPager->journalSizeLimit;


    if( doTruncate || iLimit==0 ){
      rc = sqlite3OsTruncate(pPager->jfd, 0);
    }else{
      static const char zeroHdr[28] = {0};
      rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0);
    }
    if( rc==0 && !pPager->noSync ){
      rc = sqlite3OsSync(pPager->jfd, 0x00010|pPager->syncFlags);
    }







    if( rc==0 && iLimit>0 ){
      i64 sz;
      rc = sqlite3OsFileSize(pPager->jfd, &sz);
      if( rc==0 && sz>iLimit ){
        rc = sqlite3OsTruncate(pPager->jfd, iLimit);
      }
    }
  }
  return rc;
}
# 60359 "c_tests/sqlite3.c"
static int writeJournalHdr(Pager *pPager){
  int rc = 0;
  char *zHeader = pPager->pTmpSpace;
  u32 nHeader = (u32)pPager->pageSize;
  u32 nWrite;
  int ii;

  ((void) (0));

  if( nHeader>(pPager->sectorSize) ){
    nHeader = (pPager->sectorSize);
  }





  for(ii=0; ii<pPager->nSavepoint; ii++){
    if( pPager->aSavepoint[ii].iHdrOffset==0 ){
      pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff;
    }
  }

  pPager->journalHdr = pPager->journalOff = journalHdrOffset(pPager);
# 60404 "c_tests/sqlite3.c"
  ((void) (0));
  if( pPager->noSync || (pPager->journalMode==4)
   || (sqlite3OsDeviceCharacteristics(pPager->fd)&0x00000200)
  ){
    memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
    sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)],0xffffffff);
  }else{
    memset(zHeader, 0, sizeof(aJournalMagic)+4);
  }




  if( pPager->journalMode!=4 ){
    sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);
  }
# 60438 "c_tests/sqlite3.c"
  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+4],pPager->cksumInit);


  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+8],pPager->dbOrigSize);

  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+12],pPager->sectorSize);


  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+16],pPager->pageSize);






  memset(&zHeader[sizeof(aJournalMagic)+20], 0,
         nHeader-(sizeof(aJournalMagic)+20));
# 60473 "c_tests/sqlite3.c"
  for(nWrite=0; rc==0&&nWrite<(pPager->sectorSize); nWrite+=nHeader){

    rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff);
    ((void) (0));
    pPager->journalOff += nHeader;
  }

  return rc;
}
# 60500 "c_tests/sqlite3.c"
static int readJournalHdr(
  Pager *pPager,
  int isHot,
  i64 journalSize,
  u32 *pNRec,
  u32 *pDbSize
){
  int rc;
  unsigned char aMagic[8];
  i64 iHdrOff;

  ((void) (0));





  pPager->journalOff = journalHdrOffset(pPager);
  if( pPager->journalOff+(pPager->sectorSize) > journalSize ){
    return 101;
  }
  iHdrOff = pPager->journalOff;






  if( isHot || iHdrOff!=pPager->journalHdr ){
    rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff);
    if( rc ){
      return rc;
    }
    if( memcmp(aMagic, aJournalMagic, sizeof(aMagic))!=0 ){
      return 101;
    }
  }





  if( 0!=(rc = read32bits(pPager->jfd, iHdrOff+8, pNRec))
   || 0!=(rc = read32bits(pPager->jfd, iHdrOff+12, &pPager->cksumInit))
   || 0!=(rc = read32bits(pPager->jfd, iHdrOff+16, pDbSize))
  ){
    return rc;
  }

  if( pPager->journalOff==0 ){
    u32 iPageSize;
    u32 iSectorSize;


    if( 0!=(rc = read32bits(pPager->jfd, iHdrOff+20, &iSectorSize))
     || 0!=(rc = read32bits(pPager->jfd, iHdrOff+24, &iPageSize))
    ){
      return rc;
    }





    if( iPageSize==0 ){
      iPageSize = pPager->pageSize;
    }






    if( iPageSize<512 || iSectorSize<32
     || iPageSize>65536 || iSectorSize>0x10000
     || ((iPageSize-1)&iPageSize)!=0 || ((iSectorSize-1)&iSectorSize)!=0
    ){





      return 101;
    }





    rc = sqlite3PagerSetPagesize(pPager, &iPageSize, -1);
                             ;







    pPager->sectorSize = iSectorSize;
  }

  pPager->journalOff += (pPager->sectorSize);
  return rc;
}
# 60625 "c_tests/sqlite3.c"
static int writeSuperJournal(Pager *pPager, const char *zSuper){
  int rc;
  int nSuper;
  i64 iHdrOff;
  i64 jrnlSize;
  u32 cksum = 0;

  ((void) (0));
  ((void) (0));

  if( !zSuper
   || pPager->journalMode==4
   || !((pPager->jfd)->pMethods!=0)
  ){
    return 0;
  }
  pPager->setSuper = 1;
  ((void) (0));


  for(nSuper=0; zSuper[nSuper]; nSuper++){
    cksum += zSuper[nSuper];
  }





  if( pPager->fullSync ){
    pPager->journalOff = journalHdrOffset(pPager);
  }
  iHdrOff = pPager->journalOff;




  if( (0 != (rc = write32bits(pPager->jfd, iHdrOff, ((pPager)->lckPgno))))
   || (0 != (rc = sqlite3OsWrite(pPager->jfd, zSuper, nSuper, iHdrOff+4)))
   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nSuper, nSuper)))
   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nSuper+4, cksum)))
   || (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8,
                                 iHdrOff+4+nSuper+8)))
  ){
    return rc;
  }
  pPager->journalOff += (nSuper+20);
# 60682 "c_tests/sqlite3.c"
  if( 0==(rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))
   && jrnlSize>pPager->journalOff
  ){
    rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);
  }
  return rc;
}




static void pager_reset(Pager *pPager){
  pPager->iDataVersion++;
  sqlite3BackupRestart(pPager->pBackup);
  sqlite3PcacheClear(pPager->pPCache);
}




static u32 sqlite3PagerDataVersion(Pager *pPager){
  return pPager->iDataVersion;
}






static void releaseAllSavepoints(Pager *pPager){
  int ii;
  for(ii=0; ii<pPager->nSavepoint; ii++){
    sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
  }
  if( !pPager->exclusiveMode || sqlite3JournalIsInMemory(pPager->sjfd) ){
    sqlite3OsClose(pPager->sjfd);
  }
  sqlite3_free(pPager->aSavepoint);
  pPager->aSavepoint = 0;
  pPager->nSavepoint = 0;
  pPager->nSubRec = 0;
}






static int addToSavepointBitvecs(Pager *pPager, Pgno pgno){
  int ii;
  int rc = 0;

  for(ii=0; ii<pPager->nSavepoint; ii++){
    PagerSavepoint *p = &pPager->aSavepoint[ii];
    if( pgno<=p->nOrig ){
      rc |= sqlite3BitvecSet(p->pInSavepoint, pgno);
                                  ;
      ((void) (0));
    }
  }
  return rc;
}
# 60762 "c_tests/sqlite3.c"
static void pager_unlock(Pager *pPager){

  ((void) (0));




  sqlite3BitvecDestroy(pPager->pInJournal);
  pPager->pInJournal = 0;
  releaseAllSavepoints(pPager);

  if( ((pPager)->pWal!=0) ){
    ((void) (0));
    if( pPager->eState==6 ){






      (void)sqlite3WalEndWriteTransaction(pPager->pWal);
    }
    sqlite3WalEndReadTransaction(pPager->pWal);
    pPager->eState = 0;
  }else if( !pPager->exclusiveMode ){
    int rc;
    int iDc = ((pPager->fd)->pMethods!=0)?sqlite3OsDeviceCharacteristics(pPager->fd):0;






    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    if( 0==(iDc & 0x00000800)
     || 1!=(pPager->journalMode & 5)
    ){
      sqlite3OsClose(pPager->jfd);
    }






    rc = pagerUnlockDb(pPager, 0);
    if( rc!=0 && pPager->eState==6 ){
      pPager->eLock = (4 +1);
    }





    ((void) (0));
    pPager->eState = 0;
  }






  ((void) (0));
  if( pPager->errCode ){
    if( pPager->tempFile==0 ){
      pager_reset(pPager);
      pPager->changeCountDone = 0;
      pPager->eState = 0;
    }else{
      pPager->eState = (((pPager->jfd)->pMethods!=0) ? 0 : 1);
    }
    if( ((pPager)->bUseFetch) ) sqlite3OsUnfetch(pPager->fd, 0, 0);
    pPager->errCode = 0;
    setGetterMethod(pPager);
  }

  pPager->journalOff = 0;
  pPager->journalHdr = 0;
  pPager->setSuper = 0;
}
# 60868 "c_tests/sqlite3.c"
static int pager_error(Pager *pPager, int rc){
  int rc2 = rc & 0xff;
  ((void) (0));
  ((void) (0));




  if( rc2==13 || rc2==10 ){
    pPager->errCode = rc;
    pPager->eState = 6;
    setGetterMethod(pPager);
  }
  return rc;
}

static int pager_truncate(Pager *pPager, Pgno nPage);
# 60902 "c_tests/sqlite3.c"
static int pagerFlushOnCommit(Pager *pPager, int bCommit){
  if( pPager->tempFile==0 ) return 1;
  if( !bCommit ) return 0;
  if( !((pPager->fd)->pMethods!=0) ) return 0;
  return (sqlite3PCachePercentDirty(pPager->pPCache)>=25);
}
# 60962 "c_tests/sqlite3.c"
static int pager_end_transaction(Pager *pPager, int hasSuper, int bCommit){
  int rc = 0;
  int rc2 = 0;
# 60979 "c_tests/sqlite3.c"
  ((void) (0));
  ((void) (0));
  if( pPager->eState<2 && pPager->eLock<2 ){
    return 0;
  }

  releaseAllSavepoints(pPager);
  ((void) (0));


  if( ((pPager->jfd)->pMethods!=0) ){
    ((void) (0));


    if( sqlite3JournalIsInMemory(pPager->jfd) ){

      sqlite3OsClose(pPager->jfd);
    }else if( pPager->journalMode==3 ){
      if( pPager->journalOff==0 ){
        rc = 0;
      }else{
        rc = sqlite3OsTruncate(pPager->jfd, 0);
        if( rc==0 && pPager->fullSync ){





          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
        }
      }
      pPager->journalOff = 0;
    }else if( pPager->journalMode==1
      || (pPager->exclusiveMode && pPager->journalMode<5)
    ){
      rc = zeroJournalHdr(pPager, hasSuper||pPager->tempFile);
      pPager->journalOff = 0;
    }else{





      int bDelete = !pPager->tempFile;
      ((void) (0));
      ((void) (0));



      sqlite3OsClose(pPager->jfd);
      if( bDelete ){
        rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, pPager->extraSync);
      }
    }
  }
# 61046 "c_tests/sqlite3.c"
  sqlite3BitvecDestroy(pPager->pInJournal);
  pPager->pInJournal = 0;
  pPager->nRec = 0;
  if( rc==0 ){
    if( pPager->memDb || pagerFlushOnCommit(pPager, bCommit) ){
      sqlite3PcacheCleanAll(pPager->pPCache);
    }else{
      sqlite3PcacheClearWritable(pPager->pPCache);
    }
    sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);
  }

  if( ((pPager)->pWal!=0) ){




    rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);
    ((void) (0));
  }else if( rc==0 && bCommit && pPager->dbFileSize>pPager->dbSize ){






    ((void) (0));
    rc = pager_truncate(pPager, pPager->dbSize);
  }

  if( rc==0 && bCommit ){
    rc = sqlite3OsFileControl(pPager->fd, 22, 0);
    if( rc==12 ) rc = 0;
  }

  if( !pPager->exclusiveMode
   && (!((pPager)->pWal!=0) || sqlite3WalExclusiveMode(pPager->pWal, 0))
  ){
    rc2 = pagerUnlockDb(pPager, 1);
  }
  pPager->eState = 1;
  pPager->setSuper = 0;

  return (rc==0?rc2:rc);
}


static int pager_playback(Pager *pPager, int isHot);
# 61112 "c_tests/sqlite3.c"
static void pagerUnlockAndRollback(Pager *pPager){
  if( pPager->eState!=6 && pPager->eState!=0 ){
    ((void) (0));
    if( pPager->eState>=2 ){
      sqlite3BeginBenignMalloc();
      sqlite3PagerRollback(pPager);
      sqlite3EndBenignMalloc();
    }else if( !pPager->exclusiveMode ){
      ((void) (0));
      pager_end_transaction(pPager, 0, 0);
    }
  }else if( pPager->eState==6
         && pPager->journalMode==4
         && ((pPager->jfd)->pMethods!=0)
  ){



    int errCode = pPager->errCode;
    u8 eLock = pPager->eLock;
    pPager->eState = 0;
    pPager->errCode = 0;
    pPager->eLock = 4;
    pager_playback(pPager, 1);
    pPager->errCode = errCode;
    pPager->eLock = eLock;
  }
  pager_unlock(pPager);
}
# 61161 "c_tests/sqlite3.c"
static u32 pager_cksum(Pager *pPager, const u8 *aData){
  u32 cksum = pPager->cksumInit;
  int i = pPager->pageSize-200;
  while( i>0 ){
    cksum += aData[i];
    i -= 200;
  }
  return cksum;
}
# 61208 "c_tests/sqlite3.c"
static int pager_playback_one_page(
  Pager *pPager,
  i64 *pOffset,
  Bitvec *pDone,
  int isMainJrnl,
  int isSavepnt
){
  int rc;
  PgHdr *pPg;
  Pgno pgno;
  u32 cksum;
  char *aData;
  sqlite3_file *jfd;
  int isSynced;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  aData = pPager->pTmpSpace;
  ((void) (0));
  ((void) (0));







  ((void) (0));


  ((void) (0));




  jfd = isMainJrnl ? pPager->jfd : pPager->sjfd;
  rc = read32bits(jfd, *pOffset, &pgno);
  if( rc!=0 ) return rc;
  rc = sqlite3OsRead(jfd, (u8*)aData, pPager->pageSize, (*pOffset)+4);
  if( rc!=0 ) return rc;
  *pOffset += pPager->pageSize + 4 + isMainJrnl*4;






  if( pgno==0 || pgno==((pPager)->lckPgno) ){
    ((void) (0));
    return 101;
  }
  if( pgno>(Pgno)pPager->dbSize || sqlite3BitvecTest(pDone, pgno) ){
    return 0;
  }
  if( isMainJrnl ){
    rc = read32bits(jfd, (*pOffset)-4, &cksum);
    if( rc ) return rc;
    if( !isSavepnt && pager_cksum(pPager, (u8*)aData)!=cksum ){
      return 101;
    }
  }




  if( pDone && (rc = sqlite3BitvecSet(pDone, pgno))!=0 ){
    return rc;
  }



  if( pgno==1 && pPager->nReserve!=((u8*)aData)[20] ){
    pPager->nReserve = ((u8*)aData)[20];
  }
# 61321 "c_tests/sqlite3.c"
  if( ((pPager)->pWal!=0) ){
    pPg = 0;
  }else{
    pPg = sqlite3PagerLookup(pPager, pgno);
  }
  ((void) (0));
  ((void) (0));



    ;
  if( isMainJrnl ){
    isSynced = pPager->noSync || (*pOffset <= pPager->journalHdr);
  }else{
    isSynced = (pPg==0 || 0==(pPg->flags & 0x008));
  }
  if( ((pPager->fd)->pMethods!=0)
   && (pPager->eState>=4 || pPager->eState==0)
   && isSynced
  ){
    i64 ofst = (pgno-1)*(i64)pPager->pageSize;
                                                                       ;
    ((void) (0));







    rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);

    if( pgno>pPager->dbFileSize ){
      pPager->dbFileSize = pgno;
    }
    if( pPager->pBackup ){
      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);
    }
  }else if( !isMainJrnl && pPg==0 ){
# 61376 "c_tests/sqlite3.c"
    ((void) (0));
    ((void) (0));
    pPager->doNotSpill |= 0x02;
    rc = sqlite3PagerGet(pPager, pgno, &pPg, 1);
    ((void) (0));
    pPager->doNotSpill &= ~0x02;
    if( rc!=0 ) return rc;
    sqlite3PcacheMakeDirty(pPg);
  }
  if( pPg ){






    void *pData;
    pData = pPg->pData;
    memcpy(pData, (u8*)aData, pPager->pageSize);
    pPager->xReiniter(pPg);




                           ;



    if( pgno==1 ){
      memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));
    }
    sqlite3PcacheRelease(pPg);
  }
  return rc;
}
# 61455 "c_tests/sqlite3.c"
static int pager_delsuper(Pager *pPager, const char *zSuper){
  sqlite3_vfs *pVfs = pPager->pVfs;
  int rc;
  sqlite3_file *pSuper;
  sqlite3_file *pJournal;
  char *zSuperJournal = 0;
  i64 nSuperJournal;
  char *zJournal;
  char *zSuperPtr;
  char *zFree = 0;
  i64 nSuperPtr;




  pSuper = (sqlite3_file *)sqlite3MallocZero(2 * (i64)pVfs->szOsFile);
  if( !pSuper ){
    rc = 7;
    pJournal = 0;
  }else{
    const int flags = (0x00000001|0x00004000);
    rc = sqlite3OsOpen(pVfs, zSuper, pSuper, flags, 0);
    pJournal = (sqlite3_file *)(((u8 *)pSuper) + pVfs->szOsFile);
  }
  if( rc!=0 ) goto delsuper_out;






  rc = sqlite3OsFileSize(pSuper, &nSuperJournal);
  if( rc!=0 ) goto delsuper_out;
  nSuperPtr = 1 + (i64)pVfs->mxPathname;
  ((void) (0));
  zFree = sqlite3Malloc(4 + nSuperJournal + nSuperPtr + 2);
  if( !zFree ){
    rc = 7;
    goto delsuper_out;
  }else{
    ((void) (0));
  }
  zFree[0] = zFree[1] = zFree[2] = zFree[3] = 0;
  zSuperJournal = &zFree[4];
  zSuperPtr = &zSuperJournal[nSuperJournal+2];
  rc = sqlite3OsRead(pSuper, zSuperJournal, (int)nSuperJournal, 0);
  if( rc!=0 ) goto delsuper_out;
  zSuperJournal[nSuperJournal] = 0;
  zSuperJournal[nSuperJournal+1] = 0;

  zJournal = zSuperJournal;
  while( (zJournal-zSuperJournal)<nSuperJournal ){
    int exists;
    rc = sqlite3OsAccess(pVfs, zJournal, 0, &exists);
    if( rc!=0 ){
      goto delsuper_out;
    }
    if( exists ){







      int c;
      int flags = (0x00000001|0x00004000);
      rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);
      if( rc!=0 ){
        goto delsuper_out;
      }

      rc = readSuperJournal(pJournal, zSuperPtr, nSuperPtr);
      sqlite3OsClose(pJournal);
      if( rc!=0 ){
        goto delsuper_out;
      }

      c = zSuperPtr[0]!=0 && strcmp(zSuperPtr, zSuper)==0;
      if( c ){

        goto delsuper_out;
      }
    }
    zJournal += (sqlite3Strlen30(zJournal)+1);
  }

  sqlite3OsClose(pSuper);
  rc = sqlite3OsDelete(pVfs, zSuper, 0);

delsuper_out:
  sqlite3_free(zFree);
  if( pSuper ){
    sqlite3OsClose(pSuper);
    ((void) (0));
    sqlite3_free(pSuper);
  }
  return rc;
}
# 61576 "c_tests/sqlite3.c"
static int pager_truncate(Pager *pPager, Pgno nPage){
  int rc = 0;
  ((void) (0));
  ((void) (0));
                                                                ;


  if( ((pPager->fd)->pMethods!=0)
   && (pPager->eState>=4 || pPager->eState==0)
  ){
    i64 currentSize, newSize;
    int szPage = pPager->pageSize;
    ((void) (0));

    rc = sqlite3OsFileSize(pPager->fd, &currentSize);
    newSize = szPage*(i64)nPage;
    if( rc==0 && currentSize!=newSize ){
      if( currentSize>newSize ){
        rc = sqlite3OsTruncate(pPager->fd, newSize);
      }else if( (currentSize+szPage)<=newSize ){
        char *pTmp = pPager->pTmpSpace;
        memset(pTmp, 0, szPage);
                                                   ;
                                                   ;
        sqlite3OsFileControlHint(pPager->fd, 5, &newSize);
        rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, newSize-szPage);
      }
      if( rc==0 ){
        pPager->dbFileSize = nPage;
      }
    }
  }
  return rc;
}





static int sqlite3SectorSize(sqlite3_file *pFile){
  int iRet = sqlite3OsSectorSize(pFile);
  if( iRet<32 ){
    iRet = 512;
  }else if( iRet>0x10000 ){
    ((void) (0));
    iRet = 0x10000;
  }
  return iRet;
}
# 61649 "c_tests/sqlite3.c"
static void setSectorSize(Pager *pPager){
  ((void) (0));

  if( pPager->tempFile
   || (sqlite3OsDeviceCharacteristics(pPager->fd) &
              0x00001000)!=0
  ){



    pPager->sectorSize = 512;
  }else{
    pPager->sectorSize = sqlite3SectorSize(pPager->fd);
  }
}
# 61722 "c_tests/sqlite3.c"
static int pager_playback(Pager *pPager, int isHot){
  sqlite3_vfs *pVfs = pPager->pVfs;
  i64 szJ;
  u32 nRec;
  u32 u;
  Pgno mxPg = 0;
  int rc;
  int res = 1;
  char *zSuper = 0;
  int needPagerReset;
  int nPlayback = 0;
  u32 savedPageSize = pPager->pageSize;




  ((void) (0));
  rc = sqlite3OsFileSize(pPager->jfd, &szJ);
  if( rc!=0 ){
    goto end_playback;
  }
# 61755 "c_tests/sqlite3.c"
  zSuper = pPager->pTmpSpace;
  rc = readSuperJournal(pPager->jfd, zSuper, 1+(i64)pPager->pVfs->mxPathname);
  if( rc==0 && zSuper[0] ){
    rc = sqlite3OsAccess(pVfs, zSuper, 0, &res);
  }
  zSuper = 0;
  if( rc!=0 || !res ){
    goto end_playback;
  }
  pPager->journalOff = 0;
  needPagerReset = isHot;





  while( 1 ){





    rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);
    if( rc!=0 ){
      if( rc==101 ){
        rc = 0;
      }
      goto end_playback;
    }






    if( nRec==0xffffffff ){
      ((void) (0));
      nRec = (int)((szJ - (pPager->sectorSize))/((pPager->pageSize) + 8));
    }
# 61809 "c_tests/sqlite3.c"
    if( nRec==0 && !isHot &&
        pPager->journalHdr+(pPager->sectorSize)==pPager->journalOff ){
      nRec = (int)((szJ - pPager->journalOff) / ((pPager->pageSize) + 8));
    }




    if( pPager->journalOff==(pPager->sectorSize) ){
      rc = pager_truncate(pPager, mxPg);
      if( rc!=0 ){
        goto end_playback;
      }
      pPager->dbSize = mxPg;
      if( pPager->mxPgno<mxPg ){
        pPager->mxPgno = mxPg;
      }
    }




    for(u=0; u<nRec; u++){
      if( needPagerReset ){
        pager_reset(pPager);
        needPagerReset = 0;
      }
      rc = pager_playback_one_page(pPager,&pPager->journalOff,0,1,0);
      if( rc==0 ){
        nPlayback++;
      }else{
        if( rc==101 ){
          pPager->journalOff = szJ;
          break;
        }else if( rc==(10 | (2<<8)) ){





          rc = 0;
          goto end_playback;
        }else{





          goto end_playback;
        }
      }
    }
  }

  ((void) (0));

end_playback:
  if( rc==0 ){
    rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);
  }
# 61887 "c_tests/sqlite3.c"
  pPager->changeCountDone = pPager->tempFile;

  if( rc==0 ){




    zSuper = &pPager->pTmpSpace[4];
    rc = readSuperJournal(pPager->jfd, zSuper, 1+(i64)pPager->pVfs->mxPathname);
                             ;
  }
  if( rc==0
   && (pPager->eState>=4 || pPager->eState==0)
  ){
    rc = sqlite3PagerSync(pPager, 0);
  }
  if( rc==0 ){
    rc = pager_end_transaction(pPager, zSuper[0]!='\0', 0);
                             ;
  }
  if( rc==0 && zSuper[0] && res ){



    ((void) (0));
    memset(pPager->pTmpSpace, 0, 4);
    rc = pager_delsuper(pPager, zSuper);
                             ;
  }
  if( isHot && nPlayback ){
    sqlite3_log((27 | (2<<8)), "recovered %d pages from %s",
                nPlayback, pPager->zJournal);
  }





  setSectorSize(pPager);
  return rc;
}
# 61942 "c_tests/sqlite3.c"
static int readDbPage(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  int rc = 0;


  u32 iFrame = 0;

  ((void) (0));
  ((void) (0));

  if( ((pPager)->pWal!=0) ){
    rc = sqlite3WalFindFrame(pPager->pWal, pPg->pgno, &iFrame);
    if( rc ) return rc;
  }
  if( iFrame ){
    rc = sqlite3WalReadFrame(pPager->pWal, iFrame,pPager->pageSize,pPg->pData);
  }else

  {
    i64 iOffset = (pPg->pgno-1)*(i64)pPager->pageSize;
    rc = sqlite3OsRead(pPager->fd, pPg->pData, pPager->pageSize, iOffset);
    if( rc==(10 | (2<<8)) ){
      rc = 0;
    }
  }

  if( pPg->pgno==1 ){
    if( rc ){
# 61982 "c_tests/sqlite3.c"
      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));
    }else{
      u8 *dbFileVers = &((u8*)pPg->pData)[24];
      memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));
    }
  }
                                        ;
                           ;
                                              ;

                                                                ;

  return rc;
}
# 62005 "c_tests/sqlite3.c"
static void pager_write_changecounter(PgHdr *pPg){
  u32 change_counter;
  if( (pPg==0) ) return;


  change_counter = sqlite3Get4byte((u8*)pPg->pPager->dbFileVers)+1;
  sqlite3Put4byte((u8*)((char*)pPg->pData)+24,change_counter);




  sqlite3Put4byte((u8*)((char*)pPg->pData)+92,change_counter);
  sqlite3Put4byte((u8*)((char*)pPg->pData)+96,3051002);
}
# 62033 "c_tests/sqlite3.c"
static int pagerUndoCallback(void *pCtx, Pgno iPg){
  int rc = 0;
  Pager *pPager = (Pager *)pCtx;
  PgHdr *pPg;

  ((void) (0));
  pPg = sqlite3PagerLookup(pPager, iPg);
  if( pPg ){
    if( sqlite3PcachePageRefcount(pPg)==1 ){
      sqlite3PcacheDrop(pPg);
    }else{
      rc = readDbPage(pPg);
      if( rc==0 ){
        pPager->xReiniter(pPg);
      }
      sqlite3PagerUnrefNotNull(pPg);
    }
  }
# 62060 "c_tests/sqlite3.c"
  sqlite3BackupRestart(pPager->pBackup);

  return rc;
}




static int pagerRollbackWal(Pager *pPager){
  int rc;
  PgHdr *pList;
# 62079 "c_tests/sqlite3.c"
  pPager->dbSize = pPager->dbOrigSize;
  rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, (void *)pPager);
  pList = sqlite3PcacheDirtyList(pPager->pPCache);
  while( pList && rc==0 ){
    PgHdr *pNext = pList->pDirty;
    rc = pagerUndoCallback((void *)pPager, pList->pgno);
    pList = pNext;
  }

  return rc;
}
# 62100 "c_tests/sqlite3.c"
static int pagerWalFrames(
  Pager *pPager,
  PgHdr *pList,
  Pgno nTruncate,
  int isCommit
){
  int rc;
  int nList;
  PgHdr *p;

  ((void) (0));
  ((void) (0));







  ((void) (0));
  if( isCommit ){




    PgHdr **ppNext = &pList;
    nList = 0;
    for(p=pList; (*ppNext = p)!=0; p=p->pDirty){
      if( p->pgno<=nTruncate ){
        ppNext = &p->pDirty;
        nList++;
      }
    }
    ((void) (0));
  }else{
    nList = 1;
  }
  pPager->aStat[2] += nList;

  if( pList->pgno==1 ) pager_write_changecounter(pList);
  rc = sqlite3WalFrames(pPager->pWal,
      pPager->pageSize, pList, nTruncate, isCommit, pPager->walSyncFlags
  );
  if( rc==0 && pPager->pBackup ){
    for(p=pList; p; p=p->pDirty){
      sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);
    }
  }
# 62156 "c_tests/sqlite3.c"
  return rc;
}
# 62167 "c_tests/sqlite3.c"
static int pagerBeginReadTransaction(Pager *pPager){
  int rc;
  int changed = 0;

  ((void) (0));
  ((void) (0));






  sqlite3WalEndReadTransaction(pPager->pWal);

  rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);
  if( rc!=0 || changed ){
    pager_reset(pPager);
    if( ((pPager)->bUseFetch) ) sqlite3OsUnfetch(pPager->fd, 0, 0);
  }

  return rc;
}
# 62200 "c_tests/sqlite3.c"
static int pagerPagecount(Pager *pPager, Pgno *pnPage){
  Pgno nPage;







  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  nPage = sqlite3WalDbsize(pPager->pWal);






  if( nPage==0 && (((pPager->fd)->pMethods!=0)) ){
    i64 n = 0;
    int rc = sqlite3OsFileSize(pPager->fd, &n);
    if( rc!=0 ){
      return rc;
    }
    nPage = (Pgno)((n+pPager->pageSize-1) / pPager->pageSize);
  }





  if( nPage>pPager->mxPgno ){
    pPager->mxPgno = (Pgno)nPage;
  }

  *pnPage = nPage;
  return 0;
}
# 62260 "c_tests/sqlite3.c"
static int pagerOpenWalIfPresent(Pager *pPager){
  int rc = 0;
  ((void) (0));
  ((void) (0));

  if( !pPager->tempFile ){
    int isWal;
    rc = sqlite3OsAccess(
        pPager->pVfs, pPager->zWal, 0, &isWal
    );
    if( rc==0 ){
      if( isWal ){
        Pgno nPage;

        rc = pagerPagecount(pPager, &nPage);
        if( rc ) return rc;
        if( nPage==0 ){
          rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);
        }else{
                                                                ;
          rc = sqlite3PagerOpenWal(pPager, 0);
        }
      }else if( pPager->journalMode==5 ){
        pPager->journalMode = 0;
      }
    }
  }
  return rc;
}
# 62327 "c_tests/sqlite3.c"
static int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint){
  i64 szJ;
  i64 iHdrOff;
  int rc = 0;
  Bitvec *pDone = 0;

  ((void) (0));
  ((void) (0));


  if( pSavepoint ){
    pDone = sqlite3BitvecCreate(pSavepoint->nOrig);
    if( !pDone ){
      return 7;
    }
  }




  pPager->dbSize = pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize;
  pPager->changeCountDone = pPager->tempFile;

  if( !pSavepoint && ((pPager)->pWal!=0) ){
    return pagerRollbackWal(pPager);
  }






  szJ = pPager->journalOff;
  ((void) (0));
# 62369 "c_tests/sqlite3.c"
  if( pSavepoint && !((pPager)->pWal!=0) ){
    iHdrOff = pSavepoint->iHdrOffset ? pSavepoint->iHdrOffset : szJ;
    pPager->journalOff = pSavepoint->iOffset;
    while( rc==0 && pPager->journalOff<iHdrOff ){
      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
    }
    ((void) (0));
  }else{
    pPager->journalOff = 0;
  }






  while( rc==0 && pPager->journalOff<szJ ){
    u32 ii;
    u32 nJRec = 0;
    u32 dummy;
    rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy);
    ((void) (0));






    if( nJRec==0
     && pPager->journalHdr+(pPager->sectorSize)==pPager->journalOff
    ){
      nJRec = (u32)((szJ - pPager->journalOff)/((pPager->pageSize) + 8));
    }
    for(ii=0; rc==0 && ii<nJRec && pPager->journalOff<szJ; ii++){
      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
    }
    ((void) (0));
  }
  ((void) (0));





  if( pSavepoint ){
    u32 ii;
    i64 offset = (i64)pSavepoint->iSubRec*(4+pPager->pageSize);

    if( ((pPager)->pWal!=0) ){
      rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);
    }
    for(ii=pSavepoint->iSubRec; rc==0 && ii<pPager->nSubRec; ii++){
      ((void) (0));
      rc = pager_playback_one_page(pPager, &offset, pDone, 0, 1);
    }
    ((void) (0));
  }

  sqlite3BitvecDestroy(pDone);
  if( rc==0 ){
    pPager->journalOff = szJ;
  }

  return rc;
}





static void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){
  sqlite3PcacheSetCachesize(pPager->pPCache, mxPage);
}





static int sqlite3PagerSetSpillsize(Pager *pPager, int mxPage){
  return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);
}




static void pagerFixMaplimit(Pager *pPager){

  sqlite3_file *fd = pPager->fd;
  if( ((fd)->pMethods!=0) && fd->pMethods->iVersion>=3 ){
    sqlite3_int64 sz;
    sz = pPager->szMmap;
    pPager->bUseFetch = (sz>0);
    setGetterMethod(pPager);
    sqlite3OsFileControlHint(pPager->fd, 18, &sz);
  }

}




static void sqlite3PagerSetMmapLimit(Pager *pPager, sqlite3_int64 szMmap){
  pPager->szMmap = szMmap;
  pagerFixMaplimit(pPager);
}




static void sqlite3PagerShrink(Pager *pPager){
  sqlite3PcacheShrink(pPager->pPCache);
}
# 62533 "c_tests/sqlite3.c"
static void sqlite3PagerSetFlags(
  Pager *pPager,
  unsigned pgFlags
){
  unsigned level = pgFlags & 0x07;
  if( pPager->tempFile || level==0x01 ){
    pPager->noSync = 1;
    pPager->fullSync = 0;
    pPager->extraSync = 0;
  }else{
    pPager->noSync = 0;
    pPager->fullSync = level>=0x03 ?1:0;





    if( level==0x04



    ){
      pPager->extraSync = 1;
    }else{
      pPager->extraSync = 0;
    }
  }
  if( pPager->noSync ){
    pPager->syncFlags = 0;
  }else if( pgFlags & 0x08 ){
    pPager->syncFlags = 0x00003;
  }else{
    pPager->syncFlags = 0x00002;
  }
  pPager->walSyncFlags = (pPager->syncFlags<<2);
  if( pPager->fullSync ){
    pPager->walSyncFlags |= pPager->syncFlags;
  }
  if( (pgFlags & 0x10) && !pPager->noSync ){
    pPager->walSyncFlags |= (0x00003<<2);
  }
  if( pgFlags & 0x20 ){
    pPager->doNotSpill &= ~0x01;
  }else{
    pPager->doNotSpill |= 0x01;
  }
}
# 62605 "c_tests/sqlite3.c"
static int pagerOpentemp(
  Pager *pPager,
  sqlite3_file *pFile,
  int vfsFlags
){
  int rc;





  vfsFlags |= 0x00000002 | 0x00000004 |
            0x00000010 | 0x00000008;
  rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0);
  ((void) (0));
  return rc;
}
# 62644 "c_tests/sqlite3.c"
static void sqlite3PagerSetBusyHandler(
  Pager *pPager,
  int (*xBusyHandler)(void *),
  void *pBusyHandlerArg
){
  void **ap;
  pPager->xBusyHandler = xBusyHandler;
  pPager->pBusyHandlerArg = pBusyHandlerArg;
  ap = (void **)&pPager->xBusyHandler;
  ((void) (0));
  ((void) (0));
  sqlite3OsFileControlHint(pPager->fd, 15, (void *)ap);
}
# 62688 "c_tests/sqlite3.c"
static int sqlite3PagerSetPagesize(Pager *pPager, u32 *pPageSize, int nReserve){
  int rc = 0;
# 62701 "c_tests/sqlite3.c"
  u32 pageSize = *pPageSize;
  ((void) (0));
  if( (pPager->memDb==0 || pPager->dbSize==0)
   && sqlite3PcacheRefCount(pPager->pPCache)==0
   && pageSize && pageSize!=(u32)pPager->pageSize
  ){
    char *pNew = ((void*)0);
    i64 nByte = 0;

    if( pPager->eState>0 && ((pPager->fd)->pMethods!=0) ){
      rc = sqlite3OsFileSize(pPager->fd, &nByte);
    }
    if( rc==0 ){


      pNew = (char *)sqlite3PageMalloc(pageSize+8);
      if( !pNew ){
        rc = 7;
      }else{
        memset(pNew+pageSize, 0, 8);
      }
    }

    if( rc==0 ){
      pager_reset(pPager);
      rc = sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);
    }
    if( rc==0 ){
      sqlite3PageFree(pPager->pTmpSpace);
      pPager->pTmpSpace = pNew;
      pPager->dbSize = (Pgno)((nByte+pageSize-1)/pageSize);
      pPager->pageSize = pageSize;
      pPager->lckPgno = (Pgno)(sqlite3PendingByte/pageSize) + 1;
    }else{
      sqlite3PageFree(pNew);
    }
  }

  *pPageSize = pPager->pageSize;
  if( rc==0 ){
    if( nReserve<0 ) nReserve = pPager->nReserve;
    ((void) (0));
    pPager->nReserve = (i16)nReserve;
    pagerFixMaplimit(pPager);
  }
  return rc;
}
# 62757 "c_tests/sqlite3.c"
static void *sqlite3PagerTempSpace(Pager *pPager){
  return pPager->pTmpSpace;
}
# 62768 "c_tests/sqlite3.c"
static Pgno sqlite3PagerMaxPageCount(Pager *pPager, Pgno mxPage){
  if( mxPage>0 ){
    pPager->mxPgno = mxPage;
  }
  ((void) (0));




  return pPager->mxPgno;
}
# 62818 "c_tests/sqlite3.c"
static int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){
  int rc = 0;
  memset(pDest, 0, N);
  ((void) (0));





  ((void) (0));

  if( ((pPager->fd)->pMethods!=0) ){

    rc = sqlite3OsRead(pPager->fd, pDest, N, 0);
    if( rc==(10 | (2<<8)) ){
      rc = 0;
    }
  }
  return rc;
}
# 62846 "c_tests/sqlite3.c"
static void sqlite3PagerPagecount(Pager *pPager, int *pnPage){
  ((void) (0));
  ((void) (0));
  *pnPage = (int)pPager->dbSize;
}
# 62867 "c_tests/sqlite3.c"
static int pager_wait_on_lock(Pager *pPager, int locktype){
  int rc;






  ((void) (0));




  do {
    rc = pagerLockDb(pPager, locktype);
  }while( rc==5 && pPager->xBusyHandler(pPager->pBusyHandlerArg) );
  return rc;
}
# 62938 "c_tests/sqlite3.c"
static void sqlite3PagerTruncateImage(Pager *pPager, Pgno nPage){
  ((void) (0));
  ((void) (0));
  pPager->dbSize = nPage;
# 62952 "c_tests/sqlite3.c"
}
# 62969 "c_tests/sqlite3.c"
static int pagerSyncHotJournal(Pager *pPager){
  int rc = 0;
  if( !pPager->noSync ){
    rc = sqlite3OsSync(pPager->jfd, 0x00002);
  }
  if( rc==0 ){
    rc = sqlite3OsFileSize(pPager->jfd, &pPager->journalHdr);
  }
  return rc;
}
# 62991 "c_tests/sqlite3.c"
static int pagerAcquireMapPage(
  Pager *pPager,
  Pgno pgno,
  void *pData,
  PgHdr **ppPage
){
  PgHdr *p;

  if( pPager->pMmapFreelist ){
    *ppPage = p = pPager->pMmapFreelist;
    pPager->pMmapFreelist = p->pDirty;
    p->pDirty = 0;
    ((void) (0));
    memset(p->pExtra, 0, 8);
  }else{
    *ppPage = p = (PgHdr *)sqlite3MallocZero(sizeof(PgHdr) + pPager->nExtra);
    if( p==0 ){
      sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1) * pPager->pageSize, pData);
      return 7;
    }
    p->pExtra = (void *)&p[1];
    ((void) (0));
    p->flags = 0x020;
    p->nRef = 1;
    p->pPager = pPager;
  }

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  p->pgno = pgno;
  p->pData = pData;
  pPager->nMmapOut++;

  return 0;
}






static void pagerReleaseMapPage(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  pPager->nMmapOut--;
  pPg->pDirty = pPager->pMmapFreelist;
  pPager->pMmapFreelist = pPg;

  ((void) (0));
  sqlite3OsUnfetch(pPager->fd, (i64)(pPg->pgno-1)*pPager->pageSize, pPg->pData);
}




static void pagerFreeMapHdrs(Pager *pPager){
  PgHdr *p;
  PgHdr *pNext;
  for(p=pPager->pMmapFreelist; p; p=pNext){
    pNext = p->pDirty;
    sqlite3_free(p);
  }
}






static int databaseIsUnmoved(Pager *pPager){
  int bHasMoved = 0;
  int rc;

  if( pPager->tempFile ) return 0;
  if( pPager->dbSize==0 ) return 0;
  ((void) (0));
  rc = sqlite3OsFileControl(pPager->fd, 20, &bHasMoved);
  if( rc==12 ){



    rc = 0;
  }else if( rc==0 && bHasMoved ){
    rc = (8 | (4<<8));
  }
  return rc;
}
# 63097 "c_tests/sqlite3.c"
static int sqlite3PagerClose(Pager *pPager, sqlite3 *db){
  u8 *pTmp = (u8*)pPager->pTmpSpace;
  ((void) (0));
  ((void) (0));
                               ;
  sqlite3BeginBenignMalloc();
  pagerFreeMapHdrs(pPager);

  pPager->exclusiveMode = 0;

  {
    u8 *a = 0;
    ((void) (0));
    if( db && 0==(db->flags & 0x00000800)
     && 0==databaseIsUnmoved(pPager)
    ){
      a = pTmp;
    }
    sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags, pPager->pageSize,a);
    pPager->pWal = 0;
  }

  pager_reset(pPager);
  if( pPager->memDb ){
    pager_unlock(pPager);
  }else{
# 63134 "c_tests/sqlite3.c"
    if( ((pPager->jfd)->pMethods!=0) ){
      pager_error(pPager, pagerSyncHotJournal(pPager));
    }
    pagerUnlockAndRollback(pPager);
  }
  sqlite3EndBenignMalloc();
                              ;
                                             ;

  sqlite3OsClose(pPager->jfd);
  sqlite3OsClose(pPager->fd);
  sqlite3PageFree(pTmp);
  sqlite3PcacheClose(pPager->pPCache);
  ((void) (0));
  ((void) (0));

  sqlite3_free(pPager);
  return 0;
}
# 63166 "c_tests/sqlite3.c"
static void sqlite3PagerRef(DbPage *pPg){
  sqlite3PcacheRef(pPg);
}
# 63205 "c_tests/sqlite3.c"
static int syncJournal(Pager *pPager, int newHdr){
  int rc;

  ((void) (0));


  ((void) (0));
  ((void) (0));

  rc = sqlite3PagerExclusiveLock(pPager);
  if( rc!=0 ) return rc;

  if( !pPager->noSync ){
    ((void) (0));
    if( ((pPager->jfd)->pMethods!=0) && pPager->journalMode!=4 ){
      const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
      ((void) (0));

      if( 0==(iDc&0x00000200) ){
# 63246 "c_tests/sqlite3.c"
        i64 iNextHdrOffset;
        u8 aMagic[8];
        u8 zHeader[sizeof(aJournalMagic)+4];

        memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
        sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)],pPager->nRec);

        iNextHdrOffset = journalHdrOffset(pPager);
        rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);
        if( rc==0 && 0==memcmp(aMagic, aJournalMagic, 8) ){
          static const u8 zerobyte = 0;
          rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);
        }
        if( rc!=0 && rc!=(10 | (2<<8)) ){
          return rc;
        }
# 63274 "c_tests/sqlite3.c"
        if( pPager->fullSync && 0==(iDc&0x00000400) ){
                                                               ;

          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
          if( rc!=0 ) return rc;
        }
                                                               ;
        rc = sqlite3OsWrite(
            pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr
        );
        if( rc!=0 ) return rc;
      }
      if( 0==(iDc&0x00000400) ){
                                                             ;

        rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags|
          (pPager->syncFlags==0x00003?0x00010:0)
        );
        if( rc!=0 ) return rc;
      }

      pPager->journalHdr = pPager->journalOff;
      if( newHdr && 0==(iDc&0x00000200) ){
        pPager->nRec = 0;
        rc = writeJournalHdr(pPager);
        if( rc!=0 ) return rc;
      }
    }else{
      pPager->journalHdr = pPager->journalOff;
    }
  }





  sqlite3PcacheClearSyncFlags(pPager->pPCache);
  pPager->eState = 4;
  ((void) (0));
  return 0;
}
# 63348 "c_tests/sqlite3.c"
static int pager_write_pagelist(Pager *pPager, PgHdr *pList){
  int rc = 0;


  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  if( !((pPager->fd)->pMethods!=0) ){
    ((void) (0));
    rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);
  }




  ((void) (0));
  if( rc==0
   && pPager->dbHintSize<pPager->dbSize
   && (pList->pDirty || pList->pgno>pPager->dbHintSize)
  ){
    sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;
    sqlite3OsFileControlHint(pPager->fd, 5, &szFile);
    pPager->dbHintSize = pPager->dbSize;
  }

  while( rc==0 && pList ){
    Pgno pgno = pList->pgno;
# 63390 "c_tests/sqlite3.c"
    if( pgno<=pPager->dbSize && 0==(pList->flags&0x010) ){
      i64 offset = (pgno-1)*(i64)pPager->pageSize;
      char *pData;

      ((void) (0));
      if( pList->pgno==1 ) pager_write_changecounter(pList);

      pData = pList->pData;


      rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);





      if( pgno==1 ){
        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
      }
      if( pgno>pPager->dbFileSize ){
        pPager->dbFileSize = pgno;
      }
      pPager->aStat[2]++;


      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);


                                                                 ;
                                              ;
                                             ;
    }else{
                                                                 ;
    }
                             ;
    pList = pList->pDirty;
  }

  return rc;
}
# 63439 "c_tests/sqlite3.c"
static int openSubJournal(Pager *pPager){
  int rc = 0;
  if( !((pPager->sjfd)->pMethods!=0) ){
    const int flags = 0x00002000 | 0x00000002
      | 0x00000004 | 0x00000010
      | 0x00000008;
    int nStmtSpill = sqlite3Config.nStmtSpill;
    if( pPager->journalMode==4 || pPager->subjInMemory ){
      nStmtSpill = -1;
    }
    rc = sqlite3JournalOpen(pPager->pVfs, 0, pPager->sjfd, flags, nStmtSpill);
  }
  return rc;
}
# 63465 "c_tests/sqlite3.c"
static int subjournalPage(PgHdr *pPg){
  int rc = 0;
  Pager *pPager = pPg->pPager;
  if( pPager->journalMode!=2 ){


    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));



    rc = openSubJournal(pPager);



    if( rc==0 ){
      void *pData = pPg->pData;
      i64 offset = (i64)pPager->nSubRec*(4+pPager->pageSize);
      char *pData2;
      pData2 = pData;
                                                                           ;
      rc = write32bits(pPager->sjfd, offset, pPg->pgno);
      if( rc==0 ){
        rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, offset+4);
      }
    }
  }
  if( rc==0 ){
    pPager->nSubRec++;
    ((void) (0));
    rc = addToSavepointBitvecs(pPager, pPg->pgno);
  }
  return rc;
}
static int subjournalPageIfRequired(PgHdr *pPg){
  if( subjRequiresPage(pPg) ){
    return subjournalPage(pPg);
  }else{
    return 0;
  }
}
# 63528 "c_tests/sqlite3.c"
static int pagerStress(void *p, PgHdr *pPg){
  Pager *pPager = (Pager *)p;
  int rc = 0;

  ((void) (0));
  ((void) (0));
# 63551 "c_tests/sqlite3.c"
  if( (pPager->errCode) ) return 0;
                                                     ;
                                                ;
                                                   ;
  if( pPager->doNotSpill
   && ((pPager->doNotSpill & (0x02|0x01))!=0
      || (pPg->flags & 0x008)!=0)
  ){
    return 0;
  }

  pPager->aStat[3]++;
  pPg->pDirty = 0;
  if( ((pPager)->pWal!=0) ){

    rc = subjournalPageIfRequired(pPg);
    if( rc==0 ){
      rc = pagerWalFrames(pPager, pPg, 0, 0);
    }
  }else{
# 63580 "c_tests/sqlite3.c"
    if( pPg->flags&0x008
     || pPager->eState==3
    ){
      rc = syncJournal(pPager, 1);
    }


    if( rc==0 ){
      ((void) (0));
      rc = pager_write_pagelist(pPager, pPg);
    }
  }


  if( rc==0 ){
                                                                   ;
    sqlite3PcacheMakeClean(pPg);
  }

  return pager_error(pPager, rc);
}




static int sqlite3PagerFlush(Pager *pPager){
  int rc = pPager->errCode;
  if( !pPager->memDb ){
    PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);
    ((void) (0));
    while( rc==0 && pList ){
      PgHdr *pNext = pList->pDirty;
      if( pList->nRef==0 ){
        rc = pagerStress((void*)pPager, pList);
      }
      pList = pNext;
    }
  }

  return rc;
}
# 63654 "c_tests/sqlite3.c"
static int sqlite3PagerOpen(
  sqlite3_vfs *pVfs,
  Pager **ppPager,
  const char *zFilename,
  int nExtra,
  int flags,
  int vfsFlags,
  void (*xReinit)(DbPage*)
){
  u8 *pPtr;
  Pager *pPager = 0;
  int rc = 0;
  int tempFile = 0;
  int memDb = 0;
  int memJM = 0;
  int readOnly = 0;
  int journalFileSize;
  char *zPathname = 0;
  int nPathname = 0;
  int useJournal = (flags & 0x0001)==0;
  int pcacheSize = sqlite3PcacheSize();
  u32 szPageDflt = 4096;
  const char *zUri = 0;
  int nUriByte = 1;




  journalFileSize = (((sqlite3JournalSize(pVfs))+7)&~7);


  *ppPager = 0;


  if( flags & 0x0002 ){
    memDb = 1;
    if( zFilename && zFilename[0] ){
      zPathname = sqlite3DbStrDup(0, zFilename);
      if( zPathname==0 ) return 7;
      nPathname = sqlite3Strlen30(zPathname);
      zFilename = 0;
    }
  }






  if( zFilename && zFilename[0] ){
    const char *z;
    nPathname = pVfs->mxPathname + 1;
    zPathname = sqlite3DbMallocRaw(0, 2*(i64)nPathname);
    if( zPathname==0 ){
      return 7;
    }
    zPathname[0] = 0;
    rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);
    if( rc!=0 ){
      if( rc==(0 | (2<<8)) ){
        if( vfsFlags & 0x01000000 ){
          rc = (14 | (6<<8));
        }else{
          rc = 0;
        }
      }
    }
    nPathname = sqlite3Strlen30(zPathname);
    z = zUri = &zFilename[sqlite3Strlen30(zFilename)+1];
    while( *z ){
      z += strlen(z)+1;
      z += strlen(z)+1;
    }
    nUriByte = (int)(&z[1] - zUri);
    ((void) (0));
    if( rc==0 && nPathname+8>pVfs->mxPathname ){






      rc = sqlite3CantopenError(63736);
    }
    if( rc!=0 ){
      sqlite3DbFree(0, zPathname);
      return rc;
    }
  }
# 63788 "c_tests/sqlite3.c"
  ((void) (0));
  pPtr = (u8 *)sqlite3MallocZero(
    (((sizeof(*pPager))+7)&~7) +
    (((pcacheSize)+7)&~7) +
    (((pVfs->szOsFile)+7)&~7) +
    (u64)journalFileSize * 2 +
    8 +
    4 +
    (u64)nPathname + 1 +
    (u64)nUriByte +
    (u64)nPathname + 8 + 1 +

    (u64)nPathname + 4 + 1 +

    3
  );
  ((void) (0));
  if( !pPtr ){
    sqlite3DbFree(0, zPathname);
    return 7;
  }
  pPager = (Pager*)pPtr; pPtr += (((sizeof(*pPager))+7)&~7);
  pPager->pPCache = (PCache*)pPtr; pPtr += (((pcacheSize)+7)&~7);
  pPager->fd = (sqlite3_file*)pPtr; pPtr += (((pVfs->szOsFile)+7)&~7);
  pPager->sjfd = (sqlite3_file*)pPtr; pPtr += journalFileSize;
  pPager->jfd = (sqlite3_file*)pPtr; pPtr += journalFileSize;
  ((void) (0));
  memcpy(pPtr, &pPager, 8); pPtr += 8;


                                          pPtr += 4;
  pPager->zFilename = (char*)pPtr;
  if( nPathname>0 ){
    memcpy(pPtr, zPathname, nPathname); pPtr += nPathname + 1;
    if( zUri ){
      memcpy(pPtr, zUri, nUriByte); pPtr += nUriByte;
    }else{
                                          pPtr++;
    }
  }



  if( nPathname>0 ){
    pPager->zJournal = (char*)pPtr;
    memcpy(pPtr, zPathname, nPathname); pPtr += nPathname;
    memcpy(pPtr, "-journal",8); pPtr += 8 + 1;




  }else{
    pPager->zJournal = 0;
  }



  if( nPathname>0 ){
    pPager->zWal = (char*)pPtr;
    memcpy(pPtr, zPathname, nPathname); pPtr += nPathname;
    memcpy(pPtr, "-wal", 4); pPtr += 4 + 1;




  }else{
    pPager->zWal = 0;
  }

  (void)pPtr;

  if( nPathname ) sqlite3DbFree(0, zPathname);
  pPager->pVfs = pVfs;
  pPager->vfsFlags = vfsFlags;



  if( zFilename && zFilename[0] ){
    int fout = 0;
    rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);
    ((void) (0));
    pPager->memVfs = memJM = (fout&0x00000080)!=0;
    readOnly = (fout&0x00000001)!=0;
# 63880 "c_tests/sqlite3.c"
    if( rc==0 ){
      int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
      if( !readOnly ){
        setSectorSize(pPager);
        ((void) (0));
        if( szPageDflt<pPager->sectorSize ){
          if( pPager->sectorSize>8192 ){
            szPageDflt = 8192;
          }else{
            szPageDflt = (u32)pPager->sectorSize;
          }
        }
# 63905 "c_tests/sqlite3.c"
      }
      pPager->noLock = sqlite3_uri_boolean(pPager->zFilename, "nolock", 0);
      if( (iDc & 0x00002000)!=0
       || sqlite3_uri_boolean(pPager->zFilename, "immutable", 0) ){
          vfsFlags |= 0x00000001;
          goto act_like_temp_file;
      }
    }
  }else{
# 63924 "c_tests/sqlite3.c"
act_like_temp_file:
    tempFile = 1;
    pPager->eState = 1;
    pPager->eLock = 4;
    pPager->noLock = 1;
    readOnly = (vfsFlags&0x00000001);
  }




  if( rc==0 ){
    ((void) (0));
    rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);
                             ;
  }


  if( rc==0 ){
    nExtra = (((nExtra)+7)&~7);
    ((void) (0));
    rc = sqlite3PcacheOpen(szPageDflt, nExtra, !memDb,
                       !memDb?pagerStress:0, (void *)pPager, pPager->pPCache);
  }



  if( rc!=0 ){
    sqlite3OsClose(pPager->fd);
    sqlite3PageFree(pPager->pTmpSpace);
    sqlite3_free(pPager);
    return rc;
  }

                                                                           ;


  pPager->useJournal = (u8)useJournal;






  pPager->mxPgno = 0xfffffffe;


  pPager->tempFile = (u8)tempFile;
  ((void) (0));

  ((void) (0));
  pPager->exclusiveMode = (u8)tempFile;
  pPager->changeCountDone = pPager->tempFile;
  pPager->memDb = (u8)memDb;
  pPager->readOnly = (u8)readOnly;
  ((void) (0));
  sqlite3PagerSetFlags(pPager, (2 +1)|0x20);



  pPager->nExtra = (u16)nExtra;
  pPager->journalSizeLimit = -1;
  ((void) (0));
  setSectorSize(pPager);
  if( !useJournal ){
    pPager->journalMode = 2;
  }else if( memDb || memJM ){
    pPager->journalMode = 4;
  }


  pPager->xReiniter = xReinit;
  setGetterMethod(pPager);



  *ppPager = pPager;
  return 0;
}






           sqlite3_file *sqlite3_database_file_object(const char *zName){
  Pager *pPager;
  const char *p;
  while( zName[-1]!=0 || zName[-2]!=0 || zName[-3]!=0 || zName[-4]!=0 ){
    zName--;
  }
  p = zName - 4 - sizeof(Pager*);
  ((void) (0));
  pPager = *(Pager**)p;
  return pPager->fd;
}
# 64053 "c_tests/sqlite3.c"
static int hasHotJournal(Pager *pPager, int *pExists){
  sqlite3_vfs * const pVfs = pPager->pVfs;
  int rc = 0;
  int exists = 1;
  int jrnlOpen = !!((pPager->jfd)->pMethods!=0);

  ((void) (0));
  ((void) (0));
  ((void) (0));

  ((void) (0));



  *pExists = 0;
  if( !jrnlOpen ){
    rc = sqlite3OsAccess(pVfs, pPager->zJournal, 0, &exists);
  }
  if( rc==0 && exists ){
    int locked = 0;
# 64082 "c_tests/sqlite3.c"
    rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);
    if( rc==0 && !locked ){
      Pgno nPage;

      ((void) (0));
      rc = pagerPagecount(pPager, &nPage);
      if( rc==0 ){
# 64097 "c_tests/sqlite3.c"
        if( nPage==0 && !jrnlOpen ){
          sqlite3BeginBenignMalloc();
          if( pagerLockDb(pPager, 2)==0 ){
            sqlite3OsDelete(pVfs, pPager->zJournal, 0);
            if( !pPager->exclusiveMode ) pagerUnlockDb(pPager, 1);
          }
          sqlite3EndBenignMalloc();
        }else{






          if( !jrnlOpen ){
            int f = 0x00000001|0x00000800;
            rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &f);
          }
          if( rc==0 ){
            u8 first = 0;
            rc = sqlite3OsRead(pPager->jfd, (void *)&first, 1, 0);
            if( rc==(10 | (2<<8)) ){
              rc = 0;
            }
            if( !jrnlOpen ){
              sqlite3OsClose(pPager->jfd);
            }
            *pExists = (first!=0);
          }else if( rc==14 ){
# 64135 "c_tests/sqlite3.c"
            *pExists = 1;
            rc = 0;
          }
        }
      }
    }
  }

  return rc;
}
# 64173 "c_tests/sqlite3.c"
static int sqlite3PagerSharedLock(Pager *pPager){
  int rc = 0;





  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( !((pPager)->pWal!=0) && pPager->eState==0 ){
    int bHotJournal = 1;

    ((void) (0));
    ((void) (0));

    rc = pager_wait_on_lock(pPager, 1);
    if( rc!=0 ){
      ((void) (0));
      goto failed;
    }




    if( pPager->eLock<=1 ){
      rc = hasHotJournal(pPager, &bHotJournal);
    }
    if( rc!=0 ){
      goto failed;
    }
    if( bHotJournal ){
      if( pPager->readOnly ){
        rc = (8 | (3<<8));
        goto failed;
      }
# 64227 "c_tests/sqlite3.c"
      rc = pagerLockDb(pPager, 4);
      if( rc!=0 ){
        goto failed;
      }
# 64245 "c_tests/sqlite3.c"
      if( !((pPager->jfd)->pMethods!=0) && pPager->journalMode!=2 ){
        sqlite3_vfs * const pVfs = pPager->pVfs;
        int bExists;
        rc = sqlite3OsAccess(
            pVfs, pPager->zJournal, 0, &bExists);
        if( rc==0 && bExists ){
          int fout = 0;
          int f = 0x00000002|0x00000800;
          ((void) (0));
          rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);
          ((void) (0));
          if( rc==0 && fout&0x00000001 ){
            rc = sqlite3CantopenError(64257);
            sqlite3OsClose(pPager->jfd);
          }
        }
      }
# 64271 "c_tests/sqlite3.c"
      if( ((pPager->jfd)->pMethods!=0) ){
        ((void) (0));
        rc = pagerSyncHotJournal(pPager);
        if( rc==0 ){
          rc = pager_playback(pPager, !pPager->tempFile);
          pPager->eState = 0;
        }
      }else if( !pPager->exclusiveMode ){
        pagerUnlockDb(pPager, 1);
      }

      if( rc!=0 ){
# 64299 "c_tests/sqlite3.c"
        pager_error(pPager, rc);
        goto failed;
      }

      ((void) (0));
      ((void) (0));


    }

    if( !pPager->tempFile && pPager->hasHeldSharedLock ){
# 64326 "c_tests/sqlite3.c"
      char dbFileVers[sizeof(pPager->dbFileVers)];

                                                             ;
      rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);
      if( rc!=0 ){
        if( rc!=(10 | (2<<8)) ){
          goto failed;
        }
        memset(dbFileVers, 0, sizeof(dbFileVers));
      }

      if( memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers))!=0 ){
        pager_reset(pPager);







        if( ((pPager)->bUseFetch) ){
          sqlite3OsUnfetch(pPager->fd, 0, 0);
        }
      }
    }




    rc = pagerOpenWalIfPresent(pPager);

    ((void) (0));

  }

  if( ((pPager)->pWal!=0) ){
    ((void) (0));
    rc = pagerBeginReadTransaction(pPager);
  }

  if( pPager->tempFile==0 && pPager->eState==0 && rc==0 ){
    rc = pagerPagecount(pPager, &pPager->dbSize);
  }

 failed:
  if( rc!=0 ){
    ((void) (0));
    pager_unlock(pPager);
    ((void) (0));
  }else{
    pPager->eState = 1;
    pPager->hasHeldSharedLock = 1;
  }
  return rc;
}
# 64390 "c_tests/sqlite3.c"
static void pagerUnlockIfUnused(Pager *pPager){
  if( sqlite3PcacheRefCount(pPager->pPCache)==0 ){
    ((void) (0));
    pagerUnlockAndRollback(pPager);
  }
}
# 64454 "c_tests/sqlite3.c"
static int getPageNormal(
  Pager *pPager,
  Pgno pgno,
  DbPage **ppPage,
  int flags
){
  int rc = 0;
  PgHdr *pPg;
  u8 noContent;
  sqlite3_pcache_page *pBase;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pgno==0 ) return sqlite3CorruptError(64470);
  pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);
  if( pBase==0 ){
    pPg = 0;
    rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);
    if( rc!=0 ) goto pager_acquire_err;
    if( pBase==0 ){
      rc = 7;
      goto pager_acquire_err;
    }
  }
  pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);
  ((void) (0));
  ((void) (0));
  ((void) (0));

  noContent = (flags & 0x01)!=0;
  if( pPg->pPager && !noContent ){


    ((void) (0));
    pPager->aStat[0]++;
    return 0;

  }else{






    if( pgno==((pPager)->lckPgno) ){
      rc = sqlite3CorruptError(64502);
      goto pager_acquire_err;
    }

    pPg->pPager = pPager;

    ((void) (0));
    if( !((pPager->fd)->pMethods!=0) || pPager->dbSize<pgno || noContent ){
      if( pgno>pPager->mxPgno ){
        rc = 13;
        if( pgno<=pPager->dbSize ){
          sqlite3PcacheRelease(pPg);
          pPg = 0;
        }
        goto pager_acquire_err;
      }
      if( noContent ){






        sqlite3BeginBenignMalloc();
        if( pgno<=pPager->dbOrigSize ){
                           sqlite3BitvecSet(pPager->pInJournal, pgno);
                                      ;
        }
                         addToSavepointBitvecs(pPager, pgno);
                                    ;
        sqlite3EndBenignMalloc();
      }
      memset(pPg->pData, 0, pPager->pageSize);
                                             ;
    }else{
      ((void) (0));
      pPager->aStat[1]++;
      rc = readDbPage(pPg);
      if( rc!=0 ){
        goto pager_acquire_err;
      }
    }
                           ;
  }
  return 0;

pager_acquire_err:
  ((void) (0));
  if( pPg ){
    sqlite3PcacheDrop(pPg);
  }
  pagerUnlockIfUnused(pPager);
  *ppPage = 0;
  return rc;
}



static int getPageMMap(
  Pager *pPager,
  Pgno pgno,
  DbPage **ppPage,
  int flags
){
  int rc = 0;
  PgHdr *pPg = 0;
  u32 iFrame = 0;





  const int bMmapOk = (pgno>1
   && (pPager->eState==1 || (flags & 0x02))
  );

  ((void) (0));





  if( pgno<=1 && pgno==0 ){
    return sqlite3CorruptError(64585);
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( bMmapOk && ((pPager)->pWal!=0) ){
    rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iFrame);
    if( rc!=0 ){
      *ppPage = 0;
      return rc;
    }
  }
  if( bMmapOk && iFrame==0 ){
    void *pData = 0;
    rc = sqlite3OsFetch(pPager->fd,
        (i64)(pgno-1) * pPager->pageSize, pPager->pageSize, &pData
    );
    if( rc==0 && pData ){
      if( pPager->eState>1 || pPager->tempFile ){
        pPg = sqlite3PagerLookup(pPager, pgno);
      }
      if( pPg==0 ){
        rc = pagerAcquireMapPage(pPager, pgno, pData, &pPg);
      }else{
        sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1)*pPager->pageSize, pData);
      }
      if( pPg ){
        ((void) (0));
        *ppPage = pPg;
        return 0;
      }
    }
    if( rc!=0 ){
      *ppPage = 0;
      return rc;
    }
  }
  return getPageNormal(pPager, pgno, ppPage, flags);
}



static int getPageError(
  Pager *pPager,
  Pgno pgno,
  DbPage **ppPage,
  int flags
){
  (void)(pgno);
  (void)(flags);
  ((void) (0));
  *ppPage = 0;
  return pPager->errCode;
}




static int sqlite3PagerGet(
  Pager *pPager,
  Pgno pgno,
  DbPage **ppPage,
  int flags
){
# 64663 "c_tests/sqlite3.c"
  return pPager->xGet(pPager, pgno, ppPage, flags);

}
# 64678 "c_tests/sqlite3.c"
static DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){
  sqlite3_pcache_page *pPage;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pPage = sqlite3PcacheFetch(pPager->pPCache, pgno, 0);
  ((void) (0));
  if( pPage==0 ) return 0;
  return sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pPage);
}
# 64703 "c_tests/sqlite3.c"
static void sqlite3PagerUnrefNotNull(DbPage *pPg){

  ((void) (0));
  if( pPg->flags & 0x020 ){
    ((void) (0));
    pagerReleaseMapPage(pPg);
  }else{
    sqlite3PcacheRelease(pPg);
  }

  ((void) (0));
}
static void sqlite3PagerUnref(DbPage *pPg){
  if( pPg ) sqlite3PagerUnrefNotNull(pPg);
}
static void sqlite3PagerUnrefPageOne(DbPage *pPg){
  Pager *pPager;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pPager = pPg->pPager;
  sqlite3PcacheRelease(pPg);
  pagerUnlockIfUnused(pPager);
}
# 64750 "c_tests/sqlite3.c"
static int pager_open_journal(Pager *pPager){
  int rc = 0;
  sqlite3_vfs * const pVfs = pPager->pVfs;

  ((void) (0));
  ((void) (0));
  ((void) (0));




  if( (pPager->errCode) ) return pPager->errCode;

  if( !((pPager)->pWal!=0) && pPager->journalMode!=2 ){
    pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);
    if( pPager->pInJournal==0 ){
      return 7;
    }


    if( !((pPager->jfd)->pMethods!=0) ){
      if( pPager->journalMode==4 ){
        sqlite3MemJournalOpen(pPager->jfd);
      }else{
        int flags = 0x00000002|0x00000004;
        int nSpill;

        if( pPager->tempFile ){
          flags |= (0x00000008|0x00001000);
          flags |= 0x00000010;
          nSpill = sqlite3Config.nStmtSpill;
        }else{
          flags |= 0x00000800;
          nSpill = jrnlBufferSize(pPager);
        }



        rc = databaseIsUnmoved(pPager);
        if( rc==0 ){
          rc = sqlite3JournalOpen (
              pVfs, pPager->zJournal, pPager->jfd, flags, nSpill
          );
        }
      }
      ((void) (0));
    }





    if( rc==0 ){

      pPager->nRec = 0;
      pPager->journalOff = 0;
      pPager->setSuper = 0;
      pPager->journalHdr = 0;
      rc = writeJournalHdr(pPager);
    }
  }

  if( rc!=0 ){
    sqlite3BitvecDestroy(pPager->pInJournal);
    pPager->pInJournal = 0;
    pPager->journalOff = 0;
  }else{
    ((void) (0));
    pPager->eState = 3;
  }

  return rc;
}
# 64841 "c_tests/sqlite3.c"
static int sqlite3PagerBegin(Pager *pPager, int exFlag, int subjInMemory){
  int rc = 0;

  if( pPager->errCode ) return pPager->errCode;
  ((void) (0));
  pPager->subjInMemory = (u8)subjInMemory;

  if( pPager->eState==1 ){
    ((void) (0));

    if( ((pPager)->pWal!=0) ){



      if( pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, -1) ){
        rc = pagerLockDb(pPager, 4);
        if( rc!=0 ){
          return rc;
        }
        (void)sqlite3WalExclusiveMode(pPager->pWal, 1);
      }






      rc = sqlite3WalBeginWriteTransaction(pPager->pWal);
    }else{





      rc = pagerLockDb(pPager, 2);
      if( rc==0 && exFlag ){
        rc = pager_wait_on_lock(pPager, 4);
      }
    }

    if( rc==0 ){
# 64891 "c_tests/sqlite3.c"
      pPager->eState = 2;
      pPager->dbHintSize = pPager->dbSize;
      pPager->dbFileSize = pPager->dbSize;
      pPager->dbOrigSize = pPager->dbSize;
      pPager->journalOff = 0;
    }

    ((void) (0));
    ((void) (0));
    ((void) (0));
  }

                                                   ;
  return rc;
}




static __attribute__((noinline)) int pagerAddPageToRollbackJournal(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  int rc;
  u32 cksum;
  char *pData2;
  i64 iOff = pPager->journalOff;




  ((void) (0));

  ((void) (0));
  pData2 = pPg->pData;
  cksum = pager_cksum(pPager, (u8*)pData2);
# 64933 "c_tests/sqlite3.c"
  pPg->flags |= 0x008;

  rc = write32bits(pPager->jfd, iOff, pPg->pgno);
  if( rc!=0 ) return rc;
  rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff+4);
  if( rc!=0 ) return rc;
  rc = write32bits(pPager->jfd, iOff+pPager->pageSize+4, cksum);
  if( rc!=0 ) return rc;


                                                 ;
                                        ;


                                                                ;

  pPager->journalOff += 8 + pPager->pageSize;
  pPager->nRec++;
  ((void) (0));
  rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);
                              ;
  ((void) (0));
  rc |= addToSavepointBitvecs(pPager, pPg->pgno);
  ((void) (0));
  return rc;
}
# 64967 "c_tests/sqlite3.c"
static int pager_write(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  int rc = 0;





  ((void) (0));



  ((void) (0));
  ((void) (0));
  ((void) (0));
                 ;
# 64993 "c_tests/sqlite3.c"
  if( pPager->eState==2 ){
    rc = pager_open_journal(pPager);
    if( rc!=0 ) return rc;
  }
  ((void) (0));
  ((void) (0));


  sqlite3PcacheMakeDirty(pPg);





  ((void) (0));
  if( pPager->pInJournal!=0
   && sqlite3BitvecTestNotNull(pPager->pInJournal, pPg->pgno)==0
  ){
    ((void) (0));
    if( pPg->pgno<=pPager->dbOrigSize ){
      rc = pagerAddPageToRollbackJournal(pPg);
      if( rc!=0 ){
        return rc;
      }
    }else{
      if( pPager->eState!=4 ){
        pPg->flags |= 0x008;
      }


                                                 ;
    }
  }






  pPg->flags |= 0x004;




  if( pPager->nSavepoint>0 ){
    rc = subjournalPageIfRequired(pPg);
  }


  if( pPager->dbSize<pPg->pgno ){
    pPager->dbSize = pPg->pgno;
  }
  return rc;
}
# 65059 "c_tests/sqlite3.c"
static __attribute__((noinline)) int pagerWriteLargeSector(PgHdr *pPg){
  int rc = 0;
  Pgno nPageCount;
  Pgno pg1;
  int nPage = 0;
  int ii;
  int needSync = 0;
  Pager *pPager = pPg->pPager;
  Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize);





  ((void) (0));
  ((void) (0));
  pPager->doNotSpill |= 0x04;





  pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1;

  nPageCount = pPager->dbSize;
  if( pPg->pgno>nPageCount ){
    nPage = (pPg->pgno - pg1)+1;
  }else if( (pg1+nPagePerSector-1)>nPageCount ){
    nPage = nPageCount+1-pg1;
  }else{
    nPage = nPagePerSector;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));

  for(ii=0; ii<nPage && rc==0; ii++){
    Pgno pg = pg1+ii;
    PgHdr *pPage;
    if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){
      if( pg!=((pPager)->lckPgno) ){
        rc = sqlite3PagerGet(pPager, pg, &pPage, 0);
        if( rc==0 ){
          rc = pager_write(pPage);
          if( pPage->flags&0x008 ){
            needSync = 1;
          }
          sqlite3PagerUnrefNotNull(pPage);
        }
      }
    }else if( (pPage = sqlite3PagerLookup(pPager, pg))!=0 ){
      if( pPage->flags&0x008 ){
        needSync = 1;
      }
      sqlite3PagerUnrefNotNull(pPage);
    }
  }







  if( rc==0 && needSync ){
    ((void) (0));
    for(ii=0; ii<nPage; ii++){
      PgHdr *pPage = sqlite3PagerLookup(pPager, pg1+ii);
      if( pPage ){
        pPage->flags |= 0x008;
        sqlite3PagerUnrefNotNull(pPage);
      }
    }
  }

  ((void) (0));
  pPager->doNotSpill &= ~0x04;
  return rc;
}
# 65153 "c_tests/sqlite3.c"
static int sqlite3PagerWrite(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( (pPg->flags & 0x004)!=0 && pPager->dbSize>=pPg->pgno ){
    if( pPager->nSavepoint ) return subjournalPageIfRequired(pPg);
    return 0;
  }else if( pPager->errCode ){
    return pPager->errCode;
  }else if( pPager->sectorSize > (u32)pPager->pageSize ){
    ((void) (0));
    return pagerWriteLargeSector(pPg);
  }else{
    return pager_write(pPg);
  }
}
# 65202 "c_tests/sqlite3.c"
static void sqlite3PagerDontWrite(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  if( !pPager->tempFile && (pPg->flags&0x002) && pPager->nSavepoint==0 ){
                                                                          ;

    pPg->flags |= 0x010;
    pPg->flags &= ~0x004;
                                            ;
                           ;
  }
}
# 65236 "c_tests/sqlite3.c"
static int pager_incr_changecounter(Pager *pPager, int isDirectMode){
  int rc = 0;

  ((void) (0));


  ((void) (0));
# 65256 "c_tests/sqlite3.c"
  ((void) (0));
  (void)(isDirectMode);




  if( !pPager->changeCountDone && pPager->dbSize>0 ){
    PgHdr *pPgHdr;

    ((void) (0));


    rc = sqlite3PagerGet(pPager, 1, &pPgHdr, 0);
    ((void) (0));






    if( !0 && (rc==0) ){
      rc = sqlite3PagerWrite(pPgHdr);
    }

    if( rc==0 ){

      pager_write_changecounter(pPgHdr);


      if( 0 ){
        const void *zBuf;
        ((void) (0));
        zBuf = pPgHdr->pData;
        if( rc==0 ){
          rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0);
          pPager->aStat[2]++;
        }
        if( rc==0 ){



          const void *pCopy = (const void *)&((const char *)zBuf)[24];
          memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));
          pPager->changeCountDone = 1;
        }
      }else{
        pPager->changeCountDone = 1;
      }
    }


    sqlite3PagerUnref(pPgHdr);
  }
  return rc;
}
# 65319 "c_tests/sqlite3.c"
static int sqlite3PagerSync(Pager *pPager, const char *zSuper){
  int rc = 0;
  void *pArg = (void*)zSuper;
  rc = sqlite3OsFileControl(pPager->fd, 21, pArg);
  if( rc==12 ) rc = 0;
  if( rc==0 && !pPager->noSync ){
    ((void) (0));
    rc = sqlite3OsSync(pPager->fd, pPager->syncFlags);
  }
  return rc;
}
# 65342 "c_tests/sqlite3.c"
static int sqlite3PagerExclusiveLock(Pager *pPager){
  int rc = pPager->errCode;
  ((void) (0));
  if( rc==0 ){
    ((void) (0));



    ((void) (0));
    if( 0==((pPager)->pWal!=0) ){
      rc = pager_wait_on_lock(pPager, 4);
    }
  }
  return rc;
}
# 65384 "c_tests/sqlite3.c"
static int sqlite3PagerCommitPhaseOne(
  Pager *pPager,
  const char *zSuper,
  int noSync
){
  int rc = 0;

  ((void) (0));




  ((void) (0));


  if( (pPager->errCode) ) return pPager->errCode;


  if( sqlite3FaultSim(400) ) return 10;


                                                 ;


  if( pPager->eState<3 ) return 0;

  ((void) (0));
  ((void) (0));
  if( 0==pagerFlushOnCommit(pPager, 1) ){



    sqlite3BackupRestart(pPager->pBackup);
  }else{
    PgHdr *pList;
    if( ((pPager)->pWal!=0) ){
      PgHdr *pPageOne = 0;
      pList = sqlite3PcacheDirtyList(pPager->pPCache);
      if( pList==0 ){


        rc = sqlite3PagerGet(pPager, 1, &pPageOne, 0);
        pList = pPageOne;
        pList->pDirty = 0;
      }
      ((void) (0));
      if( (pList) ){
        rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);
      }
      sqlite3PagerUnref(pPageOne);
      if( rc==0 ){
        sqlite3PcacheCleanAll(pPager->pPCache);
      }
    }else{
# 65509 "c_tests/sqlite3.c"
      rc = pager_incr_changecounter(pPager, 0);

      if( rc!=0 ) goto commit_phase_one_exit;





      rc = writeSuperJournal(pPager, zSuper);
      if( rc!=0 ) goto commit_phase_one_exit;
# 65531 "c_tests/sqlite3.c"
      rc = syncJournal(pPager, 0);
      if( rc!=0 ) goto commit_phase_one_exit;

      pList = sqlite3PcacheDirtyList(pPager->pPCache);
# 65568 "c_tests/sqlite3.c"
      if( 0==0 ){
        rc = pager_write_pagelist(pPager, pList);
      }
      if( rc!=0 ){
        ((void) (0));
        goto commit_phase_one_exit;
      }
      sqlite3PcacheCleanAll(pPager->pPCache);







      if( pPager->dbSize>pPager->dbFileSize ){
        Pgno nNew = pPager->dbSize - (pPager->dbSize==((pPager)->lckPgno));
        ((void) (0));
        rc = pager_truncate(pPager, nNew);
        if( rc!=0 ) goto commit_phase_one_exit;
      }


      if( !noSync ){
        rc = sqlite3PagerSync(pPager, zSuper);
      }

    }
  }

commit_phase_one_exit:
  if( rc==0 && !((pPager)->pWal!=0) ){
    pPager->eState = 5;
  }
  return rc;
}
# 65621 "c_tests/sqlite3.c"
static int sqlite3PagerCommitPhaseTwo(Pager *pPager){
  int rc = 0;




  if( (pPager->errCode) ) return pPager->errCode;
  pPager->iDataVersion++;

  ((void) (0));



  ((void) (0));
# 65647 "c_tests/sqlite3.c"
  if( pPager->eState==2
   && pPager->exclusiveMode
   && pPager->journalMode==1
  ){
    ((void) (0));
    pPager->eState = 1;
    return 0;
  }

                                              ;
  rc = pager_end_transaction(pPager, pPager->setSuper, 1);
  return pager_error(pPager, rc);
}
# 65687 "c_tests/sqlite3.c"
static int sqlite3PagerRollback(Pager *pPager){
  int rc = 0;
                                                ;





  ((void) (0));
  if( pPager->eState==6 ) return pPager->errCode;
  if( pPager->eState<=1 ) return 0;

  if( ((pPager)->pWal!=0) ){
    int rc2;
    rc = sqlite3PagerSavepoint(pPager, 2, -1);
    rc2 = pager_end_transaction(pPager, pPager->setSuper, 0);
    if( rc==0 ) rc = rc2;
  }else if( !((pPager->jfd)->pMethods!=0) || pPager->eState==2 ){
    int eState = pPager->eState;
    rc = pager_end_transaction(pPager, 0, 0);
    if( !pPager->memDb && eState>2 ){




      pPager->errCode = 4;
      pPager->eState = 6;
      setGetterMethod(pPager);
      return rc;
    }
  }else{
    rc = pager_playback(pPager, 0);
  }

  ((void) (0));
  ((void) (0));







  return pager_error(pPager, rc);
}





static u8 sqlite3PagerIsreadonly(Pager *pPager){
  return pPager->readOnly;
}
# 65754 "c_tests/sqlite3.c"
static int sqlite3PagerMemUsed(Pager *pPager){
  int perPageSize = pPager->pageSize + pPager->nExtra
    + (int)(sizeof(PgHdr) + 5*sizeof(void*));
  return perPageSize*sqlite3PcachePagecount(pPager->pPCache)
           + sqlite3MallocSize(pPager)
           + pPager->pageSize;
}




static int sqlite3PagerPageRefcount(DbPage *pPage){
  return sqlite3PcachePageRefcount(pPage);
}
# 65801 "c_tests/sqlite3.c"
static void sqlite3PagerCacheStat(Pager *pPager, int eStat, int reset, u64 *pnVal){

  ((void) (0));





  ((void) (0));
  ((void) (0));
  ((void) (0));


  eStat -= 7;
  *pnVal += pPager->aStat[eStat];
  if( reset ){
    pPager->aStat[eStat] = 0;
  }
}




static int sqlite3PagerIsMemdb(Pager *pPager){
  return pPager->tempFile || pPager->memVfs;
}
# 65838 "c_tests/sqlite3.c"
static __attribute__((noinline)) int pagerOpenSavepoint(Pager *pPager, int nSavepoint){
  int rc = 0;
  int nCurrent = pPager->nSavepoint;
  int ii;
  PagerSavepoint *aNew;

  ((void) (0));
  ((void) (0));
  ((void) (0));





  aNew = (PagerSavepoint *)sqlite3Realloc(
      pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint
  );
  if( !aNew ){
    return 7;
  }
  memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));
  pPager->aSavepoint = aNew;


  for(ii=nCurrent; ii<nSavepoint; ii++){
    aNew[ii].nOrig = pPager->dbSize;
    if( ((pPager->jfd)->pMethods!=0) && pPager->journalOff>0 ){
      aNew[ii].iOffset = pPager->journalOff;
    }else{
      aNew[ii].iOffset = (pPager->sectorSize);
    }
    aNew[ii].iSubRec = pPager->nSubRec;
    aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);
    aNew[ii].bTruncateOnRelease = 1;
    if( !aNew[ii].pInSavepoint ){
      return 7;
    }
    if( ((pPager)->pWal!=0) ){
      sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);
    }
    pPager->nSavepoint = ii+1;
  }
  ((void) (0));
                                  ;
  return rc;
}
static int sqlite3PagerOpenSavepoint(Pager *pPager, int nSavepoint){
  ((void) (0));
  ((void) (0));

  if( nSavepoint>pPager->nSavepoint && pPager->useJournal ){
    return pagerOpenSavepoint(pPager, nSavepoint);
  }else{
    return 0;
  }
}
# 65926 "c_tests/sqlite3.c"
static int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint){
  int rc = pPager->errCode;





  ((void) (0));
  ((void) (0));

  if( rc==0 && iSavepoint<pPager->nSavepoint ){
    int ii;
    int nNew;





    nNew = iSavepoint + (( op==1 ) ? 0 : 1);
    for(ii=nNew; ii<pPager->nSavepoint; ii++){
      sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
    }
    pPager->nSavepoint = nNew;



    if( op==1 ){
      PagerSavepoint *pRel = &pPager->aSavepoint[nNew];
      if( pRel->bTruncateOnRelease && ((pPager->sjfd)->pMethods!=0) ){

        if( sqlite3JournalIsInMemory(pPager->sjfd) ){
          i64 sz = (pPager->pageSize+4)*(i64)pRel->iSubRec;
          rc = sqlite3OsTruncate(pPager->sjfd, sz);
          ((void) (0));
        }
        pPager->nSubRec = pRel->iSubRec;
      }
    }





    else if( ((pPager)->pWal!=0) || ((pPager->jfd)->pMethods!=0) ){
      PagerSavepoint *pSavepoint = (nNew==0)?0:&pPager->aSavepoint[nNew-1];
      rc = pagerPlaybackSavepoint(pPager, pSavepoint);
      ((void) (0));
    }
# 65989 "c_tests/sqlite3.c"
  }

  return rc;
}
# 66007 "c_tests/sqlite3.c"
static const char *sqlite3PagerFilename(const Pager *pPager, int nullIfMemDb){
  static const char zFake[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
  if( nullIfMemDb && (pPager->memDb || sqlite3IsMemdb(pPager->pVfs)) ){
    return &zFake[4];
  }else{
    return pPager->zFilename;
  }
}




static sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){
  return pPager->pVfs;
}






static sqlite3_file *sqlite3PagerFile(Pager *pPager){
  return pPager->fd;
}





static sqlite3_file *sqlite3PagerJrnlFile(Pager *pPager){



  return pPager->pWal ? sqlite3WalFile(pPager->pWal) : pPager->jfd;

}




static const char *sqlite3PagerJournalname(Pager *pPager){
  return pPager->zJournal;
}
# 66077 "c_tests/sqlite3.c"
static int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){
  PgHdr *pPgOld;
  Pgno needSyncPgno = 0;
  int rc;
  Pgno origPgno;

  ((void) (0));
  ((void) (0));


  ((void) (0));




  ((void) (0));
  if( pPager->tempFile ){
    rc = sqlite3PagerWrite(pPg);
    if( rc ) return rc;
  }
# 66116 "c_tests/sqlite3.c"
  if( (pPg->flags & 0x002)!=0
   && 0!=(rc = subjournalPageIfRequired(pPg))
  ){
    return rc;
  }


                                                                          ;
# 66133 "c_tests/sqlite3.c"
  if( (pPg->flags&0x008) && !isCommit ){
    needSyncPgno = pPg->pgno;
    ((void) (0));

    ((void) (0));
  }






  pPg->flags &= ~0x008;
  pPgOld = sqlite3PagerLookup(pPager, pgno);
  ((void) (0));
  if( pPgOld ){
    if( (pPgOld->nRef>1) ){
      sqlite3PagerUnrefNotNull(pPgOld);
      return sqlite3CorruptError(66151);
    }
    pPg->flags |= (pPgOld->flags&0x008);
    if( pPager->tempFile ){


      sqlite3PcacheMove(pPgOld, pPager->dbSize+1);
    }else{
      sqlite3PcacheDrop(pPgOld);
    }
  }

  origPgno = pPg->pgno;
  sqlite3PcacheMove(pPg, pgno);
  sqlite3PcacheMakeDirty(pPg);





  if( pPager->tempFile && pPgOld ){
    sqlite3PcacheMove(pPgOld, origPgno);
    sqlite3PagerUnrefNotNull(pPgOld);
  }

  if( needSyncPgno ){
# 66191 "c_tests/sqlite3.c"
    PgHdr *pPgHdr;
    rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr, 0);
    if( rc!=0 ){
      if( needSyncPgno<=pPager->dbOrigSize ){
        ((void) (0));
        sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, pPager->pTmpSpace);
      }
      return rc;
    }
    pPgHdr->flags |= 0x008;
    sqlite3PcacheMakeDirty(pPgHdr);
    sqlite3PagerUnrefNotNull(pPgHdr);
  }

  return 0;
}
# 66215 "c_tests/sqlite3.c"
static void sqlite3PagerRekey(DbPage *pPg, Pgno iNew, u16 flags){
  ((void) (0));
  pPg->flags = flags;
  sqlite3PcacheMove(pPg, iNew);
}




static void *sqlite3PagerGetData(DbPage *pPg){
  ((void) (0));
  return pPg->pData;
}





static void *sqlite3PagerGetExtra(DbPage *pPg){
  return pPg->pExtra;
}
# 66247 "c_tests/sqlite3.c"
static int sqlite3PagerLockingMode(Pager *pPager, int eMode){
  ((void) (0));


  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( eMode>=0 && !pPager->tempFile && !sqlite3WalHeapMemory(pPager->pWal) ){
    pPager->exclusiveMode = (u8)eMode;
  }
  return (int)pPager->exclusiveMode;
}
# 66280 "c_tests/sqlite3.c"
static int sqlite3PagerSetJournalMode(Pager *pPager, int eMode){
  u8 eOld = pPager->journalMode;


  ((void) (0));
# 66295 "c_tests/sqlite3.c"
  ((void) (0));




  if( pPager->memDb ){
    ((void) (0));
    if( eMode!=4 && eMode!=2 ){
      eMode = eOld;
    }
  }

  if( eMode!=eOld ){


    ((void) (0));
    pPager->journalMode = (u8)eMode;





    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));

    ((void) (0));
    if( !pPager->exclusiveMode && (eOld & 5)==1 && (eMode & 1)==0 ){
# 66334 "c_tests/sqlite3.c"
      sqlite3OsClose(pPager->jfd);
      if( pPager->eLock>=2 ){
        sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
      }else{
        int rc = 0;
        int state = pPager->eState;
        ((void) (0));
        if( state==0 ){
          rc = sqlite3PagerSharedLock(pPager);
        }
        if( pPager->eState==1 ){
          ((void) (0));
          rc = pagerLockDb(pPager, 2);
        }
        if( rc==0 ){
          sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
        }
        if( rc==0 && state==1 ){
          pagerUnlockDb(pPager, 1);
        }else if( state==0 ){
          pager_unlock(pPager);
        }
        ((void) (0));
      }
    }else if( eMode==2 || eMode==4 ){
      sqlite3OsClose(pPager->jfd);
    }
  }


  return (int)pPager->journalMode;
}




static int sqlite3PagerGetJournalMode(Pager *pPager){
  return (int)pPager->journalMode;
}






static int sqlite3PagerOkToChangeJournalMode(Pager *pPager){
  ((void) (0));
  if( pPager->eState>=3 ) return 0;
  if( (((pPager->jfd)->pMethods!=0) && pPager->journalOff>0) ) return 0;
  return 1;
}







static i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit){
  if( iLimit>=-1 ){
    pPager->journalSizeLimit = iLimit;
    sqlite3WalLimit(pPager->pWal, iLimit);
  }
  return pPager->journalSizeLimit;
}







static sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager){
  return &pPager->pBackup;
}





static void sqlite3PagerClearCache(Pager *pPager){
  ((void) (0));
  if( pPager->tempFile==0 ) pager_reset(pPager);
}
# 66429 "c_tests/sqlite3.c"
static int sqlite3PagerCheckpoint(
  Pager *pPager,
  sqlite3 *db,
  int eMode,
  int *pnLog,
  int *pnCkpt
){
  int rc = 0;
  if( pPager->pWal==0 && pPager->journalMode==5 ){
# 66447 "c_tests/sqlite3.c"
    sqlite3_exec(db, "PRAGMA table_list",0,0,0);
  }
  if( pPager->pWal ){
    rc = sqlite3WalCheckpoint(pPager->pWal, db, eMode,
        (eMode<=0 ? 0 : pPager->xBusyHandler),
        pPager->pBusyHandlerArg,
        pPager->walSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,
        pnLog, pnCkpt
    );
  }
  return rc;
}

static int sqlite3PagerWalCallback(Pager *pPager){
  return sqlite3WalCallback(pPager->pWal);
}





static int sqlite3PagerWalSupported(Pager *pPager){
  const sqlite3_io_methods *pMethods = pPager->fd->pMethods;
  if( pPager->noLock ) return 0;
  return pPager->exclusiveMode || (pMethods->iVersion>=2 && pMethods->xShmMap);
}





static int pagerExclusiveLock(Pager *pPager){
  int rc;
  u8 eOrigLock;

  ((void) (0));
  eOrigLock = pPager->eLock;
  rc = pagerLockDb(pPager, 4);
  if( rc!=0 ){


    pagerUnlockDb(pPager, eOrigLock);
  }

  return rc;
}







static int pagerOpenWal(Pager *pPager){
  int rc = 0;

  ((void) (0));
  ((void) (0));






  if( pPager->exclusiveMode ){
    rc = pagerExclusiveLock(pPager);
  }




  if( rc==0 ){
    rc = sqlite3WalOpen(pPager->pVfs,
        pPager->fd, pPager->zWal, pPager->exclusiveMode,
        pPager->journalSizeLimit, &pPager->pWal
    );





  }
  pagerFixMaplimit(pPager);

  return rc;
}
# 66550 "c_tests/sqlite3.c"
static int sqlite3PagerOpenWal(
  Pager *pPager,
  int *pbOpen
){
  int rc = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( !pPager->tempFile && !pPager->pWal ){
    if( !sqlite3PagerWalSupported(pPager) ) return 14;


    sqlite3OsClose(pPager->jfd);

    rc = pagerOpenWal(pPager);
    if( rc==0 ){
      pPager->journalMode = 5;
      pPager->eState = 0;
    }
  }else{
    *pbOpen = 1;
  }

  return rc;
}
# 66589 "c_tests/sqlite3.c"
static int sqlite3PagerCloseWal(Pager *pPager, sqlite3 *db){
  int rc = 0;

  ((void) (0));





  if( !pPager->pWal ){
    int logexists = 0;
    rc = pagerLockDb(pPager, 1);
    if( rc==0 ){
      rc = sqlite3OsAccess(
          pPager->pVfs, pPager->zWal, 0, &logexists
      );
    }
    if( rc==0 && logexists ){
      rc = pagerOpenWal(pPager);
    }
  }




  if( rc==0 && pPager->pWal ){
    rc = pagerExclusiveLock(pPager);
    if( rc==0 ){
      rc = sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags,
                           pPager->pageSize, (u8*)pPager->pTmpSpace);
      pPager->pWal = 0;
      pagerFixMaplimit(pPager);
      if( rc && !pPager->exclusiveMode ) pagerUnlockDb(pPager, 1);
    }
  }
  return rc;
}
# 67059 "c_tests/sqlite3.c"
typedef struct WalIndexHdr WalIndexHdr;
typedef struct WalIterator WalIterator;
typedef struct WalCkptInfo WalCkptInfo;
# 67077 "c_tests/sqlite3.c"
struct WalIndexHdr {
  u32 iVersion;
  u32 unused;
  u32 iChange;
  u8 isInit;
  u8 bigEndCksum;
  u16 szPage;
  u32 mxFrame;
  u32 nPage;
  u32 aFrameCksum[2];
  u32 aSalt[2];
  u32 aCksum[2];
};
# 67150 "c_tests/sqlite3.c"
struct WalCkptInfo {
  u32 nBackfill;
  u32 aReadMark[(8 -3)];
  u8 aLock[8];
  u32 nBackfillAttempted;
  u32 notUsed0;
};
# 67267 "c_tests/sqlite3.c"
struct Wal {
  sqlite3_vfs *pVfs;
  sqlite3_file *pDbFd;
  sqlite3_file *pWalFd;
  u32 iCallback;
  i64 mxWalSize;
  int nWiData;
  int szFirstBlock;
  volatile u32 **apWiData;
  u32 szPage;
  i16 readLock;
  u8 syncFlags;
  u8 exclusiveMode;
  u8 writeLock;
  u8 ckptLock;
  u8 readOnly;
  u8 truncateOnCommit;
  u8 syncHeader;
  u8 padToSectorBoundary;
  u8 bShmUnreliable;
  WalIndexHdr hdr;
  u32 minFrame;
  u32 iReCksum;
  const char *zWalName;
  u32 nCkpt;
# 67310 "c_tests/sqlite3.c"
};
# 67330 "c_tests/sqlite3.c"
typedef u16 ht_slot;
# 67347 "c_tests/sqlite3.c"
struct WalIterator {
  u32 iPrior;
  int nSegment;
  struct WalSegment {
    int iNext;
    ht_slot *aIndex;
    u32 *aPgno;
    int nEntry;
    int iZero;
  } aSegment[];
};
# 67512 "c_tests/sqlite3.c"
static __attribute__((noinline)) int walIndexPageRealloc(
  Wal *pWal,
  int iPage,
  volatile u32 **ppPage
){
  int rc = 0;


  if( pWal->nWiData<=iPage ){
    sqlite3_int64 nByte = sizeof(u32*)*(1+(i64)iPage);
    volatile u32 **apNew;
    apNew = (volatile u32 **)sqlite3Realloc((void *)pWal->apWiData, nByte);
    if( !apNew ){
      *ppPage = 0;
      return 7;
    }
    memset((void*)&apNew[pWal->nWiData], 0,
           sizeof(u32*)*(iPage+1-pWal->nWiData));
    pWal->apWiData = apNew;
    pWal->nWiData = iPage+1;
  }


  ((void) (0));
  if( pWal->exclusiveMode==2 ){
    pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(( sizeof(ht_slot)*(4096*2) + 4096*sizeof(u32) ));
    if( !pWal->apWiData[iPage] ) rc = 7;
  }else{
    rc = sqlite3OsShmMap(pWal->pDbFd, iPage, ( sizeof(ht_slot)*(4096*2) + 4096*sizeof(u32) ),
        pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]
    );
    ((void) (0));


                                                         ;
    if( rc==0 ){
      if( iPage>0 && sqlite3FaultSim(600) ) rc = 7;
    }else if( (rc&0xff)==8 ){
      pWal->readOnly |= 2;
      if( rc==8 ){
        rc = 0;
      }
    }
  }

  *ppPage = pWal->apWiData[iPage];
  ((void) (0));
  return rc;
}
static int walIndexPage(
  Wal *pWal,
  int iPage,
  volatile u32 **ppPage
){
  ((void) (0));;
  if( pWal->nWiData<=iPage || (*ppPage = pWal->apWiData[iPage])==0 ){
    return walIndexPageRealloc(pWal, iPage, ppPage);
  }
  return 0;
}




static volatile WalCkptInfo *walCkptInfo(Wal *pWal){
  ((void) (0));
  ((void) (0));;
  return (volatile WalCkptInfo*)&(pWal->apWiData[0][sizeof(WalIndexHdr)/2]);
}




static volatile WalIndexHdr *walIndexHdr(Wal *pWal){
  ((void) (0));
  ((void) (0));;
  return (volatile WalIndexHdr*)pWal->apWiData[0];
}
# 67612 "c_tests/sqlite3.c"
static void walChecksumBytes(
  int nativeCksum,
  u8 *a,
  int nByte,
  const u32 *aIn,
  u32 *aOut
){
  u32 s1, s2;
  u32 *aData = (u32 *)a;
  u32 *aEnd = (u32 *)&a[nByte];

  if( aIn ){
    s1 = aIn[0];
    s2 = aIn[1];
  }else{
    s1 = s2 = 0;
  }


  ((void) (0));

  if( !nativeCksum ){
    do {
      s1 += ( (((aData[0])&0x000000FF)<<24) + (((aData[0])&0x0000FF00)<<8) + (((aData[0])&0x00FF0000)>>8) + (((aData[0])&0xFF000000)>>24) ) + s2;
      s2 += ( (((aData[1])&0x000000FF)<<24) + (((aData[1])&0x0000FF00)<<8) + (((aData[1])&0x00FF0000)>>8) + (((aData[1])&0xFF000000)>>24) ) + s1;
      aData += 2;
    }while( aData<aEnd );
  }else if( nByte%64==0 ){
    do {
      s1 += *aData++ + s2;
      s2 += *aData++ + s1;
      s1 += *aData++ + s2;
      s2 += *aData++ + s1;
      s1 += *aData++ + s2;
      s2 += *aData++ + s1;
      s1 += *aData++ + s2;
      s2 += *aData++ + s1;
      s1 += *aData++ + s2;
      s2 += *aData++ + s1;
      s1 += *aData++ + s2;
      s2 += *aData++ + s1;
      s1 += *aData++ + s2;
      s2 += *aData++ + s1;
      s1 += *aData++ + s2;
      s2 += *aData++ + s1;
    }while( aData<aEnd );
  }else{
    do {
      s1 += *aData++ + s2;
      s2 += *aData++ + s1;
    }while( aData<aEnd );
  }
  ((void) (0));

  aOut[0] = s1;
  aOut[1] = s2;
}





static void walShmBarrier(Wal *pWal){
  if( pWal->exclusiveMode!=2 ){
    sqlite3OsShmBarrier(pWal->pDbFd);
  }
}
# 67698 "c_tests/sqlite3.c"
static __attribute__((no_sanitize_thread)) void walIndexWriteHdr(Wal *pWal){
  volatile WalIndexHdr *aHdr = walIndexHdr(pWal);
  const int nCksum = __builtin_offsetof(WalIndexHdr, aCksum);

  ((void) (0));
  pWal->hdr.isInit = 1;
  pWal->hdr.iVersion = 3007000;
  walChecksumBytes(1, (u8*)&pWal->hdr, nCksum, 0, pWal->hdr.aCksum);

  memcpy((void*)&aHdr[1], (const void*)&pWal->hdr, sizeof(WalIndexHdr));
  walShmBarrier(pWal);
  memcpy((void*)&aHdr[0], (const void*)&pWal->hdr, sizeof(WalIndexHdr));
}
# 67725 "c_tests/sqlite3.c"
static void walEncodeFrame(
  Wal *pWal,
  u32 iPage,
  u32 nTruncate,
  u8 *aData,
  u8 *aFrame
){
  int nativeCksum;
  u32 *aCksum = pWal->hdr.aFrameCksum;
  ((void) (0));
  sqlite3Put4byte(&aFrame[0], iPage);
  sqlite3Put4byte(&aFrame[4], nTruncate);
  if( pWal->iReCksum==0 ){
    memcpy(&aFrame[8], pWal->hdr.aSalt, 8);

    nativeCksum = (pWal->hdr.bigEndCksum==0);
    walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);
    walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);

    sqlite3Put4byte(&aFrame[16], aCksum[0]);
    sqlite3Put4byte(&aFrame[20], aCksum[1]);
  }else{
    memset(&aFrame[8], 0, 16);
  }
}






static int walDecodeFrame(
  Wal *pWal,
  u32 *piPage,
  u32 *pnTruncate,
  u8 *aData,
  u8 *aFrame
){
  int nativeCksum;
  u32 *aCksum = pWal->hdr.aFrameCksum;
  u32 pgno;
  ((void) (0));




  if( memcmp(&pWal->hdr.aSalt, &aFrame[8], 8)!=0 ){
    return 0;
  }



  pgno = sqlite3Get4byte(&aFrame[0]);
  if( pgno==0 ){
    return 0;
  }






  nativeCksum = (pWal->hdr.bigEndCksum==0);
  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);
  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);
  if( aCksum[0]!=sqlite3Get4byte(&aFrame[16])
   || aCksum[1]!=sqlite3Get4byte(&aFrame[20])
  ){

    return 0;
  }




  *piPage = pgno;
  *pnTruncate = sqlite3Get4byte(&aFrame[4]);
  return 1;
}
# 67835 "c_tests/sqlite3.c"
static int walLockShared(Wal *pWal, int lockIdx){
  int rc;
  if( pWal->exclusiveMode ) return 0;
  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,
                        2 | 4);

                                                        ;




  return rc;
}
static void walUnlockShared(Wal *pWal, int lockIdx){
  if( pWal->exclusiveMode ) return;
  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,
                         1 | 4);



                                                                      ;
}
static int walLockExclusive(Wal *pWal, int lockIdx, int n){
  int rc;
  if( pWal->exclusiveMode ) return 0;
  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,
                        2 | 8);

                                                           ;






  return rc;
}
static void walUnlockExclusive(Wal *pWal, int lockIdx, int n){
  if( pWal->exclusiveMode ) return;
  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,
                         1 | 8);




                                      ;
}






static int walHash(u32 iPage){
  ((void) (0));
  ((void) (0));
  return (iPage*383) & ((4096*2)-1);
}
static int walNextHash(int iPriorHash){
  return (iPriorHash+1)&((4096*2)-1);
}






typedef struct WalHashLoc WalHashLoc;
struct WalHashLoc {
  volatile ht_slot *aHash;
  volatile u32 *aPgno;
  u32 iZero;
};
# 67923 "c_tests/sqlite3.c"
static int walHashGet(
  Wal *pWal,
  int iHash,
  WalHashLoc *pLoc
){
  int rc;

  rc = walIndexPage(pWal, iHash, &pLoc->aPgno);
  ((void) (0));

  if( pLoc->aPgno ){
    pLoc->aHash = (volatile ht_slot *)&pLoc->aPgno[4096];
    if( iHash==0 ){
      pLoc->aPgno = &pLoc->aPgno[(sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32)];
      pLoc->iZero = 0;
    }else{
      pLoc->iZero = (4096 - ((sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32))) + (iHash-1)*4096;
    }
  }else if( (rc==0) ){
    rc = 1;
  }
  return rc;
}







static int walFramePage(u32 iFrame){
  int iHash = (iFrame+4096 -(4096 - ((sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32)))-1) / 4096;
  ((void) (0));





  ((void) (0));
  return iHash;
}




static u32 walFramePgno(Wal *pWal, u32 iFrame){
  int iHash = walFramePage(iFrame);
  ((void) (0));;
  if( iHash==0 ){
    return pWal->apWiData[0][(sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32) + iFrame - 1];
  }
  return pWal->apWiData[iHash][(iFrame-1-(4096 - ((sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32))))%4096];
}
# 67989 "c_tests/sqlite3.c"
static void walCleanupHash(Wal *pWal){
  WalHashLoc sLoc;
  int iLimit = 0;
  int nByte;
  int i;

  ((void) (0));
                                                      ;
                                                    ;
                                                      ;

  if( pWal->hdr.mxFrame==0 ) return;





  ((void) (0));
  ((void) (0));
  i = walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &sLoc);
  if( (i) ) return;




  iLimit = pWal->hdr.mxFrame - sLoc.iZero;
  ((void) (0));
  for(i=0; i<(4096*2); i++){
    if( sLoc.aHash[i]>iLimit ){
      sLoc.aHash[i] = 0;
    }
  }




  nByte = (int)((char *)sLoc.aHash - (char *)&sLoc.aPgno[iLimit]);
  ((void) (0));
  memset((void *)&sLoc.aPgno[iLimit], 0, nByte);
# 68044 "c_tests/sqlite3.c"
}






static int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage){
  int rc;
  WalHashLoc sLoc;

  rc = walHashGet(pWal, walFramePage(iFrame), &sLoc);




  if( rc==0 ){
    int iKey;
    int idx;
    int nCollide;

    idx = iFrame - sLoc.iZero;
    ((void) (0));




    if( idx==1 ){
      int nByte = (int)((u8*)&sLoc.aHash[(4096*2)] - (u8*)sLoc.aPgno);
      ((void) (0));
      memset((void*)sLoc.aPgno, 0, nByte);
    }







    if( sLoc.aPgno[idx-1] ){
      walCleanupHash(pWal);
      ((void) (0));
    }


    nCollide = idx;
    for(iKey=walHash(iPage); sLoc.aHash[iKey]; iKey=walNextHash(iKey)){
      if( (nCollide--)==0 ) return sqlite3CorruptError(68091);
    }
    sLoc.aPgno[idx-1] = iPage;
    __atomic_store_n((&sLoc.aHash[iKey]),((ht_slot)idx),0);
# 68124 "c_tests/sqlite3.c"
  }

  return rc;
}
# 68140 "c_tests/sqlite3.c"
static int walIndexRecover(Wal *pWal){
  int rc;
  i64 nSize;
  u32 aFrameCksum[2] = {0, 0};
  int iLock;







  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  iLock = 1 + pWal->ckptLock;
  rc = walLockExclusive(pWal, iLock, (3+(0))-iLock);
  if( rc ){
    return rc;
  }

                                                ;

  memset(&pWal->hdr, 0, sizeof(WalIndexHdr));

  rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);
  if( rc!=0 ){
    goto recovery_error;
  }

  if( nSize>32 ){
    u8 aBuf[32];
    u32 *aPrivate = 0;
    u8 *aFrame = 0;
    int szFrame;
    u8 *aData;
    int szPage;
    u32 magic;
    u32 version;
    int isValid;
    u32 iPg;
    u32 iLastFrame;


    rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0);
    if( rc!=0 ){
      goto recovery_error;
    }






    magic = sqlite3Get4byte(&aBuf[0]);
    szPage = sqlite3Get4byte(&aBuf[8]);
    if( (magic&0xFFFFFFFE)!=0x377f0682
     || szPage&(szPage-1)
     || szPage>65536
     || szPage<512
    ){
      goto finished;
    }
    pWal->hdr.bigEndCksum = (u8)(magic&0x00000001);
    pWal->szPage = szPage;
    pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);
    memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);


    walChecksumBytes(pWal->hdr.bigEndCksum==0,
        aBuf, 32 -2*4, 0, pWal->hdr.aFrameCksum
    );
    if( pWal->hdr.aFrameCksum[0]!=sqlite3Get4byte(&aBuf[24])
     || pWal->hdr.aFrameCksum[1]!=sqlite3Get4byte(&aBuf[28])
    ){
      goto finished;
    }



    version = sqlite3Get4byte(&aBuf[4]);
    if( version!=3007000 ){
      rc = sqlite3CantopenError(68223);
      goto finished;
    }


    szFrame = szPage + 24;
    aFrame = (u8 *)sqlite3_malloc64(szFrame + ( sizeof(ht_slot)*(4096*2) + 4096*sizeof(u32) ));
                                ;
    if( !aFrame ){
      rc = 7;
      goto recovery_error;
    }
    aData = &aFrame[24];
    aPrivate = (u32*)&aData[szPage];


    iLastFrame = (nSize - 32) / szFrame;
    for(iPg=0; iPg<=(u32)walFramePage(iLastFrame); iPg++){
      u32 *aShare;
      u32 iFrame;
      u32 iLast = ((iLastFrame)<((4096 - ((sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32)))+iPg*4096)?(iLastFrame):((4096 - ((sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32)))+iPg*4096));
      u32 iFirst = 1 + (iPg==0?0:(4096 - ((sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32)))+(iPg-1)*4096);
      u32 nHdr, nHdr32;
      rc = walIndexPage(pWal, iPg, (volatile u32**)&aShare);
      ((void) (0));
      if( aShare==0 ) break;
                                   ;
      pWal->apWiData[iPg] = aPrivate;

      for(iFrame=iFirst; iFrame<=iLast; iFrame++){
        i64 iOffset = ( 32 + ((iFrame)-1)*(i64)((szPage)+24) );
        u32 pgno;
        u32 nTruncate;


        rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);
        if( rc!=0 ) break;
        isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);
        if( !isValid ) break;
        rc = walIndexAppend(pWal, iFrame, pgno);
        if( (rc!=0) ) break;


        if( nTruncate ){
          pWal->hdr.mxFrame = iFrame;
          pWal->hdr.nPage = nTruncate;
          pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));
                                   ;
                                   ;
          aFrameCksum[0] = pWal->hdr.aFrameCksum[0];
          aFrameCksum[1] = pWal->hdr.aFrameCksum[1];
        }
      }
      pWal->apWiData[iPg] = aShare;
                           ;
      nHdr = (iPg==0 ? (sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo)) : 0);
      nHdr32 = nHdr / sizeof(u32);
# 68289 "c_tests/sqlite3.c"
      memcpy(&aShare[nHdr32], &aPrivate[nHdr32], ( sizeof(ht_slot)*(4096*2) + 4096*sizeof(u32) )-nHdr);
# 68308 "c_tests/sqlite3.c"
      ((void) (0));;
      if( iFrame<=iLast ) break;
    }

                                ;
    sqlite3_free(aFrame);
  }

finished:
  if( rc==0 ){
    volatile WalCkptInfo *pInfo;
    int i;
    pWal->hdr.aFrameCksum[0] = aFrameCksum[0];
    pWal->hdr.aFrameCksum[1] = aFrameCksum[1];
    walIndexWriteHdr(pWal);





    pInfo = walCkptInfo(pWal);
    pInfo->nBackfill = 0;
    pInfo->nBackfillAttempted = pWal->hdr.mxFrame;
    pInfo->aReadMark[0] = 0;
    for(i=1; i<(8 -3); i++){
      rc = walLockExclusive(pWal, (3+(i)), 1);
      if( rc==0 ){
        if( i==1 && pWal->hdr.mxFrame ){
          pInfo->aReadMark[i] = pWal->hdr.mxFrame;
        }else{
          pInfo->aReadMark[i] = 0xffffffff;
        }
        ((void) (0));;
        walUnlockExclusive(pWal, (3+(i)), 1);
      }else if( rc!=5 ){
        goto recovery_error;
      }
    }






    if( pWal->hdr.nPage ){
      sqlite3_log((27 | (1<<8)),
          "recovered %d frames from WAL file %s",
          pWal->hdr.mxFrame, pWal->zWalName
      );
    }
  }

recovery_error:
                                                                ;
  walUnlockExclusive(pWal, iLock, (3+(0))-iLock);
  return rc;
}




static void walIndexClose(Wal *pWal, int isDelete){
  if( pWal->exclusiveMode==2 || pWal->bShmUnreliable ){
    int i;
    for(i=0; i<pWal->nWiData; i++){
      sqlite3_free((void *)pWal->apWiData[i]);
      pWal->apWiData[i] = 0;
    }
  }
  if( pWal->exclusiveMode!=2 ){
    sqlite3OsShmUnmap(pWal->pDbFd, isDelete);
  }
}
# 68397 "c_tests/sqlite3.c"
static int sqlite3WalOpen(
  sqlite3_vfs *pVfs,
  sqlite3_file *pDbFd,
  const char *zWalName,
  int bNoShm,
  i64 mxWalSize,
  Wal **ppWal
){
  int rc;
  Wal *pRet;
  int flags;

  ((void) (0));
  ((void) (0));
# 68421 "c_tests/sqlite3.c"
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
# 68453 "c_tests/sqlite3.c"
  ((void) (0));




  *ppWal = 0;
  pRet = (Wal*)sqlite3MallocZero(sizeof(Wal) + pVfs->szOsFile);
  if( !pRet ){
    return 7;
  }

  pRet->pVfs = pVfs;
  pRet->pWalFd = (sqlite3_file *)&pRet[1];
  pRet->pDbFd = pDbFd;
  pRet->readLock = -1;
  pRet->mxWalSize = mxWalSize;
  pRet->zWalName = zWalName;
  pRet->syncHeader = 1;
  pRet->padToSectorBoundary = 1;
  pRet->exclusiveMode = (bNoShm ? 2: 0);


  flags = (0x00000002|0x00000004|0x00080000);
  rc = sqlite3OsOpen(pVfs, zWalName, pRet->pWalFd, flags, &flags);
  if( rc==0 && flags&0x00000001 ){
    pRet->readOnly = 1;
  }

  if( rc!=0 ){
    walIndexClose(pRet, 0);
    sqlite3OsClose(pRet->pWalFd);
    sqlite3_free(pRet);
  }else{
    int iDC = sqlite3OsDeviceCharacteristics(pDbFd);
    if( iDC & 0x00000400 ){ pRet->syncHeader = 0; }
    if( iDC & 0x00001000 ){
      pRet->padToSectorBoundary = 0;
    }
    *ppWal = pRet;
                                       ;
  }
  return rc;
}




static void sqlite3WalLimit(Wal *pWal, i64 iLimit){
  if( pWal ) pWal->mxWalSize = iLimit;
}
# 68514 "c_tests/sqlite3.c"
static int walIteratorNext(
  WalIterator *p,
  u32 *piPage,
  u32 *piFrame
){
  u32 iMin;
  u32 iRet = 0xFFFFFFFF;
  int i;

  iMin = p->iPrior;
  ((void) (0));
  for(i=p->nSegment-1; i>=0; i--){
    struct WalSegment *pSegment = &p->aSegment[i];
    while( pSegment->iNext<pSegment->nEntry ){
      u32 iPg = pSegment->aPgno[pSegment->aIndex[pSegment->iNext]];
      if( iPg>iMin ){
        if( iPg<iRet ){
          iRet = iPg;
          *piFrame = pSegment->iZero + pSegment->aIndex[pSegment->iNext];
        }
        break;
      }
      pSegment->iNext++;
    }
  }

  *piPage = p->iPrior = iRet;
  return (iRet==0xFFFFFFFF);
}
# 68567 "c_tests/sqlite3.c"
static void walMerge(
  const u32 *aContent,
  ht_slot *aLeft,
  int nLeft,
  ht_slot **paRight,
  int *pnRight,
  ht_slot *aTmp
){
  int iLeft = 0;
  int iRight = 0;
  int iOut = 0;
  int nRight = *pnRight;
  ht_slot *aRight = *paRight;

  ((void) (0));
  while( iRight<nRight || iLeft<nLeft ){
    ht_slot logpage;
    Pgno dbpage;

    if( (iLeft<nLeft)
     && (iRight>=nRight || aContent[aLeft[iLeft]]<aContent[aRight[iRight]])
    ){
      logpage = aLeft[iLeft++];
    }else{
      logpage = aRight[iRight++];
    }
    dbpage = aContent[logpage];

    aTmp[iOut++] = logpage;
    if( iLeft<nLeft && aContent[aLeft[iLeft]]==dbpage ) iLeft++;

    ((void) (0));
    ((void) (0));
  }

  *paRight = aLeft;
  *pnRight = iOut;
  memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);
}
# 68624 "c_tests/sqlite3.c"
static void walMergesort(
  const u32 *aContent,
  ht_slot *aBuffer,
  ht_slot *aList,
  int *pnList
){
  struct Sublist {
    int nList;
    ht_slot *aList;
  };

  const int nList = *pnList;
  int nMerge = 0;
  ht_slot *aMerge = 0;
  int iList;
  u32 iSub = 0;
  struct Sublist aSub[13];

  memset(aSub, 0, sizeof(aSub));
  ((void) (0));
  ((void) (0));

  for(iList=0; iList<nList; iList++){
    nMerge = 1;
    aMerge = &aList[iList];
    for(iSub=0; iList & (1<<iSub); iSub++){
      struct Sublist *p;
      ((void) (0));
      p = &aSub[iSub];
      ((void) (0));
      ((void) (0));
      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);
    }
    aSub[iSub].aList = aMerge;
    aSub[iSub].nList = nMerge;
  }

  for(iSub++; iSub<((int)(sizeof(aSub)/sizeof(aSub[0]))); iSub++){
    if( nList & (1<<iSub) ){
      struct Sublist *p;
      ((void) (0));
      p = &aSub[iSub];
      ((void) (0));
      ((void) (0));
      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);
    }
  }
  ((void) (0));
  *pnList = nMerge;
# 68682 "c_tests/sqlite3.c"
}




static void walIteratorFree(WalIterator *p){
  sqlite3_free(p);
}
# 68704 "c_tests/sqlite3.c"
static int walIteratorInit(Wal *pWal, u32 nBackfill, WalIterator **pp){
  WalIterator *p;
  int nSegment;
  u32 iLast;
  sqlite3_int64 nByte;
  int i;
  ht_slot *aTmp;
  int rc = 0;




  ((void) (0));
  iLast = pWal->hdr.mxFrame;


  nSegment = walFramePage(iLast) + 1;
  nByte = (__builtin_offsetof(WalIterator, aSegment)+(nSegment)*sizeof(struct WalSegment))
        + iLast*sizeof(ht_slot);
  p = (WalIterator *)sqlite3_malloc64(nByte
      + sizeof(ht_slot) * (iLast>4096?4096:iLast)
  );
  if( !p ){
    return 7;
  }
  memset(p, 0, nByte);
  p->nSegment = nSegment;
  aTmp = (ht_slot*)&(((u8*)p)[nByte]);
                         ;
  for(i=walFramePage(nBackfill+1); rc==0 && i<nSegment; i++){
    WalHashLoc sLoc;

    rc = walHashGet(pWal, i, &sLoc);
    if( rc==0 ){
      int j;
      int nEntry;
      ht_slot *aIndex;

      if( (i+1)==nSegment ){
        nEntry = (int)(iLast - sLoc.iZero);
      }else{
        nEntry = (int)((u32*)sLoc.aHash - (u32*)sLoc.aPgno);
      }
      aIndex = &((ht_slot *)&p->aSegment[p->nSegment])[sLoc.iZero];
      sLoc.iZero++;

      for(j=0; j<nEntry; j++){
        aIndex[j] = (ht_slot)j;
      }
      walMergesort((u32 *)sLoc.aPgno, aTmp, aIndex, &nEntry);
      p->aSegment[i].iZero = sLoc.iZero;
      p->aSegment[i].nEntry = nEntry;
      p->aSegment[i].aIndex = aIndex;
      p->aSegment[i].aPgno = (u32 *)sLoc.aPgno;
    }
  }
  if( rc!=0 ){
                           ;
    walIteratorFree(p);
    p = 0;
  }
  *pp = p;
  return rc;
}
# 68857 "c_tests/sqlite3.c"
static int walBusyLock(
  Wal *pWal,
  int (*xBusy)(void*),
  void *pBusyArg,
  int lockIdx,
  int n
){
  int rc;
  do {
    rc = walLockExclusive(pWal, lockIdx, n);
  }while( xBusy && rc==5 && xBusy(pBusyArg) );






  return rc;
}





static int walPagesize(Wal *pWal){
  return (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);
}
# 68902 "c_tests/sqlite3.c"
static void walRestartHdr(Wal *pWal, u32 salt1){
  volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
  int i;
  u32 *aSalt = pWal->hdr.aSalt;
  pWal->nCkpt++;
  pWal->hdr.mxFrame = 0;
  sqlite3Put4byte((u8*)&aSalt[0], 1 + sqlite3Get4byte((u8*)&aSalt[0]));
  memcpy(&pWal->hdr.aSalt[1], &salt1, 4);
  walIndexWriteHdr(pWal);
  __atomic_store_n((&pInfo->nBackfill),(0),0);
  pInfo->nBackfillAttempted = 0;
  pInfo->aReadMark[1] = 0;
  for(i=2; i<(8 -3); i++) pInfo->aReadMark[i] = 0xffffffff;
  ((void) (0));
}
# 68949 "c_tests/sqlite3.c"
static int walCheckpoint(
  Wal *pWal,
  sqlite3 *db,
  int eMode,
  int (*xBusy)(void*),
  void *pBusyArg,
  int sync_flags,
  u8 *zBuf
){
  int rc = 0;
  int szPage;
  WalIterator *pIter = 0;
  u32 iDbpage = 0;
  u32 iFrame = 0;
  u32 mxSafeFrame;
  u32 mxPage;
  int i;
  volatile WalCkptInfo *pInfo;

  szPage = walPagesize(pWal);
                           ;
                           ;
  pInfo = walCkptInfo(pWal);
  if( pInfo->nBackfill<pWal->hdr.mxFrame ){



    ((void) (0));






    mxSafeFrame = pWal->hdr.mxFrame;
    mxPage = pWal->hdr.nPage;
    for(i=1; i<(8 -3); i++){
      u32 y = __atomic_load_n((pInfo->aReadMark+i),0); ((void) (0));;
      if( mxSafeFrame>y ){
        ((void) (0));
        rc = walBusyLock(pWal, xBusy, pBusyArg, (3+(i)), 1);
        if( rc==0 ){
          u32 iMark = (i==1 ? mxSafeFrame : 0xffffffff);
          __atomic_store_n((pInfo->aReadMark+i),(iMark),0); ((void) (0));;
          walUnlockExclusive(pWal, (3+(i)), 1);
        }else if( rc==5 ){
          mxSafeFrame = y;
          xBusy = 0;
        }else{
          goto walcheckpoint_out;
        }
      }
    }


    if( pInfo->nBackfill<mxSafeFrame ){
      rc = walIteratorInit(pWal, pInfo->nBackfill, &pIter);
      ((void) (0));
    }

    if( pIter
     && (rc = walBusyLock(pWal,xBusy,pBusyArg,(3+(0)),1))==0
    ){
      u32 nBackfill = pInfo->nBackfill;
      pInfo->nBackfillAttempted = mxSafeFrame; ((void) (0));;


      rc = sqlite3OsSync(pWal->pWalFd, (((sync_flags)>>2)&0x03));




      if( rc==0 ){
        i64 nReq = ((i64)mxPage * szPage);
        i64 nSize;
        sqlite3OsFileControl(pWal->pDbFd, 39, 0);
        rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);
        if( rc==0 && nSize<nReq ){
          if( (nSize+65536+(i64)pWal->hdr.mxFrame*szPage)<nReq ){




            rc = sqlite3CorruptError(69032);
          }else{
            sqlite3OsFileControlHint(pWal->pDbFd, 5,&nReq);
          }
        }

      }


      while( rc==0 && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){
        i64 iOffset;
        ((void) (0));
        ((void) (0));;
        if( __atomic_load_n((&db->u1.isInterrupted),0) ){
          rc = db->mallocFailed ? 7 : 9;
          break;
        }
        if( iFrame<=nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage ){
          continue;
        }
        iOffset = ( 32 + ((iFrame)-1)*(i64)((szPage)+24) ) + 24;

        rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);
        if( rc!=0 ) break;
        iOffset = (iDbpage-1)*(i64)szPage;
                                       ;
        rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);
        if( rc!=0 ) break;
      }
      sqlite3OsFileControl(pWal->pDbFd, 37, 0);


      if( rc==0 ){
        if( mxSafeFrame==walIndexHdr(pWal)->mxFrame ){
          i64 szDb = pWal->hdr.nPage*(i64)szPage;
                                      ;
          rc = sqlite3OsTruncate(pWal->pDbFd, szDb);
          if( rc==0 ){
            rc = sqlite3OsSync(pWal->pDbFd, (((sync_flags)>>2)&0x03));
          }
        }
        if( rc==0 ){
          __atomic_store_n((&pInfo->nBackfill),(mxSafeFrame),0); ((void) (0));;
        }
      }


      walUnlockExclusive(pWal, (3+(0)), 1);
    }

    if( rc==5 ){


      rc = 0;
    }
  }






  if( rc==0 && eMode!=0 ){
    ((void) (0));
    ((void) (0));;
    if( pInfo->nBackfill<pWal->hdr.mxFrame ){
      rc = 5;
    }else if( eMode>=2 ){
      u32 salt1;
      sqlite3_randomness(4, &salt1);
      ((void) (0));
      rc = walBusyLock(pWal, xBusy, pBusyArg, (3+(1)), (8 -3)-1);
      if( rc==0 ){
        if( eMode==3 ){
# 69119 "c_tests/sqlite3.c"
          walRestartHdr(pWal, salt1);
          rc = sqlite3OsTruncate(pWal->pWalFd, 0);
        }
        walUnlockExclusive(pWal, (3+(1)), (8 -3)-1);
      }
    }
  }

 walcheckpoint_out:
                             ;
  walIteratorFree(pIter);
  return rc;
}





static void walLimitSize(Wal *pWal, i64 nMax){
  i64 sz;
  int rx;
  sqlite3BeginBenignMalloc();
  rx = sqlite3OsFileSize(pWal->pWalFd, &sz);
  if( rx==0 && (sz > nMax ) ){
    rx = sqlite3OsTruncate(pWal->pWalFd, nMax);
  }
  sqlite3EndBenignMalloc();
  if( rx ){
    sqlite3_log(rx, "cannot limit WAL size: %s", pWal->zWalName);
  }
}
# 69243 "c_tests/sqlite3.c"
static int sqlite3WalClose(
  Wal *pWal,
  sqlite3 *db,
  int sync_flags,
  int nBuf,
  u8 *zBuf
){
  int rc = 0;
  if( pWal ){
    int isDelete = 0;

    ((void) (0));
# 69264 "c_tests/sqlite3.c"
    if( zBuf!=0
     && 0==(rc = sqlite3OsLock(pWal->pDbFd, 4))
    ){
      if( pWal->exclusiveMode==0 ){
        pWal->exclusiveMode = 1;
      }
      rc = sqlite3WalCheckpoint(pWal, db,
          0, 0, 0, sync_flags, nBuf, zBuf, 0, 0
      );
      if( rc==0 ){
        int bPersist = -1;
        sqlite3OsFileControlHint(
            pWal->pDbFd, 10, &bPersist
        );
        if( bPersist!=1 ){



          isDelete = 1;
        }else if( pWal->mxWalSize>=0 ){






          walLimitSize(pWal, 0);
        }
      }
    }

    walIndexClose(pWal, isDelete);
    sqlite3OsClose(pWal->pWalFd);
    if( isDelete ){
      sqlite3BeginBenignMalloc();
      sqlite3OsDelete(pWal->pVfs, pWal->zWalName, 0);
      sqlite3EndBenignMalloc();
    }
                                       ;
    sqlite3_free((void *)pWal->apWiData);
    sqlite3_free(pWal);
  }
  return rc;
}
# 69326 "c_tests/sqlite3.c"
static __attribute__((no_sanitize_thread)) int walIndexTryHdr(Wal *pWal, int *pChanged){
  u32 aCksum[2];
  WalIndexHdr h1, h2;
  WalIndexHdr volatile *aHdr;


  ((void) (0));
# 69350 "c_tests/sqlite3.c"
  aHdr = walIndexHdr(pWal);
  memcpy(&h1, (void *)&aHdr[0], sizeof(h1));
  walShmBarrier(pWal);
  memcpy(&h2, (void *)&aHdr[1], sizeof(h2));

  if( memcmp(&h1, &h2, sizeof(h1))!=0 ){
    return 1;
  }
  if( h1.isInit==0 ){
    return 1;
  }
  walChecksumBytes(1, (u8*)&h1, sizeof(h1)-sizeof(h1.aCksum), 0, aCksum);
  if( aCksum[0]!=h1.aCksum[0] || aCksum[1]!=h1.aCksum[1] ){
    return 1;
  }

  if( memcmp(&pWal->hdr, &h1, sizeof(WalIndexHdr)) ){
    *pChanged = 1;
    memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));
    pWal->szPage = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);
                                   ;
                                   ;
  }


  return 0;
}
# 69396 "c_tests/sqlite3.c"
static int walIndexReadHdr(Wal *pWal, int *pChanged){
  int rc;
  int badHdr;
  volatile u32 *page0;




  ((void) (0));
  rc = walIndexPage(pWal, 0, &page0);
  if( rc!=0 ){
    ((void) (0));
    if( rc==(8 | (5<<8)) ){






      ((void) (0));
      ((void) (0));
      ((void) (0));
      pWal->bShmUnreliable = 1;
      pWal->exclusiveMode = 2;
      *pChanged = 1;
    }else{
      return rc;
    }
  }else{


                        ;
  }
  ((void) (0));






  badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1);




  if( badHdr ){
    if( pWal->bShmUnreliable==0 && (pWal->readOnly & 2) ){
      if( 0==(rc = walLockShared(pWal, 0)) ){
        walUnlockShared(pWal, 0);
        rc = (8 | (1<<8));
      }
    }else{
      int bWriteLock = pWal->writeLock;
      if( bWriteLock
       || 0==(rc = walLockExclusive(pWal, 0, 1))
      ){





        if( !bWriteLock ) pWal->writeLock = 2;
        if( 0==(rc = walIndexPage(pWal, 0, &page0)) ){
          badHdr = walIndexTryHdr(pWal, pChanged);
          if( badHdr ){




                                    ;
            rc = walIndexRecover(pWal);
            *pChanged = 1;
          }
        }
        if( bWriteLock==0 ){
          pWal->writeLock = 0;
          walUnlockExclusive(pWal, 0, 1);
        }
      }
    }
  }





  if( badHdr==0 && pWal->hdr.iVersion!=3007000 ){
    rc = sqlite3CantopenError(69483);
  }
  if( pWal->bShmUnreliable ){
    if( rc!=0 ){
      walIndexClose(pWal, 0);
      pWal->bShmUnreliable = 0;
      ((void) (0));



      if( rc==(10 | (2<<8)) ) rc = (-1);
    }
    pWal->exclusiveMode = 0;
  }

  return rc;
}
# 69528 "c_tests/sqlite3.c"
static int walBeginShmUnreliable(Wal *pWal, int *pChanged){
  i64 szWal;
  i64 iOffset;
  u8 aBuf[32];
  u8 *aFrame = 0;
  int szFrame;
  u8 *aData;
  volatile void *pDummy;
  int rc;
  u32 aSaveCksum[2];

  ((void) (0));
  ((void) (0));
  ((void) (0));




  rc = walLockShared(pWal, (3+(0)));
  if( rc!=0 ){
    if( rc==5 ) rc = (-1);
    goto begin_unreliable_shm_out;
  }
  pWal->readLock = 0;
# 69575 "c_tests/sqlite3.c"
  rc = sqlite3OsShmMap(pWal->pDbFd, 0, ( sizeof(ht_slot)*(4096*2) + 4096*sizeof(u32) ), 0, &pDummy);
  ((void) (0));
  if( rc!=(8 | (5<<8)) ){
    rc = (rc==8 ? (-1) : rc);
    goto begin_unreliable_shm_out;
  }





  memcpy(&pWal->hdr, (void*)walIndexHdr(pWal), sizeof(WalIndexHdr));




  rc = sqlite3OsFileSize(pWal->pWalFd, &szWal);
  if( rc!=0 ){
    goto begin_unreliable_shm_out;
  }
  if( szWal<32 ){






    *pChanged = 1;
    rc = (pWal->hdr.mxFrame==0 ? 0 : (-1));
    goto begin_unreliable_shm_out;
  }


  rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0);
  if( rc!=0 ){
    goto begin_unreliable_shm_out;
  }
  if( memcmp(&pWal->hdr.aSalt, &aBuf[16], 8) ){



    rc = (-1);
    goto begin_unreliable_shm_out;
  }


  ((void) (0));
  ((void) (0));
  szFrame = pWal->szPage + 24;
  aFrame = (u8 *)sqlite3_malloc64(szFrame);
  if( aFrame==0 ){
    rc = 7;
    goto begin_unreliable_shm_out;
  }
  aData = &aFrame[24];





  aSaveCksum[0] = pWal->hdr.aFrameCksum[0];
  aSaveCksum[1] = pWal->hdr.aFrameCksum[1];
  for(iOffset=( 32 + ((pWal->hdr.mxFrame+1)-1)*(i64)((pWal->szPage)+24) );
      iOffset+szFrame<=szWal;
      iOffset+=szFrame
  ){
    u32 pgno;
    u32 nTruncate;


    rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);
    if( rc!=0 ) break;
    if( !walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame) ) break;




    if( nTruncate ){
      rc = (-1);
      break;
    }
  }
  pWal->hdr.aFrameCksum[0] = aSaveCksum[0];
  pWal->hdr.aFrameCksum[1] = aSaveCksum[1];

 begin_unreliable_shm_out:
  sqlite3_free(aFrame);
  if( rc!=0 ){
    int i;
    for(i=0; i<pWal->nWiData; i++){
      sqlite3_free((void*)pWal->apWiData[i]);
      pWal->apWiData[i] = 0;
    }
    pWal->bShmUnreliable = 0;
    sqlite3WalEndReadTransaction(pWal);
    *pChanged = 1;
  }
  return rc;
}
# 69756 "c_tests/sqlite3.c"
static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int *pCnt){
  volatile WalCkptInfo *pInfo;
  int rc = 0;




  ((void) (0));


  ((void) (0));
# 69785 "c_tests/sqlite3.c"
  (*pCnt)++;
  if( *pCnt>5 ){
    int nDelay = 1;
    int cnt = (*pCnt & ~0);
    if( cnt>100 ){

      return 15;
    }
    if( *pCnt>=10 ) nDelay = (cnt-9)*(cnt-9)*39;
# 69811 "c_tests/sqlite3.c"
    sqlite3OsSleep(pWal->pVfs, nDelay);
    *pCnt &= ~0;
  }

  if( !useWal ){
    ((void) (0));
    if( pWal->bShmUnreliable==0 ){
      rc = walIndexReadHdr(pWal, pChanged);
    }






    if( rc==5 ){
# 69835 "c_tests/sqlite3.c"
      (void)0;
      if( pWal->apWiData[0]==0 ){







        rc = (-1);
      }else if( 0==(rc = walLockShared(pWal, 2)) ){
        walUnlockShared(pWal, 2);
        rc = (-1);
      }else if( rc==5 ){
        rc = (5 | (1<<8));
      }
    }
                            ;
    if( rc!=0 ){
      return rc;
    }
    else if( pWal->bShmUnreliable ){
      return walBeginShmUnreliable(pWal, pChanged);
    }
  }

  ((void) (0));
  ((void) (0));
  pInfo = walCkptInfo(pWal);
  ((void) (0));;
  {
    u32 mxReadMark;
    int mxI;
    int i;
    u32 mxFrame;
    if( !useWal && __atomic_load_n((&pInfo->nBackfill),0)==pWal->hdr.mxFrame



    ){



      rc = walLockShared(pWal, (3+(0)));
      walShmBarrier(pWal);
      if( rc==0 ){
        if( memcmp((void *)walIndexHdr(pWal), &pWal->hdr,sizeof(WalIndexHdr)) ){
# 69895 "c_tests/sqlite3.c"
          walUnlockShared(pWal, (3+(0)));
          return (-1);
        }
        pWal->readLock = 0;
        return 0;
      }else if( rc!=5 ){
        return rc;
      }
    }






    mxReadMark = 0;
    mxI = 0;
    mxFrame = pWal->hdr.mxFrame;





    for(i=1; i<(8 -3); i++){
      u32 thisMark = __atomic_load_n((pInfo->aReadMark+i),0); ((void) (0));;
      if( mxReadMark<=thisMark && thisMark<=mxFrame ){
        ((void) (0));
        mxReadMark = thisMark;
        mxI = i;
      }
    }
    if( (pWal->readOnly & 2)==0
     && (mxReadMark<mxFrame || mxI==0)
    ){
      for(i=1; i<(8 -3); i++){
        rc = walLockExclusive(pWal, (3+(i)), 1);
        if( rc==0 ){
          __atomic_store_n((pInfo->aReadMark+i),(mxFrame),0);
          mxReadMark = mxFrame;
          mxI = i;
          walUnlockExclusive(pWal, (3+(i)), 1);
          break;
        }else if( rc!=5 ){
          return rc;
        }
      }
    }
    if( mxI==0 ){
      ((void) (0));
      return rc==5 ? (-1) : (8 | (5<<8));
    }

    (void)0;
    rc = walLockShared(pWal, (3+(mxI)));
                            ;
    if( rc ){





      ((void) (0));

      ((void) (0));
      return (rc&0xFF)==5 ? (-1) : rc;
    }
# 69995 "c_tests/sqlite3.c"
    pWal->minFrame = __atomic_load_n((&pInfo->nBackfill),0)+1; ((void) (0));;
    walShmBarrier(pWal);
    if( __atomic_load_n((pInfo->aReadMark+mxI),0)!=mxReadMark
     || memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))
    ){
      walUnlockShared(pWal, (3+(mxI)));
      return (-1);
    }else{
      ((void) (0));
      pWal->readLock = (i16)mxI;
    }
  }
  return rc;
}
# 70110 "c_tests/sqlite3.c"
static int walBeginReadTransaction(Wal *pWal, int *pChanged){
  int rc;
  int cnt = 0;






  ((void) (0));
  ((void) (0));
# 70147 "c_tests/sqlite3.c"
  do{
    rc = walTryBeginRead(pWal, pChanged, 0, &cnt);
  }while( rc==(-1) );
                                    ;
                                     ;
                                 ;
                           ;
# 70212 "c_tests/sqlite3.c"
  return rc;
}
# 70229 "c_tests/sqlite3.c"
static int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){
  int rc;
  ; {
    rc = walBeginReadTransaction(pWal, pChanged);
  }
  ; ((void) (0));
  return rc;
}





static void sqlite3WalEndReadTransaction(Wal *pWal){

  ((void) (0));

  if( pWal->readLock>=0 ){
    (void)sqlite3WalEndWriteTransaction(pWal);
    walUnlockShared(pWal, (3+(pWal->readLock)));
    pWal->readLock = -1;
  }
}
# 70261 "c_tests/sqlite3.c"
static int walFindFrame(
  Wal *pWal,
  Pgno pgno,
  u32 *piRead
){
  u32 iRead = 0;
  u32 iLast = pWal->hdr.mxFrame;
  int iHash;
  int iMinHash;


  ((void) (0));







  if( iLast==0 || (pWal->readLock==0 && pWal->bShmUnreliable==0) ){
    *piRead = 0;
    return 0;
  }
# 70310 "c_tests/sqlite3.c"
  iMinHash = walFramePage(pWal->minFrame);
  for(iHash=walFramePage(iLast); iHash>=iMinHash; iHash--){
    WalHashLoc sLoc;
    int iKey;
    int nCollide;
    int rc;
    u32 iH;

    rc = walHashGet(pWal, iHash, &sLoc);
    if( rc!=0 ){
      return rc;
    }
    nCollide = (4096*2);
    iKey = walHash(pgno);
    ((void) (0));;
    while( (iH = __atomic_load_n((&sLoc.aHash[iKey]),0))!=0 ){
      u32 iFrame = iH + sLoc.iZero;
      if( iFrame<=iLast && iFrame>=pWal->minFrame && sLoc.aPgno[iH-1]==pgno ){
        ((void) (0));
        iRead = iFrame;
      }
      if( (nCollide--)==0 ){
        *piRead = 0;
        return sqlite3CorruptError(70333);
      }
      iKey = walNextHash(iKey);
    }
    if( iRead ) break;
  }
# 70358 "c_tests/sqlite3.c"
  *piRead = iRead;
  return 0;
}
# 70373 "c_tests/sqlite3.c"
static int sqlite3WalFindFrame(
  Wal *pWal,
  Pgno pgno,
  u32 *piRead
){
  int rc;
  ; {
    rc = walFindFrame(pWal, pgno, piRead);
  }
  ; ((void) (0));
  return rc;
}






static int sqlite3WalReadFrame(
  Wal *pWal,
  u32 iRead,
  int nOut,
  u8 *pOut
){
  int sz;
  i64 iOffset;
  sz = pWal->hdr.szPage;
  sz = (sz&0xfe00) + ((sz&0x0001)<<16);
                       ;
                       ;
  iOffset = ( 32 + ((iRead)-1)*(i64)((sz)+24) ) + 24;

  return sqlite3OsRead(pWal->pWalFd, pOut, (nOut>sz ? sz : nOut), iOffset);
}




static Pgno sqlite3WalDbsize(Wal *pWal){
  if( pWal && (pWal->readLock>=0) ){
    return pWal->hdr.nPage;
  }
  return 0;
}
# 70432 "c_tests/sqlite3.c"
static int sqlite3WalBeginWriteTransaction(Wal *pWal){
  int rc;
# 70447 "c_tests/sqlite3.c"
  ((void) (0));
  ((void) (0));

  if( pWal->readOnly ){
    return 8;
  }




  rc = walLockExclusive(pWal, 0, 1);
  if( rc ){
    return rc;
  }
  pWal->writeLock = 1;





  ; {
    if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){
      rc = (5 | (2<<8));
    }
  }
  ; ((void) (0));

  if( rc!=0 ){
    walUnlockExclusive(pWal, 0, 1);
    pWal->writeLock = 0;
  }
  return rc;
}





static int sqlite3WalEndWriteTransaction(Wal *pWal){
  if( pWal->writeLock ){
    walUnlockExclusive(pWal, 0, 1);
    pWal->writeLock = 0;
    pWal->iReCksum = 0;
    pWal->truncateOnCommit = 0;
  }
  return 0;
}
# 70507 "c_tests/sqlite3.c"
static int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx){
  int rc = 0;
  if( (pWal->writeLock) ){
    Pgno iMax = pWal->hdr.mxFrame;
    Pgno iFrame;

    ; {



      memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));

      for(iFrame=pWal->hdr.mxFrame+1;
          (rc==0) && iFrame<=iMax;
          iFrame++
      ){
# 70534 "c_tests/sqlite3.c"
        ((void) (0));
        rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame));
      }
      if( iMax!=pWal->hdr.mxFrame ) walCleanupHash(pWal);
    }
    ; ((void) (0));
    pWal->iReCksum = 0;
  }
  return rc;
}







static void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData){
  ((void) (0));
  aWalData[0] = pWal->hdr.mxFrame;
  aWalData[1] = pWal->hdr.aFrameCksum[0];
  aWalData[2] = pWal->hdr.aFrameCksum[1];
  aWalData[3] = pWal->nCkpt;
}







static int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData){
  int rc = 0;

  ((void) (0));
  ((void) (0));

  if( aWalData[3]!=pWal->nCkpt ){




    aWalData[0] = 0;
    aWalData[3] = pWal->nCkpt;
  }

  if( aWalData[0]<pWal->hdr.mxFrame ){
    pWal->hdr.mxFrame = aWalData[0];
    pWal->hdr.aFrameCksum[0] = aWalData[1];
    pWal->hdr.aFrameCksum[1] = aWalData[2];
    ; {
      walCleanupHash(pWal);
    }
    ; ((void) (0));
    if( pWal->iReCksum>pWal->hdr.mxFrame ){
      pWal->iReCksum = 0;
    }
  }

  return rc;
}
# 70608 "c_tests/sqlite3.c"
static int walRestartLog(Wal *pWal){
  int rc = 0;
  int cnt;

  if( pWal->readLock==0 ){
    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
    ((void) (0));
    if( pInfo->nBackfill>0 ){
      u32 salt1;
      sqlite3_randomness(4, &salt1);
      rc = walLockExclusive(pWal, (3+(1)), (8 -3)-1);
      if( rc==0 ){
# 70629 "c_tests/sqlite3.c"
        walRestartHdr(pWal, salt1);
        walUnlockExclusive(pWal, (3+(1)), (8 -3)-1);
      }else if( rc!=5 ){
        return rc;
      }
    }
    walUnlockShared(pWal, (3+(0)));
    pWal->readLock = -1;
    cnt = 0;
    do{
      int notUsed;
      rc = walTryBeginRead(pWal, &notUsed, 1, &cnt);
    }while( rc==(-1) );
    ((void) (0));
                                       ;
                                   ;
                             ;
  }
  return rc;
}






typedef struct WalWriter {
  Wal *pWal;
  sqlite3_file *pFd;
  sqlite3_int64 iSyncPoint;
  int syncFlags;
  int szPage;
} WalWriter;
# 70671 "c_tests/sqlite3.c"
static int walWriteToLog(
  WalWriter *p,
  void *pContent,
  int iAmt,
  sqlite3_int64 iOffset
){
  int rc;
  if( iOffset<p->iSyncPoint && iOffset+iAmt>=p->iSyncPoint ){
    int iFirstAmt = (int)(p->iSyncPoint - iOffset);
    rc = sqlite3OsWrite(p->pFd, pContent, iFirstAmt, iOffset);
    if( rc ) return rc;
    iOffset += iFirstAmt;
    iAmt -= iFirstAmt;
    pContent = (void*)(iFirstAmt + (char*)pContent);
    ((void) (0));
    rc = sqlite3OsSync(p->pFd, ((p->syncFlags)&0x03));
    if( iAmt==0 || rc ) return rc;
  }
  rc = sqlite3OsWrite(p->pFd, pContent, iAmt, iOffset);
  return rc;
}




static int walWriteOneFrame(
  WalWriter *p,
  PgHdr *pPage,
  int nTruncate,
  sqlite3_int64 iOffset
){
  int rc;
  void *pData;
  u8 aFrame[24];
  pData = pPage->pData;
  walEncodeFrame(p->pWal, pPage->pgno, nTruncate, pData, aFrame);
  rc = walWriteToLog(p, aFrame, sizeof(aFrame), iOffset);
  if( rc ) return rc;

  rc = walWriteToLog(p, pData, p->szPage, iOffset+sizeof(aFrame));
  return rc;
}
# 70722 "c_tests/sqlite3.c"
static int walRewriteChecksums(Wal *pWal, u32 iLast){
  const int szPage = pWal->szPage;
  int rc = 0;
  u8 *aBuf;
  u8 aFrame[24];
  u32 iRead;
  i64 iCksumOff;

  aBuf = sqlite3_malloc(szPage + 24);
  if( aBuf==0 ) return 7;






  ((void) (0));
  if( pWal->iReCksum==1 ){
    iCksumOff = 24;
  }else{
    iCksumOff = ( 32 + ((pWal->iReCksum-1)-1)*(i64)((szPage)+24) ) + 16;
  }
  rc = sqlite3OsRead(pWal->pWalFd, aBuf, sizeof(u32)*2, iCksumOff);
  pWal->hdr.aFrameCksum[0] = sqlite3Get4byte(aBuf);
  pWal->hdr.aFrameCksum[1] = sqlite3Get4byte(&aBuf[sizeof(u32)]);

  iRead = pWal->iReCksum;
  pWal->iReCksum = 0;
  for(; rc==0 && iRead<=iLast; iRead++){
    i64 iOff = ( 32 + ((iRead)-1)*(i64)((szPage)+24) );
    rc = sqlite3OsRead(pWal->pWalFd, aBuf, szPage+24, iOff);
    if( rc==0 ){
      u32 iPgno, nDbSize;
      iPgno = sqlite3Get4byte(aBuf);
      nDbSize = sqlite3Get4byte(&aBuf[4]);

      walEncodeFrame(pWal, iPgno, nDbSize, &aBuf[24], aFrame);
      rc = sqlite3OsWrite(pWal->pWalFd, aFrame, sizeof(aFrame), iOff);
    }
  }

  sqlite3_free(aBuf);
  return rc;
}





static int walFrames(
  Wal *pWal,
  int szPage,
  PgHdr *pList,
  Pgno nTruncate,
  int isCommit,
  int sync_flags
){
  int rc;
  u32 iFrame;
  PgHdr *p;
  PgHdr *pLast = 0;
  int nExtra = 0;
  int szFrame;
  i64 iOffset;
  WalWriter w;
  u32 iFirst = 0;
  WalIndexHdr *pLive;

  ((void) (0));
  ((void) (0));



  ((void) (0));
# 70804 "c_tests/sqlite3.c"
  pLive = (WalIndexHdr*)walIndexHdr(pWal);
  if( memcmp(&pWal->hdr, (void *)pLive, sizeof(WalIndexHdr))!=0 ){
    iFirst = pLive->mxFrame+1;
  }




  if( 0!=(rc = walRestartLog(pWal)) ){
    return rc;
  }





  iFrame = pWal->hdr.mxFrame;
  if( iFrame==0 ){
    u8 aWalHdr[32];
    u32 aCksum[2];

    sqlite3Put4byte(&aWalHdr[0], (0x377f0682 | 0));
    sqlite3Put4byte(&aWalHdr[4], 3007000);
    sqlite3Put4byte(&aWalHdr[8], szPage);
    sqlite3Put4byte(&aWalHdr[12], pWal->nCkpt);
    if( pWal->nCkpt==0 ) sqlite3_randomness(8, pWal->hdr.aSalt);
    memcpy(&aWalHdr[16], pWal->hdr.aSalt, 8);
    walChecksumBytes(1, aWalHdr, 32 -2*4, 0, aCksum);
    sqlite3Put4byte(&aWalHdr[24], aCksum[0]);
    sqlite3Put4byte(&aWalHdr[28], aCksum[1]);

    pWal->szPage = szPage;
    pWal->hdr.bigEndCksum = 0;
    pWal->hdr.aFrameCksum[0] = aCksum[0];
    pWal->hdr.aFrameCksum[1] = aCksum[1];
    pWal->truncateOnCommit = 1;

    rc = sqlite3OsWrite(pWal->pWalFd, aWalHdr, sizeof(aWalHdr), 0);
                                                                          ;
    if( rc!=0 ){
      return rc;
    }
# 70854 "c_tests/sqlite3.c"
    if( pWal->syncHeader ){
      rc = sqlite3OsSync(pWal->pWalFd, (((sync_flags)>>2)&0x03));
      if( rc ) return rc;
    }
  }
  if( (int)pWal->szPage!=szPage ){
    return sqlite3CorruptError(70860);
  }


  w.pWal = pWal;
  w.pFd = pWal->pWalFd;
  w.iSyncPoint = 0;
  w.syncFlags = sync_flags;
  w.szPage = szPage;
  iOffset = ( 32 + ((iFrame+1)-1)*(i64)((szPage)+24) );
  szFrame = szPage + 24;


  for(p=pList; p; p=p->pDirty){
    int nDbSize;





    if( iFirst && (p->pDirty || isCommit==0) ){
      u32 iWrite = 0;
                     walFindFrame(pWal, p->pgno, &iWrite);
      ((void) (0));
      if( iWrite>=iFirst ){
        i64 iOff = ( 32 + ((iWrite)-1)*(i64)((szPage)+24) ) + 24;
        void *pData;
        if( pWal->iReCksum==0 || iWrite<pWal->iReCksum ){
          pWal->iReCksum = iWrite;
        }
        pData = p->pData;
        rc = sqlite3OsWrite(pWal->pWalFd, pData, szPage, iOff);
        if( rc ) return rc;
        p->flags &= ~0x040;
        continue;
      }
    }

    iFrame++;
    ((void) (0));
    nDbSize = (isCommit && p->pDirty==0) ? nTruncate : 0;
    rc = walWriteOneFrame(&w, p, nDbSize, iOffset);
    if( rc ) return rc;
    pLast = p;
    iOffset += szFrame;
    p->flags |= 0x040;
  }


  if( isCommit && pWal->iReCksum ){
    rc = walRewriteChecksums(pWal, iFrame);
    if( rc ) return rc;
  }
# 70928 "c_tests/sqlite3.c"
  if( isCommit && ((sync_flags)&0x03)!=0 ){
    int bSync = 1;
    if( pWal->padToSectorBoundary ){
      int sectorSize = sqlite3SectorSize(pWal->pWalFd);
      w.iSyncPoint = ((iOffset+sectorSize-1)/sectorSize)*sectorSize;
      bSync = (w.iSyncPoint==iOffset);
                       ;
      while( iOffset<w.iSyncPoint ){
        rc = walWriteOneFrame(&w, pLast, nTruncate, iOffset);
        if( rc ) return rc;
        iOffset += szFrame;
        nExtra++;
        ((void) (0));
      }
    }
    if( bSync ){
      ((void) (0));
      rc = sqlite3OsSync(w.pFd, ((sync_flags)&0x03));
    }
  }





  if( isCommit && pWal->truncateOnCommit && pWal->mxWalSize>=0 ){
    i64 sz = pWal->mxWalSize;
    if( ( 32 + ((iFrame+nExtra+1)-1)*(i64)((szPage)+24) )>pWal->mxWalSize ){
      sz = ( 32 + ((iFrame+nExtra+1)-1)*(i64)((szPage)+24) );
    }
    walLimitSize(pWal, sz);
    pWal->truncateOnCommit = 0;
  }






  iFrame = pWal->hdr.mxFrame;
  for(p=pList; p && rc==0; p=p->pDirty){
    if( (p->flags & 0x040)==0 ) continue;
    iFrame++;
    rc = walIndexAppend(pWal, iFrame, p->pgno);
  }
  ((void) (0));
  while( rc==0 && nExtra>0 ){
    iFrame++;
    nExtra--;
    rc = walIndexAppend(pWal, iFrame, pLast->pgno);
  }

  if( rc==0 ){

    pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));
                             ;
                             ;
    pWal->hdr.mxFrame = iFrame;
    if( isCommit ){
      pWal->hdr.iChange++;
      pWal->hdr.nPage = nTruncate;
    }

    if( isCommit ){
      walIndexWriteHdr(pWal);
      pWal->iCallback = iFrame;
    }
  }

                                                                   ;
  return rc;
}
# 71008 "c_tests/sqlite3.c"
static int sqlite3WalFrames(
  Wal *pWal,
  int szPage,
  PgHdr *pList,
  Pgno nTruncate,
  int isCommit,
  int sync_flags
){
  int rc;
  ; {
    rc = walFrames(pWal, szPage, pList, nTruncate, isCommit, sync_flags);
  }
  ; ((void) (0));
  return rc;
}
# 71034 "c_tests/sqlite3.c"
static int sqlite3WalCheckpoint(
  Wal *pWal,
  sqlite3 *db,
  int eMode,
  int (*xBusy)(void*),
  void *pBusyArg,
  int sync_flags,
  int nBuf,
  u8 *zBuf,
  int *pnLog,
  int *pnCkpt
){
  int rc;
  int isChanged = 0;
  int eMode2 = eMode;
  int (*xBusy2)(void*) = xBusy;

  ((void) (0));
  ((void) (0));



  ((void) (0));
  ((void) (0));

  if( pWal->readOnly ) return 8;
                                                ;


                        ;
  if( xBusy2 ) (void)0;
# 71074 "c_tests/sqlite3.c"
  if( eMode!=-1 ){
    rc = walLockExclusive(pWal, 1, 1);
                               ;
                                          ;
    if( rc==0 ){
      pWal->ckptLock = 1;
# 71090 "c_tests/sqlite3.c"
      if( eMode!=0 ){
        rc = walBusyLock(pWal, xBusy2, pBusyArg, 0, 1);
        if( rc==0 ){
          pWal->writeLock = 1;
        }else if( rc==5 ){
          eMode2 = 0;
          xBusy2 = 0;
          rc = 0;
        }
      }
    }
  }else{
    rc = 0;
  }



  ; {
    if( rc==0 ){





                              ;
      rc = walIndexReadHdr(pWal, &isChanged);
      if( eMode2>0 ) (void)0;
      if( isChanged && pWal->pDbFd->pMethods->iVersion>=3 ){
        sqlite3OsUnfetch(pWal->pDbFd, 0, 0);
      }
    }


    if( rc==0 ){
      if( pWal->hdr.mxFrame && walPagesize(pWal)!=nBuf ){
        rc = sqlite3CorruptError(71125);
      }else if( eMode2!=-1 ){
        rc = walCheckpoint(pWal, db, eMode2, xBusy2, pBusyArg, sync_flags,zBuf);
      }


      if( rc==0 || rc==5 ){
        if( pnLog ) *pnLog = (int)pWal->hdr.mxFrame;
        ((void) (0));;
        if( pnCkpt ) *pnCkpt = (int)(walCkptInfo(pWal)->nBackfill);
      }
    }
  }
  ; ((void) (0));

  if( isChanged ){






    memset(&pWal->hdr, 0, sizeof(WalIndexHdr));
  }

                          ;
                       ;


  (void)sqlite3WalEndWriteTransaction(pWal);
  if( pWal->ckptLock ){
    walUnlockExclusive(pWal, 1, 1);
    pWal->ckptLock = 0;
  }
                                                                  ;



  return (rc==0 && eMode!=eMode2 ? 5 : rc);
}






static int sqlite3WalCallback(Wal *pWal){
  u32 ret = 0;
  if( pWal ){
    ret = pWal->iCallback;
    pWal->iCallback = 0;
  }
  return (int)ret;
}
# 71204 "c_tests/sqlite3.c"
static int sqlite3WalExclusiveMode(Wal *pWal, int op){
  int rc;
  ((void) (0));
  ((void) (0));
# 71216 "c_tests/sqlite3.c"
  ((void) (0));

  ((void) (0));

  if( op==0 ){
    if( pWal->exclusiveMode!=0 ){
      pWal->exclusiveMode = 0;
      if( walLockShared(pWal, (3+(pWal->readLock)))!=0 ){
        pWal->exclusiveMode = 1;
      }
      rc = pWal->exclusiveMode==0;
    }else{

      rc = 0;
    }
  }else if( op>0 ){
    ((void) (0));
    ((void) (0));
    walUnlockShared(pWal, (3+(pWal->readLock)));
    pWal->exclusiveMode = 1;
    rc = 1;
  }else{
    rc = pWal->exclusiveMode==0;
  }
  return rc;
}






static int sqlite3WalHeapMemory(Wal *pWal){
  return (pWal && pWal->exclusiveMode==2 );
}
# 71373 "c_tests/sqlite3.c"
static sqlite3_file *sqlite3WalFile(Wal *pWal){
  return pWal->pWalFd;
}
# 71631 "c_tests/sqlite3.c"
typedef struct MemPage MemPage;
typedef struct BtLock BtLock;
typedef struct CellInfo CellInfo;
# 71672 "c_tests/sqlite3.c"
struct MemPage {
  u8 isInit;
  u8 intKey;
  u8 intKeyLeaf;
  Pgno pgno;


  u8 leaf;
  u8 hdrOffset;
  u8 childPtrSize;
  u8 max1bytePayload;
  u8 nOverflow;
  u16 maxLocal;
  u16 minLocal;
  u16 cellOffset;
  int nFree;
  u16 nCell;
  u16 maskPage;
  u16 aiOvfl[4];

  u8 *apOvfl[4];
  BtShared *pBt;
  u8 *aData;
  u8 *aDataEnd;


  u8 *aCellIdx;
  u8 *aDataOfst;
  DbPage *pDbPage;
  u16 (*xCellSize)(MemPage*,u8*);
  void (*xParseCell)(MemPage*,u8*,CellInfo*);
};
# 71712 "c_tests/sqlite3.c"
struct BtLock {
  Btree *pBtree;
  Pgno iTable;
  u8 eLock;
  BtLock *pNext;
};
# 71744 "c_tests/sqlite3.c"
struct Btree {
  sqlite3 *db;
  BtShared *pBt;
  u8 inTrans;
  u8 sharable;
  u8 locked;
  u8 hasIncrblobCur;
  int wantToLock;
  int nBackup;
  u32 iBDataVersion;
  Btree *pNext;
  Btree *pPrev;




  BtLock lock;

};
# 71824 "c_tests/sqlite3.c"
struct BtShared {
  Pager *pPager;
  sqlite3 *db;
  BtCursor *pCursor;
  MemPage *pPage1;
  u8 openFlags;

  u8 autoVacuum;
  u8 incrVacuum;
  u8 bDoTruncate;

  u8 inTransaction;
  u8 max1bytePayload;
  u8 nReserveWanted;
  u16 btsFlags;
  u16 maxLocal;
  u16 minLocal;
  u16 maxLeaf;
  u16 minLeaf;
  u32 pageSize;
  u32 usableSize;
  int nTransaction;
  u32 nPage;
  void *pSchema;
  void (*xFreeSchema)(void*);
  sqlite3_mutex *mutex;
  Bitvec *pHasContent;

  int nRef;
  BtShared *pNext;
  BtLock *pLock;
  Btree *pWriter;

  u8 *pTmpSpace;
  int nPreformatSize;
};
# 71879 "c_tests/sqlite3.c"
struct CellInfo {
  i64 nKey;
  u8 *pPayload;
  u32 nPayload;
  u16 nLocal;
  u16 nSize;
};
# 71930 "c_tests/sqlite3.c"
struct BtCursor {
  u8 eState;
  u8 curFlags;
  u8 curPagerFlags;
  u8 hints;
  int skipNext;

  Btree *pBtree;
  Pgno *aOverflow;
  void *pKey;




  BtShared *pBt;
  BtCursor *pNext;
  CellInfo info;
  i64 nKey;
  Pgno pgnoRoot;
  i8 iPage;
  u8 curIntKey;
  u16 ix;
  u16 aiIdx[20 -1];
  struct KeyInfo *pKeyInfo;
  MemPage *pPage;
  MemPage *apPage[20 -1];
};
# 72098 "c_tests/sqlite3.c"
typedef struct IntegrityCk IntegrityCk;
struct IntegrityCk {
  BtShared *pBt;
  Pager *pPager;
  u8 *aPgRef;
  Pgno nCkPage;
  int mxErr;
  int nErr;
  int rc;
  u32 nStep;
  const char *zPfx;
  Pgno v0;
  Pgno v1;
  int v2;
  StrAccum errMsg;
  u32 *heap;
  sqlite3 *db;
  i64 nRow;
};
# 72151 "c_tests/sqlite3.c"
static void lockBtreeMutex(Btree *p){
  ((void) (0));
  ((void) (0));
  ((void) (0));

  sqlite3_mutex_enter(p->pBt->mutex);
  p->pBt->db = p->db;
  p->locked = 1;
}





static void __attribute__((noinline)) unlockBtreeMutex(Btree *p){
  BtShared *pBt = p->pBt;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  sqlite3_mutex_leave(pBt->mutex);
  p->locked = 0;
}


static void __attribute__((noinline)) btreeLockCarefully(Btree *p);
# 72195 "c_tests/sqlite3.c"
static void sqlite3BtreeEnter(Btree *p){




  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  ((void) (0));
  ((void) (0));


  ((void) (0));



  ((void) (0));

  if( !p->sharable ) return;
  p->wantToLock++;
  if( p->locked ) return;
  btreeLockCarefully(p);
}







static void __attribute__((noinline)) btreeLockCarefully(Btree *p){
  Btree *pLater;





  if( sqlite3_mutex_try(p->pBt->mutex)==0 ){
    p->pBt->db = p->db;
    p->locked = 1;
    return;
  }






  for(pLater=p->pNext; pLater; pLater=pLater->pNext){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    if( pLater->locked ){
      unlockBtreeMutex(pLater);
    }
  }
  lockBtreeMutex(p);
  for(pLater=p->pNext; pLater; pLater=pLater->pNext){
    if( pLater->wantToLock ){
      lockBtreeMutex(pLater);
    }
  }
}





static void sqlite3BtreeLeave(Btree *p){
  ((void) (0));
  if( p->sharable ){
    ((void) (0));
    p->wantToLock--;
    if( p->wantToLock==0 ){
      unlockBtreeMutex(p);
    }
  }
}
# 72310 "c_tests/sqlite3.c"
static void __attribute__((noinline)) btreeEnterAll(sqlite3 *db){
  int i;
  u8 skipOk = 1;
  Btree *p;
  ((void) (0));
  for(i=0; i<db->nDb; i++){
    p = db->aDb[i].pBt;
    if( p && p->sharable ){
      sqlite3BtreeEnter(p);
      skipOk = 0;
    }
  }
  db->noSharedCache = skipOk;
}
static void sqlite3BtreeEnterAll(sqlite3 *db){
  if( db->noSharedCache==0 ) btreeEnterAll(db);
}
static void __attribute__((noinline)) btreeLeaveAll(sqlite3 *db){
  int i;
  Btree *p;
  ((void) (0));
  for(i=0; i<db->nDb; i++){
    p = db->aDb[i].pBt;
    if( p ) sqlite3BtreeLeave(p);
  }
}
static void sqlite3BtreeLeaveAll(sqlite3 *db){
  if( db->noSharedCache==0 ) btreeLeaveAll(db);
}
# 72423 "c_tests/sqlite3.c"
static void sqlite3BtreeEnterCursor(BtCursor *pCur){
  sqlite3BtreeEnter(pCur->pBtree);
}

static void sqlite3BtreeLeaveCursor(BtCursor *pCur){
  sqlite3BtreeLeave(pCur->pBtree);
}
# 72458 "c_tests/sqlite3.c"
static const char zMagicHeader[] = "SQLite format 3";
# 72513 "c_tests/sqlite3.c"
static BtShared * sqlite3SharedCacheList = 0;
# 72525 "c_tests/sqlite3.c"
           int sqlite3_enable_shared_cache(int enable){
  sqlite3Config.sharedCacheEnabled = enable;
  return 0;
}
# 72765 "c_tests/sqlite3.c"
static int querySharedCacheTableLock(Btree *p, Pgno iTab, u8 eLock){
  BtShared *pBt = p->pBt;
  BtLock *pIter;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  ((void) (0));
  ((void) (0));


  if( !p->sharable ){
    return 0;
  }




  if( pBt->pWriter!=p && (pBt->btsFlags & 0x0040)!=0 ){
                                                     ;
    return (6 | (1<<8));
  }

  for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
# 72804 "c_tests/sqlite3.c"
    ((void) (0));
    ((void) (0));
    if( pIter->pBtree!=p && pIter->iTable==iTab && pIter->eLock!=eLock ){
                                                        ;
      if( eLock==2 ){
        ((void) (0));
        pBt->btsFlags |= 0x0080;
      }
      return (6 | (1<<8));
    }
  }
  return 0;
}
# 72837 "c_tests/sqlite3.c"
static int setSharedCacheTableLock(Btree *p, Pgno iTable, u8 eLock){
  BtShared *pBt = p->pBt;
  BtLock *pLock = 0;
  BtLock *pIter;

                                                 ;

  ((void) (0));
  ((void) (0));
  ((void) (0));





  ((void) (0));



  ((void) (0));
  ((void) (0));


  for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
    if( pIter->iTable==iTable && pIter->pBtree==p ){
      pLock = pIter;
      break;
    }
  }




  if( !pLock ){
    pLock = (BtLock *)sqlite3MallocZero(sizeof(BtLock));
    if( !pLock ){
      return 7;
    }
    pLock->iTable = iTable;
    pLock->pBtree = p;
    pLock->pNext = pBt->pLock;
    pBt->pLock = pLock;
  }





  ((void) (0));
  if( eLock>pLock->eLock ){
    pLock->eLock = eLock;
  }

  return 0;
}
# 72903 "c_tests/sqlite3.c"
static void clearAllSharedCacheTableLocks(Btree *p){
  BtShared *pBt = p->pBt;
  BtLock **ppIter = &pBt->pLock;

  ((void) (0));
  ((void) (0));
  ((void) (0));

                                               ;

  while( *ppIter ){
    BtLock *pLock = *ppIter;
    ((void) (0));
    ((void) (0));
    if( pLock->pBtree==p ){
      *ppIter = pLock->pNext;
      ((void) (0));
      if( pLock->iTable!=1 ){
        sqlite3_free(pLock);
      }
    }else{
      ppIter = &pLock->pNext;
    }
  }

  ((void) (0));
  if( pBt->pWriter==p ){
    pBt->pWriter = 0;
    pBt->btsFlags &= ~(0x0040|0x0080);
  }else if( pBt->nTransaction==2 ){
# 72942 "c_tests/sqlite3.c"
    pBt->btsFlags &= ~0x0080;
  }
}




static void downgradeAllSharedCacheTableLocks(Btree *p){
  BtShared *pBt = p->pBt;

                                                ;

  if( pBt->pWriter==p ){
    BtLock *pLock;
    pBt->pWriter = 0;
    pBt->btsFlags &= ~(0x0040|0x0080);
    for(pLock=pBt->pLock; pLock; pLock=pLock->pNext){
      ((void) (0));
      pLock->eLock = 1;
    }
  }
}



static void releasePage(MemPage *pPage);
static void releasePageOne(MemPage *pPage);
static void releasePageNotNull(MemPage *pPage);
# 73005 "c_tests/sqlite3.c"
static void invalidateAllOverflowCache(BtShared *pBt){
  BtCursor *p;
  ((void) (0));
  for(p=pBt->pCursor; p; p=p->pNext){
    (p->curFlags &= ~0x04);
  }
}
# 73027 "c_tests/sqlite3.c"
static void invalidateIncrblobCursors(
  Btree *pBtree,
  Pgno pgnoRoot,
  i64 iRow,
  int isClearTable
){
  BtCursor *p;
  ((void) (0));
  ((void) (0));
  pBtree->hasIncrblobCur = 0;
  for(p=pBtree->pBt->pCursor; p; p=p->pNext){
    if( (p->curFlags & 0x10)!=0 ){
      pBtree->hasIncrblobCur = 1;
      if( p->pgnoRoot==pgnoRoot && (isClearTable || p->info.nKey==iRow) ){
        p->eState = 1;
      }
    }
  }
}
# 73087 "c_tests/sqlite3.c"
static int btreeSetHasContent(BtShared *pBt, Pgno pgno){
  int rc = 0;
  if( !pBt->pHasContent ){
    ((void) (0));
    pBt->pHasContent = sqlite3BitvecCreate(pBt->nPage);
    if( !pBt->pHasContent ){
      rc = 7;
    }
  }
  if( rc==0 && pgno<=sqlite3BitvecSize(pBt->pHasContent) ){
    rc = sqlite3BitvecSet(pBt->pHasContent, pgno);
  }
  return rc;
}
# 73109 "c_tests/sqlite3.c"
static int btreeGetHasContent(BtShared *pBt, Pgno pgno){
  Bitvec *p = pBt->pHasContent;
  return p && (pgno>sqlite3BitvecSize(p) || sqlite3BitvecTestNotNull(p, pgno));
}





static void btreeClearHasContent(BtShared *pBt){
  sqlite3BitvecDestroy(pBt->pHasContent);
  pBt->pHasContent = 0;
}




static void btreeReleaseAllCursorPages(BtCursor *pCur){
  int i;
  if( pCur->iPage>=0 ){
    for(i=0; i<pCur->iPage; i++){
      releasePageNotNull(pCur->apPage[i]);
    }
    releasePageNotNull(pCur->pPage);
    pCur->iPage = -1;
  }
}
# 73150 "c_tests/sqlite3.c"
static int saveCursorKey(BtCursor *pCur){
  int rc = 0;
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pCur->curIntKey ){

    pCur->nKey = sqlite3BtreeIntegerKey(pCur);
  }else{






    void *pKey;
    pCur->nKey = sqlite3BtreePayloadSize(pCur);
    pKey = sqlite3Malloc( ((i64)pCur->nKey) + 9 + 8 );
    if( pKey ){
      rc = sqlite3BtreePayload(pCur, 0, (int)pCur->nKey, pKey);
      if( rc==0 ){
        memset(((u8*)pKey)+pCur->nKey, 0, 9+8);
        pCur->pKey = pKey;
      }else{
        sqlite3_free(pKey);
      }
    }else{
      rc = 7;
    }
  }
  ((void) (0));
  return rc;
}
# 73192 "c_tests/sqlite3.c"
static int saveCursorPosition(BtCursor *pCur){
  int rc;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pCur->curFlags & 0x40 ){
    return (19 |(11<<8));
  }
  if( pCur->eState==2 ){
    pCur->eState = 0;
  }else{
    pCur->skipNext = 0;
  }

  rc = saveCursorKey(pCur);
  if( rc==0 ){
    btreeReleaseAllCursorPages(pCur);
    pCur->eState = 3;
  }

  pCur->curFlags &= ~(0x02|0x04|0x08);
  return rc;
}


static int __attribute__((noinline)) saveCursorsOnList(BtCursor*,Pgno,BtCursor*);
# 73242 "c_tests/sqlite3.c"
static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept){
  BtCursor *p;
  ((void) (0));
  ((void) (0));
  for(p=pBt->pCursor; p; p=p->pNext){
    if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) ) break;
  }
  if( p ) return saveCursorsOnList(p, iRoot, pExcept);
  if( pExcept ) pExcept->curFlags &= ~0x20;
  return 0;
}






static int __attribute__((noinline)) saveCursorsOnList(
  BtCursor *p,
  Pgno iRoot,
  BtCursor *pExcept
){
  do{
    if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) ){
      if( p->eState==0 || p->eState==2 ){
        int rc = saveCursorPosition(p);
        if( 0!=rc ){
          return rc;
        }
      }else{
                               ;
        btreeReleaseAllCursorPages(p);
      }
    }
    p = p->pNext;
  }while( p );
  return 0;
}




static void sqlite3BtreeClearCursor(BtCursor *pCur){
  ((void) (0));
  sqlite3_free(pCur->pKey);
  pCur->pKey = 0;
  pCur->eState = 1;
}






static int btreeMoveto(
  BtCursor *pCur,
  const void *pKey,
  i64 nKey,
  int bias,
  int *pRes
){
  int rc;
  UnpackedRecord *pIdxKey;

  if( pKey ){
    KeyInfo *pKeyInfo = pCur->pKeyInfo;
    ((void) (0));
    pIdxKey = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
    if( pIdxKey==0 ) return 7;
    sqlite3VdbeRecordUnpack((int)nKey, pKey, pIdxKey);
    if( pIdxKey->nField==0 || pIdxKey->nField>pKeyInfo->nAllField ){
      rc = sqlite3CorruptError(73313);
    }else{
      rc = sqlite3BtreeIndexMoveto(pCur, pIdxKey, pRes);
    }
    sqlite3DbFree(pCur->pKeyInfo->db, pIdxKey);
  }else{
    pIdxKey = 0;
    rc = sqlite3BtreeTableMoveto(pCur, nKey, bias, pRes);
  }
  return rc;
}
# 73332 "c_tests/sqlite3.c"
static int btreeRestoreCursorPosition(BtCursor *pCur){
  int rc;
  int skipNext = 0;
  ((void) (0));
  ((void) (0));
  if( pCur->eState==4 ){
    return pCur->skipNext;
  }
  pCur->eState = 1;
  if( sqlite3FaultSim(410) ){
    rc = 10;
  }else{
    rc = btreeMoveto(pCur, pCur->pKey, pCur->nKey, 0, &skipNext);
  }
  if( rc==0 ){
    sqlite3_free(pCur->pKey);
    pCur->pKey = 0;
    ((void) (0));
    if( skipNext ) pCur->skipNext = skipNext;
    if( pCur->skipNext && pCur->eState==0 ){
      pCur->eState = 2;
    }
  }
  return rc;
}
# 73375 "c_tests/sqlite3.c"
static int sqlite3BtreeCursorHasMoved(BtCursor *pCur){
  ((void) (0));

  ((void) (0));
  ((void) (0));
  return 0 != *(u8*)pCur;
}






static BtCursor *sqlite3BtreeFakeValidCursor(void){
  static u8 fakeCursor = 0;
  ((void) (0));
  return (BtCursor*)&fakeCursor;
}
# 73407 "c_tests/sqlite3.c"
static int sqlite3BtreeCursorRestore(BtCursor *pCur, int *pDifferentRow){
  int rc;

  ((void) (0));
  ((void) (0));
  rc = (pCur->eState>=3 ? btreeRestoreCursorPosition(pCur) : 0);
  if( rc ){
    *pDifferentRow = 1;
    return rc;
  }
  if( pCur->eState!=0 ){
    *pDifferentRow = 1;
  }else{
    *pDifferentRow = 0;
  }
  return 0;
}
# 73456 "c_tests/sqlite3.c"
static void sqlite3BtreeCursorHintFlags(BtCursor *pCur, unsigned x){
  ((void) (0));
  pCur->hints = (u8)x;
}
# 73472 "c_tests/sqlite3.c"
static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno){
  int nPagesPerMapPage;
  Pgno iPtrMap, ret;
  ((void) (0));
  if( pgno<2 ) return 0;
  nPagesPerMapPage = (pBt->usableSize/5)+1;
  iPtrMap = (pgno-2)/nPagesPerMapPage;
  ret = (iPtrMap*nPagesPerMapPage) + 2;
  if( ret==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
    ret++;
  }
  return ret;
}
# 73496 "c_tests/sqlite3.c"
static void ptrmapPut(BtShared *pBt, Pgno key, u8 eType, Pgno parent, int *pRC){
  DbPage *pDbPage;
  u8 *pPtrmap;
  Pgno iPtrmap;
  int offset;
  int rc;

  if( *pRC ) return;

  ((void) (0));

  ((void) (0));

  ((void) (0));
  if( key==0 ){
    *pRC = sqlite3CorruptError(73511);
    return;
  }
  iPtrmap = ptrmapPageno(pBt, key);
  rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);
  if( rc!=0 ){
    *pRC = rc;
    return;
  }
  if( ((char*)sqlite3PagerGetExtra(pDbPage))[0]!=0 ){



    *pRC = sqlite3CorruptError(73524);
    goto ptrmap_exit;
  }
  offset = (5*(key-iPtrmap-1));
  if( offset<0 ){
    *pRC = sqlite3CorruptError(73529);
    goto ptrmap_exit;
  }
  ((void) (0));
  pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);

  if( eType!=pPtrmap[offset] || sqlite3Get4byte(&pPtrmap[offset+1])!=parent ){
                                                               ;
    *pRC= rc = sqlite3PagerWrite(pDbPage);
    if( rc==0 ){
      pPtrmap[offset] = eType;
      sqlite3Put4byte(&pPtrmap[offset+1], parent);
    }
  }

ptrmap_exit:
  sqlite3PagerUnref(pDbPage);
}
# 73555 "c_tests/sqlite3.c"
static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){
  DbPage *pDbPage;
  int iPtrmap;
  u8 *pPtrmap;
  int offset;
  int rc;

  ((void) (0));

  iPtrmap = ptrmapPageno(pBt, key);
  rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);
  if( rc!=0 ){
    return rc;
  }
  pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);

  offset = (5*(key-iPtrmap-1));
  if( offset<0 ){
    sqlite3PagerUnref(pDbPage);
    return sqlite3CorruptError(73574);
  }
  ((void) (0));
  ((void) (0));
  *pEType = pPtrmap[offset];
  if( pPgno ) *pPgno = sqlite3Get4byte(&pPtrmap[offset+1]);

  sqlite3PagerUnref(pDbPage);
  if( *pEType<1 || *pEType>5 ) return sqlite3CorruptError(73582);
  return 0;
}
# 73614 "c_tests/sqlite3.c"
static __attribute__((noinline)) void btreeParseCellAdjustSizeForOverflow(
  MemPage *pPage,
  u8 *pCell,
  CellInfo *pInfo
){
# 73628 "c_tests/sqlite3.c"
  int minLocal;
  int maxLocal;
  int surplus;

  minLocal = pPage->minLocal;
  maxLocal = pPage->maxLocal;
  surplus = minLocal + (pInfo->nPayload - minLocal)%(pPage->pBt->usableSize-4);
                               ;
                                 ;
  if( surplus <= maxLocal ){
    pInfo->nLocal = (u16)surplus;
  }else{
    pInfo->nLocal = (u16)minLocal;
  }
  pInfo->nSize = (u16)(&pInfo->pPayload[pInfo->nLocal] - pCell) + 4;
}





static int btreePayloadToLocal(MemPage *pPage, i64 nPayload){
  int maxLocal;
  maxLocal = pPage->maxLocal;
  ((void) (0));
  if( nPayload<=maxLocal ){
    return (int)nPayload;
  }else{
    int minLocal;
    int surplus;
    minLocal = pPage->minLocal;
    surplus = (int)(minLocal +(nPayload - minLocal)%(pPage->pBt->usableSize-4));
    return (surplus <= maxLocal) ? surplus : minLocal;
  }
}
# 73678 "c_tests/sqlite3.c"
static void btreeParseCellPtrNoPayload(
  MemPage *pPage,
  u8 *pCell,
  CellInfo *pInfo
){
  ((void) (0));
  ((void) (0));
  ((void) (0));

  (void)(pPage);

  pInfo->nSize = 4 + sqlite3GetVarint(&pCell[4], (u64*)&pInfo->nKey);
  pInfo->nPayload = 0;
  pInfo->nLocal = 0;
  pInfo->pPayload = 0;
  return;
}
static void btreeParseCellPtr(
  MemPage *pPage,
  u8 *pCell,
  CellInfo *pInfo
){
  u8 *pIter;
  u32 nPayload;
  u64 iKey;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pIter = pCell;







  nPayload = *pIter;
  if( nPayload>=0x80 ){
    u8 *pEnd = &pIter[8];
    nPayload &= 0x7f;
    do{
      nPayload = (nPayload<<7) | (*++pIter & 0x7f);
    }while( (*pIter)>=0x80 && pIter<pEnd );
  }
  pIter++;
# 73733 "c_tests/sqlite3.c"
  iKey = *pIter;
  if( iKey>=0x80 ){
    u8 x;
    iKey = (iKey<<7) ^ (x = *++pIter);
    if( x>=0x80 ){
      iKey = (iKey<<7) ^ (x = *++pIter);
      if( x>=0x80 ){
        iKey = (iKey<<7) ^ 0x10204000 ^ (x = *++pIter);
        if( x>=0x80 ){
          iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);
          if( x>=0x80 ){
            iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);
            if( x>=0x80 ){
              iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);
              if( x>=0x80 ){
                iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);
                if( x>=0x80 ){
                  iKey = (iKey<<8) ^ 0x8000 ^ (*++pIter);
                }
              }
            }
          }
        }
      }else{
        iKey ^= 0x204000;
      }
    }else{
      iKey ^= 0x4000;
    }
  }
  pIter++;

  pInfo->nKey = *(i64*)&iKey;
  pInfo->nPayload = nPayload;
  pInfo->pPayload = pIter;
                                       ;
                                              ;
  ((void) (0));
  ((void) (0));
  if( nPayload<=pPage->maxLocal ){



    pInfo->nSize = (u16)nPayload + (u16)(pIter - pCell);
    if( pInfo->nSize<4 ) pInfo->nSize = 4;
    pInfo->nLocal = (u16)nPayload;
  }else{
    btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
  }
}
static void btreeParseCellPtrIndex(
  MemPage *pPage,
  u8 *pCell,
  CellInfo *pInfo
){
  u8 *pIter;
  u32 nPayload;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  pIter = pCell + pPage->childPtrSize;
  nPayload = *pIter;
  if( nPayload>=0x80 ){
    u8 *pEnd = &pIter[8];
    nPayload &= 0x7f;
    do{
      nPayload = (nPayload<<7) | (*++pIter & 0x7f);
    }while( *(pIter)>=0x80 && pIter<pEnd );
  }
  pIter++;
  pInfo->nKey = nPayload;
  pInfo->nPayload = nPayload;
  pInfo->pPayload = pIter;
                                       ;
                                              ;
  ((void) (0));
  ((void) (0));
  if( nPayload<=pPage->maxLocal ){



    pInfo->nSize = (u16)nPayload + (u16)(pIter - pCell);
    if( pInfo->nSize<4 ) pInfo->nSize = 4;
    pInfo->nLocal = (u16)nPayload;
  }else{
    btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
  }
}
static void btreeParseCell(
  MemPage *pPage,
  int iCell,
  CellInfo *pInfo
){
  pPage->xParseCell(pPage, ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(iCell)])[0]<<8 | (&(pPage)->aCellIdx[2*(iCell)])[1]))), pInfo);
}
# 73844 "c_tests/sqlite3.c"
static u16 cellSizePtr(MemPage *pPage, u8 *pCell){
  u8 *pIter = pCell + 4;
  u8 *pEnd;
  u32 nSize;
# 73858 "c_tests/sqlite3.c"
  ((void) (0));
  nSize = *pIter;
  if( nSize>=0x80 ){
    pEnd = &pIter[8];
    nSize &= 0x7f;
    do{
      nSize = (nSize<<7) | (*++pIter & 0x7f);
    }while( *(pIter)>=0x80 && pIter<pEnd );
  }
  pIter++;
                                    ;
                                           ;
  if( nSize<=pPage->maxLocal ){
    nSize += (u32)(pIter - pCell);
    ((void) (0));
  }else{
    int minLocal = pPage->minLocal;
    nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);
                                      ;
                                             ;
    if( nSize>pPage->maxLocal ){
      nSize = minLocal;
    }
    nSize += 4 + (u16)(pIter - pCell);
  }
  ((void) (0));
  return (u16)nSize;
}
static u16 cellSizePtrIdxLeaf(MemPage *pPage, u8 *pCell){
  u8 *pIter = pCell;
  u8 *pEnd;
  u32 nSize;
# 73900 "c_tests/sqlite3.c"
  ((void) (0));
  nSize = *pIter;
  if( nSize>=0x80 ){
    pEnd = &pIter[8];
    nSize &= 0x7f;
    do{
      nSize = (nSize<<7) | (*++pIter & 0x7f);
    }while( *(pIter)>=0x80 && pIter<pEnd );
  }
  pIter++;
                                    ;
                                           ;
  if( nSize<=pPage->maxLocal ){
    nSize += (u32)(pIter - pCell);
    if( nSize<4 ) nSize = 4;
  }else{
    int minLocal = pPage->minLocal;
    nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);
                                      ;
                                             ;
    if( nSize>pPage->maxLocal ){
      nSize = minLocal;
    }
    nSize += 4 + (u16)(pIter - pCell);
  }
  ((void) (0));
  return (u16)nSize;
}
static u16 cellSizePtrNoPayload(MemPage *pPage, u8 *pCell){
  u8 *pIter = pCell + 4;
  u8 *pEnd;
# 73940 "c_tests/sqlite3.c"
  (void)(pPage);


  ((void) (0));
  pEnd = pIter + 9;
  while( (*pIter++)&0x80 && pIter<pEnd );
  ((void) (0));
  return (u16)(pIter - pCell);
}
static u16 cellSizePtrTableLeaf(MemPage *pPage, u8 *pCell){
  u8 *pIter = pCell;
  u8 *pEnd;
  u32 nSize;
# 73963 "c_tests/sqlite3.c"
  nSize = *pIter;
  if( nSize>=0x80 ){
    pEnd = &pIter[8];
    nSize &= 0x7f;
    do{
      nSize = (nSize<<7) | (*++pIter & 0x7f);
    }while( *(pIter)>=0x80 && pIter<pEnd );
  }
  pIter++;



  if( (*pIter++)&0x80
   && (*pIter++)&0x80
   && (*pIter++)&0x80
   && (*pIter++)&0x80
   && (*pIter++)&0x80
   && (*pIter++)&0x80
   && (*pIter++)&0x80
   && (*pIter++)&0x80 ){ pIter++; }
                                    ;
                                           ;
  if( nSize<=pPage->maxLocal ){
    nSize += (u32)(pIter - pCell);
    if( nSize<4 ) nSize = 4;
  }else{
    int minLocal = pPage->minLocal;
    nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);
                                      ;
                                             ;
    if( nSize>pPage->maxLocal ){
      nSize = minLocal;
    }
    nSize += 4 + (u16)(pIter - pCell);
  }
  ((void) (0));
  return (u16)nSize;
}
# 74018 "c_tests/sqlite3.c"
static void ptrmapPutOvflPtr(MemPage *pPage, MemPage *pSrc, u8 *pCell,int *pRC){
  CellInfo info;
  if( *pRC ) return;
  ((void) (0));
  pPage->xParseCell(pPage, pCell, &info);
  if( info.nLocal<info.nPayload ){
    Pgno ovfl;
    if( (((uptr)(pCell)<(uptr)(pSrc->aDataEnd))&&((uptr)(pCell+info.nLocal)>(uptr)(pSrc->aDataEnd))) ){
                             ;
      *pRC = sqlite3CorruptError(74027);
      return;
    }
    ovfl = sqlite3Get4byte(&pCell[info.nSize-4]);
    ptrmapPut(pPage->pBt, ovfl, 3, pPage->pgno, pRC);
  }
}
# 74049 "c_tests/sqlite3.c"
static int defragmentPage(MemPage *pPage, int nMaxFrag){
  int i;
  int pc;
  int hdr;
  int size;
  int usableSize;
  int cellOffset;
  int cbrk;
  int nCell;
  unsigned char *data;
  unsigned char *temp;
  unsigned char *src;
  int iCellFirst;
  int iCellLast;
  int iCellStart;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  data = pPage->aData;
  hdr = pPage->hdrOffset;
  cellOffset = pPage->cellOffset;
  nCell = pPage->nCell;
  ((void) (0));
  iCellFirst = cellOffset + 2*nCell;
  usableSize = pPage->pBt->usableSize;






  if( (int)data[hdr+7]<=nMaxFrag ){
    int iFree = ((&data[hdr+1])[0]<<8 | (&data[hdr+1])[1]);
    if( iFree>usableSize-4 ) return sqlite3CorruptError(74085);
    if( iFree ){
      int iFree2 = ((&data[iFree])[0]<<8 | (&data[iFree])[1]);
      if( iFree2>usableSize-4 ) return sqlite3CorruptError(74088);
      if( 0==iFree2 || (data[iFree2]==0 && data[iFree2+1]==0) ){
        u8 *pEnd = &data[cellOffset + nCell*2];
        u8 *pAddr;
        int sz2 = 0;
        int sz = ((&data[iFree+2])[0]<<8 | (&data[iFree+2])[1]);
        int top = ((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]);
        if( top>=iFree ){
          return sqlite3CorruptError(74096);
        }
        if( iFree2 ){
          if( iFree+sz>iFree2 ) return sqlite3CorruptError(74099);
          sz2 = ((&data[iFree2+2])[0]<<8 | (&data[iFree2+2])[1]);
          if( iFree2+sz2 > usableSize ) return sqlite3CorruptError(74101);
          memmove(&data[iFree+sz+sz2], &data[iFree+sz], iFree2-(iFree+sz));
          sz += sz2;
        }else if( iFree+sz>usableSize ){
          return sqlite3CorruptError(74105);
        }

        cbrk = top+sz;
        ((void) (0));
        memmove(&data[cbrk], &data[top], iFree-top);
        for(pAddr=&data[cellOffset]; pAddr<pEnd; pAddr+=2){
          pc = ((pAddr)[0]<<8 | (pAddr)[1]);
          if( pc<iFree ){ ((pAddr)[0] = (u8)((pc+sz)>>8), (pAddr)[1] = (u8)(pc+sz)); }
          else if( pc<iFree2 ){ ((pAddr)[0] = (u8)((pc+sz2)>>8), (pAddr)[1] = (u8)(pc+sz2)); }
        }
        goto defragment_out;
      }
    }
  }

  cbrk = usableSize;
  iCellLast = usableSize - 4;
  iCellStart = ((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]);
  if( nCell>0 ){
    temp = sqlite3PagerTempSpace(pPage->pBt->pPager);
    memcpy(temp, data, usableSize);
    src = temp;
    for(i=0; i<nCell; i++){
      u8 *pAddr;
      pAddr = &data[cellOffset + i*2];
      pc = ((pAddr)[0]<<8 | (pAddr)[1]);
                                ;
                               ;



      if( pc>iCellLast ){
        return sqlite3CorruptError(74138);
      }
      ((void) (0));
      size = pPage->xCellSize(pPage, &src[pc]);
      cbrk -= size;
      if( cbrk<iCellStart || pc+size>usableSize ){
        return sqlite3CorruptError(74144);
      }
      ((void) (0));
                                       ;
                                     ;
      ((pAddr)[0] = (u8)((cbrk)>>8), (pAddr)[1] = (u8)(cbrk));
      memcpy(&data[cbrk], &src[pc], size);
    }
  }
  data[hdr+7] = 0;

defragment_out:
  ((void) (0));
  if( data[hdr+7]+cbrk-iCellFirst!=pPage->nFree ){
    return sqlite3CorruptError(74158);
  }
  ((void) (0));
  ((&data[hdr+5])[0] = (u8)((cbrk)>>8), (&data[hdr+5])[1] = (u8)(cbrk));
  data[hdr+1] = 0;
  data[hdr+2] = 0;
  memset(&data[iCellFirst], 0, cbrk-iCellFirst);
  ((void) (0));
  return 0;
}
# 74183 "c_tests/sqlite3.c"
static u8 *pageFindSlot(MemPage *pPg, int nByte, int *pRc){
  const int hdr = pPg->hdrOffset;
  u8 * const aData = pPg->aData;
  int iAddr = hdr + 1;
  u8 *pTmp = &aData[iAddr];
  int pc = ((pTmp)[0]<<8 | (pTmp)[1]);
  int x;
  int maxPC = pPg->pBt->usableSize - nByte;
  int size;

  ((void) (0));
  while( pc<=maxPC ){



    pTmp = &aData[pc+2];
    size = ((pTmp)[0]<<8 | (pTmp)[1]);
    if( (x = size - nByte)>=0 ){
                      ;
                      ;
      if( x<4 ){


        if( aData[hdr+7]>57 ) return 0;



        memcpy(&aData[iAddr], &aData[pc], 2);
        aData[hdr+7] += (u8)x;
        return &aData[pc];
      }else if( x+pc > maxPC ){

        *pRc = sqlite3CorruptError(74215);
        return 0;
      }else{


        ((&aData[pc+2])[0] = (u8)((x)>>8), (&aData[pc+2])[1] = (u8)(x));
      }
      return &aData[pc + x];
    }
    iAddr = pc;
    pTmp = &aData[pc];
    pc = ((pTmp)[0]<<8 | (pTmp)[1]);
    if( pc<=iAddr ){
      if( pc ){

        *pRc = sqlite3CorruptError(74230);
      }
      return 0;
    }
  }
  if( pc>maxPC+nByte-4 ){

    *pRc = sqlite3CorruptError(74237);
  }
  return 0;
}
# 74255 "c_tests/sqlite3.c"
static int allocateSpace(MemPage *pPage, int nByte, int *pIdx){
  const int hdr = pPage->hdrOffset;
  u8 * const data = pPage->aData;
  int top;
  int rc = 0;
  u8 *pTmp;
  int gap;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  ((void) (0));
  gap = pPage->cellOffset + 2*pPage->nCell;
  ((void) (0));





  pTmp = &data[hdr+5];
  top = ((pTmp)[0]<<8 | (pTmp)[1]);
  if( gap>top ){
    if( top==0 && pPage->pBt->usableSize==65536 ){
      top = 65536;
    }else{
      return sqlite3CorruptError(74285);
    }
  }else if( top>(int)pPage->pBt->usableSize ){
    return sqlite3CorruptError(74288);
  }





                        ;
                        ;
                      ;
  if( (data[hdr+2] || data[hdr+1]) && gap+2<=top ){
    u8 *pSpace = pageFindSlot(pPage, nByte, &rc);
    if( pSpace ){
      int g2;
      ((void) (0));
      *pIdx = g2 = (int)(pSpace-data);
      if( g2<=gap ){
        return sqlite3CorruptError(74305);
      }else{
        return 0;
      }
    }else if( rc ){
      return rc;
    }
  }




                              ;
  if( gap+2+nByte>top ){
    ((void) (0));
    ((void) (0));
    rc = defragmentPage(pPage, ((4)<(pPage->nFree - (2+nByte))?(4):(pPage->nFree - (2+nByte))));
    if( rc ) return rc;
    top = (((((int)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);
    ((void) (0));
  }
# 74334 "c_tests/sqlite3.c"
  top -= nByte;
  ((&data[hdr+5])[0] = (u8)((top)>>8), (&data[hdr+5])[1] = (u8)(top));
  ((void) (0));
  *pIdx = top;
  return 0;
}
# 74354 "c_tests/sqlite3.c"
static int freeSpace(MemPage *pPage, int iStart, int iSize){
  int iPtr;
  int iFreeBlk;
  u8 hdr;
  int nFrag = 0;
  int iOrigSize = iSize;
  int x;
  int iEnd = iStart + iSize;
  unsigned char *data = pPage->aData;
  u8 *pTmp;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));




  hdr = pPage->hdrOffset;
  iPtr = hdr + 1;
  if( data[iPtr+1]==0 && data[iPtr]==0 ){
    iFreeBlk = 0;
  }else{
    while( (iFreeBlk = ((&data[iPtr])[0]<<8 | (&data[iPtr])[1]))<iStart ){
      if( iFreeBlk<=iPtr ){
        if( iFreeBlk==0 ) break;
        return sqlite3CorruptError(74384);
      }
      iPtr = iFreeBlk;
    }
    if( iFreeBlk>(int)pPage->pBt->usableSize-4 ){
      return sqlite3CorruptError(74389);
    }
    ((void) (0));







    if( iFreeBlk && iEnd+3>=iFreeBlk ){
      nFrag = iFreeBlk - iEnd;
      if( iEnd>iFreeBlk ) return sqlite3CorruptError(74401);
      iEnd = iFreeBlk + ((&data[iFreeBlk+2])[0]<<8 | (&data[iFreeBlk+2])[1]);
      if( iEnd > (int)pPage->pBt->usableSize ){
        return sqlite3CorruptError(74404);
      }
      iSize = iEnd - iStart;
      iFreeBlk = ((&data[iFreeBlk])[0]<<8 | (&data[iFreeBlk])[1]);
    }





    if( iPtr>hdr+1 ){
      int iPtrEnd = iPtr + ((&data[iPtr+2])[0]<<8 | (&data[iPtr+2])[1]);
      if( iPtrEnd+3>=iStart ){
        if( iPtrEnd>iStart ) return sqlite3CorruptError(74417);
        nFrag += iStart - iPtrEnd;
        iSize = iEnd - iPtr;
        iStart = iPtr;
      }
    }
    if( nFrag>data[hdr+7] ) return sqlite3CorruptError(74423);
    data[hdr+7] -= (u8)nFrag;
  }
  pTmp = &data[hdr+5];
  x = ((pTmp)[0]<<8 | (pTmp)[1]);
  if( pPage->pBt->btsFlags & 0x000c ){


    memset(&data[iStart], 0, iSize);
  }
  if( iStart<=x ){



    if( iStart<x ) return sqlite3CorruptError(74437);
    if( iPtr!=hdr+1 ) return sqlite3CorruptError(74438);
    ((&data[hdr+1])[0] = (u8)((iFreeBlk)>>8), (&data[hdr+1])[1] = (u8)(iFreeBlk));
    ((&data[hdr+5])[0] = (u8)((iEnd)>>8), (&data[hdr+5])[1] = (u8)(iEnd));
  }else{

    ((&data[iPtr])[0] = (u8)((iStart)>>8), (&data[iPtr])[1] = (u8)(iStart));
    ((&data[iStart])[0] = (u8)((iFreeBlk)>>8), (&data[iStart])[1] = (u8)(iFreeBlk));
    ((void) (0));
    ((&data[iStart+2])[0] = (u8)(((u16)iSize)>>8), (&data[iStart+2])[1] = (u8)((u16)iSize));
  }
  pPage->nFree += iOrigSize;
  return 0;
}
# 74464 "c_tests/sqlite3.c"
static int decodeFlags(MemPage *pPage, int flagByte){
  BtShared *pBt;

  ((void) (0));
  ((void) (0));
  pBt = pPage->pBt;
  pPage->max1bytePayload = pBt->max1bytePayload;
  if( flagByte>=(0x02 | 0x08) ){
    pPage->childPtrSize = 0;
    pPage->leaf = 1;
    if( flagByte==(0x04 | 0x01 | 0x08) ){
      pPage->intKeyLeaf = 1;
      pPage->xCellSize = cellSizePtrTableLeaf;
      pPage->xParseCell = btreeParseCellPtr;
      pPage->intKey = 1;
      pPage->maxLocal = pBt->maxLeaf;
      pPage->minLocal = pBt->minLeaf;
    }else if( flagByte==(0x02 | 0x08) ){
      pPage->intKey = 0;
      pPage->intKeyLeaf = 0;
      pPage->xCellSize = cellSizePtrIdxLeaf;
      pPage->xParseCell = btreeParseCellPtrIndex;
      pPage->maxLocal = pBt->maxLocal;
      pPage->minLocal = pBt->minLocal;
    }else{
      pPage->intKey = 0;
      pPage->intKeyLeaf = 0;
      pPage->xCellSize = cellSizePtrIdxLeaf;
      pPage->xParseCell = btreeParseCellPtrIndex;
      return sqlite3CorruptError(74493);
    }
  }else{
    pPage->childPtrSize = 4;
    pPage->leaf = 0;
    if( flagByte==(0x02) ){
      pPage->intKey = 0;
      pPage->intKeyLeaf = 0;
      pPage->xCellSize = cellSizePtr;
      pPage->xParseCell = btreeParseCellPtrIndex;
      pPage->maxLocal = pBt->maxLocal;
      pPage->minLocal = pBt->minLocal;
    }else if( flagByte==(0x04 | 0x01) ){
      pPage->intKeyLeaf = 0;
      pPage->xCellSize = cellSizePtrNoPayload;
      pPage->xParseCell = btreeParseCellPtrNoPayload;
      pPage->intKey = 1;
      pPage->maxLocal = pBt->maxLeaf;
      pPage->minLocal = pBt->minLeaf;
    }else{
      pPage->intKey = 0;
      pPage->intKeyLeaf = 0;
      pPage->xCellSize = cellSizePtr;
      pPage->xParseCell = btreeParseCellPtrIndex;
      return sqlite3CorruptError(74517);
    }
  }
  return 0;
}





static int btreeComputeFreeSpace(MemPage *pPage){
  int pc;
  u8 hdr;
  u8 *data;
  int usableSize;
  int nFree;
  int top;
  int iCellFirst;
  int iCellLast;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  usableSize = pPage->pBt->usableSize;
  hdr = pPage->hdrOffset;
  data = pPage->aData;



  top = (((((int)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);
  iCellFirst = hdr + 8 + pPage->childPtrSize + 2*pPage->nCell;
  iCellLast = usableSize - 4;





  pc = ((&data[hdr+1])[0]<<8 | (&data[hdr+1])[1]);
  nFree = data[hdr+7] + top;
  if( pc>0 ){
    u32 next, size;
    if( pc<top ){



      return sqlite3CorruptError(74568);
    }
    while( 1 ){
      if( pc>iCellLast ){

        return sqlite3CorruptError(74573);
      }
      next = ((&data[pc])[0]<<8 | (&data[pc])[1]);
      size = ((&data[pc+2])[0]<<8 | (&data[pc+2])[1]);
      nFree = nFree + size;
      if( next<=pc+size+3 ) break;
      pc = next;
    }
    if( next>0 ){

      return sqlite3CorruptError(74583);
    }
    if( pc+size>(unsigned int)usableSize ){

      return sqlite3CorruptError(74587);
    }
  }
# 74598 "c_tests/sqlite3.c"
  if( nFree>usableSize || nFree<iCellFirst ){
    return sqlite3CorruptError(74599);
  }
  pPage->nFree = (u16)(nFree - iCellFirst);
  return 0;
}





static __attribute__((noinline)) int btreeCellSizeCheck(MemPage *pPage){
  int iCellFirst;
  int iCellLast;
  int i;
  int sz;
  int pc;
  u8 *data;
  int usableSize;
  int cellOffset;

  iCellFirst = pPage->cellOffset + 2*pPage->nCell;
  usableSize = pPage->pBt->usableSize;
  iCellLast = usableSize - 4;
  data = pPage->aData;
  cellOffset = pPage->cellOffset;
  if( !pPage->leaf ) iCellLast--;
  for(i=0; i<pPage->nCell; i++){
    pc = ((&data[cellOffset+i*2])[0]<<8 | (&data[cellOffset+i*2])[1]);
                              ;
                             ;
    if( pc<iCellFirst || pc>iCellLast ){
      return sqlite3CorruptError(74630);
    }
    sz = pPage->xCellSize(pPage, &data[pc]);
                                 ;
    if( pc+sz>usableSize ){
      return sqlite3CorruptError(74635);
    }
  }
  return 0;
}
# 74650 "c_tests/sqlite3.c"
static int btreeInitPage(MemPage *pPage){
  u8 *data;
  BtShared *pBt;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  pBt = pPage->pBt;
  data = pPage->aData + pPage->hdrOffset;


  if( decodeFlags(pPage, data[0]) ){
    return sqlite3CorruptError(74667);
  }
  ((void) (0));
  pPage->maskPage = (u16)(pBt->pageSize - 1);
  pPage->nOverflow = 0;
  pPage->cellOffset = (u16)(pPage->hdrOffset + 8 + pPage->childPtrSize);
  pPage->aCellIdx = data + pPage->childPtrSize + 8;
  pPage->aDataEnd = pPage->aData + pBt->pageSize;
  pPage->aDataOfst = pPage->aData + pPage->childPtrSize;


  pPage->nCell = ((&data[3])[0]<<8 | (&data[3])[1]);
  if( pPage->nCell>((pBt->pageSize-8)/6) ){

    return sqlite3CorruptError(74681);
  }
                                        ;




  ((void) (0));


  pPage->nFree = -1;
  pPage->isInit = 1;
  if( pBt->db->flags & 0x00200000 ){
    return btreeCellSizeCheck(pPage);
  }
  return 0;
}





static void zeroPage(MemPage *pPage, int flags){
  unsigned char *data = pPage->aData;
  BtShared *pBt = pPage->pBt;
  int hdr = pPage->hdrOffset;
  int first;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pBt->btsFlags & 0x000c ){
    memset(&data[hdr], 0, pBt->usableSize - hdr);
  }
  data[hdr] = (char)flags;
  first = hdr + ((flags&0x08)==0 ? 12 : 8);
  memset(&data[hdr+1], 0, 4);
  data[hdr+7] = 0;
  ((&data[hdr+5])[0] = (u8)((pBt->usableSize)>>8), (&data[hdr+5])[1] = (u8)(pBt->usableSize));
  pPage->nFree = (u16)(pBt->usableSize - first);
  decodeFlags(pPage, flags);
  pPage->cellOffset = (u16)first;
  pPage->aDataEnd = &data[pBt->pageSize];
  pPage->aCellIdx = &data[first];
  pPage->aDataOfst = &data[pPage->childPtrSize];
  pPage->nOverflow = 0;
  ((void) (0));
  pPage->maskPage = (u16)(pBt->pageSize - 1);
  pPage->nCell = 0;
  pPage->isInit = 1;
}






static MemPage *btreePageFromDbPage(DbPage *pDbPage, Pgno pgno, BtShared *pBt){
  MemPage *pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);
  if( pgno!=pPage->pgno ){
    pPage->aData = sqlite3PagerGetData(pDbPage);
    pPage->pDbPage = pDbPage;
    pPage->pBt = pBt;
    pPage->pgno = pgno;
    pPage->hdrOffset = pgno==1 ? 100 : 0;
  }
  ((void) (0));
  return pPage;
}
# 74764 "c_tests/sqlite3.c"
static int btreeGetPage(
  BtShared *pBt,
  Pgno pgno,
  MemPage **ppPage,
  int flags
){
  int rc;
  DbPage *pDbPage;

  ((void) (0));
  ((void) (0));
  rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return 0;
}






static MemPage *btreePageLookup(BtShared *pBt, Pgno pgno){
  DbPage *pDbPage;
  ((void) (0));
  pDbPage = sqlite3PagerLookup(pBt->pPager, pgno);
  if( pDbPage ){
    return btreePageFromDbPage(pDbPage, pgno, pBt);
  }
  return 0;
}





static Pgno btreePagecount(BtShared *pBt){
  return pBt->nPage;
}
static Pgno sqlite3BtreeLastPage(Btree *p){
  ((void) (0));
  return btreePagecount(p->pBt);
}




static int getAndInitPage(
  BtShared *pBt,
  Pgno pgno,
  MemPage **ppPage,
  int bReadOnly
){
  int rc;
  DbPage *pDbPage;
  MemPage *pPage;
  ((void) (0));

  if( pgno>btreePagecount(pBt) ){
    *ppPage = 0;
    return sqlite3CorruptError(74824);
  }
  rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, bReadOnly);
  if( rc ){
    *ppPage = 0;
    return rc;
  }
  pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);
  if( pPage->isInit==0 ){
    btreePageFromDbPage(pDbPage, pgno, pBt);
    rc = btreeInitPage(pPage);
    if( rc!=0 ){
      releasePage(pPage);
      *ppPage = 0;
      return rc;
    }
  }
  ((void) (0));
  ((void) (0));
  *ppPage = pPage;
  return 0;
}







static void releasePageNotNull(MemPage *pPage){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  sqlite3PagerUnrefNotNull(pPage->pDbPage);
}
static void releasePage(MemPage *pPage){
  if( pPage ) releasePageNotNull(pPage);
}
static void releasePageOne(MemPage *pPage){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  sqlite3PagerUnrefPageOne(pPage->pDbPage);
}
# 74885 "c_tests/sqlite3.c"
static int btreeGetUnusedPage(
  BtShared *pBt,
  Pgno pgno,
  MemPage **ppPage,
  int flags
){
  int rc = btreeGetPage(pBt, pgno, ppPage, flags);
  if( rc==0 ){
    if( sqlite3PagerPageRefcount((*ppPage)->pDbPage)>1 ){
      releasePage(*ppPage);
      *ppPage = 0;
      return sqlite3CorruptError(74896);
    }
    (*ppPage)->isInit = 0;
  }else{
    *ppPage = 0;
  }
  return rc;
}
# 74914 "c_tests/sqlite3.c"
static void pageReinit(DbPage *pData){
  MemPage *pPage;
  pPage = (MemPage *)sqlite3PagerGetExtra(pData);
  ((void) (0));
  if( pPage->isInit ){
    ((void) (0));
    pPage->isInit = 0;
    if( sqlite3PagerPageRefcount(pData)>1 ){






      btreeInitPage(pPage);
    }
  }
}




static int btreeInvokeBusyHandler(void *pArg){
  BtShared *pBt = (BtShared*)pArg;
  ((void) (0));
  ((void) (0));
  return sqlite3InvokeBusyHandler(&pBt->db->busyHandler);
}
# 74964 "c_tests/sqlite3.c"
static int sqlite3BtreeOpen(
  sqlite3_vfs *pVfs,
  const char *zFilename,
  sqlite3 *db,
  Btree **ppBtree,
  int flags,
  int vfsFlags
){
  BtShared *pBt = 0;
  Btree *p;
  sqlite3_mutex *mutexOpen = 0;
  int rc = 0;
  u8 nReserve;
  unsigned char zDbHeader[100];


  const int isTempDb = zFilename==0 || zFilename[0]==0;







  const int isMemdb = (zFilename && strcmp(zFilename, ":memory:")==0)
                       || (isTempDb && sqlite3TempInMemory(db))
                       || (vfsFlags & 0x00000080)!=0;


  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  ((void) (0));


  ((void) (0));

  if( isMemdb ){
    flags |= 2;
  }
  if( (vfsFlags & 0x00000100)!=0 && (isMemdb || isTempDb) ){
    vfsFlags = (vfsFlags & ~0x00000100) | 0x00000200;
  }
  p = sqlite3MallocZero(sizeof(Btree));
  if( !p ){
    return 7;
  }
  p->inTrans = 0;
  p->db = db;

  p->lock.pBtree = p;
  p->lock.iTable = 1;







  if( isTempDb==0 && (isMemdb==0 || (vfsFlags&0x00000040)!=0) ){
    if( vfsFlags & 0x00020000 ){
      int nFilename = sqlite3Strlen30(zFilename)+1;
      int nFullPathname = pVfs->mxPathname+1;
      char *zFullPathname = sqlite3Malloc(((nFullPathname)>(nFilename)?(nFullPathname):(nFilename)));
      sqlite3_mutex *mutexShared;

      p->sharable = 1;
      if( !zFullPathname ){
        sqlite3_free(p);
        return 7;
      }
      if( isMemdb ){
        memcpy(zFullPathname, zFilename, nFilename);
      }else{
        rc = sqlite3OsFullPathname(pVfs, zFilename,
                                   nFullPathname, zFullPathname);
        if( rc ){
          if( rc==(0 | (2<<8)) ){
            rc = 0;
          }else{
            sqlite3_free(zFullPathname);
            sqlite3_free(p);
            return rc;
          }
        }
      }

      mutexOpen = sqlite3MutexAlloc(4);
      sqlite3_mutex_enter(mutexOpen);
      mutexShared = sqlite3MutexAlloc(2);
      sqlite3_mutex_enter(mutexShared);

      for(pBt=sqlite3SharedCacheList; pBt; pBt=pBt->pNext){
        ((void) (0));
        if( 0==strcmp(zFullPathname, sqlite3PagerFilename(pBt->pPager, 0))
                 && sqlite3PagerVfs(pBt->pPager)==pVfs ){
          int iDb;
          for(iDb=db->nDb-1; iDb>=0; iDb--){
            Btree *pExisting = db->aDb[iDb].pBt;
            if( pExisting && pExisting->pBt==pBt ){
              sqlite3_mutex_leave(mutexShared);
              sqlite3_mutex_leave(mutexOpen);
              sqlite3_free(zFullPathname);
              sqlite3_free(p);
              return 19;
            }
          }
          p->pBt = pBt;
          pBt->nRef++;
          break;
        }
      }
      sqlite3_mutex_leave(mutexShared);
      sqlite3_free(zFullPathname);
    }
# 75092 "c_tests/sqlite3.c"
  }

  if( pBt==0 ){





    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));


    memset(&zDbHeader[16], 0, 8);

    pBt = sqlite3MallocZero( sizeof(*pBt) );
    if( pBt==0 ){
      rc = 7;
      goto btree_open_out;
    }
    rc = sqlite3PagerOpen(pVfs, &pBt->pPager, zFilename,
                          sizeof(MemPage), flags, vfsFlags, pageReinit);
    if( rc==0 ){
      sqlite3PagerSetMmapLimit(pBt->pPager, db->szMmap);
      rc = sqlite3PagerReadFileheader(pBt->pPager,sizeof(zDbHeader),zDbHeader);
    }
    if( rc!=0 ){
      goto btree_open_out;
    }
    pBt->openFlags = (u8)flags;
    pBt->db = db;
    sqlite3PagerSetBusyHandler(pBt->pPager, btreeInvokeBusyHandler, pBt);
    p->pBt = pBt;

    pBt->pCursor = 0;
    pBt->pPage1 = 0;
    if( sqlite3PagerIsreadonly(pBt->pPager) ) pBt->btsFlags |= 0x0001;
# 75139 "c_tests/sqlite3.c"
    pBt->pageSize = (zDbHeader[16]<<8) | (zDbHeader[17]<<16);
    if( pBt->pageSize<512 || pBt->pageSize>65536
         || ((pBt->pageSize-1)&pBt->pageSize)!=0 ){
      pBt->pageSize = 0;







      if( zFilename && !isMemdb ){
        pBt->autoVacuum = (0 ? 1 : 0);
        pBt->incrVacuum = (0==2 ? 1 : 0);
      }

      nReserve = 0;
    }else{



      nReserve = zDbHeader[20];
      pBt->btsFlags |= 0x0002;

      pBt->autoVacuum = (sqlite3Get4byte(&zDbHeader[36 + 4*4])?1:0);
      pBt->incrVacuum = (sqlite3Get4byte(&zDbHeader[36 + 7*4])?1:0);

    }
    rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);
    if( rc ) goto btree_open_out;
    pBt->usableSize = pBt->pageSize - nReserve;
    ((void) (0));




    pBt->nRef = 1;
    if( p->sharable ){
      sqlite3_mutex *mutexShared;
      mutexShared = sqlite3MutexAlloc(2);
      if( 1 && sqlite3Config.bCoreMutex ){
        pBt->mutex = sqlite3MutexAlloc(0);
        if( pBt->mutex==0 ){
          rc = 7;
          goto btree_open_out;
        }
      }
      sqlite3_mutex_enter(mutexShared);
      pBt->pNext = sqlite3SharedCacheList;
      sqlite3SharedCacheList = pBt;
      sqlite3_mutex_leave(mutexShared);
    }

  }






  if( p->sharable ){
    int i;
    Btree *pSib;
    for(i=0; i<db->nDb; i++){
      if( (pSib = db->aDb[i].pBt)!=0 && pSib->sharable ){
        while( pSib->pPrev ){ pSib = pSib->pPrev; }
        if( (uptr)p->pBt<(uptr)pSib->pBt ){
          p->pNext = pSib;
          p->pPrev = 0;
          pSib->pPrev = p;
        }else{
          while( pSib->pNext && (uptr)pSib->pNext->pBt<(uptr)p->pBt ){
            pSib = pSib->pNext;
          }
          p->pNext = pSib->pNext;
          p->pPrev = pSib;
          if( p->pNext ){
            p->pNext->pPrev = p;
          }
          pSib->pNext = p;
        }
        break;
      }
    }
  }

  *ppBtree = p;

btree_open_out:
  if( rc!=0 ){
    if( pBt && pBt->pPager ){
      sqlite3PagerClose(pBt->pPager, 0);
    }
    sqlite3_free(pBt);
    sqlite3_free(p);
    *ppBtree = 0;
  }else{
    sqlite3_file *pFile;





    if( sqlite3BtreeSchema(p, 0, 0)==0 ){
      sqlite3BtreeSetCacheSize(p, -2000);
    }

    pFile = sqlite3PagerFile(pBt->pPager);
    if( pFile->pMethods ){
      sqlite3OsFileControlHint(pFile, 30, (void*)&pBt->db);
    }
  }
  if( mutexOpen ){
    ((void) (0));
    sqlite3_mutex_leave(mutexOpen);
  }
  ((void) (0));
  return rc;
}







static int removeFromSharingList(BtShared *pBt){

  sqlite3_mutex *pMainMtx;
  BtShared *pList;
  int removed = 0;

  ((void) (0));
  pMainMtx = sqlite3MutexAlloc(2);
  sqlite3_mutex_enter(pMainMtx);
  pBt->nRef--;
  if( pBt->nRef<=0 ){
    if( sqlite3SharedCacheList==pBt ){
      sqlite3SharedCacheList = pBt->pNext;
    }else{
      pList = sqlite3SharedCacheList;
      while( (pList) && pList->pNext!=pBt ){
        pList=pList->pNext;
      }
      if( (pList) ){
        pList->pNext = pBt->pNext;
      }
    }
    if( 1 ){
      sqlite3_mutex_free(pBt->mutex);
    }
    removed = 1;
  }
  sqlite3_mutex_leave(pMainMtx);
  return removed;




}






static __attribute__((noinline)) int allocateTempSpace(BtShared *pBt){
  ((void) (0));
  ((void) (0));


  ((void) (0));
  pBt->pTmpSpace = sqlite3PageMalloc( pBt->pageSize );
  if( pBt->pTmpSpace==0 ){
    BtCursor *pCur = pBt->pCursor;
    pBt->pCursor = pCur->pNext;
    memset(pCur, 0, sizeof(*pCur));
    return 7;
  }
# 75334 "c_tests/sqlite3.c"
  memset(pBt->pTmpSpace, 0, 8);
  pBt->pTmpSpace += 4;
  return 0;
}




static void freeTempSpace(BtShared *pBt){
  if( pBt->pTmpSpace ){
    pBt->pTmpSpace -= 4;
    sqlite3PageFree(pBt->pTmpSpace);
    pBt->pTmpSpace = 0;
  }
}




static int sqlite3BtreeClose(Btree *p){
  BtShared *pBt = p->pBt;


  ((void) (0));
  sqlite3BtreeEnter(p);
# 75377 "c_tests/sqlite3.c"
  sqlite3BtreeRollback(p, 0, 0);
  sqlite3BtreeLeave(p);





  ((void) (0));
  if( !p->sharable || removeFromSharingList(pBt) ){





    ((void) (0));
    sqlite3PagerClose(pBt->pPager, p->db);
    if( pBt->xFreeSchema && pBt->pSchema ){
      pBt->xFreeSchema(pBt->pSchema);
    }
    sqlite3DbFree(0, pBt->pSchema);
    freeTempSpace(pBt);
    sqlite3_free(pBt);
  }


  ((void) (0));
  ((void) (0));
  if( p->pPrev ) p->pPrev->pNext = p->pNext;
  if( p->pNext ) p->pNext->pPrev = p->pPrev;


  sqlite3_free(p);
  return 0;
}
# 75419 "c_tests/sqlite3.c"
static int sqlite3BtreeSetCacheSize(Btree *p, int mxPage){
  BtShared *pBt = p->pBt;
  ((void) (0));
  sqlite3BtreeEnter(p);
  sqlite3PagerSetCachesize(pBt->pPager, mxPage);
  sqlite3BtreeLeave(p);
  return 0;
}
# 75438 "c_tests/sqlite3.c"
static int sqlite3BtreeSetSpillSize(Btree *p, int mxPage){
  BtShared *pBt = p->pBt;
  int res;
  ((void) (0));
  sqlite3BtreeEnter(p);
  res = sqlite3PagerSetSpillsize(pBt->pPager, mxPage);
  sqlite3BtreeLeave(p);
  return res;
}






static int sqlite3BtreeSetMmapLimit(Btree *p, sqlite3_int64 szMmap){
  BtShared *pBt = p->pBt;
  ((void) (0));
  sqlite3BtreeEnter(p);
  sqlite3PagerSetMmapLimit(pBt->pPager, szMmap);
  sqlite3BtreeLeave(p);
  return 0;
}
# 75472 "c_tests/sqlite3.c"
static int sqlite3BtreeSetPagerFlags(
  Btree *p,
  unsigned pgFlags
){
  BtShared *pBt = p->pBt;
  ((void) (0));
  sqlite3BtreeEnter(p);
  sqlite3PagerSetFlags(pBt->pPager, pgFlags);
  sqlite3BtreeLeave(p);
  return 0;
}
# 75505 "c_tests/sqlite3.c"
static int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve, int iFix){
  int rc = 0;
  int x;
  BtShared *pBt = p->pBt;
  ((void) (0));
  sqlite3BtreeEnter(p);
  pBt->nReserveWanted = (u8)nReserve;
  x = pBt->pageSize - pBt->usableSize;
  if( x==nReserve && (pageSize==0 || (u32)pageSize==pBt->pageSize) ){
    sqlite3BtreeLeave(p);
    return 0;
  }
  if( nReserve<x ) nReserve = x;
  if( pBt->btsFlags & 0x0002 ){
    sqlite3BtreeLeave(p);
    return 8;
  }
  ((void) (0));
  if( pageSize>=512 && pageSize<=65536 &&
        ((pageSize-1)&pageSize)==0 ){
    ((void) (0));
    ((void) (0));
    if( nReserve>32 && pageSize==512 ) pageSize = 1024;
    pBt->pageSize = (u32)pageSize;
    freeTempSpace(pBt);
  }
  rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);
  pBt->usableSize = pBt->pageSize - (u16)nReserve;
  if( iFix ) pBt->btsFlags |= 0x0002;
  sqlite3BtreeLeave(p);
  return rc;
}




static int sqlite3BtreeGetPageSize(Btree *p){
  return p->pBt->pageSize;
}
# 75556 "c_tests/sqlite3.c"
static int sqlite3BtreeGetReserveNoMutex(Btree *p){
  int n;
  ((void) (0));
  n = p->pBt->pageSize - p->pBt->usableSize;
  return n;
}
# 75572 "c_tests/sqlite3.c"
static int sqlite3BtreeGetRequestedReserve(Btree *p){
  int n1, n2;
  sqlite3BtreeEnter(p);
  n1 = (int)p->pBt->nReserveWanted;
  n2 = sqlite3BtreeGetReserveNoMutex(p);
  sqlite3BtreeLeave(p);
  return n1>n2 ? n1 : n2;
}







static Pgno sqlite3BtreeMaxPageCount(Btree *p, Pgno mxPage){
  Pgno n;
  sqlite3BtreeEnter(p);
  n = sqlite3PagerMaxPageCount(p->pBt->pPager, mxPage);
  sqlite3BtreeLeave(p);
  return n;
}
# 75613 "c_tests/sqlite3.c"
static int sqlite3BtreeSecureDelete(Btree *p, int newFlag){
  int b;
  if( p==0 ) return 0;
  sqlite3BtreeEnter(p);
  ((void) (0));
  ((void) (0));
  if( newFlag>=0 ){
    p->pBt->btsFlags &= ~0x000c;
    p->pBt->btsFlags |= (u16)(0x0004*newFlag);
  }
  b = (p->pBt->btsFlags & 0x000c)/0x0004;
  sqlite3BtreeLeave(p);
  return b;
}







static int sqlite3BtreeSetAutoVacuum(Btree *p, int autoVacuum){



  BtShared *pBt = p->pBt;
  int rc = 0;
  u8 av = (u8)autoVacuum;

  sqlite3BtreeEnter(p);
  if( (pBt->btsFlags & 0x0002)!=0 && (av ?1:0)!=pBt->autoVacuum ){
    rc = 8;
  }else{
    pBt->autoVacuum = av ?1:0;
    pBt->incrVacuum = av==2 ?1:0;
  }
  sqlite3BtreeLeave(p);
  return rc;

}





static int sqlite3BtreeGetAutoVacuum(Btree *p){



  int rc;
  sqlite3BtreeEnter(p);
  rc = (
    (!p->pBt->autoVacuum)?0:
    (!p->pBt->incrVacuum)?1:
    2
  );
  sqlite3BtreeLeave(p);
  return rc;

}
# 75702 "c_tests/sqlite3.c"
static int newDatabase(BtShared*);
# 75714 "c_tests/sqlite3.c"
static int lockBtree(BtShared *pBt){
  int rc;
  MemPage *pPage1;
  u32 nPage;
  u32 nPageFile = 0;

  ((void) (0));
  ((void) (0));
  rc = sqlite3PagerSharedLock(pBt->pPager);
  if( rc!=0 ) return rc;
  rc = btreeGetPage(pBt, 1, &pPage1, 0);
  if( rc!=0 ) return rc;




  nPage = sqlite3Get4byte(28+(u8*)pPage1->aData);
  sqlite3PagerPagecount(pBt->pPager, (int*)&nPageFile);
  if( nPage==0 || memcmp(24+(u8*)pPage1->aData, 92+(u8*)pPage1->aData,4)!=0 ){
    nPage = nPageFile;
  }
  if( (pBt->db->flags & 0x02000000)!=0 ){
    nPage = 0;
  }
  if( nPage>0 ){
    u32 pageSize;
    u32 usableSize;
    u8 *page1 = pPage1->aData;
    rc = 26;



    if( memcmp(page1, zMagicHeader, 16)!=0 ){
      goto page1_init_failed;
    }
# 75758 "c_tests/sqlite3.c"
    if( page1[18]>2 ){
      pBt->btsFlags |= 0x0001;
    }
    if( page1[19]>2 ){
      goto page1_init_failed;
    }
# 75773 "c_tests/sqlite3.c"
    if( page1[19]==2 && (pBt->btsFlags & 0x0020)==0 ){
      int isOpen = 0;
      rc = sqlite3PagerOpenWal(pBt->pPager, &isOpen);
      if( rc!=0 ){
        goto page1_init_failed;
      }else{
                                                                 ;
        if( isOpen==0 ){
          releasePageOne(pPage1);
          return 0;
        }
      }
      rc = 26;
    }else{
                                                           ;
    }
# 75797 "c_tests/sqlite3.c"
    if( memcmp(&page1[21], "\100\040\040",3)!=0 ){
      goto page1_init_failed;
    }



    pageSize = (page1[16]<<8) | (page1[17]<<16);


    if( ((pageSize-1)&pageSize)!=0
     || pageSize>65536
     || pageSize<=256
    ){
      goto page1_init_failed;
    }
    ((void) (0));







    usableSize = pageSize - page1[20];
    if( (u32)pageSize!=pBt->pageSize ){






      releasePageOne(pPage1);
      pBt->usableSize = usableSize;
      pBt->pageSize = pageSize;
      pBt->btsFlags |= 0x0002;
      freeTempSpace(pBt);
      rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize,
                                   pageSize-usableSize);
      return rc;
    }
    if( nPage>nPageFile ){
      if( sqlite3WritableSchema(pBt->db)==0 ){
        rc = sqlite3CorruptError(75839);
        goto page1_init_failed;
      }else{
        nPage = nPageFile;
      }
    }



    if( usableSize<480 ){
      goto page1_init_failed;
    }
    pBt->btsFlags |= 0x0002;
    pBt->pageSize = pageSize;
    pBt->usableSize = usableSize;

    pBt->autoVacuum = (sqlite3Get4byte(&page1[36 + 4*4])?1:0);
    pBt->incrVacuum = (sqlite3Get4byte(&page1[36 + 7*4])?1:0);

  }
# 75873 "c_tests/sqlite3.c"
  pBt->maxLocal = (u16)((pBt->usableSize-12)*64/255 - 23);
  pBt->minLocal = (u16)((pBt->usableSize-12)*32/255 - 23);
  pBt->maxLeaf = (u16)(pBt->usableSize - 35);
  pBt->minLeaf = (u16)((pBt->usableSize-12)*32/255 - 23);
  if( pBt->maxLocal>127 ){
    pBt->max1bytePayload = 127;
  }else{
    pBt->max1bytePayload = (u8)pBt->maxLocal;
  }
  ((void) (0));
  pBt->pPage1 = pPage1;
  pBt->nPage = nPage;
  return 0;

page1_init_failed:
  releasePageOne(pPage1);
  pBt->pPage1 = 0;
  return rc;
}
# 75925 "c_tests/sqlite3.c"
static void unlockBtreeIfUnused(BtShared *pBt){
  ((void) (0));
  ((void) (0));
  if( pBt->inTransaction==0 && pBt->pPage1!=0 ){
    MemPage *pPage1 = pBt->pPage1;
    ((void) (0));
    ((void) (0));
    pBt->pPage1 = 0;
    releasePageOne(pPage1);
  }
}






static int newDatabase(BtShared *pBt){
  MemPage *pP1;
  unsigned char *data;
  int rc;

  ((void) (0));
  if( pBt->nPage>0 ){
    return 0;
  }
  pP1 = pBt->pPage1;
  ((void) (0));
  data = pP1->aData;
  rc = sqlite3PagerWrite(pP1->pDbPage);
  if( rc ) return rc;
  memcpy(data, zMagicHeader, sizeof(zMagicHeader));
  ((void) (0));
  data[16] = (u8)((pBt->pageSize>>8)&0xff);
  data[17] = (u8)((pBt->pageSize>>16)&0xff);
  data[18] = 1;
  data[19] = 1;
  ((void) (0));
  data[20] = (u8)(pBt->pageSize - pBt->usableSize);
  data[21] = 64;
  data[22] = 32;
  data[23] = 32;
  memset(&data[24], 0, 100-24);
  zeroPage(pP1, 0x01|0x08|0x04 );
  pBt->btsFlags |= 0x0002;

  ((void) (0));
  ((void) (0));
  sqlite3Put4byte(&data[36 + 4*4], pBt->autoVacuum);
  sqlite3Put4byte(&data[36 + 7*4], pBt->incrVacuum);

  pBt->nPage = 1;
  data[31] = 1;
  return 0;
}






static int sqlite3BtreeNewDb(Btree *p){
  int rc;
  sqlite3BtreeEnter(p);
  p->pBt->nPage = 0;
  rc = newDatabase(p->pBt);
  sqlite3BtreeLeave(p);
  return rc;
}
# 76030 "c_tests/sqlite3.c"
static __attribute__((noinline)) int btreeBeginTrans(
  Btree *p,
  int wrflag,
  int *pSchemaVersion
){
  BtShared *pBt = p->pBt;
  Pager *pPager = pBt->pPager;
  int rc = 0;

  sqlite3BtreeEnter(p);
  ((void) (0)); ((void) (0));;





  if( p->inTrans==2 || (p->inTrans==1 && !wrflag) ){
    goto trans_begun;
  }
  ((void) (0));

  if( (p->db->flags & 0x02000000)
   && sqlite3PagerIsreadonly(pPager)==0
  ){
    pBt->btsFlags &= ~0x0001;
  }


  if( (pBt->btsFlags & 0x0001)!=0 && wrflag ){
    rc = 8;
    goto trans_begun;
  }


  {
    sqlite3 *pBlock = 0;




    if( (wrflag && pBt->inTransaction==2)
     || (pBt->btsFlags & 0x0080)!=0
    ){
      pBlock = pBt->pWriter->db;
    }else if( wrflag>1 ){
      BtLock *pIter;
      for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
        if( pIter->pBtree!=p ){
          pBlock = pIter->pBtree->db;
          break;
        }
      }
    }
    if( pBlock ){
                                             ;
      rc = (6 | (1<<8));
      goto trans_begun;
    }
  }





  rc = querySharedCacheTableLock(p, 1, 1);
  if( 0!=rc ) goto trans_begun;

  pBt->btsFlags &= ~0x0010;
  if( pBt->nPage==0 ) pBt->btsFlags |= 0x0010;
  do {
                                    ;
# 76119 "c_tests/sqlite3.c"
    while( pBt->pPage1==0 && 0==(rc = lockBtree(pBt)) );

    if( rc==0 && wrflag ){
      if( (pBt->btsFlags & 0x0001)!=0 ){
        rc = 8;
      }else{
        rc = sqlite3PagerBegin(pPager, wrflag>1, sqlite3TempInMemory(p->db));
        if( rc==0 ){
          rc = newDatabase(pBt);
        }else if( rc==(5 | (2<<8)) && pBt->inTransaction==0 ){



          rc = 5;
        }
      }
    }

    if( rc!=0 ){
      (void)0;
      unlockBtreeIfUnused(pBt);
    }







  }while( (rc&0xFF)==5 && pBt->inTransaction==0 &&
          btreeInvokeBusyHandler(pBt) );
                              ;




  if( rc==0 ){
    if( p->inTrans==0 ){
      pBt->nTransaction++;

      if( p->sharable ){
        ((void) (0));
        p->lock.eLock = 1;
        p->lock.pNext = pBt->pLock;
        pBt->pLock = &p->lock;
      }

    }
    p->inTrans = (wrflag?2:1);
    if( p->inTrans>pBt->inTransaction ){
      pBt->inTransaction = p->inTrans;
    }
    if( wrflag ){
      MemPage *pPage1 = pBt->pPage1;

      ((void) (0));
      pBt->pWriter = p;
      pBt->btsFlags &= ~0x0040;
      if( wrflag>1 ) pBt->btsFlags |= 0x0040;
# 76186 "c_tests/sqlite3.c"
      if( pBt->nPage!=sqlite3Get4byte(&pPage1->aData[28]) ){
        rc = sqlite3PagerWrite(pPage1->pDbPage);
        if( rc==0 ){
          sqlite3Put4byte(&pPage1->aData[28], pBt->nPage);
        }
      }
    }
  }

trans_begun:
  if( rc==0 ){
    if( pSchemaVersion ){
      *pSchemaVersion = sqlite3Get4byte(&pBt->pPage1->aData[40]);
    }
    if( wrflag ){




      rc = sqlite3PagerOpenSavepoint(pPager, p->db->nSavepoint);
    }
  }

  ((void) (0)); ((void) (0));;
  sqlite3BtreeLeave(p);
  return rc;
}
static int sqlite3BtreeBeginTrans(Btree *p, int wrflag, int *pSchemaVersion){
  BtShared *pBt;
  if( p->sharable
   || p->inTrans==0
   || (p->inTrans==1 && wrflag!=0)
  ){
    return btreeBeginTrans(p,wrflag,pSchemaVersion);
  }
  pBt = p->pBt;
  if( pSchemaVersion ){
    *pSchemaVersion = sqlite3Get4byte(&pBt->pPage1->aData[40]);
  }
  if( wrflag ){




    return sqlite3PagerOpenSavepoint(pBt->pPager, p->db->nSavepoint);
  }else{
    return 0;
  }
}
# 76243 "c_tests/sqlite3.c"
static int setChildPtrmaps(MemPage *pPage){
  int i;
  int nCell;
  int rc;
  BtShared *pBt = pPage->pBt;
  Pgno pgno = pPage->pgno;

  ((void) (0));
  rc = pPage->isInit ? 0 : btreeInitPage(pPage);
  if( rc!=0 ) return rc;
  nCell = pPage->nCell;

  for(i=0; i<nCell; i++){
    u8 *pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(i)])[0]<<8 | (&(pPage)->aCellIdx[2*(i)])[1])));

    ptrmapPutOvflPtr(pPage, pPage, pCell, &rc);

    if( !pPage->leaf ){
      Pgno childPgno = sqlite3Get4byte(pCell);
      ptrmapPut(pBt, childPgno, 5, pgno, &rc);
    }
  }

  if( !pPage->leaf ){
    Pgno childPgno = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]);
    ptrmapPut(pBt, childPgno, 5, pgno, &rc);
  }

  return rc;
}
# 76288 "c_tests/sqlite3.c"
static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){
  ((void) (0));
  ((void) (0));
  if( eType==4 ){

    if( sqlite3Get4byte(pPage->aData)!=iFrom ){
      return sqlite3CorruptError(76294);
    }
    sqlite3Put4byte(pPage->aData, iTo);
  }else{
    int i;
    int nCell;
    int rc;

    rc = pPage->isInit ? 0 : btreeInitPage(pPage);
    if( rc ) return rc;
    nCell = pPage->nCell;

    for(i=0; i<nCell; i++){
      u8 *pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(i)])[0]<<8 | (&(pPage)->aCellIdx[2*(i)])[1])));
      if( eType==3 ){
        CellInfo info;
        pPage->xParseCell(pPage, pCell, &info);
        if( info.nLocal<info.nPayload ){
          if( pCell+info.nSize > pPage->aData+pPage->pBt->usableSize ){
            return sqlite3CorruptError(76313);
          }
          if( iFrom==sqlite3Get4byte(pCell+info.nSize-4) ){
            sqlite3Put4byte(pCell+info.nSize-4, iTo);
            break;
          }
        }
      }else{
        if( pCell+4 > pPage->aData+pPage->pBt->usableSize ){
          return sqlite3CorruptError(76322);
        }
        if( sqlite3Get4byte(pCell)==iFrom ){
          sqlite3Put4byte(pCell, iTo);
          break;
        }
      }
    }

    if( i==nCell ){
      if( eType!=5 ||
          sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8])!=iFrom ){
        return sqlite3CorruptError(76334);
      }
      sqlite3Put4byte(&pPage->aData[pPage->hdrOffset+8], iTo);
    }
  }
  return 0;
}
# 76352 "c_tests/sqlite3.c"
static int relocatePage(
  BtShared *pBt,
  MemPage *pDbPage,
  u8 eType,
  Pgno iPtrPage,
  Pgno iFreePage,
  int isCommit
){
  MemPage *pPtrPage;
  Pgno iDbPage = pDbPage->pgno;
  Pager *pPager = pBt->pPager;
  int rc;

  ((void) (0));

  ((void) (0));
  ((void) (0));
  if( iDbPage<3 ) return sqlite3CorruptError(76369);



                                           ;
  rc = sqlite3PagerMovepage(pPager, pDbPage->pDbPage, iFreePage, isCommit);
  if( rc!=0 ){
    return rc;
  }
  pDbPage->pgno = iFreePage;
# 76388 "c_tests/sqlite3.c"
  if( eType==5 || eType==1 ){
    rc = setChildPtrmaps(pDbPage);
    if( rc!=0 ){
      return rc;
    }
  }else{
    Pgno nextOvfl = sqlite3Get4byte(pDbPage->aData);
    if( nextOvfl!=0 ){
      ptrmapPut(pBt, nextOvfl, 4, iFreePage, &rc);
      if( rc!=0 ){
        return rc;
      }
    }
  }





  if( eType!=1 ){
    rc = btreeGetPage(pBt, iPtrPage, &pPtrPage, 0);
    if( rc!=0 ){
      return rc;
    }
    rc = sqlite3PagerWrite(pPtrPage->pDbPage);
    if( rc!=0 ){
      releasePage(pPtrPage);
      return rc;
    }
    rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType);
    releasePage(pPtrPage);
    if( rc==0 ){
      ptrmapPut(pBt, iFreePage, eType, iPtrPage, &rc);
    }
  }
  return rc;
}


static int allocateBtreePage(BtShared *, MemPage **, Pgno *, Pgno, u8);
# 76446 "c_tests/sqlite3.c"
static int incrVacuumStep(BtShared *pBt, Pgno nFin, Pgno iLastPg, int bCommit){
  Pgno nFreeList;
  int rc;

  ((void) (0));
  ((void) (0));

  if( !(ptrmapPageno((pBt), (iLastPg))==(iLastPg)) && iLastPg!=((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
    u8 eType;
    Pgno iPtrPage;

    nFreeList = sqlite3Get4byte(&pBt->pPage1->aData[36]);
    if( nFreeList==0 ){
      return 101;
    }

    rc = ptrmapGet(pBt, iLastPg, &eType, &iPtrPage);
    if( rc!=0 ){
      return rc;
    }
    if( eType==1 ){
      return sqlite3CorruptError(76467);
    }

    if( eType==2 ){
      if( bCommit==0 ){





        Pgno iFreePg;
        MemPage *pFreePg;
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, 1);
        if( rc!=0 ){
          return rc;
        }
        ((void) (0));
        releasePage(pFreePg);
      }
    } else {
      Pgno iFreePg;
      MemPage *pLastPg;
      u8 eMode = 0;
      Pgno iNear = 0;

      rc = btreeGetPage(pBt, iLastPg, &pLastPg, 0);
      if( rc!=0 ){
        return rc;
      }
# 76504 "c_tests/sqlite3.c"
      if( bCommit==0 ){
        eMode = 2;
        iNear = nFin;
      }
      do {
        MemPage *pFreePg;
        Pgno dbSize = btreePagecount(pBt);
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iNear, eMode);
        if( rc!=0 ){
          releasePage(pLastPg);
          return rc;
        }
        releasePage(pFreePg);
        if( iFreePg>dbSize ){
          releasePage(pLastPg);
          return sqlite3CorruptError(76519);
        }
      }while( bCommit && iFreePg>nFin );
      ((void) (0));

      rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, bCommit);
      releasePage(pLastPg);
      if( rc!=0 ){
        return rc;
      }
    }
  }

  if( bCommit==0 ){
    do {
      iLastPg--;
    }while( iLastPg==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) || (ptrmapPageno((pBt), (iLastPg))==(iLastPg)) );
    pBt->bDoTruncate = 1;
    pBt->nPage = iLastPg;
  }
  return 0;
}






static Pgno finalDbSize(BtShared *pBt, Pgno nOrig, Pgno nFree){
  int nEntry;
  Pgno nPtrmap;
  Pgno nFin;

  nEntry = pBt->usableSize/5;
  nPtrmap = (nFree-nOrig+ptrmapPageno(pBt, nOrig)+nEntry)/nEntry;
  nFin = nOrig - nFree - nPtrmap;
  if( nOrig>((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) && nFin<((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
    nFin--;
  }
  while( (ptrmapPageno((pBt), (nFin))==(nFin)) || nFin==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
    nFin--;
  }

  return nFin;
}
# 76573 "c_tests/sqlite3.c"
static int sqlite3BtreeIncrVacuum(Btree *p){
  int rc;
  BtShared *pBt = p->pBt;

  sqlite3BtreeEnter(p);
  ((void) (0));
  if( !pBt->autoVacuum ){
    rc = 101;
  }else{
    Pgno nOrig = btreePagecount(pBt);
    Pgno nFree = sqlite3Get4byte(&pBt->pPage1->aData[36]);
    Pgno nFin = finalDbSize(pBt, nOrig, nFree);

    if( nOrig<nFin || nFree>=nOrig ){
      rc = sqlite3CorruptError(76587);
    }else if( nFree>0 ){
      rc = saveAllCursors(pBt, 0, 0);
      if( rc==0 ){
        invalidateAllOverflowCache(pBt);
        rc = incrVacuumStep(pBt, nFin, nOrig, 0);
      }
      if( rc==0 ){
        rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
        sqlite3Put4byte(&pBt->pPage1->aData[28], pBt->nPage);
      }
    }else{
      rc = 101;
    }
  }
  sqlite3BtreeLeave(p);
  return rc;
}





static int autoVacuumCommit(Btree *p){
  int rc = 0;
  Pager *pPager;
  BtShared *pBt;
  sqlite3 *db;
                      ;

  ((void) (0));
  pBt = p->pBt;
  pPager = pBt->pPager;


  ((void) (0));
  invalidateAllOverflowCache(pBt);
  ((void) (0));
  if( !pBt->incrVacuum ){
    Pgno nFin;
    Pgno nFree;
    Pgno nVac;
    Pgno iFree;
    Pgno nOrig;

    nOrig = btreePagecount(pBt);
    if( (ptrmapPageno((pBt), (nOrig))==(nOrig)) || nOrig==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){




      return sqlite3CorruptError(76638);
    }

    nFree = sqlite3Get4byte(&pBt->pPage1->aData[36]);
    db = p->db;
    if( db->xAutovacPages ){
      int iDb;
      for(iDb=0; (iDb<db->nDb); iDb++){
        if( db->aDb[iDb].pBt==p ) break;
      }
      nVac = db->xAutovacPages(
        db->pAutovacPagesArg,
        db->aDb[iDb].zDbSName,
        nOrig,
        nFree,
        pBt->pageSize
      );
      if( nVac>nFree ){
        nVac = nFree;
      }
      if( nVac==0 ){
        return 0;
      }
    }else{
      nVac = nFree;
    }
    nFin = finalDbSize(pBt, nOrig, nVac);
    if( nFin>nOrig ) return sqlite3CorruptError(76665);
    if( nFin<nOrig ){
      rc = saveAllCursors(pBt, 0, 0);
    }
    for(iFree=nOrig; iFree>nFin && rc==0; iFree--){
      rc = incrVacuumStep(pBt, nFin, iFree, nVac==nFree);
    }
    if( (rc==101 || rc==0) && nFree>0 ){
      rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
      if( nVac==nFree ){
        sqlite3Put4byte(&pBt->pPage1->aData[32], 0);
        sqlite3Put4byte(&pBt->pPage1->aData[36], 0);
      }
      sqlite3Put4byte(&pBt->pPage1->aData[28], nFin);
      pBt->bDoTruncate = 1;
      pBt->nPage = nFin;
    }
    if( rc!=0 ){
      sqlite3PagerRollback(pPager);
    }
  }

  ((void) (0));
  return rc;
}
# 76721 "c_tests/sqlite3.c"
static int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zSuperJrnl){
  int rc = 0;
  if( p->inTrans==2 ){
    BtShared *pBt = p->pBt;
    sqlite3BtreeEnter(p);

    if( pBt->autoVacuum ){
      rc = autoVacuumCommit(p);
      if( rc!=0 ){
        sqlite3BtreeLeave(p);
        return rc;
      }
    }
    if( pBt->bDoTruncate ){
      sqlite3PagerTruncateImage(pBt->pPager, pBt->nPage);
    }

    rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zSuperJrnl, 0);
    sqlite3BtreeLeave(p);
  }
  return rc;
}





static void btreeEndTransaction(Btree *p){
  BtShared *pBt = p->pBt;
  sqlite3 *db = p->db;
  ((void) (0));


  pBt->bDoTruncate = 0;

  if( p->inTrans>0 && db->nVdbeRead>1 ){



    downgradeAllSharedCacheTableLocks(p);
    p->inTrans = 1;
  }else{




    if( p->inTrans!=0 ){
      clearAllSharedCacheTableLocks(p);
      pBt->nTransaction--;
      if( 0==pBt->nTransaction ){
        pBt->inTransaction = 0;
      }
    }



    p->inTrans = 0;
    unlockBtreeIfUnused(pBt);
  }

  ((void) (0)); ((void) (0));;
}
# 76810 "c_tests/sqlite3.c"
static int sqlite3BtreeCommitPhaseTwo(Btree *p, int bCleanup){

  if( p->inTrans==0 ) return 0;
  sqlite3BtreeEnter(p);
  ((void) (0)); ((void) (0));;




  if( p->inTrans==2 ){
    int rc;
    BtShared *pBt = p->pBt;
    ((void) (0));
    ((void) (0));
    rc = sqlite3PagerCommitPhaseTwo(pBt->pPager);
    if( rc!=0 && bCleanup==0 ){
      sqlite3BtreeLeave(p);
      return rc;
    }
    p->iBDataVersion--;
    pBt->inTransaction = 1;
    btreeClearHasContent(pBt);
  }

  btreeEndTransaction(p);
  sqlite3BtreeLeave(p);
  return 0;
}




static int sqlite3BtreeCommit(Btree *p){
  int rc;
  sqlite3BtreeEnter(p);
  rc = sqlite3BtreeCommitPhaseOne(p, 0);
  if( rc==0 ){
    rc = sqlite3BtreeCommitPhaseTwo(p, 0);
  }
  sqlite3BtreeLeave(p);
  return rc;
}
# 76879 "c_tests/sqlite3.c"
static int sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode, int writeOnly){
  BtCursor *p;
  int rc = 0;

  ((void) (0));
  if( pBtree ){
    sqlite3BtreeEnter(pBtree);
    for(p=pBtree->pBt->pCursor; p; p=p->pNext){
      if( writeOnly && (p->curFlags & 0x01)==0 ){
        if( p->eState==0 || p->eState==2 ){
          rc = saveCursorPosition(p);
          if( rc!=0 ){
            (void)sqlite3BtreeTripAllCursors(pBtree, rc, 0);
            break;
          }
        }
      }else{
        sqlite3BtreeClearCursor(p);
        p->eState = 4;
        p->skipNext = errCode;
      }
      btreeReleaseAllCursorPages(p);
    }
    sqlite3BtreeLeave(pBtree);
  }
  return rc;
}





static void btreeSetNPage(BtShared *pBt, MemPage *pPage1){
  int nPage = sqlite3Get4byte(&pPage1->aData[28]);
                      ;
  if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);
                                    ;
  pBt->nPage = nPage;
}
# 76930 "c_tests/sqlite3.c"
static int sqlite3BtreeRollback(Btree *p, int tripCode, int writeOnly){
  int rc;
  BtShared *pBt = p->pBt;
  MemPage *pPage1;

  ((void) (0));
  ((void) (0));
  sqlite3BtreeEnter(p);
  if( tripCode==0 ){
    rc = tripCode = saveAllCursors(pBt, 0, 0);
    if( rc ) writeOnly = 0;
  }else{
    rc = 0;
  }
  if( tripCode ){
    int rc2 = sqlite3BtreeTripAllCursors(p, tripCode, writeOnly);
    ((void) (0));
    if( rc2!=0 ) rc = rc2;
  }
  ((void) (0)); ((void) (0));;

  if( p->inTrans==2 ){
    int rc2;

    ((void) (0));
    rc2 = sqlite3PagerRollback(pBt->pPager);
    if( rc2!=0 ){
      rc = rc2;
    }




    if( btreeGetPage(pBt, 1, &pPage1, 0)==0 ){
      btreeSetNPage(pBt, pPage1);
      releasePageOne(pPage1);
    }
    ((void) (0));
    pBt->inTransaction = 1;
    btreeClearHasContent(pBt);
  }

  btreeEndTransaction(p);
  sqlite3BtreeLeave(p);
  return rc;
}
# 76995 "c_tests/sqlite3.c"
static int sqlite3BtreeBeginStmt(Btree *p, int iStatement){
  int rc;
  BtShared *pBt = p->pBt;
  sqlite3BtreeEnter(p);
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  rc = sqlite3PagerOpenSavepoint(pBt->pPager, iStatement);
  sqlite3BtreeLeave(p);
  return rc;
}
# 77026 "c_tests/sqlite3.c"
static int sqlite3BtreeSavepoint(Btree *p, int op, int iSavepoint){
  int rc = 0;
  if( p && p->inTrans==2 ){
    BtShared *pBt = p->pBt;
    ((void) (0));
    ((void) (0));
    sqlite3BtreeEnter(p);
    if( op==2 ){
      rc = saveAllCursors(pBt, 0, 0);
    }
    if( rc==0 ){
      rc = sqlite3PagerSavepoint(pBt->pPager, op, iSavepoint);
    }
    if( rc==0 ){
      if( iSavepoint<0 && (pBt->btsFlags & 0x0010)!=0 ){
        pBt->nPage = 0;
      }
      rc = newDatabase(pBt);
      btreeSetNPage(pBt, pBt->pPage1);



      ((void) (0));
    }
    sqlite3BtreeLeave(p);
  }
  return rc;
}
# 77097 "c_tests/sqlite3.c"
static int btreeCursor(
  Btree *p,
  Pgno iTable,
  int wrFlag,
  struct KeyInfo *pKeyInfo,
  BtCursor *pCur
){
  BtShared *pBt = p->pBt;
  BtCursor *pX;

  ((void) (0));
  ((void) (0));
# 77117 "c_tests/sqlite3.c"
  ((void) (0));

  ((void) (0));


  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( iTable<=1 ){
    if( iTable<1 ){
      return sqlite3CorruptError(77129);
    }else if( btreePagecount(pBt)==0 ){
      ((void) (0));
      iTable = 0;
    }
  }



  pCur->pgnoRoot = iTable;
  pCur->iPage = -1;
  pCur->pKeyInfo = pKeyInfo;
  pCur->pBtree = p;
  pCur->pBt = pBt;
  pCur->curFlags = 0;


  for(pX=pBt->pCursor; pX; pX=pX->pNext){
    if( pX->pgnoRoot==iTable ){
      pX->curFlags |= 0x20;
      pCur->curFlags = 0x20;
    }
  }
  pCur->eState = 1;
  pCur->pNext = pBt->pCursor;
  pBt->pCursor = pCur;
  if( wrFlag ){
    pCur->curFlags |= 0x01;
    pCur->curPagerFlags = 0;
    if( pBt->pTmpSpace==0 ) return allocateTempSpace(pBt);
  }else{
    pCur->curPagerFlags = 0x02;
  }
  return 0;
}
static int btreeCursorWithLock(
  Btree *p,
  Pgno iTable,
  int wrFlag,
  struct KeyInfo *pKeyInfo,
  BtCursor *pCur
){
  int rc;
  sqlite3BtreeEnter(p);
  rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);
  sqlite3BtreeLeave(p);
  return rc;
}
static int sqlite3BtreeCursor(
  Btree *p,
  Pgno iTable,
  int wrFlag,
  struct KeyInfo *pKeyInfo,
  BtCursor *pCur
){
  if( p->sharable ){
    return btreeCursorWithLock(p, iTable, wrFlag, pKeyInfo, pCur);
  }else{
    return btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);
  }
}
# 77199 "c_tests/sqlite3.c"
static int sqlite3BtreeCursorSize(void){
  return (((sizeof(BtCursor))+7)&~7);
}
# 77230 "c_tests/sqlite3.c"
static void sqlite3BtreeCursorZero(BtCursor *p){
  memset(p, 0, __builtin_offsetof(BtCursor, pBt));
}





static int sqlite3BtreeCloseCursor(BtCursor *pCur){
  Btree *pBtree = pCur->pBtree;
  if( pBtree ){
    BtShared *pBt = pCur->pBt;
    sqlite3BtreeEnter(pBtree);
    ((void) (0));
    if( pBt->pCursor==pCur ){
      pBt->pCursor = pCur->pNext;
    }else{
      BtCursor *pPrev = pBt->pCursor;
      do{
        if( pPrev->pNext==pCur ){
          pPrev->pNext = pCur->pNext;
          break;
        }
        pPrev = pPrev->pNext;
      }while( (pPrev) );
    }
    btreeReleaseAllCursorPages(pCur);
    unlockBtreeIfUnused(pBt);
    sqlite3_free(pCur->aOverflow);
    sqlite3_free(pCur->pKey);
    if( (pBt->openFlags & 4) && pBt->pCursor==0 ){


      ((void) (0));
      sqlite3BtreeClose(pBtree);
    }else{
      sqlite3BtreeLeave(pBtree);
    }
    pCur->pBtree = 0;
  }
  return 0;
}
# 77299 "c_tests/sqlite3.c"
static __attribute__((noinline)) void getCellInfo(BtCursor *pCur){
  if( pCur->info.nSize==0 ){
    pCur->curFlags |= 0x02;
    btreeParseCell(pCur->pPage,pCur->ix,&pCur->info);
  }else{
                        ;
  }
}
# 77318 "c_tests/sqlite3.c"
static int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  ((void) (0));
  return pCur->eState==0;
}







static i64 sqlite3BtreeIntegerKey(BtCursor *pCur){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  getCellInfo(pCur);
  return pCur->info.nKey;
}




static void sqlite3BtreeCursorPin(BtCursor *pCur){
  ((void) (0));
  pCur->curFlags |= 0x40;
}
static void sqlite3BtreeCursorUnpin(BtCursor *pCur){
  ((void) (0));
  pCur->curFlags &= ~0x40;
}





static i64 sqlite3BtreeOffset(BtCursor *pCur){
  ((void) (0));
  ((void) (0));
  getCellInfo(pCur);
  return (i64)pCur->pBt->pageSize*((i64)pCur->pPage->pgno - 1) +
         (i64)(pCur->info.pPayload - pCur->pPage->aData);
}
# 77370 "c_tests/sqlite3.c"
static u32 sqlite3BtreePayloadSize(BtCursor *pCur){
  ((void) (0));
  ((void) (0));
  getCellInfo(pCur);
  return pCur->info.nPayload;
}
# 77390 "c_tests/sqlite3.c"
static sqlite3_int64 sqlite3BtreeMaxRecordSize(BtCursor *pCur){
  ((void) (0));
  ((void) (0));
  return pCur->pBt->pageSize * (sqlite3_int64)pCur->pBt->nPage;
}
# 77415 "c_tests/sqlite3.c"
static int getOverflowPage(
  BtShared *pBt,
  Pgno ovfl,
  MemPage **ppPage,
  Pgno *pPgnoNext
){
  Pgno next = 0;
  MemPage *pPage = 0;
  int rc = 0;

  ((void) (0));
  ((void) (0));
# 77435 "c_tests/sqlite3.c"
  if( pBt->autoVacuum ){
    Pgno pgno;
    Pgno iGuess = ovfl+1;
    u8 eType;

    while( (ptrmapPageno((pBt), (iGuess))==(iGuess)) || iGuess==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
      iGuess++;
    }

    if( iGuess<=btreePagecount(pBt) ){
      rc = ptrmapGet(pBt, iGuess, &eType, &pgno);
      if( rc==0 && eType==4 && pgno==ovfl ){
        next = iGuess;
        rc = 101;
      }
    }
  }


  ((void) (0));
  if( rc==0 ){
    rc = btreeGetPage(pBt, ovfl, &pPage, (ppPage==0) ? 0x02 : 0);
    ((void) (0));
    if( rc==0 ){
      next = sqlite3Get4byte(pPage->aData);
    }
  }

  *pPgnoNext = next;
  if( ppPage ){
    *ppPage = pPage;
  }else{
    releasePage(pPage);
  }
  return (rc==101 ? 0 : rc);
}
# 77483 "c_tests/sqlite3.c"
static int copyPayload(
  void *pPayload,
  void *pBuf,
  int nByte,
  int eOp,
  DbPage *pDbPage
){
  if( eOp ){

    int rc = sqlite3PagerWrite(pDbPage);
    if( rc!=0 ){
      return rc;
    }
    memcpy(pPayload, pBuf, nByte);
  }else{

    memcpy(pBuf, pPayload, nByte);
  }
  return 0;
}
# 77533 "c_tests/sqlite3.c"
static int accessPayload(
  BtCursor *pCur,
  u32 offset,
  u32 amt,
  unsigned char *pBuf,
  int eOp
){
  unsigned char *aPayload;
  int rc = 0;
  int iIdx = 0;
  MemPage *pPage = pCur->pPage;
  BtShared *pBt = pCur->pBt;

  unsigned char * const pBufStart = pBuf;


  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pCur->ix>=pPage->nCell ){
    return sqlite3CorruptError(77553);
  }
  ((void) (0));

  getCellInfo(pCur);
  aPayload = pCur->info.pPayload;
  ((void) (0));

  ((void) (0));
  if( (uptr)(aPayload - pPage->aData) > (pBt->usableSize - pCur->info.nLocal) ){





    return sqlite3CorruptError(77568);
  }


  if( offset<pCur->info.nLocal ){
    int a = amt;
    if( a+offset>pCur->info.nLocal ){
      a = pCur->info.nLocal - offset;
    }
    rc = copyPayload(&aPayload[offset], pBuf, a, eOp, pPage->pDbPage);
    offset = 0;
    pBuf += a;
    amt -= a;
  }else{
    offset -= pCur->info.nLocal;
  }


  if( rc==0 && amt>0 ){
    const u32 ovflSize = pBt->usableSize - 4;
    Pgno nextPage;

    nextPage = sqlite3Get4byte(&aPayload[pCur->info.nLocal]);
# 77599 "c_tests/sqlite3.c"
    if( (pCur->curFlags & 0x04)==0 ){
      int nOvfl = (pCur->info.nPayload-pCur->info.nLocal+ovflSize-1)/ovflSize;
      if( pCur->aOverflow==0
       || nOvfl*(int)sizeof(Pgno) > sqlite3MallocSize(pCur->aOverflow)
      ){
        Pgno *aNew;
        if( sqlite3FaultSim(413) ){
          aNew = 0;
        }else{
          aNew = (Pgno*)sqlite3Realloc(pCur->aOverflow, nOvfl*2*sizeof(Pgno));
        }
        if( aNew==0 ){
          return 7;
        }else{
          pCur->aOverflow = aNew;
        }
      }
      memset(pCur->aOverflow, 0, nOvfl*sizeof(Pgno));
      pCur->curFlags |= 0x04;
    }else{

      ((void) (0));


      ((void) (0));





      if( pCur->aOverflow[offset/ovflSize] ){
        iIdx = (offset/ovflSize);
        nextPage = pCur->aOverflow[iIdx];
        offset = (offset%ovflSize);
      }
    }

    ((void) (0));
    while( nextPage ){

      if( nextPage > pBt->nPage ) return sqlite3CorruptError(77639);
      ((void) (0));


      pCur->aOverflow[iIdx] = nextPage;

      if( offset>=ovflSize ){






        ((void) (0));
        ((void) (0));
        if( pCur->aOverflow[iIdx+1] ){
          nextPage = pCur->aOverflow[iIdx+1];
        }else{
          rc = getOverflowPage(pBt, nextPage, 0, &nextPage);
        }
        offset -= ovflSize;
      }else{



        int a = amt;
        if( a + offset > ovflSize ){
          a = ovflSize - offset;
        }
# 77683 "c_tests/sqlite3.c"
        if( eOp==0
         && offset==0
         && sqlite3PagerDirectReadOk(pBt->pPager, nextPage)
         && &pBuf[-4]>=pBufStart
        ){
          sqlite3_file *fd = sqlite3PagerFile(pBt->pPager);
          u8 aSave[4];
          u8 *aWrite = &pBuf[-4];
          ((void) (0));
          memcpy(aSave, aWrite, 4);
          rc = sqlite3OsRead(fd, aWrite, a+4, (i64)pBt->pageSize*(nextPage-1));
          nextPage = sqlite3Get4byte(aWrite);
          memcpy(aWrite, aSave, 4);
        }else


        {
          DbPage *pDbPage;
          rc = sqlite3PagerGet(pBt->pPager, nextPage, &pDbPage,
              (eOp==0 ? 0x02 : 0)
          );
          if( rc==0 ){
            aPayload = sqlite3PagerGetData(pDbPage);
            nextPage = sqlite3Get4byte(aPayload);
            rc = copyPayload(&aPayload[offset+4], pBuf, a, eOp, pDbPage);
            sqlite3PagerUnref(pDbPage);
            offset = 0;
          }
        }
        amt -= a;
        if( amt==0 ) return rc;
        pBuf += a;
      }
      if( rc ) break;
      iIdx++;
    }
  }

  if( rc==0 && amt>0 ){

    return sqlite3CorruptError(77723);
  }
  return rc;
}
# 77745 "c_tests/sqlite3.c"
static int sqlite3BtreePayload(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return accessPayload(pCur, offset, amt, (unsigned char*)pBuf, 0);
}







static __attribute__((noinline)) int accessPayloadChecked(
  BtCursor *pCur,
  u32 offset,
  u32 amt,
  void *pBuf
){
  int rc;
  if ( pCur->eState==1 ){
    return 4;
  }
  ((void) (0));
  rc = btreeRestoreCursorPosition(pCur);
  return rc ? rc : accessPayload(pCur, offset, amt, pBuf, 0);
}
static int sqlite3BtreePayloadChecked(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
  if( pCur->eState==0 ){
    ((void) (0));
    return accessPayload(pCur, offset, amt, pBuf, 0);
  }else{
    return accessPayloadChecked(pCur, offset, amt, pBuf);
  }
}
# 77801 "c_tests/sqlite3.c"
static const void *fetchPayload(
  BtCursor *pCur,
  u32 *pAmt
){
  int amt;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  amt = pCur->info.nLocal;
  if( amt>(int)(pCur->pPage->aDataEnd - pCur->info.pPayload) ){


    ((void) (0));
    amt = ((0)>((int)(pCur->pPage->aDataEnd - pCur->info.pPayload))?(0):((int)(pCur->pPage->aDataEnd - pCur->info.pPayload)));
  }
  *pAmt = (u32)amt;
  return (void*)pCur->info.pPayload;
}
# 77840 "c_tests/sqlite3.c"
static const void *sqlite3BtreePayloadFetch(BtCursor *pCur, u32 *pAmt){
  return fetchPayload(pCur, pAmt);
}
# 77854 "c_tests/sqlite3.c"
static int moveToChild(BtCursor *pCur, u32 newPgno){
  int rc;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pCur->iPage>=(20 -1) ){
    return sqlite3CorruptError(77861);
  }
  pCur->info.nSize = 0;
  pCur->curFlags &= ~(0x02|0x04);
  pCur->aiIdx[pCur->iPage] = pCur->ix;
  pCur->apPage[pCur->iPage] = pCur->pPage;
  pCur->ix = 0;
  pCur->iPage++;
  rc = getAndInitPage(pCur->pBt, newPgno, &pCur->pPage, pCur->curPagerFlags);
  ((void) (0));
  if( rc==0
   && (pCur->pPage->nCell<1 || pCur->pPage->intKey!=pCur->curIntKey)
  ){
    releasePage(pCur->pPage);
    rc = sqlite3CorruptError(77875);
  }
  if( rc ){
    pCur->pPage = pCur->apPage[--pCur->iPage];
  }
  return rc;
}
# 77913 "c_tests/sqlite3.c"
static void moveToParent(BtCursor *pCur){
  MemPage *pLeaf;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));




   ;
                                                                             ;
  pCur->info.nSize = 0;
  pCur->curFlags &= ~(0x02|0x04);
  pCur->ix = pCur->aiIdx[pCur->iPage-1];
  pLeaf = pCur->pPage;
  pCur->pPage = pCur->apPage[--pCur->iPage];
  releasePageNotNull(pLeaf);
}
# 77954 "c_tests/sqlite3.c"
static int moveToRoot(BtCursor *pCur){
  MemPage *pRoot;
  int rc = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pCur->iPage>=0 ){
    if( pCur->iPage ){
      releasePageNotNull(pCur->pPage);
      while( --pCur->iPage ){
        releasePageNotNull(pCur->apPage[pCur->iPage]);
      }
      pRoot = pCur->pPage = pCur->apPage[0];
      goto skip_init;
    }
  }else if( pCur->pgnoRoot==0 ){
    pCur->eState = 1;
    return 16;
  }else{
    ((void) (0));
    if( pCur->eState>=3 ){
      if( pCur->eState==4 ){
        ((void) (0));
        return pCur->skipNext;
      }
      sqlite3BtreeClearCursor(pCur);
    }
    rc = getAndInitPage(pCur->pBt, pCur->pgnoRoot, &pCur->pPage,
                        pCur->curPagerFlags);
    if( rc!=0 ){
      pCur->eState = 1;
      return rc;
    }
    pCur->iPage = 0;
    pCur->curIntKey = pCur->pPage->intKey;
  }
  pRoot = pCur->pPage;
  ((void) (0));
# 78008 "c_tests/sqlite3.c"
  ((void) (0));
  if( pRoot->isInit==0 || (pCur->pKeyInfo==0)!=pRoot->intKey ){
    return sqlite3CorruptError(78010);
  }

skip_init:
  pCur->ix = 0;
  pCur->info.nSize = 0;
  pCur->curFlags &= ~(0x08|0x02|0x04);

  if( pRoot->nCell>0 ){
    pCur->eState = 0;
  }else if( !pRoot->leaf ){
    Pgno subpage;
    if( pRoot->pgno!=1 ) return sqlite3CorruptError(78022);
    subpage = sqlite3Get4byte(&pRoot->aData[pRoot->hdrOffset+8]);
    pCur->eState = 0;
    rc = moveToChild(pCur, subpage);
  }else{
    pCur->eState = 1;
    rc = 16;
  }
  return rc;
}
# 78040 "c_tests/sqlite3.c"
static int moveToLeftmost(BtCursor *pCur){
  Pgno pgno;
  int rc = 0;
  MemPage *pPage;

  ((void) (0));
  ((void) (0));
  while( rc==0 && !(pPage = pCur->pPage)->leaf ){
    ((void) (0));
    pgno = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(pCur->ix)])[0]<<8 | (&(pPage)->aCellIdx[2*(pCur->ix)])[1]))));
    rc = moveToChild(pCur, pgno);
  }
  return rc;
}
# 78065 "c_tests/sqlite3.c"
static int moveToRightmost(BtCursor *pCur){
  Pgno pgno;
  int rc = 0;
  MemPage *pPage = 0;

  ((void) (0));
  ((void) (0));
  while( !(pPage = pCur->pPage)->leaf ){
    pgno = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]);
    pCur->ix = pPage->nCell;
    rc = moveToChild(pCur, pgno);
    if( rc ) return rc;
  }
  pCur->ix = pPage->nCell-1;
  ((void) (0));
  ((void) (0));
  return 0;
}





static int sqlite3BtreeFirst(BtCursor *pCur, int *pRes){
  int rc;

  ((void) (0));
  ((void) (0));
  rc = moveToRoot(pCur);
  if( rc==0 ){
    ((void) (0));
    *pRes = 0;
    rc = moveToLeftmost(pCur);
  }else if( rc==16 ){
    ((void) (0));
    *pRes = 1;
    rc = 0;
  }
  return rc;
}






static int sqlite3BtreeIsEmpty(BtCursor *pCur, int *pRes){
  int rc;

  ((void) (0));
  ((void) (0));
  if( pCur->eState==0 ){
    *pRes = 0;
    return 0;
  }
  rc = moveToRoot(pCur);
  if( rc==16 ){
    *pRes = 1;
    rc = 0;
  }else{
    *pRes = 0;
  }
  return rc;
}
# 78151 "c_tests/sqlite3.c"
static __attribute__((noinline)) int btreeLast(BtCursor *pCur, int *pRes){
  int rc = moveToRoot(pCur);
  if( rc==0 ){
    ((void) (0));
    *pRes = 0;
    rc = moveToRightmost(pCur);
    if( rc==0 ){
      pCur->curFlags |= 0x08;
    }else{
      pCur->curFlags &= ~0x08;
    }
  }else if( rc==16 ){
    ((void) (0));
    *pRes = 1;
    rc = 0;
  }
  return rc;
}
static int sqlite3BtreeLast(BtCursor *pCur, int *pRes){
  ((void) (0));
  ((void) (0));


  if( 0==pCur->eState && (pCur->curFlags & 0x08)!=0 ){
    ((void) (0));
    *pRes = 0;
    return 0;
  }
  return btreeLast(pCur, pRes);
}
# 78205 "c_tests/sqlite3.c"
static int sqlite3BtreeTableMoveto(
  BtCursor *pCur,
  i64 intKey,
  int biasRight,
  int *pRes
){
  int rc;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));



  if( pCur->eState==0 && (pCur->curFlags & 0x02)!=0 ){
    if( pCur->info.nKey==intKey ){
      *pRes = 0;
      return 0;
    }
    if( pCur->info.nKey<intKey ){
      if( (pCur->curFlags & 0x08)!=0 ){
        ((void) (0));
        *pRes = -1;
        return 0;
      }




      if( pCur->info.nKey+1==intKey ){
        *pRes = 0;
        rc = sqlite3BtreeNext(pCur, 0);
        if( rc==0 ){
          getCellInfo(pCur);
          if( pCur->info.nKey==intKey ){
            return 0;
          }
        }else if( rc!=101 ){
          return rc;
        }
      }
    }
  }





  rc = moveToRoot(pCur);
  if( rc ){
    if( rc==16 ){
      ((void) (0));
      *pRes = -1;
      return 0;
    }
    return rc;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  for(;;){
    int lwr, upr, idx, c;
    Pgno chldPg;
    MemPage *pPage = pCur->pPage;
    u8 *pCell;







    ((void) (0));
    ((void) (0));
    lwr = 0;
    upr = pPage->nCell-1;
    ((void) (0));
    idx = upr>>(1-biasRight);
    for(;;){
      i64 nCellKey;
      pCell = ((pPage)->aDataOfst + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(idx)])[0]<<8 | (&(pPage)->aCellIdx[2*(idx)])[1])));
      if( pPage->intKeyLeaf ){
        while( 0x80 <= *(pCell++) ){
          if( pCell>=pPage->aDataEnd ){
            return sqlite3CorruptError(78295);
          }
        }
      }
      sqlite3GetVarint(pCell, (u64*)&nCellKey);
      if( nCellKey<intKey ){
        lwr = idx+1;
        if( lwr>upr ){ c = -1; break; }
      }else if( nCellKey>intKey ){
        upr = idx-1;
        if( lwr>upr ){ c = +1; break; }
      }else{
        ((void) (0));
        pCur->ix = (u16)idx;
        if( !pPage->leaf ){
          lwr = idx;
          goto moveto_table_next_layer;
        }else{
          pCur->curFlags |= 0x02;
          pCur->info.nKey = nCellKey;
          pCur->info.nSize = 0;
          *pRes = 0;
          return 0;
        }
      }
      ((void) (0));
      idx = (lwr+upr)>>1;
    }
    ((void) (0));
    ((void) (0));
    if( pPage->leaf ){
      ((void) (0));
      pCur->ix = (u16)idx;
      *pRes = c;
      rc = 0;
      goto moveto_table_finish;
    }
moveto_table_next_layer:
    if( lwr>=pPage->nCell ){
      chldPg = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]);
    }else{
      chldPg = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(lwr)])[0]<<8 | (&(pPage)->aCellIdx[2*(lwr)])[1]))));
    }
    pCur->ix = (u16)lwr;
    rc = moveToChild(pCur, chldPg);
    if( rc ) break;
  }
moveto_table_finish:
  pCur->info.nSize = 0;
  ((void) (0));
  return rc;
}
# 78364 "c_tests/sqlite3.c"
static int indexCellCompare(
  MemPage *pPage,
  int idx,
  UnpackedRecord *pIdxKey,
  RecordCompare xRecordCompare
){
  int c;
  int nCell;
  u8 *pCell = ((pPage)->aDataOfst + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(idx)])[0]<<8 | (&(pPage)->aCellIdx[2*(idx)])[1])));

  nCell = pCell[0];
  if( nCell<=pPage->max1bytePayload ){



                                              ;
    c = xRecordCompare(nCell, (void*)&pCell[1], pIdxKey);
  }else if( !(pCell[1] & 0x80)
    && (nCell = ((nCell&0x7f)<<7) + pCell[1])<=pPage->maxLocal
  ){


                                              ;
    c = xRecordCompare(nCell, (void*)&pCell[2], pIdxKey);
  }else{


    c = 99;
  }
  return c;
}





static int cursorOnLastPage(BtCursor *pCur){
  int i;
  ((void) (0));
  for(i=0; i<pCur->iPage; i++){
    MemPage *pPage = pCur->apPage[i];
    if( pCur->aiIdx[i]<pPage->nCell ) return 0;
  }
  return 1;
}
# 78436 "c_tests/sqlite3.c"
static int sqlite3BtreeIndexMoveto(
  BtCursor *pCur,
  UnpackedRecord *pIdxKey,
  int *pRes
){
  int rc;
  RecordCompare xRecordCompare;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);
  pIdxKey->errCode = 0;
  ((void) (0));
# 78472 "c_tests/sqlite3.c"
  if( pCur->eState==0
   && pCur->pPage->leaf
   && cursorOnLastPage(pCur)
  ){
    int c;
    if( pCur->ix==pCur->pPage->nCell-1
     && (c = indexCellCompare(pCur->pPage,pCur->ix,pIdxKey,xRecordCompare))<=0
     && pIdxKey->errCode==0
    ){
      *pRes = c;
      return 0;
    }
    if( pCur->iPage>0
     && indexCellCompare(pCur->pPage, 0, pIdxKey, xRecordCompare)<=0
     && pIdxKey->errCode==0
    ){
      pCur->curFlags &= ~(0x04|0x08);
      if( !pCur->pPage->isInit ){
        return sqlite3CorruptError(78490);
      }
      goto bypass_moveto_root;
    }
    pIdxKey->errCode = 0;
  }

  rc = moveToRoot(pCur);
  if( rc ){
    if( rc==16 ){
      ((void) (0));
      *pRes = -1;
      return 0;
    }
    return rc;
  }

bypass_moveto_root:
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  for(;;){
    int lwr, upr, idx, c;
    Pgno chldPg;
    MemPage *pPage = pCur->pPage;
    u8 *pCell;







    ((void) (0));
    ((void) (0));
    lwr = 0;
    upr = pPage->nCell-1;
    idx = upr>>1;
    for(;;){
      int nCell;
      pCell = ((pPage)->aDataOfst + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(idx)])[0]<<8 | (&(pPage)->aCellIdx[2*(idx)])[1])));
# 78543 "c_tests/sqlite3.c"
      nCell = pCell[0];
      if( nCell<=pPage->max1bytePayload ){



                                                  ;
        c = xRecordCompare(nCell, (void*)&pCell[1], pIdxKey);
      }else if( !(pCell[1] & 0x80)
        && (nCell = ((nCell&0x7f)<<7) + pCell[1])<=pPage->maxLocal
      ){


                                                  ;
        c = xRecordCompare(nCell, (void*)&pCell[2], pIdxKey);
      }else{
# 78567 "c_tests/sqlite3.c"
        void *pCellKey;
        u8 * const pCellBody = pCell - pPage->childPtrSize;
        const int nOverrun = 18;
        pPage->xParseCell(pPage, pCellBody, &pCur->info);
        nCell = (int)pCur->info.nKey;
                           ;
                            ;
                            ;
                            ;
        if( nCell<2 || nCell/pCur->pBt->usableSize>pCur->pBt->nPage ){
          rc = sqlite3CorruptError(78577);
          goto moveto_index_finish;
        }
        pCellKey = sqlite3Malloc( (u64)nCell+(u64)nOverrun );
        if( pCellKey==0 ){
          rc = 7;
          goto moveto_index_finish;
        }
        pCur->ix = (u16)idx;
        rc = accessPayload(pCur, 0, nCell, (unsigned char*)pCellKey, 0);
        memset(((u8*)pCellKey)+nCell,0,nOverrun);
        pCur->curFlags &= ~0x04;
        if( rc ){
          sqlite3_free(pCellKey);
          goto moveto_index_finish;
        }
        c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey);
        sqlite3_free(pCellKey);
      }
      ((void) (0));



      if( c<0 ){
        lwr = idx+1;
      }else if( c>0 ){
        upr = idx-1;
      }else{
        ((void) (0));
        *pRes = 0;
        rc = 0;
        pCur->ix = (u16)idx;
        if( pIdxKey->errCode ) rc = sqlite3CorruptError(78609);
        goto moveto_index_finish;
      }
      if( lwr>upr ) break;
      ((void) (0));
      idx = (lwr+upr)>>1;
    }
    ((void) (0));
    ((void) (0));
    if( pPage->leaf ){
      ((void) (0));
      pCur->ix = (u16)idx;
      *pRes = c;
      rc = 0;
      goto moveto_index_finish;
    }
    if( lwr>=pPage->nCell ){
      chldPg = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]);
    }else{
      chldPg = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(lwr)])[0]<<8 | (&(pPage)->aCellIdx[2*(lwr)])[1]))));
    }







    pCur->info.nSize = 0;
    pCur->curFlags &= ~(0x02|0x04);
    if( pCur->iPage>=(20 -1) ){
      return sqlite3CorruptError(78640);
    }
    pCur->aiIdx[pCur->iPage] = (u16)lwr;
    pCur->apPage[pCur->iPage] = pCur->pPage;
    pCur->ix = 0;
    pCur->iPage++;
    rc = getAndInitPage(pCur->pBt, chldPg, &pCur->pPage, pCur->curPagerFlags);
    if( rc==0
     && (pCur->pPage->nCell<1 || pCur->pPage->intKey!=pCur->curIntKey)
    ){
      releasePage(pCur->pPage);
      rc = sqlite3CorruptError(78651);
    }
    if( rc ){
      pCur->pPage = pCur->apPage[--pCur->iPage];
      break;
    }


 }
moveto_index_finish:
  pCur->info.nSize = 0;
  ((void) (0));
  return rc;
}
# 78674 "c_tests/sqlite3.c"
static int sqlite3BtreeEof(BtCursor *pCur){




  return (0!=pCur->eState);
}






static i64 sqlite3BtreeRowCountEst(BtCursor *pCur){
  i64 n;
  u8 i;

  ((void) (0));
  ((void) (0));




  if( pCur->eState!=0 ) return 0;
  if( (pCur->pPage->leaf==0) ) return -1;

  n = pCur->pPage->nCell;
  for(i=0; i<pCur->iPage; i++){
    n *= pCur->apPage[i]->nCell+1;
  }
  return n;
}
# 78727 "c_tests/sqlite3.c"
static __attribute__((noinline)) int btreeNext(BtCursor *pCur){
  int rc;
  int idx;
  MemPage *pPage;

  ((void) (0));
  if( pCur->eState!=0 ){
    ((void) (0));
    rc = (pCur->eState>=3 ? btreeRestoreCursorPosition(pCur) : 0);
    if( rc!=0 ){
      return rc;
    }
    if( 1==pCur->eState ){
      return 101;
    }
    if( pCur->eState==2 ){
      pCur->eState = 0;
      if( pCur->skipNext>0 ) return 0;
    }
  }

  pPage = pCur->pPage;
  idx = ++pCur->ix;
  if( sqlite3FaultSim(412) ) pPage->isInit = 0;
  if( !pPage->isInit ){
    return sqlite3CorruptError(78752);
  }

  if( idx>=pPage->nCell ){
    if( !pPage->leaf ){
      rc = moveToChild(pCur, sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]));
      if( rc ) return rc;
      return moveToLeftmost(pCur);
    }
    do{
      if( pCur->iPage==0 ){
        pCur->eState = 1;
        return 101;
      }
      moveToParent(pCur);
      pPage = pCur->pPage;
    }while( pCur->ix>=pPage->nCell );
    if( pPage->intKey ){
      return sqlite3BtreeNext(pCur, 0);
    }else{
      return 0;
    }
  }
  if( pPage->leaf ){
    return 0;
  }else{
    return moveToLeftmost(pCur);
  }
}
static int sqlite3BtreeNext(BtCursor *pCur, int flags){
  MemPage *pPage;
  (void)(flags);
  ((void) (0));
  ((void) (0));
  pCur->info.nSize = 0;
  pCur->curFlags &= ~(0x02|0x04);
  if( pCur->eState!=0 ) return btreeNext(pCur);
  pPage = pCur->pPage;
  if( (++pCur->ix)>=pPage->nCell ){
    pCur->ix--;
    return btreeNext(pCur);
  }
  if( pPage->leaf ){
    return 0;
  }else{
    return moveToLeftmost(pCur);
  }
}
# 78821 "c_tests/sqlite3.c"
static __attribute__((noinline)) int btreePrevious(BtCursor *pCur){
  int rc;
  MemPage *pPage;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pCur->eState!=0 ){
    rc = (pCur->eState>=3 ? btreeRestoreCursorPosition(pCur) : 0);
    if( rc!=0 ){
      return rc;
    }
    if( 1==pCur->eState ){
      return 101;
    }
    if( 2==pCur->eState ){
      pCur->eState = 0;
      if( pCur->skipNext<0 ) return 0;
    }
  }

  pPage = pCur->pPage;
  if( sqlite3FaultSim(412) ) pPage->isInit = 0;
  if( !pPage->isInit ){
    return sqlite3CorruptError(78845);
  }
  if( !pPage->leaf ){
    int idx = pCur->ix;
    rc = moveToChild(pCur, sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(idx)])[0]<<8 | (&(pPage)->aCellIdx[2*(idx)])[1])))));
    if( rc ) return rc;
    rc = moveToRightmost(pCur);
  }else{
    while( pCur->ix==0 ){
      if( pCur->iPage==0 ){
        pCur->eState = 1;
        return 101;
      }
      moveToParent(pCur);
    }
    ((void) (0));
    ((void) (0));

    pCur->ix--;
    pPage = pCur->pPage;
    if( pPage->intKey && !pPage->leaf ){
      rc = sqlite3BtreePrevious(pCur, 0);
    }else{
      rc = 0;
    }
  }
  return rc;
}
static int sqlite3BtreePrevious(BtCursor *pCur, int flags){
  ((void) (0));
  ((void) (0));
  (void)(flags);
  pCur->curFlags &= ~(0x08|0x04|0x02);
  pCur->info.nSize = 0;
  if( pCur->eState!=0
   || pCur->ix==0
   || pCur->pPage->leaf==0
  ){
    return btreePrevious(pCur);
  }
  pCur->ix--;
  return 0;
}
# 78911 "c_tests/sqlite3.c"
static int allocateBtreePage(
  BtShared *pBt,
  MemPage **ppPage,
  Pgno *pPgno,
  Pgno nearby,
  u8 eMode
){
  MemPage *pPage1;
  int rc;
  u32 n;
  u32 k;
  MemPage *pTrunk = 0;
  MemPage *pPrevTrunk = 0;
  Pgno mxPage;

  ((void) (0));
  ((void) (0));
  pPage1 = pBt->pPage1;
  mxPage = btreePagecount(pBt);


  n = sqlite3Get4byte(&pPage1->aData[36]);
                         ;
  if( n>=mxPage ){
    return sqlite3CorruptError(78935);
  }
  if( n>0 ){

    Pgno iTrunk;
    u8 searchList = 0;
    u32 nSearch = 0;






    if( eMode==1 ){
      if( nearby<=mxPage ){
        u8 eType;
        ((void) (0));
        ((void) (0));
        rc = ptrmapGet(pBt, nearby, &eType, 0);
        if( rc ) return rc;
        if( eType==2 ){
          searchList = 1;
        }
      }
    }else if( eMode==2 ){
      searchList = 1;
    }





    rc = sqlite3PagerWrite(pPage1->pDbPage);
    if( rc ) return rc;
    sqlite3Put4byte(&pPage1->aData[36], n-1);






    do {
      pPrevTrunk = pTrunk;
      if( pPrevTrunk ){



        iTrunk = sqlite3Get4byte(&pPrevTrunk->aData[0]);
      }else{



        iTrunk = sqlite3Get4byte(&pPage1->aData[32]);
      }
                                ;
      if( iTrunk>mxPage || nSearch++ > n ){
        rc = sqlite3CorruptError(78991);
      }else{
        rc = btreeGetUnusedPage(pBt, iTrunk, &pTrunk, 0);
      }
      if( rc ){
        pTrunk = 0;
        goto end_allocate_page;
      }
      ((void) (0));
      ((void) (0));


      k = sqlite3Get4byte(&pTrunk->aData[4]);
      if( k==0 && !searchList ){



        ((void) (0));
        rc = sqlite3PagerWrite(pTrunk->pDbPage);
        if( rc ){
          goto end_allocate_page;
        }
        *pPgno = iTrunk;
        memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
        *ppPage = pTrunk;
        pTrunk = 0;
                                                                         ;
      }else if( k>(u32)(pBt->usableSize/4 - 2) ){

        rc = sqlite3CorruptError(79020);
        goto end_allocate_page;

      }else if( searchList
            && (nearby==iTrunk || (iTrunk<nearby && eMode==2))
      ){



        *pPgno = iTrunk;
        *ppPage = pTrunk;
        searchList = 0;
        rc = sqlite3PagerWrite(pTrunk->pDbPage);
        if( rc ){
          goto end_allocate_page;
        }
        if( k==0 ){
          if( !pPrevTrunk ){
            memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
          }else{
            rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);
            if( rc!=0 ){
              goto end_allocate_page;
            }
            memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4);
          }
        }else{




          MemPage *pNewTrunk;
          Pgno iNewTrunk = sqlite3Get4byte(&pTrunk->aData[8]);
          if( iNewTrunk>mxPage ){
            rc = sqlite3CorruptError(79054);
            goto end_allocate_page;
          }
                                       ;
          rc = btreeGetUnusedPage(pBt, iNewTrunk, &pNewTrunk, 0);
          if( rc!=0 ){
            goto end_allocate_page;
          }
          rc = sqlite3PagerWrite(pNewTrunk->pDbPage);
          if( rc!=0 ){
            releasePage(pNewTrunk);
            goto end_allocate_page;
          }
          memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4);
          sqlite3Put4byte(&pNewTrunk->aData[4], k-1);
          memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k-1)*4);
          releasePage(pNewTrunk);
          if( !pPrevTrunk ){
            ((void) (0));
            sqlite3Put4byte(&pPage1->aData[32], iNewTrunk);
          }else{
            rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);
            if( rc ){
              goto end_allocate_page;
            }
            sqlite3Put4byte(&pPrevTrunk->aData[0], iNewTrunk);
          }
        }
        pTrunk = 0;
                                                                         ;

      }else if( k>0 ){

        u32 closest;
        Pgno iPage;
        unsigned char *aData = pTrunk->aData;
        if( nearby>0 ){
          u32 i;
          closest = 0;
          if( eMode==2 ){
            for(i=0; i<k; i++){
              iPage = sqlite3Get4byte(&aData[8+i*4]);
              if( iPage<=nearby ){
                closest = i;
                break;
              }
            }
          }else{
            int dist;
            dist = sqlite3AbsInt32(sqlite3Get4byte(&aData[8]) - nearby);
            for(i=1; i<k; i++){
              int d2 = sqlite3AbsInt32(sqlite3Get4byte(&aData[8+i*4]) - nearby);
              if( d2<dist ){
                closest = i;
                dist = d2;
              }
            }
          }
        }else{
          closest = 0;
        }

        iPage = sqlite3Get4byte(&aData[8+closest*4]);
                                 ;
        if( iPage>mxPage || iPage<2 ){
          rc = sqlite3CorruptError(79119);
          goto end_allocate_page;
        }
                                 ;
        if( !searchList
         || (iPage==nearby || (iPage<nearby && eMode==2))
        ){
          int noContent;
          *pPgno = iPage;


                                                          ;
          rc = sqlite3PagerWrite(pTrunk->pDbPage);
          if( rc ) goto end_allocate_page;
          if( closest<k-1 ){
            memcpy(&aData[8+closest*4], &aData[4+k*4], 4);
          }
          sqlite3Put4byte(&aData[4], k-1);
          noContent = !btreeGetHasContent(pBt, *pPgno)? 0x01 : 0;
          rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, noContent);
          if( rc==0 ){
            rc = sqlite3PagerWrite((*ppPage)->pDbPage);
            if( rc!=0 ){
              releasePage(*ppPage);
              *ppPage = 0;
            }
          }
          searchList = 0;
        }
      }
      releasePage(pPrevTrunk);
      pPrevTrunk = 0;
    }while( searchList );
  }else{
# 79171 "c_tests/sqlite3.c"
    int bNoContent = (0==(pBt->bDoTruncate))? 0x01:0;

    rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
    if( rc ) return rc;
    pBt->nPage++;
    if( pBt->nPage==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ) pBt->nPage++;


    if( pBt->autoVacuum && (ptrmapPageno((pBt), (pBt->nPage))==(pBt->nPage)) ){




      MemPage *pPg = 0;
                                                                               ;
      ((void) (0));
      rc = btreeGetUnusedPage(pBt, pBt->nPage, &pPg, bNoContent);
      if( rc==0 ){
        rc = sqlite3PagerWrite(pPg->pDbPage);
        releasePage(pPg);
      }
      if( rc ) return rc;
      pBt->nPage++;
      if( pBt->nPage==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){ pBt->nPage++; }
    }

    sqlite3Put4byte(28 + (u8*)pBt->pPage1->aData, pBt->nPage);
    *pPgno = pBt->nPage;

    ((void) (0));
    rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, bNoContent);
    if( rc ) return rc;
    rc = sqlite3PagerWrite((*ppPage)->pDbPage);
    if( rc!=0 ){
      releasePage(*ppPage);
      *ppPage = 0;
    }
                                                      ;
  }

  ((void) (0));

end_allocate_page:
  releasePage(pTrunk);
  releasePage(pPrevTrunk);
  ((void) (0));
  ((void) (0));
  return rc;
}
# 79233 "c_tests/sqlite3.c"
static int freePage2(BtShared *pBt, MemPage *pMemPage, Pgno iPage){
  MemPage *pTrunk = 0;
  Pgno iTrunk = 0;
  MemPage *pPage1 = pBt->pPage1;
  MemPage *pPage;
  int rc;
  u32 nFree;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( iPage<2 || iPage>pBt->nPage ){
    return sqlite3CorruptError(79246);
  }
  if( pMemPage ){
    pPage = pMemPage;
    sqlite3PagerRef(pPage->pDbPage);
  }else{
    pPage = btreePageLookup(pBt, iPage);
  }


  rc = sqlite3PagerWrite(pPage1->pDbPage);
  if( rc ) goto freepage_out;
  nFree = sqlite3Get4byte(&pPage1->aData[36]);
  sqlite3Put4byte(&pPage1->aData[36], nFree+1);

  if( pBt->btsFlags & 0x0004 ){



    if( (!pPage && ((rc = btreeGetPage(pBt, iPage, &pPage, 0))!=0) )
     || ((rc = sqlite3PagerWrite(pPage->pDbPage))!=0)
    ){
      goto freepage_out;
    }
    memset(pPage->aData, 0, pPage->pBt->pageSize);
  }




  if( (pBt->autoVacuum) ){
    ptrmapPut(pBt, iPage, 2, 0, &rc);
    if( rc ) goto freepage_out;
  }
# 79288 "c_tests/sqlite3.c"
  if( nFree!=0 ){
    u32 nLeaf;

    iTrunk = sqlite3Get4byte(&pPage1->aData[32]);
    if( iTrunk>btreePagecount(pBt) ){
      rc = sqlite3CorruptError(79293);
      goto freepage_out;
    }
    rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0);
    if( rc!=0 ){
      goto freepage_out;
    }

    nLeaf = sqlite3Get4byte(&pTrunk->aData[4]);
    ((void) (0));
    if( nLeaf > (u32)pBt->usableSize/4 - 2 ){
      rc = sqlite3CorruptError(79304);
      goto freepage_out;
    }
    if( nLeaf < (u32)pBt->usableSize/4 - 8 ){
# 79327 "c_tests/sqlite3.c"
      rc = sqlite3PagerWrite(pTrunk->pDbPage);
      if( rc==0 ){
        sqlite3Put4byte(&pTrunk->aData[4], nLeaf+1);
        sqlite3Put4byte(&pTrunk->aData[8+nLeaf*4], iPage);
        if( pPage && (pBt->btsFlags & 0x0004)==0 ){
          sqlite3PagerDontWrite(pPage->pDbPage);
        }
        rc = btreeSetHasContent(pBt, iPage);
      }
                                                                               ;
      goto freepage_out;
    }
  }







  if( pPage==0 && 0!=(rc = btreeGetPage(pBt, iPage, &pPage, 0)) ){
    goto freepage_out;
  }
  rc = sqlite3PagerWrite(pPage->pDbPage);
  if( rc!=0 ){
    goto freepage_out;
  }
  sqlite3Put4byte(pPage->aData, iTrunk);
  sqlite3Put4byte(&pPage->aData[4], 0);
  sqlite3Put4byte(&pPage1->aData[32], iPage);
                                                                             ;

freepage_out:
  if( pPage ){
    pPage->isInit = 0;
  }
  releasePage(pPage);
  releasePage(pTrunk);
  return rc;
}
static void freePage(MemPage *pPage, int *pRC){
  if( (*pRC)==0 ){
    *pRC = freePage2(pPage->pBt, pPage, pPage->pgno);
  }
}




static __attribute__((noinline)) int clearCellOverflow(
  MemPage *pPage,
  unsigned char *pCell,
  CellInfo *pInfo
){
  BtShared *pBt;
  Pgno ovflPgno;
  int rc;
  int nOvfl;
  u32 ovflPageSize;

  ((void) (0));
  ((void) (0));
                                                     ;
                                                         ;
  if( pCell + pInfo->nSize > pPage->aDataEnd ){

    return sqlite3CorruptError(79393);
  }
  ovflPgno = sqlite3Get4byte(pCell + pInfo->nSize - 4);
  pBt = pPage->pBt;
  ((void) (0));
  ovflPageSize = pBt->usableSize - 4;
  nOvfl = (pInfo->nPayload - pInfo->nLocal + ovflPageSize - 1)/ovflPageSize;
  ((void) (0));


  while( nOvfl-- ){
    Pgno iNext = 0;
    MemPage *pOvfl = 0;
    if( ovflPgno<2 || ovflPgno>btreePagecount(pBt) ){



      return sqlite3CorruptError(79410);
    }
    if( nOvfl ){
      rc = getOverflowPage(pBt, ovflPgno, &pOvfl, &iNext);
      if( rc ) return rc;
    }

    if( ( pOvfl || ((pOvfl = btreePageLookup(pBt, ovflPgno))!=0) )
     && sqlite3PagerPageRefcount(pOvfl->pDbPage)!=1
    ){
# 79430 "c_tests/sqlite3.c"
      rc = sqlite3CorruptError(79430);
    }else{
      rc = freePage2(pBt, pOvfl, ovflPgno);
    }

    if( pOvfl ){
      sqlite3PagerUnref(pOvfl->pDbPage);
    }
    if( rc ) return rc;
    ovflPgno = iNext;
  }
  return 0;
}
# 79471 "c_tests/sqlite3.c"
static int fillInCell(
  MemPage *pPage,
  unsigned char *pCell,
  const BtreePayload *pX,
  int *pnSize
){
  int nPayload;
  const u8 *pSrc;
  int nSrc, n, rc, mn;
  int spaceLeft;
  MemPage *pToRelease;
  unsigned char *pPrior;
  unsigned char *pPayload;
  BtShared *pBt;
  Pgno pgnoOvfl;
  int nHeader;

  ((void) (0));



  ((void) (0));



  nHeader = pPage->childPtrSize;
  if( pPage->intKey ){
    nPayload = pX->nData + pX->nZero;
    pSrc = pX->pData;
    nSrc = pX->nData;
    ((void) (0));
    nHeader += (u8)(((u32)(nPayload)<(u32)0x80)?(*(&pCell[nHeader])=(unsigned char)(nPayload)),1: sqlite3PutVarint((&pCell[nHeader]),(nPayload)));
    nHeader += sqlite3PutVarint(&pCell[nHeader], *(u64*)&pX->nKey);
  }else{
    ((void) (0));
    nSrc = nPayload = (int)pX->nKey;
    pSrc = pX->pKey;
    nHeader += (u8)(((u32)(nPayload)<(u32)0x80)?(*(&pCell[nHeader])=(unsigned char)(nPayload)),1: sqlite3PutVarint((&pCell[nHeader]),(nPayload)));
  }


  pPayload = &pCell[nHeader];
  if( nPayload<=pPage->maxLocal ){


    n = nHeader + nPayload;
                    ;
                    ;
    if( n<4 ){
      n = 4;
      pPayload[nPayload] = 0;
    }
    *pnSize = n;
    ((void) (0));
                             ;
    memcpy(pPayload, pSrc, nSrc);
    memset(pPayload+nSrc, 0, nPayload-nSrc);
    return 0;
  }




  mn = pPage->minLocal;
  n = mn + (nPayload - mn) % (pPage->pBt->usableSize - 4);
                                ;
                                  ;
  if( n > pPage->maxLocal ) n = mn;
  spaceLeft = n;
  *pnSize = n + nHeader + 4;
  pPrior = &pCell[nHeader+n];
  pToRelease = 0;
  pgnoOvfl = 0;
  pBt = pPage->pBt;
# 79570 "c_tests/sqlite3.c"
  while( 1 ){
    n = nPayload;
    if( n>spaceLeft ) n = spaceLeft;



    ((void) (0));



    ((void) (0));


    if( nSrc>=n ){
      memcpy(pPayload, pSrc, n);
    }else if( nSrc>0 ){
      n = nSrc;
      memcpy(pPayload, pSrc, n);
    }else{
      memset(pPayload, 0, n);
    }
    nPayload -= n;
    if( nPayload<=0 ) break;
    pPayload += n;
    pSrc += n;
    nSrc -= n;
    spaceLeft -= n;
    if( spaceLeft==0 ){
      MemPage *pOvfl = 0;

      Pgno pgnoPtrmap = pgnoOvfl;
      if( pBt->autoVacuum ){
        do{
          pgnoOvfl++;
        } while(
          (ptrmapPageno((pBt), (pgnoOvfl))==(pgnoOvfl)) || pgnoOvfl==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1))
        );
      }

      rc = allocateBtreePage(pBt, &pOvfl, &pgnoOvfl, pgnoOvfl, 0);
# 79621 "c_tests/sqlite3.c"
      if( pBt->autoVacuum && rc==0 ){
        u8 eType = (pgnoPtrmap?4:3);
        ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap, &rc);
        if( rc ){
          releasePage(pOvfl);
        }
      }

      if( rc ){
        releasePage(pToRelease);
        return rc;
      }



      ((void) (0));



      ((void) (0));


      sqlite3Put4byte(pPrior, pgnoOvfl);
      releasePage(pToRelease);
      pToRelease = pOvfl;
      pPrior = pOvfl->aData;
      sqlite3Put4byte(pPrior, 0);
      pPayload = &pOvfl->aData[4];
      spaceLeft = pBt->usableSize - 4;
    }
  }
  releasePage(pToRelease);
  return 0;
}
# 79664 "c_tests/sqlite3.c"
static void dropCell(MemPage *pPage, int idx, int sz, int *pRC){
  u32 pc;
  u8 *data;
  u8 *ptr;
  int rc;
  int hdr;

  if( *pRC ) return;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  data = pPage->aData;
  ptr = &pPage->aCellIdx[2*idx];
  ((void) (0));
  pc = ((ptr)[0]<<8 | (ptr)[1]);
  hdr = pPage->hdrOffset;
                                             ;
                                           ;
  if( pc+sz > pPage->pBt->usableSize ){
    *pRC = sqlite3CorruptError(79686);
    return;
  }
  rc = freeSpace(pPage, pc, sz);
  if( rc ){
    *pRC = rc;
    return;
  }
  pPage->nCell--;
  if( pPage->nCell==0 ){
    memset(&data[hdr+1], 0, 4);
    data[hdr+7] = 0;
    ((&data[hdr+5])[0] = (u8)((pPage->pBt->usableSize)>>8), (&data[hdr+5])[1] = (u8)(pPage->pBt->usableSize));
    pPage->nFree = pPage->pBt->usableSize - pPage->hdrOffset
                       - pPage->childPtrSize - 8;
  }else{
    memmove(ptr, ptr+2, 2*(pPage->nCell - idx));
    ((&data[hdr+3])[0] = (u8)((pPage->nCell)>>8), (&data[hdr+3])[1] = (u8)(pPage->nCell));
    pPage->nFree += 2;
  }
}
# 79728 "c_tests/sqlite3.c"
static int insertCell(
  MemPage *pPage,
  int i,
  u8 *pCell,
  int sz,
  u8 *pTemp,
  Pgno iChild
){
  int idx = 0;
  int j;
  u8 *data;
  u8 *pIns;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pPage->nOverflow || sz+2>pPage->nFree ){
    if( pTemp ){
      memcpy(pTemp, pCell, sz);
      pCell = pTemp;
    }
    sqlite3Put4byte(pCell, iChild);
    j = pPage->nOverflow++;



    ((void) (0));
    pPage->apOvfl[j] = pCell;
    pPage->aiOvfl[j] = (u16)i;






    ((void) (0));
    ((void) (0));
  }else{
    int rc = sqlite3PagerWrite(pPage->pDbPage);
    if( (rc!=0) ){
      return rc;
    }
    ((void) (0));
    data = pPage->aData;
    ((void) (0));
    rc = allocateSpace(pPage, sz, &idx);
    if( rc ){ return rc; }


    ((void) (0));
    ((void) (0));
    ((void) (0));
    pPage->nFree -= (u16)(2 + sz);





    memcpy(&data[idx+4], pCell+4, sz-4);
    sqlite3Put4byte(&data[idx], iChild);
    pIns = pPage->aCellIdx + i*2;
    memmove(pIns+2, pIns, 2*(pPage->nCell - i));
    ((pIns)[0] = (u8)((idx)>>8), (pIns)[1] = (u8)(idx));
    pPage->nCell++;

    if( (++data[pPage->hdrOffset+4])==0 ) data[pPage->hdrOffset+3]++;
    ((void) (0));

    if( pPage->pBt->autoVacuum ){
      int rc2 = 0;



      ptrmapPutOvflPtr(pPage, pPage, pCell, &rc2);
      if( rc2 ) return rc2;
    }

  }
  return 0;
}
# 79825 "c_tests/sqlite3.c"
static int insertCellFast(
  MemPage *pPage,
  int i,
  u8 *pCell,
  int sz
){
  int idx = 0;
  int j;
  u8 *data;
  u8 *pIns;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( sz+2>pPage->nFree ){
    j = pPage->nOverflow++;



    ((void) (0));
    pPage->apOvfl[j] = pCell;
    pPage->aiOvfl[j] = (u16)i;






    ((void) (0));
    ((void) (0));
  }else{
    int rc = sqlite3PagerWrite(pPage->pDbPage);
    if( rc!=0 ){
      return rc;
    }
    ((void) (0));
    data = pPage->aData;
    ((void) (0));
    rc = allocateSpace(pPage, sz, &idx);
    if( rc ){ return rc; }


    ((void) (0));
    ((void) (0));
    ((void) (0));
    pPage->nFree -= (u16)(2 + sz);
    memcpy(&data[idx], pCell, sz);
    pIns = pPage->aCellIdx + i*2;
    memmove(pIns+2, pIns, 2*(pPage->nCell - i));
    ((pIns)[0] = (u8)((idx)>>8), (pIns)[1] = (u8)(idx));
    pPage->nCell++;

    if( (++data[pPage->hdrOffset+4])==0 ) data[pPage->hdrOffset+3]++;
    ((void) (0));

    if( pPage->pBt->autoVacuum ){
      int rc2 = 0;



      ptrmapPutOvflPtr(pPage, pPage, pCell, &rc2);
      if( rc2 ) return rc2;
    }

  }
  return 0;
}
# 79982 "c_tests/sqlite3.c"
typedef struct CellArray CellArray;
struct CellArray {
  int nCell;
  MemPage *pRef;
  u8 **apCell;
  u16 *szCell;
  u8 *apEnd[3*2];
  int ixNx[3*2];
};





static void populateCellCache(CellArray *p, int idx, int N){
  MemPage *pRef = p->pRef;
  u16 *szCell = p->szCell;
  ((void) (0));
  while( N>0 ){
    ((void) (0));
    if( szCell[idx]==0 ){
      szCell[idx] = pRef->xCellSize(pRef, p->apCell[idx]);
    }else{
      ((void) (0));

    }
    idx++;
    N--;
  }
}




static __attribute__((noinline)) u16 computeCellSize(CellArray *p, int N){
  ((void) (0));
  ((void) (0));
  p->szCell[N] = p->pRef->xCellSize(p->pRef, p->apCell[N]);
  return p->szCell[N];
}
static u16 cachedCellSize(CellArray *p, int N){
  ((void) (0));
  if( p->szCell[N] ) return p->szCell[N];
  return computeCellSize(p, N);
}
# 80041 "c_tests/sqlite3.c"
static int rebuildPage(
  CellArray *pCArray,
  int iFirst,
  int nCell,
  MemPage *pPg
){
  const int hdr = pPg->hdrOffset;
  u8 * const aData = pPg->aData;
  const int usableSize = pPg->pBt->usableSize;
  u8 * const pEnd = &aData[usableSize];
  int i = iFirst;
  u32 j;
  int iEnd = i+nCell;
  u8 *pCellptr = pPg->aCellIdx;
  u8 *pTmp = sqlite3PagerTempSpace(pPg->pBt->pPager);
  u8 *pData;
  int k;
  u8 *pSrcEnd;

  ((void) (0));
  ((void) (0));
  j = ((&aData[hdr+5])[0]<<8 | (&aData[hdr+5])[1]);
  if( j>(u32)usableSize ){ j = 0; }
  memcpy(&pTmp[j], &aData[j], usableSize - j);

  ((void) (0));
  for(k=0; pCArray->ixNx[k]<=i; k++){}
  pSrcEnd = pCArray->apEnd[k];

  pData = pEnd;
  while( 1 ){
    u8 *pCell = pCArray->apCell[i];
    u16 sz = pCArray->szCell[i];
    ((void) (0));
    if( (((uptr)(pCell)>=(uptr)(aData+j))&&((uptr)(pCell)<(uptr)(pEnd))) ){
      if( ((uptr)(pCell+sz))>(uptr)pEnd ) return sqlite3CorruptError(80076);
      pCell = &pTmp[pCell - aData];
    }else if( (uptr)(pCell+sz)>(uptr)pSrcEnd
           && (uptr)(pCell)<(uptr)pSrcEnd
    ){
      return sqlite3CorruptError(80081);
    }

    pData -= sz;
    ((pCellptr)[0] = (u8)(((pData - aData))>>8), (pCellptr)[1] = (u8)((pData - aData)));
    pCellptr += 2;
    if( pData < pCellptr ) return sqlite3CorruptError(80087);
    memmove(pData, pCell, sz);
    ((void) (0));
    i++;
    if( i>=iEnd ) break;
    if( pCArray->ixNx[k]<=i ){
      k++;
      pSrcEnd = pCArray->apEnd[k];
    }
  }


  ((void) (0));
  pPg->nCell = (u16)nCell;
  pPg->nOverflow = 0;

  ((&aData[hdr+1])[0] = (u8)((0)>>8), (&aData[hdr+1])[1] = (u8)(0));
  ((&aData[hdr+3])[0] = (u8)((pPg->nCell)>>8), (&aData[hdr+3])[1] = (u8)(pPg->nCell));
  ((&aData[hdr+5])[0] = (u8)((pData - aData)>>8), (&aData[hdr+5])[1] = (u8)(pData - aData));
  aData[hdr+7] = 0x00;
  return 0;
}
# 80134 "c_tests/sqlite3.c"
static int pageInsertArray(
  MemPage *pPg,
  u8 *pBegin,
  u8 **ppData,
  u8 *pCellptr,
  int iFirst,
  int nCell,
  CellArray *pCArray
){
  int i = iFirst;
  u8 *aData = pPg->aData;
  u8 *pData = *ppData;
  int iEnd = iFirst + nCell;
  int k;
  u8 *pEnd;
  ((void) (0));
  if( iEnd<=iFirst ) return 0;
  ((void) (0));
  for(k=0; pCArray->ixNx[k]<=i ; k++){}
  pEnd = pCArray->apEnd[k];
  while( 1 ){
    int sz, rc;
    u8 *pSlot;
    ((void) (0));
    sz = pCArray->szCell[i];
    if( (aData[1]==0 && aData[2]==0) || (pSlot = pageFindSlot(pPg,sz,&rc))==0 ){
      if( (pData - pBegin)<sz ) return 1;
      pData -= sz;
      pSlot = pData;
    }



    ((void) (0));


    if( (uptr)(pCArray->apCell[i]+sz)>(uptr)pEnd
     && (uptr)(pCArray->apCell[i])<(uptr)pEnd
    ){
      ((void) (0));
      (void)sqlite3CorruptError(80174);
      return 1;
    }
    memmove(pSlot, pCArray->apCell[i], sz);
    ((pCellptr)[0] = (u8)(((pSlot - aData))>>8), (pCellptr)[1] = (u8)((pSlot - aData)));
    pCellptr += 2;
    i++;
    if( i>=iEnd ) break;
    if( pCArray->ixNx[k]<=i ){
      k++;
      pEnd = pCArray->apEnd[k];
    }
  }
  *ppData = pData;
  return 0;
}
# 80200 "c_tests/sqlite3.c"
static int pageFreeArray(
  MemPage *pPg,
  int iFirst,
  int nCell,
  CellArray *pCArray
){
  u8 * const aData = pPg->aData;
  u8 * const pEnd = &aData[pPg->pBt->usableSize];
  u8 * const pStart = &aData[pPg->hdrOffset + 8 + pPg->childPtrSize];
  int nRet = 0;
  int i, j;
  int iEnd = iFirst + nCell;
  int nFree = 0;
  int aOfst[10];
  int aAfter[10];

  for(i=iFirst; i<iEnd; i++){
    u8 *pCell = pCArray->apCell[i];
    if( (((uptr)(pCell)>=(uptr)(pStart))&&((uptr)(pCell)<(uptr)(pEnd))) ){
      int sz;
      int iAfter;
      int iOfst;



      sz = pCArray->szCell[i]; ((void) (0));
      iOfst = (u16)(pCell - aData);
      iAfter = iOfst+sz;
      for(j=0; j<nFree; j++){
        if( aOfst[j]==iAfter ){
          aOfst[j] = iOfst;
          break;
        }else if( aAfter[j]==iOfst ){
          aAfter[j] = iAfter;
          break;
        }
      }
      if( j>=nFree ){
        if( nFree>=(int)(sizeof(aOfst)/sizeof(aOfst[0])) ){
          for(j=0; j<nFree; j++){
            freeSpace(pPg, aOfst[j], aAfter[j]-aOfst[j]);
          }
          nFree = 0;
        }
        aOfst[nFree] = iOfst;
        aAfter[nFree] = iAfter;
        if( &aData[iAfter]>pEnd ) return 0;
        nFree++;
      }
      nRet++;
    }
  }
  for(j=0; j<nFree; j++){
    freeSpace(pPg, aOfst[j], aAfter[j]-aOfst[j]);
  }
  return nRet;
}
# 80270 "c_tests/sqlite3.c"
static int editPage(
  MemPage *pPg,
  int iOld,
  int iNew,
  int nNew,
  CellArray *pCArray
){
  u8 * const aData = pPg->aData;
  const int hdr = pPg->hdrOffset;
  u8 *pBegin = &pPg->aCellIdx[nNew * 2];
  int nCell = pPg->nCell;
  u8 *pData;
  u8 *pCellptr;
  int i;
  int iOldEnd = iOld + pPg->nCell + pPg->nOverflow;
  int iNewEnd = iNew + nNew;







  ((void) (0));
  if( iOld<iNew ){
    int nShift = pageFreeArray(pPg, iOld, iNew-iOld, pCArray);
    if( (nShift>nCell) ) return sqlite3CorruptError(80296);
    memmove(pPg->aCellIdx, &pPg->aCellIdx[nShift*2], nCell*2);
    nCell -= nShift;
  }
  if( iNewEnd < iOldEnd ){
    int nTail = pageFreeArray(pPg, iNewEnd, iOldEnd - iNewEnd, pCArray);
    ((void) (0));
    nCell -= nTail;
  }

  pData = &aData[((&aData[hdr+5])[0]<<8 | (&aData[hdr+5])[1])];
  if( pData<pBegin ) goto editpage_fail;
  if( (pData>pPg->aDataEnd) ) goto editpage_fail;


  if( iNew<iOld ){
    int nAdd = ((nNew)<(iOld-iNew)?(nNew):(iOld-iNew));
    ((void) (0));
    ((void) (0));
    pCellptr = pPg->aCellIdx;
    memmove(&pCellptr[nAdd*2], pCellptr, nCell*2);
    if( pageInsertArray(
          pPg, pBegin, &pData, pCellptr,
          iNew, nAdd, pCArray
    ) ) goto editpage_fail;
    nCell += nAdd;
  }


  for(i=0; i<pPg->nOverflow; i++){
    int iCell = (iOld + pPg->aiOvfl[i]) - iNew;
    if( iCell>=0 && iCell<nNew ){
      pCellptr = &pPg->aCellIdx[iCell * 2];
      if( nCell>iCell ){
        memmove(&pCellptr[2], pCellptr, (nCell - iCell) * 2);
      }
      nCell++;
      cachedCellSize(pCArray, iCell+iNew);
      if( pageInsertArray(
            pPg, pBegin, &pData, pCellptr,
            iCell+iNew, 1, pCArray
      ) ) goto editpage_fail;
    }
  }


  ((void) (0));
  pCellptr = &pPg->aCellIdx[nCell*2];
  if( pageInsertArray(
        pPg, pBegin, &pData, pCellptr,
        iNew+nCell, nNew-nCell, pCArray
      )
  ){
    goto editpage_fail;
  }

  ((void) (0));
  pPg->nCell = (u16)nNew;
  pPg->nOverflow = 0;

  ((&aData[hdr+3])[0] = (u8)((pPg->nCell)>>8), (&aData[hdr+3])[1] = (u8)(pPg->nCell));
  ((&aData[hdr+5])[0] = (u8)((pData - aData)>>8), (&aData[hdr+5])[1] = (u8)(pData - aData));
# 80371 "c_tests/sqlite3.c"
  return 0;
 editpage_fail:

  if( nNew<1 ) return sqlite3CorruptError(80374);
  populateCellCache(pCArray, iNew, nNew);
  return rebuildPage(pCArray, iNew, nNew, pPg);
}
# 80404 "c_tests/sqlite3.c"
static int balance_quick(MemPage *pParent, MemPage *pPage, u8 *pSpace){
  BtShared *const pBt = pPage->pBt;
  MemPage *pNew;
  int rc;
  Pgno pgnoNew;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pPage->nCell==0 ) return sqlite3CorruptError(80414);
  ((void) (0));
  ((void) (0));





  rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0);

  if( rc==0 ){

    u8 *pOut = &pSpace[4];
    u8 *pCell = pPage->apOvfl[0];
    u16 szCell = pPage->xCellSize(pPage, pCell);
    u8 *pStop;
    CellArray b;

    ((void) (0));
    ((void) (0));
    zeroPage(pNew, 0x01|0x04|0x08);
    b.nCell = 1;
    b.pRef = pPage;
    b.apCell = &pCell;
    b.szCell = &szCell;
    b.apEnd[0] = pPage->aDataEnd;
    b.ixNx[0] = 2;
    b.ixNx[3*2-1] = 0x7fffffff;
    rc = rebuildPage(&b, 0, 1, pNew);
    if( (rc) ){
      releasePage(pNew);
      return rc;
    }
    pNew->nFree = pBt->usableSize - pNew->cellOffset - 2 - szCell;
# 80458 "c_tests/sqlite3.c"
    if( (pBt->autoVacuum) ){
      ptrmapPut(pBt, pgnoNew, 5, pParent->pgno, &rc);
      if( szCell>pNew->minLocal ){
        ptrmapPutOvflPtr(pNew, pNew, pCell, &rc);
      }
    }
# 80478 "c_tests/sqlite3.c"
    pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(pPage->nCell-1)])[0]<<8 | (&(pPage)->aCellIdx[2*(pPage->nCell-1)])[1])));
    pStop = &pCell[9];
    while( (*(pCell++)&0x80) && pCell<pStop );
    pStop = &pCell[9];
    while( ((*(pOut++) = *(pCell++))&0x80) && pCell<pStop );


    if( rc==0 ){
      rc = insertCell(pParent, pParent->nCell, pSpace, (int)(pOut-pSpace),
                      0, pPage->pgno);
    }


    sqlite3Put4byte(&pParent->aData[pParent->hdrOffset+8], pgnoNew);


    releasePage(pNew);
  }

  return rc;
}
# 80560 "c_tests/sqlite3.c"
static void copyNodeContent(MemPage *pFrom, MemPage *pTo, int *pRC){
  if( (*pRC)==0 ){
    BtShared * const pBt = pFrom->pBt;
    u8 * const aFrom = pFrom->aData;
    u8 * const aTo = pTo->aData;
    int const iFromHdr = pFrom->hdrOffset;
    int const iToHdr = ((pTo->pgno==1) ? 100 : 0);
    int rc;
    int iData;


    ((void) (0));
    ((void) (0));
    ((void) (0));


    iData = ((&aFrom[iFromHdr+5])[0]<<8 | (&aFrom[iFromHdr+5])[1]);
    memcpy(&aTo[iData], &aFrom[iData], pBt->usableSize-iData);
    memcpy(&aTo[iToHdr], &aFrom[iFromHdr], pFrom->cellOffset + 2*pFrom->nCell);






    pTo->isInit = 0;
    rc = btreeInitPage(pTo);
    if( rc==0 ) rc = btreeComputeFreeSpace(pTo);
    if( rc!=0 ){
      *pRC = rc;
      return;
    }




    if( (pBt->autoVacuum) ){
      *pRC = setChildPtrmaps(pTo);
    }
  }
}
# 80642 "c_tests/sqlite3.c"
static int balance_nonroot(
  MemPage *pParent,
  int iParentIdx,
  u8 *aOvflSpace,
  int isRoot,
  int bBulk
){
  BtShared *pBt;
  int nMaxCells = 0;
  int nNew = 0;
  int nOld;
  int i, j, k;
  int nxDiv;
  int rc = 0;
  u16 leafCorrection;
  int leafData;
  int usableSpace;
  int pageFlags;
  int iSpace1 = 0;
  int iOvflSpace = 0;
  u64 szScratch;
  MemPage *apOld[3];
  MemPage *apNew[3 +2];
  u8 *pRight;
  u8 *apDiv[3 -1];
  int cntNew[3 +2];
  int cntOld[3 +2];
  int szNew[3 +2];
  u8 *aSpace1;
  Pgno pgno;
  u8 abDone[3 +2];
  Pgno aPgno[3 +2];
  CellArray b;

  memset(abDone, 0, sizeof(abDone));
  ((void) (0));
  memset(&b, 0, sizeof(b)-sizeof(b.ixNx[0]));
  b.ixNx[3*2-1] = 0x7fffffff;
  pBt = pParent->pBt;
  ((void) (0));
  ((void) (0));






  ((void) (0));
  ((void) (0));

  if( !aOvflSpace ){
    return 7;
  }
  ((void) (0));
# 80708 "c_tests/sqlite3.c"
  i = pParent->nOverflow + pParent->nCell;
  if( i<2 ){
    nxDiv = 0;
  }else{
    ((void) (0));
    if( iParentIdx==0 ){
      nxDiv = 0;
    }else if( iParentIdx==i ){
      nxDiv = i-2+bBulk;
    }else{
      nxDiv = iParentIdx-1;
    }
    i = 2-bBulk;
  }
  nOld = i+1;
  if( (i+nxDiv-pParent->nOverflow)==pParent->nCell ){
    pRight = &pParent->aData[pParent->hdrOffset+8];
  }else{
    pRight = ((pParent)->aData + ((pParent)->maskPage & ((&(pParent)->aCellIdx[2*(i+nxDiv-pParent->nOverflow)])[0]<<8 | (&(pParent)->aCellIdx[2*(i+nxDiv-pParent->nOverflow)])[1])));
  }
  pgno = sqlite3Get4byte(pRight);
  while( 1 ){
    if( rc==0 ){
      rc = getAndInitPage(pBt, pgno, &apOld[i], 0);
    }
    if( rc ){
      memset(apOld, 0, (i+1)*sizeof(MemPage*));
      goto balance_cleanup;
    }
    if( apOld[i]->nFree<0 ){
      rc = btreeComputeFreeSpace(apOld[i]);
      if( rc ){
        memset(apOld, 0, (i)*sizeof(MemPage*));
        goto balance_cleanup;
      }
    }
    nMaxCells += apOld[i]->nCell + ((int)(sizeof(pParent->apOvfl)/sizeof(pParent->apOvfl[0])));
    if( (i--)==0 ) break;

    if( pParent->nOverflow && i+nxDiv==pParent->aiOvfl[0] ){
      apDiv[i] = pParent->apOvfl[0];
      pgno = sqlite3Get4byte(apDiv[i]);
      szNew[i] = pParent->xCellSize(pParent, apDiv[i]);
      pParent->nOverflow = 0;
    }else{
      apDiv[i] = ((pParent)->aData + ((pParent)->maskPage & ((&(pParent)->aCellIdx[2*(i+nxDiv-pParent->nOverflow)])[0]<<8 | (&(pParent)->aCellIdx[2*(i+nxDiv-pParent->nOverflow)])[1])));
      pgno = sqlite3Get4byte(apDiv[i]);
      szNew[i] = pParent->xCellSize(pParent, apDiv[i]);
# 80769 "c_tests/sqlite3.c"
      if( pBt->btsFlags & 0x000c ){
        int iOff;



        iOff = ((int)(long int)(apDiv[i])) - ((int)(long int)(pParent->aData));
        if( (iOff+szNew[i])<=(int)pBt->usableSize ){
          memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);
          apDiv[i] = &aOvflSpace[apDiv[i]-pParent->aData];
        }
      }
      dropCell(pParent, i+nxDiv-pParent->nOverflow, szNew[i], &rc);
    }
  }



  nMaxCells = (nMaxCells + 3)&~3;




  szScratch =
       nMaxCells*sizeof(u8*)
     + nMaxCells*sizeof(u16)
     + pBt->pageSize;

  ((void) (0));
  b.apCell = sqlite3DbMallocRaw(0,szScratch);
  if( b.apCell==0 ){
    rc = 7;
    goto balance_cleanup;
  }
  b.szCell = (u16*)&b.apCell[nMaxCells];
  aSpace1 = (u8*)&b.szCell[nMaxCells];
  ((void) (0));
# 80822 "c_tests/sqlite3.c"
  b.pRef = apOld[0];
  leafCorrection = b.pRef->leaf*4;
  leafData = b.pRef->intKeyLeaf;
  for(i=0; i<nOld; i++){
    MemPage *pOld = apOld[i];
    int limit = pOld->nCell;
    u8 *aData = pOld->aData;
    u16 maskPage = pOld->maskPage;
    u8 *piCell = aData + pOld->cellOffset;
    u8 *piEnd;





    if( pOld->aData[0]!=apOld[0]->aData[0] ){
      rc = sqlite3CorruptError(80838);
      goto balance_cleanup;
    }
# 80859 "c_tests/sqlite3.c"
    memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit+pOld->nOverflow));
    if( pOld->nOverflow>0 ){
      if( (limit<pOld->aiOvfl[0]) ){
        rc = sqlite3CorruptError(80862);
        goto balance_cleanup;
      }
      limit = pOld->aiOvfl[0];
      for(j=0; j<limit; j++){
        b.apCell[b.nCell] = aData + (maskPage & ((piCell)[0]<<8 | (piCell)[1]));
        piCell += 2;
        b.nCell++;
      }
      for(k=0; k<pOld->nOverflow; k++){
        ((void) (0));
        b.apCell[b.nCell] = pOld->apOvfl[k];
        b.nCell++;
      }
    }
    piEnd = aData + pOld->cellOffset + 2*pOld->nCell;
    while( piCell<piEnd ){
      ((void) (0));
      b.apCell[b.nCell] = aData + (maskPage & ((piCell)[0]<<8 | (piCell)[1]));
      piCell += 2;
      b.nCell++;
    }
    ((void) (0));

    cntOld[i] = b.nCell;
    if( i<nOld-1 && !leafData){
      u16 sz = (u16)szNew[i];
      u8 *pTemp;
      ((void) (0));
      b.szCell[b.nCell] = sz;
      pTemp = &aSpace1[iSpace1];
      iSpace1 += sz;
      ((void) (0));
      ((void) (0));
      memcpy(pTemp, apDiv[i], sz);
      b.apCell[b.nCell] = pTemp+leafCorrection;
      ((void) (0));
      b.szCell[b.nCell] = b.szCell[b.nCell] - leafCorrection;
      if( !pOld->leaf ){
        ((void) (0));
        ((void) (0));


        memcpy(b.apCell[b.nCell], &pOld->aData[8], 4);
      }else{
        ((void) (0));
        while( b.szCell[b.nCell]<4 ){


          ((void) (0));
          ((void) (0));
          aSpace1[iSpace1++] = 0x00;
          b.szCell[b.nCell]++;
        }
      }
      b.nCell++;
    }
  }
# 80937 "c_tests/sqlite3.c"
  usableSpace = pBt->usableSize - 12 + leafCorrection;
  for(i=k=0; i<nOld; i++, k++){
    MemPage *p = apOld[i];
    b.apEnd[k] = p->aDataEnd;
    b.ixNx[k] = cntOld[i];
    if( k && b.ixNx[k]==b.ixNx[k-1] ){
      k--;
    }
    if( !leafData ){
      k++;
      b.apEnd[k] = pParent->aDataEnd;
      b.ixNx[k] = cntOld[i]+1;
    }
    ((void) (0));
    szNew[i] = usableSpace - p->nFree;
    for(j=0; j<p->nOverflow; j++){
      szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);
    }
    cntNew[i] = cntOld[i];
  }
  k = nOld;
  for(i=0; i<k; i++){
    int sz;
    while( szNew[i]>usableSpace ){
      if( i+1>=k ){
        k = i+2;
        if( k>3 +2 ){ rc = sqlite3CorruptError(80963); goto balance_cleanup; }
        szNew[k-1] = 0;
        cntNew[k-1] = b.nCell;
      }
      sz = 2 + cachedCellSize(&b, cntNew[i]-1);
      szNew[i] -= sz;
      if( !leafData ){
        if( cntNew[i]<b.nCell ){
          sz = 2 + cachedCellSize(&b, cntNew[i]);
        }else{
          sz = 0;
        }
      }
      szNew[i+1] += sz;
      cntNew[i]--;
    }
    while( cntNew[i]<b.nCell ){
      sz = 2 + cachedCellSize(&b, cntNew[i]);
      if( szNew[i]+sz>usableSpace ) break;
      szNew[i] += sz;
      cntNew[i]++;
      if( !leafData ){
        if( cntNew[i]<b.nCell ){
          sz = 2 + cachedCellSize(&b, cntNew[i]);
        }else{
          sz = 0;
        }
      }
      szNew[i+1] -= sz;
    }
    if( cntNew[i]>=b.nCell ){
      k = i+1;
    }else if( cntNew[i] <= (i>0 ? cntNew[i-1] : 0) ){
      rc = sqlite3CorruptError(80996);
      goto balance_cleanup;
    }
  }
# 81012 "c_tests/sqlite3.c"
  for(i=k-1; i>0; i--){
    int szRight = szNew[i];
    int szLeft = szNew[i-1];
    int r;
    int d;

    r = cntNew[i-1] - 1;
    d = r + 1 - leafData;
    (void)cachedCellSize(&b, d);
    do{
      int szR, szD;
      ((void) (0));
      ((void) (0));
      szR = cachedCellSize(&b, r);
      szD = b.szCell[d];
      if( szRight!=0
       && (bBulk || szRight+szD+2 > szLeft-(szR+(i==k-1?0:2)))){
        break;
      }
      szRight += szD + 2;
      szLeft -= szR + 2;
      cntNew[i-1] = r;
      r--;
      d--;
    }while( r>=0 );
    szNew[i] = szRight;
    szNew[i-1] = szLeft;
    if( cntNew[i-1] <= (i>1 ? cntNew[i-2] : 0) ){
      rc = sqlite3CorruptError(81040);
      goto balance_cleanup;
    }
  }
# 81052 "c_tests/sqlite3.c"
  ((void) (0));




    ;




  pageFlags = apOld[0]->aData[0];
  for(i=0; i<k; i++){
    MemPage *pNew;
    if( i<nOld ){
      pNew = apNew[i] = apOld[i];
      apOld[i] = 0;
      rc = sqlite3PagerWrite(pNew->pDbPage);
      nNew++;
      if( sqlite3PagerPageRefcount(pNew->pDbPage)!=1+(i==(iParentIdx-nxDiv))
       && rc==0
      ){
        rc = sqlite3CorruptError(81073);
      }
      if( rc ) goto balance_cleanup;
    }else{
      ((void) (0));
      rc = allocateBtreePage(pBt, &pNew, &pgno, (bBulk ? 1 : pgno), 0);
      if( rc ) goto balance_cleanup;
      zeroPage(pNew, pageFlags);
      apNew[i] = pNew;
      nNew++;
      cntOld[i] = b.nCell;


      if( (pBt->autoVacuum) ){
        ptrmapPut(pBt, pNew->pgno, 5, pParent->pgno, &rc);
        if( rc!=0 ){
          goto balance_cleanup;
        }
      }
    }
  }
# 81107 "c_tests/sqlite3.c"
  for(i=0; i<nNew; i++){
    aPgno[i] = apNew[i]->pgno;
    ((void) (0));
    ((void) (0));
  }
  for(i=0; i<nNew-1; i++){
    int iB = i;
    for(j=i+1; j<nNew; j++){
      if( apNew[j]->pgno < apNew[iB]->pgno ) iB = j;
    }






    if( iB!=i ){
      Pgno pgnoA = apNew[i]->pgno;
      Pgno pgnoB = apNew[iB]->pgno;
      Pgno pgnoTemp = (sqlite3PendingByte/pBt->pageSize)+1;
      u16 fgA = apNew[i]->pDbPage->flags;
      u16 fgB = apNew[iB]->pDbPage->flags;
      sqlite3PagerRekey(apNew[i]->pDbPage, pgnoTemp, fgB);
      sqlite3PagerRekey(apNew[iB]->pDbPage, pgnoA, fgA);
      sqlite3PagerRekey(apNew[i]->pDbPage, pgnoB, fgB);
      apNew[i]->pgno = pgnoB;
      apNew[iB]->pgno = pgnoA;
    }
  }
# 81148 "c_tests/sqlite3.c"
    ;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  sqlite3Put4byte(pRight, apNew[nNew-1]->pgno);




  if( (pageFlags & 0x08)==0 && nOld!=nNew ){
    MemPage *pOld;
    if( nNew>nOld ){
      pOld = apNew[nOld-1];
    }else{
      pOld = apOld[nOld-1];
    }
    memcpy(&apNew[nNew-1]->aData[8], &pOld->aData[8], 4);
  }
# 81184 "c_tests/sqlite3.c"
  if( (pBt->autoVacuum) ){
    MemPage *pOld;
    MemPage *pNew = pOld = apNew[0];
    int cntOldNext = pNew->nCell + pNew->nOverflow;
    int iNew = 0;
    int iOld = 0;

    for(i=0; i<b.nCell; i++){
      u8 *pCell = b.apCell[i];
      while( i==cntOldNext ){
        iOld++;
        ((void) (0));
        ((void) (0));
        pOld = iOld<nNew ? apNew[iOld] : apOld[iOld];
        cntOldNext += pOld->nCell + pOld->nOverflow + !leafData;
      }
      if( i==cntNew[iNew] ){
        pNew = apNew[++iNew];
        if( !leafData ) continue;
      }







      if( iOld>=nNew
       || pNew->pgno!=aPgno[iOld]
       || !(((uptr)(pCell)>=(uptr)(pOld->aData))&&((uptr)(pCell)<(uptr)(pOld->aDataEnd)))
      ){
        if( !leafCorrection ){
          ptrmapPut(pBt, sqlite3Get4byte(pCell), 5, pNew->pgno, &rc);
        }
        if( cachedCellSize(&b,i)>pNew->minLocal ){
          ptrmapPutOvflPtr(pNew, pOld, pCell, &rc);
        }
        if( rc ) goto balance_cleanup;
      }
    }
  }


  for(i=0; i<nNew-1; i++){
    u8 *pCell;
    u8 *pTemp;
    int sz;
    u8 *pSrcEnd;
    MemPage *pNew = apNew[i];
    j = cntNew[i];

    ((void) (0));
    ((void) (0));
    pCell = b.apCell[j];
    sz = b.szCell[j] + leafCorrection;
    pTemp = &aOvflSpace[iOvflSpace];
    if( !pNew->leaf ){
      memcpy(&pNew->aData[8], pCell, 4);
    }else if( leafData ){





      CellInfo info;
      j--;
      pNew->xParseCell(pNew, b.apCell[j], &info);
      pCell = pTemp;
      sz = 4 + sqlite3PutVarint(&pCell[4], info.nKey);
      pTemp = 0;
    }else{
      pCell -= 4;
# 81267 "c_tests/sqlite3.c"
      if( b.szCell[j]==4 ){
        ((void) (0));
        sz = pParent->xCellSize(pParent, pCell);
      }
    }
    iOvflSpace += sz;
    ((void) (0));
    ((void) (0));
    ((void) (0));
    for(k=0; b.ixNx[k]<=j; k++){}
    pSrcEnd = b.apEnd[k];
    if( (((uptr)(pCell)<(uptr)(pSrcEnd))&&((uptr)(pCell+sz)>(uptr)(pSrcEnd))) ){
      rc = sqlite3CorruptError(81279);
      goto balance_cleanup;
    }
    rc = insertCell(pParent, nxDiv+i, pCell, sz, pTemp, pNew->pgno);
    if( rc!=0 ) goto balance_cleanup;
    ((void) (0));
  }
# 81309 "c_tests/sqlite3.c"
  for(i=1-nNew; i<nNew; i++){
    int iPg = i<0 ? -i : i;
    ((void) (0));
    ((void) (0));
    ((void) (0));
    if( abDone[iPg] ) continue;
    if( i>=0
     || cntOld[iPg-1]>=cntNew[iPg-1]
    ){
      int iNew;
      int iOld;
      int nNewCell;



      ((void) (0));



      ((void) (0));

      if( iPg==0 ){
        iNew = iOld = 0;
        nNewCell = cntNew[0];
      }else{
        iOld = iPg<nOld ? (cntOld[iPg-1] + !leafData) : b.nCell;
        iNew = cntNew[iPg-1] + !leafData;
        nNewCell = cntNew[iPg] - iNew;
      }

      rc = editPage(apNew[iPg], iOld, iNew, nNewCell, &b);
      if( rc ) goto balance_cleanup;
      abDone[iPg]++;
      apNew[iPg]->nFree = usableSpace-szNew[iPg];
      ((void) (0));
      ((void) (0));
    }
  }


  ((void) (0));

  ((void) (0));
  ((void) (0));

  if( isRoot && pParent->nCell==0 && pParent->hdrOffset<=apNew[0]->nFree ){
# 81370 "c_tests/sqlite3.c"
    ((void) (0));
    rc = defragmentPage(apNew[0], -1);
                             ;
    ((void) (0));




    copyNodeContent(apNew[0], pParent, &rc);
    freePage(apNew[0], &rc);
  }else if( (pBt->autoVacuum) && !leafCorrection ){



    for(i=0; i<nNew; i++){
      u32 key = sqlite3Get4byte(&apNew[i]->aData[8]);
      ptrmapPut(pBt, key, 5, apNew[i]->pgno, &rc);
    }
  }

  ((void) (0));

                               ;



  for(i=nNew; i<nOld; i++){
    freePage(apOld[i], &rc);
  }
# 81414 "c_tests/sqlite3.c"
balance_cleanup:
  sqlite3DbFree(0,b.apCell);
  for(i=0; i<nOld; i++){
    releasePage(apOld[i]);
  }
  for(i=0; i<nNew; i++){
    releasePage(apNew[i]);
  }

  return rc;
}
# 81446 "c_tests/sqlite3.c"
static int balance_deeper(MemPage *pRoot, MemPage **ppChild){
  int rc;
  MemPage *pChild = 0;
  Pgno pgnoChild = 0;
  BtShared *pBt = pRoot->pBt;

  ((void) (0));
  ((void) (0));





  rc = sqlite3PagerWrite(pRoot->pDbPage);
  if( rc==0 ){
    rc = allocateBtreePage(pBt,&pChild,&pgnoChild,pRoot->pgno,0);
    copyNodeContent(pRoot, pChild, &rc);
    if( (pBt->autoVacuum) ){
      ptrmapPut(pBt, pgnoChild, 5, pRoot->pgno, &rc);
    }
  }
  if( rc ){
    *ppChild = 0;
    releasePage(pChild);
    return rc;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));

                                                                       ;


  memcpy(pChild->aiOvfl, pRoot->aiOvfl,
         pRoot->nOverflow*sizeof(pRoot->aiOvfl[0]));
  memcpy(pChild->apOvfl, pRoot->apOvfl,
         pRoot->nOverflow*sizeof(pRoot->apOvfl[0]));
  pChild->nOverflow = pRoot->nOverflow;


  zeroPage(pRoot, pChild->aData[0] & ~0x08);
  sqlite3Put4byte(&pRoot->aData[pRoot->hdrOffset+8], pgnoChild);

  *ppChild = pChild;
  return 0;
}
# 81504 "c_tests/sqlite3.c"
static int anotherValidCursor(BtCursor *pCur){
  BtCursor *pOther;
  for(pOther=pCur->pBt->pCursor; pOther; pOther=pOther->pNext){
    if( pOther!=pCur
     && pOther->eState==0
     && pOther->pPage==pCur->pPage
    ){
      return sqlite3CorruptError(81511);
    }
  }
  return 0;
}
# 81527 "c_tests/sqlite3.c"
static int balance(BtCursor *pCur){
  int rc = 0;
  u8 aBalanceQuickSpace[13];
  u8 *pFree = 0;

                                          ;
                                           ;

  do {
    int iPage;
    MemPage *pPage = pCur->pPage;

    if( (pPage->nFree<0) && btreeComputeFreeSpace(pPage) ) break;
    if( pPage->nOverflow==0 && pPage->nFree*3<=(int)pCur->pBt->usableSize*2 ){




      break;
    }else if( (iPage = pCur->iPage)==0 ){
      if( pPage->nOverflow && (rc = anotherValidCursor(pCur))==0 ){





        ((void) (0));
                                           ;
        rc = balance_deeper(pPage, &pCur->apPage[1]);
        if( rc==0 ){
          pCur->iPage = 1;
          pCur->ix = 0;
          pCur->aiIdx[0] = 0;
          pCur->apPage[0] = pPage;
          pCur->pPage = pCur->apPage[1];
          ((void) (0));
        }
      }else{
        break;
      }
    }else if( sqlite3PagerPageRefcount(pPage->pDbPage)>1 ){



      rc = sqlite3CorruptError(81571);
    }else{
      MemPage * const pParent = pCur->apPage[iPage-1];
      int const iIdx = pCur->aiIdx[iPage-1];

      rc = sqlite3PagerWrite(pParent->pDbPage);
      if( rc==0 && pParent->nFree<0 ){
        rc = btreeComputeFreeSpace(pParent);
      }
      if( rc==0 ){

        if( pPage->intKeyLeaf
         && pPage->nOverflow==1
         && pPage->aiOvfl[0]==pPage->nCell
         && pParent->pgno!=1
         && pParent->nCell==iIdx
        ){
# 81601 "c_tests/sqlite3.c"
          ((void) (0));
                                            ;
          rc = balance_quick(pParent, pPage, aBalanceQuickSpace);
        }else

        {
# 81624 "c_tests/sqlite3.c"
          u8 *pSpace = sqlite3PageMalloc(pCur->pBt->pageSize);
          rc = balance_nonroot(pParent, iIdx, pSpace, iPage==1,
                               pCur->hints&0x00000001);
          if( pFree ){




            sqlite3PageFree(pFree);
          }




          pFree = pSpace;
        }
      }

      pPage->nOverflow = 0;


      releasePage(pPage);
      pCur->iPage--;
      ((void) (0));
      pCur->pPage = pCur->apPage[pCur->iPage];
    }
  }while( rc==0 );

  if( pFree ){
    sqlite3PageFree(pFree);
  }
  return rc;
}




static int btreeOverwriteContent(
  MemPage *pPage,
  u8 *pDest,
  const BtreePayload *pX,
  int iOffset,
  int iAmt
){
  int nData = pX->nData - iOffset;
  if( nData<=0 ){

    int i;
    for(i=0; i<iAmt && pDest[i]==0; i++){}
    if( i<iAmt ){
      int rc = sqlite3PagerWrite(pPage->pDbPage);
      if( rc ) return rc;
      memset(pDest + i, 0, iAmt - i);
    }
  }else{
    if( nData<iAmt ){


      int rc = btreeOverwriteContent(pPage, pDest+nData, pX, iOffset+nData,
                                 iAmt-nData);
      if( rc ) return rc;
      iAmt = nData;
    }
    if( memcmp(pDest, ((u8*)pX->pData) + iOffset, iAmt)!=0 ){
      int rc = sqlite3PagerWrite(pPage->pDbPage);
      if( rc ) return rc;




      memmove(pDest, ((u8*)pX->pData) + iOffset, iAmt);
    }
  }
  return 0;
}






static __attribute__((noinline)) int btreeOverwriteOverflowCell(
  BtCursor *pCur,
  const BtreePayload *pX
){
  int iOffset;
  int nTotal = pX->nData + pX->nZero;
  int rc;
  MemPage *pPage = pCur->pPage;
  BtShared *pBt;
  Pgno ovflPgno;
  u32 ovflPageSize;

  ((void) (0));


  rc = btreeOverwriteContent(pPage, pCur->info.pPayload, pX,
                             0, pCur->info.nLocal);
  if( rc ) return rc;


  iOffset = pCur->info.nLocal;
  ((void) (0));
  ((void) (0));
  ovflPgno = sqlite3Get4byte(pCur->info.pPayload + iOffset);
  pBt = pPage->pBt;
  ovflPageSize = pBt->usableSize - 4;
  do{
    rc = btreeGetPage(pBt, ovflPgno, &pPage, 0);
    if( rc ) return rc;
    if( sqlite3PagerPageRefcount(pPage->pDbPage)!=1 || pPage->isInit ){
      rc = sqlite3CorruptError(81735);
    }else{
      if( iOffset+ovflPageSize<(u32)nTotal ){
        ovflPgno = sqlite3Get4byte(pPage->aData);
      }else{
        ovflPageSize = nTotal - iOffset;
      }
      rc = btreeOverwriteContent(pPage, pPage->aData+4, pX,
                                 iOffset, ovflPageSize);
    }
    sqlite3PagerUnref(pPage->pDbPage);
    if( rc ) return rc;
    iOffset += ovflPageSize;
  }while( iOffset<nTotal );
  return 0;
}





static int btreeOverwriteCell(BtCursor *pCur, const BtreePayload *pX){
  int nTotal = pX->nData + pX->nZero;
  MemPage *pPage = pCur->pPage;

  if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd
   || pCur->info.pPayload < pPage->aData + pPage->cellOffset
  ){
    return sqlite3CorruptError(81763);
  }
  if( pCur->info.nLocal==nTotal ){

    return btreeOverwriteContent(pPage, pCur->info.pPayload, pX,
                                 0, pCur->info.nLocal);
  }else{

    return btreeOverwriteOverflowCell(pCur, pX);
  }
}
# 81806 "c_tests/sqlite3.c"
static int sqlite3BtreeInsert(
  BtCursor *pCur,
  const BtreePayload *pX,
  int flags,
  int seekResult
){
  int rc;
  int loc = seekResult;
  int szNew = 0;
  int idx;
  MemPage *pPage;
  Btree *p = pCur->pBtree;
  unsigned char *oldCell;
  unsigned char *newCell = 0;

  ((void) (0));
  ((void) (0));
# 81835 "c_tests/sqlite3.c"
  if( pCur->curFlags & 0x20 ){
    rc = saveAllCursors(p->pBt, pCur->pgnoRoot, pCur);
    if( rc ) return rc;
    if( loc && pCur->iPage<0 ){





      return sqlite3CorruptError(81844);
    }
  }




  if( pCur->eState>=3 ){
                                                ;
                                          ;
    rc = moveToRoot(pCur);
    if( rc && rc!=16 ) return rc;
  }

  ((void) (0));
  ((void) (0));


  ((void) (0));






  ((void) (0));

  if( pCur->pKeyInfo==0 ){
    ((void) (0));


    if( p->hasIncrblobCur ){
      invalidateIncrblobCursors(p, pCur->pgnoRoot, pX->nKey, 0);
    }
# 81894 "c_tests/sqlite3.c"
    if( (pCur->curFlags&0x02)!=0 && pX->nKey==pCur->info.nKey ){


      ((void) (0));
      if( pCur->info.nSize!=0
       && pCur->info.nPayload==(u32)pX->nData+pX->nZero
      ){

        return btreeOverwriteCell(pCur, pX);
      }
      ((void) (0));
    }else if( loc==0 ){




      rc = sqlite3BtreeTableMoveto(pCur, pX->nKey,
               (flags & 0x08)!=0, &loc);
      if( rc ) return rc;
    }
  }else{





    ((void) (0));






    if( loc==0 && (flags & 0x02)==0 ){
      if( pX->nMem ){
        UnpackedRecord r;
        r.pKeyInfo = pCur->pKeyInfo;
        r.aMem = pX->aMem;
        r.nField = pX->nMem;
        r.default_rc = 0;
        r.eqSeen = 0;
        rc = sqlite3BtreeIndexMoveto(pCur, &r, &loc);
      }else{
        rc = btreeMoveto(pCur, pX->pKey, pX->nKey,
                    (flags & 0x08)!=0, &loc);
      }
      if( rc ) return rc;
    }





    if( loc==0 ){
      getCellInfo(pCur);
      if( pCur->info.nKey==pX->nKey ){
        BtreePayload x2;
        x2.pData = pX->pKey;
        x2.nData = (int)pX->nKey; ((void) (0));
        x2.nZero = 0;
        return btreeOverwriteCell(pCur, &x2);
      }
    }
  }
  ((void) (0));


  pPage = pCur->pPage;
  ((void) (0));
  ((void) (0));
  if( pPage->nFree<0 ){
    if( (pCur->eState>1) ){

      rc = sqlite3CorruptError(81967);
    }else{
      rc = btreeComputeFreeSpace(pPage);
    }
    if( rc ) return rc;
  }



                                              ;
  ((void) (0));
  newCell = p->pBt->pTmpSpace;
  ((void) (0));
  ((void) (0));
  if( flags & 0x80 ){
    rc = 0;
    szNew = p->pBt->nPreformatSize;
    if( szNew<4 ){
      szNew = 4;
      newCell[3] = 0;
    }
    if( (p->pBt->autoVacuum) && szNew>pPage->maxLocal ){
      CellInfo info;
      pPage->xParseCell(pPage, newCell, &info);
      if( info.nPayload!=info.nLocal ){
        Pgno ovfl = sqlite3Get4byte(&newCell[szNew-4]);
        ptrmapPut(p->pBt, ovfl, 3, pPage->pgno, &rc);
        if( (rc) ) goto end_insert;
      }
    }
  }else{
    rc = fillInCell(pPage, newCell, pX, &szNew);
    if( rc ) goto end_insert;
  }
  ((void) (0));
  ((void) (0));
  idx = pCur->ix;
  pCur->info.nSize = 0;
  if( loc==0 ){
    CellInfo info;
    ((void) (0));
    if( idx>=pPage->nCell ){
      return sqlite3CorruptError(82009);
    }
    rc = sqlite3PagerWrite(pPage->pDbPage);
    if( rc ){
      goto end_insert;
    }
    oldCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(idx)])[0]<<8 | (&(pPage)->aCellIdx[2*(idx)])[1])));
    if( !pPage->leaf ){
      memcpy(newCell, oldCell, 4);
    }
    pPage->xParseCell(pPage, oldCell, &info); if( info.nLocal!=info.nPayload ){ rc = clearCellOverflow(pPage, oldCell, &info); }else{ rc = 0; };
                                               ;
    (pCur->curFlags &= ~0x04);
    if( info.nSize==szNew && info.nLocal==info.nPayload
     && (!(p->pBt->autoVacuum) || szNew<pPage->minLocal)
    ){
# 82034 "c_tests/sqlite3.c"
      ((void) (0));
      if( oldCell < pPage->aData+pPage->hdrOffset+10 ){
        return sqlite3CorruptError(82036);
      }
      if( oldCell+szNew > pPage->aDataEnd ){
        return sqlite3CorruptError(82039);
      }
      memcpy(oldCell, newCell, szNew);
      return 0;
    }
    dropCell(pPage, idx, info.nSize, &rc);
    if( rc ) goto end_insert;
  }else if( loc<0 && pPage->nCell>0 ){
    ((void) (0));
    idx = ++pCur->ix;
    pCur->curFlags &= ~(0x02|0x04);
  }else{
    ((void) (0));
  }
  rc = insertCellFast(pPage, idx, newCell, szNew);
  ((void) (0));
  ((void) (0));
# 82077 "c_tests/sqlite3.c"
  if( pPage->nOverflow ){
    ((void) (0));
    pCur->curFlags &= ~(0x02|0x04);
    rc = balance(pCur);





    pCur->pPage->nOverflow = 0;
    pCur->eState = 1;
    if( (flags & 0x02) && rc==0 ){
      btreeReleaseAllCursorPages(pCur);
      if( pCur->pKeyInfo ){
        ((void) (0));
        pCur->pKey = sqlite3Malloc( pX->nKey );
        if( pCur->pKey==0 ){
          rc = 7;
        }else{
          memcpy(pCur->pKey, pX->pKey, pX->nKey);
        }
      }
      pCur->eState = 3;
      pCur->nKey = pX->nKey;
    }
  }
  ((void) (0));

end_insert:
  return rc;
}
# 82124 "c_tests/sqlite3.c"
static int sqlite3BtreeTransferRow(BtCursor *pDest, BtCursor *pSrc, i64 iKey){
  BtShared *pBt = pDest->pBt;
  u8 *aOut = pBt->pTmpSpace;
  const u8 *aIn;
  u32 nIn;
  u32 nRem;

  getCellInfo(pSrc);
  if( pSrc->info.nPayload<0x80 ){
    *(aOut++) = (u8)pSrc->info.nPayload;
  }else{
    aOut += sqlite3PutVarint(aOut, pSrc->info.nPayload);
  }
  if( pDest->pKeyInfo==0 ) aOut += sqlite3PutVarint(aOut, iKey);
  nIn = pSrc->info.nLocal;
  aIn = pSrc->info.pPayload;
  if( aIn+nIn>pSrc->pPage->aDataEnd ){
    return sqlite3CorruptError(82141);
  }
  nRem = pSrc->info.nPayload;
  if( nIn==nRem && nIn<pDest->pPage->maxLocal ){
    memcpy(aOut, aIn, nIn);
    pBt->nPreformatSize = nIn + (int)(aOut - pBt->pTmpSpace);
    return 0;
  }else{
    int rc = 0;
    Pager *pSrcPager = pSrc->pBt->pPager;
    u8 *pPgnoOut = 0;
    Pgno ovflIn = 0;
    DbPage *pPageIn = 0;
    MemPage *pPageOut = 0;
    u32 nOut;

    nOut = btreePayloadToLocal(pDest->pPage, pSrc->info.nPayload);
    pBt->nPreformatSize = (int)nOut + (int)(aOut - pBt->pTmpSpace);
    if( nOut<pSrc->info.nPayload ){
      pPgnoOut = &aOut[nOut];
      pBt->nPreformatSize += 4;
    }

    if( nRem>nIn ){
      if( aIn+nIn+4>pSrc->pPage->aDataEnd ){
        return sqlite3CorruptError(82166);
      }
      ovflIn = sqlite3Get4byte(&pSrc->info.pPayload[nIn]);
    }

    do {
      nRem -= nOut;
      do{
        ((void) (0));
        if( nIn>0 ){
          int nCopy = ((nOut)<(nIn)?(nOut):(nIn));
          memcpy(aOut, aIn, nCopy);
          nOut -= nCopy;
          nIn -= nCopy;
          aOut += nCopy;
          aIn += nCopy;
        }
        if( nOut>0 ){
          sqlite3PagerUnref(pPageIn);
          pPageIn = 0;
          rc = sqlite3PagerGet(pSrcPager, ovflIn, &pPageIn, 0x02);
          if( rc==0 ){
            aIn = (const u8*)sqlite3PagerGetData(pPageIn);
            ovflIn = sqlite3Get4byte(aIn);
            aIn += 4;
            nIn = pSrc->pBt->usableSize - 4;
          }
        }
      }while( rc==0 && nOut>0 );

      if( rc==0 && nRem>0 && (pPgnoOut) ){
        Pgno pgnoNew;
        MemPage *pNew = 0;
        rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0);
        sqlite3Put4byte(pPgnoOut, pgnoNew);
        if( (pBt->autoVacuum) && pPageOut ){
          ptrmapPut(pBt, pgnoNew, 4, pPageOut->pgno, &rc);
        }
        releasePage(pPageOut);
        pPageOut = pNew;
        if( pPageOut ){
          pPgnoOut = pPageOut->aData;
          sqlite3Put4byte(pPgnoOut, 0);
          aOut = &pPgnoOut[4];
          nOut = ((pBt->usableSize - 4)<(nRem)?(pBt->usableSize - 4):(nRem));
        }
      }
    }while( nRem>0 && rc==0 );

    releasePage(pPageOut);
    sqlite3PagerUnref(pPageIn);
    return rc;
  }
}
# 82238 "c_tests/sqlite3.c"
static int sqlite3BtreeDelete(BtCursor *pCur, u8 flags){
  Btree *p = pCur->pBtree;
  BtShared *pBt = p->pBt;
  int rc;
  MemPage *pPage;
  unsigned char *pCell;
  int iCellIdx;
  int iCellDepth;
  CellInfo info;
  u8 bPreserve;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pCur->eState!=0 ){
    if( pCur->eState>=3 ){
      rc = btreeRestoreCursorPosition(pCur);
      ((void) (0));
      if( rc || pCur->eState!=0 ) return rc;
    }else{
      return sqlite3CorruptError(82262);
    }
  }
  ((void) (0));

  iCellDepth = pCur->iPage;
  iCellIdx = pCur->ix;
  pPage = pCur->pPage;
  if( pPage->nCell<=iCellIdx ){
    return sqlite3CorruptError(82271);
  }
  pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(iCellIdx)])[0]<<8 | (&(pPage)->aCellIdx[2*(iCellIdx)])[1])));
  if( pPage->nFree<0 && btreeComputeFreeSpace(pPage) ){
    return sqlite3CorruptError(82275);
  }
  if( pCell<&pPage->aCellIdx[pPage->nCell] ){
    return sqlite3CorruptError(82278);
  }
# 82297 "c_tests/sqlite3.c"
  bPreserve = (flags & 0x02)!=0;
  if( bPreserve ){
    if( !pPage->leaf
     || (pPage->nFree+pPage->xCellSize(pPage,pCell)+2) >
                                                   (int)(pBt->usableSize*2/3)
     || pPage->nCell==1
    ){


      rc = saveCursorKey(pCur);
      if( rc ) return rc;
    }else{
      bPreserve = 2;
    }
  }
# 82320 "c_tests/sqlite3.c"
  if( !pPage->leaf ){
    rc = sqlite3BtreePrevious(pCur, 0);
    ((void) (0));
    if( rc ) return rc;
  }



  if( pCur->curFlags & 0x20 ){
    rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
    if( rc ) return rc;
  }



  if( pCur->pKeyInfo==0 && p->hasIncrblobCur ){
    invalidateIncrblobCursors(p, pCur->pgnoRoot, pCur->info.nKey, 0);
  }




  rc = sqlite3PagerWrite(pPage->pDbPage);
  if( rc ) return rc;
  pPage->xParseCell(pPage, pCell, &info); if( info.nLocal!=info.nPayload ){ rc = clearCellOverflow(pPage, pCell, &info); }else{ rc = 0; };
  dropCell(pPage, iCellIdx, info.nSize, &rc);
  if( rc ) return rc;






  if( !pPage->leaf ){
    MemPage *pLeaf = pCur->pPage;
    int nCell;
    Pgno n;
    unsigned char *pTmp;

    if( pLeaf->nFree<0 ){
      rc = btreeComputeFreeSpace(pLeaf);
      if( rc ) return rc;
    }
    if( iCellDepth<pCur->iPage-1 ){
      n = pCur->apPage[iCellDepth+1]->pgno;
    }else{
      n = pCur->pPage->pgno;
    }
    pCell = ((pLeaf)->aData + ((pLeaf)->maskPage & ((&(pLeaf)->aCellIdx[2*(pLeaf->nCell-1)])[0]<<8 | (&(pLeaf)->aCellIdx[2*(pLeaf->nCell-1)])[1])));
    if( pCell<&pLeaf->aData[4] ) return sqlite3CorruptError(82369);
    nCell = pLeaf->xCellSize(pLeaf, pCell);
    ((void) (0));
    pTmp = pBt->pTmpSpace;
    ((void) (0));
    rc = sqlite3PagerWrite(pLeaf->pDbPage);
    if( rc==0 ){
      rc = insertCell(pPage, iCellIdx, pCell-4, nCell+4, pTmp, n);
    }
    dropCell(pLeaf, pLeaf->nCell-1, nCell, &rc);
    if( rc ) return rc;
  }
# 82397 "c_tests/sqlite3.c"
  ((void) (0));
  ((void) (0));
  if( pCur->pPage->nFree*3<=(int)pCur->pBt->usableSize*2 ){


    rc = 0;
  }else{
    rc = balance(pCur);
  }
  if( rc==0 && pCur->iPage>iCellDepth ){
    releasePageNotNull(pCur->pPage);
    pCur->iPage--;
    while( pCur->iPage>iCellDepth ){
      releasePage(pCur->apPage[pCur->iPage--]);
    }
    pCur->pPage = pCur->apPage[pCur->iPage];
    rc = balance(pCur);
  }

  if( rc==0 ){
    if( bPreserve>1 ){
      ((void) (0));
      ((void) (0));
      ((void) (0));
      pCur->eState = 2;
      if( iCellIdx>=pPage->nCell ){
        pCur->skipNext = -1;
        pCur->ix = pPage->nCell-1;
      }else{
        pCur->skipNext = 1;
      }
    }else{
      rc = moveToRoot(pCur);
      if( bPreserve ){
        btreeReleaseAllCursorPages(pCur);
        pCur->eState = 3;
      }
      if( rc==16 ) rc = 0;
    }
  }
  return rc;
}
# 82451 "c_tests/sqlite3.c"
static int btreeCreateTable(Btree *p, Pgno *piTable, int createTabFlags){
  BtShared *pBt = p->pBt;
  MemPage *pRoot;
  Pgno pgnoRoot;
  int rc;
  int ptfFlags;

  ((void) (0));
  ((void) (0));
  ((void) (0));







  if( pBt->autoVacuum ){
    Pgno pgnoMove;
    MemPage *pPageMove;






    invalidateAllOverflowCache(pBt);





    sqlite3BtreeGetMeta(p, 4, &pgnoRoot);
    if( pgnoRoot>btreePagecount(pBt) ){
      return sqlite3CorruptError(82485);
    }
    pgnoRoot++;




    while( pgnoRoot==ptrmapPageno(pBt, pgnoRoot) ||
        pgnoRoot==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
      pgnoRoot++;
    }
    ((void) (0));





    rc = allocateBtreePage(pBt, &pPageMove, &pgnoMove, pgnoRoot, 1);
    if( rc!=0 ){
      return rc;
    }

    if( pgnoMove!=pgnoRoot ){






      u8 eType = 0;
      Pgno iPtrPage = 0;




      rc = saveAllCursors(pBt, 0, 0);
      releasePage(pPageMove);
      if( rc!=0 ){
        return rc;
      }


      rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);
      if( rc!=0 ){
        return rc;
      }
      rc = ptrmapGet(pBt, pgnoRoot, &eType, &iPtrPage);
      if( eType==1 || eType==2 ){
        rc = sqlite3CorruptError(82533);
      }
      if( rc!=0 ){
        releasePage(pRoot);
        return rc;
      }
      ((void) (0));
      ((void) (0));
      rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0);
      releasePage(pRoot);


      if( rc!=0 ){
        return rc;
      }
      rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);
      if( rc!=0 ){
        return rc;
      }
      rc = sqlite3PagerWrite(pRoot->pDbPage);
      if( rc!=0 ){
        releasePage(pRoot);
        return rc;
      }
    }else{
      pRoot = pPageMove;
    }


    ptrmapPut(pBt, pgnoRoot, 1, 0, &rc);
    if( rc ){
      releasePage(pRoot);
      return rc;
    }





    ((void) (0));
    rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot);
    if( (rc) ){
      releasePage(pRoot);
      return rc;
    }

  }else{
    rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, 1, 0);
    if( rc ) return rc;
  }

  ((void) (0));
  if( createTabFlags & 1 ){
    ptfFlags = 0x01 | 0x04 | 0x08;
  }else{
    ptfFlags = 0x02 | 0x08;
  }
  zeroPage(pRoot, ptfFlags);
  sqlite3PagerUnref(pRoot->pDbPage);
  ((void) (0));
  *piTable = pgnoRoot;
  return 0;
}
static int sqlite3BtreeCreateTable(Btree *p, Pgno *piTable, int flags){
  int rc;
  sqlite3BtreeEnter(p);
  rc = btreeCreateTable(p, piTable, flags);
  sqlite3BtreeLeave(p);
  return rc;
}





static int clearDatabasePage(
  BtShared *pBt,
  Pgno pgno,
  int freePageFlag,
  i64 *pnChange
){
  MemPage *pPage;
  int rc;
  unsigned char *pCell;
  int i;
  int hdr;
  CellInfo info;

  ((void) (0));
  if( pgno>btreePagecount(pBt) ){
    return sqlite3CorruptError(82623);
  }
  rc = getAndInitPage(pBt, pgno, &pPage, 0);
  if( rc ) return rc;
  if( (pBt->openFlags & 4)==0
   && sqlite3PagerPageRefcount(pPage->pDbPage) != (1 + (pgno==1))
  ){
    rc = sqlite3CorruptError(82630);
    goto cleardatabasepage_out;
  }
  hdr = pPage->hdrOffset;
  for(i=0; i<pPage->nCell; i++){
    pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(i)])[0]<<8 | (&(pPage)->aCellIdx[2*(i)])[1])));
    if( !pPage->leaf ){
      rc = clearDatabasePage(pBt, sqlite3Get4byte(pCell), 1, pnChange);
      if( rc ) goto cleardatabasepage_out;
    }
    pPage->xParseCell(pPage, pCell, &info); if( info.nLocal!=info.nPayload ){ rc = clearCellOverflow(pPage, pCell, &info); }else{ rc = 0; };
    if( rc ) goto cleardatabasepage_out;
  }
  if( !pPage->leaf ){
    rc = clearDatabasePage(pBt, sqlite3Get4byte(&pPage->aData[hdr+8]), 1, pnChange);
    if( rc ) goto cleardatabasepage_out;
    if( pPage->intKey ) pnChange = 0;
  }
  if( pnChange ){
                              ;
    *pnChange += pPage->nCell;
  }
  if( freePageFlag ){
    freePage(pPage, &rc);
  }else if( (rc = sqlite3PagerWrite(pPage->pDbPage))==0 ){
    zeroPage(pPage, pPage->aData[hdr] | 0x08);
  }

cleardatabasepage_out:
  releasePage(pPage);
  return rc;
}
# 82675 "c_tests/sqlite3.c"
static int sqlite3BtreeClearTable(Btree *p, int iTable, i64 *pnChange){
  int rc;
  BtShared *pBt = p->pBt;
  sqlite3BtreeEnter(p);
  ((void) (0));

  rc = saveAllCursors(pBt, (Pgno)iTable, 0);

  if( 0==rc ){



    if( p->hasIncrblobCur ){
      invalidateIncrblobCursors(p, (Pgno)iTable, 0, 1);
    }
    rc = clearDatabasePage(pBt, (Pgno)iTable, 0, pnChange);
  }
  sqlite3BtreeLeave(p);
  return rc;
}






static int sqlite3BtreeClearTableOfCursor(BtCursor *pCur){
  return sqlite3BtreeClearTable(pCur->pBtree, pCur->pgnoRoot, 0);
}
# 82725 "c_tests/sqlite3.c"
static int btreeDropTable(Btree *p, Pgno iTable, int *piMoved){
  int rc;
  MemPage *pPage = 0;
  BtShared *pBt = p->pBt;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( iTable>btreePagecount(pBt) ){
    return sqlite3CorruptError(82734);
  }

  rc = sqlite3BtreeClearTable(p, iTable, 0);
  if( rc ) return rc;
  rc = btreeGetPage(pBt, (Pgno)iTable, &pPage, 0);
  if( (rc) ){
    releasePage(pPage);
    return rc;
  }

  *piMoved = 0;





  if( pBt->autoVacuum ){
    Pgno maxRootPgno;
    sqlite3BtreeGetMeta(p, 4, &maxRootPgno);

    if( iTable==maxRootPgno ){



      freePage(pPage, &rc);
      releasePage(pPage);
      if( rc!=0 ){
        return rc;
      }
    }else{




      MemPage *pMove;
      releasePage(pPage);
      rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);
      if( rc!=0 ){
        return rc;
      }
      rc = relocatePage(pBt, pMove, 1, 0, iTable, 0);
      releasePage(pMove);
      if( rc!=0 ){
        return rc;
      }
      pMove = 0;
      rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);
      freePage(pMove, &rc);
      releasePage(pMove);
      if( rc!=0 ){
        return rc;
      }
      *piMoved = maxRootPgno;
    }






    maxRootPgno--;
    while( maxRootPgno==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1))
           || (ptrmapPageno((pBt), (maxRootPgno))==(maxRootPgno)) ){
      maxRootPgno--;
    }
    ((void) (0));

    rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno);
  }else{
    freePage(pPage, &rc);
    releasePage(pPage);
  }

  return rc;
}
static int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){
  int rc;
  sqlite3BtreeEnter(p);
  rc = btreeDropTable(p, iTable, piMoved);
  sqlite3BtreeLeave(p);
  return rc;
}
# 82839 "c_tests/sqlite3.c"
static void sqlite3BtreeGetMeta(Btree *p, int idx, u32 *pMeta){
  BtShared *pBt = p->pBt;

  sqlite3BtreeEnter(p);
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( idx==15 ){
    *pMeta = sqlite3PagerDataVersion(pBt->pPager) + p->iBDataVersion;
  }else{
    *pMeta = sqlite3Get4byte(&pBt->pPage1->aData[36 + idx*4]);
  }
# 82862 "c_tests/sqlite3.c"
  sqlite3BtreeLeave(p);
}





static int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){
  BtShared *pBt = p->pBt;
  unsigned char *pP1;
  int rc;
  ((void) (0));
  sqlite3BtreeEnter(p);
  ((void) (0));
  ((void) (0));
  pP1 = pBt->pPage1->aData;
  rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
  if( rc==0 ){
    sqlite3Put4byte(&pP1[36 + idx*4], iMeta);

    if( idx==7 ){
      ((void) (0));
      ((void) (0));
      pBt->incrVacuum = (u8)iMeta;
    }

  }
  sqlite3BtreeLeave(p);
  return rc;
}
# 82901 "c_tests/sqlite3.c"
static int sqlite3BtreeCount(sqlite3 *db, BtCursor *pCur, i64 *pnEntry){
  i64 nEntry = 0;
  int rc;

  rc = moveToRoot(pCur);
  if( rc==16 ){
    *pnEntry = 0;
    return 0;
  }




  while( rc==0 && !__atomic_load_n((&db->u1.isInterrupted),0) ){
    int iIdx;
    MemPage *pPage;





    pPage = pCur->pPage;
    if( pPage->leaf || !pPage->intKey ){
      nEntry += pPage->nCell;
    }
# 82937 "c_tests/sqlite3.c"
    if( pPage->leaf ){
      do {
        if( pCur->iPage==0 ){

          *pnEntry = nEntry;
          return moveToRoot(pCur);
        }
        moveToParent(pCur);
      }while ( pCur->ix>=pCur->pPage->nCell );

      pCur->ix++;
      pPage = pCur->pPage;
    }




    iIdx = pCur->ix;
    if( iIdx==pPage->nCell ){
      rc = moveToChild(pCur, sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]));
    }else{
      rc = moveToChild(pCur, sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aCellIdx[2*(iIdx)])[0]<<8 | (&(pPage)->aCellIdx[2*(iIdx)])[1])))));
    }
  }


  return rc;
}





static Pager *sqlite3BtreePager(Btree *p){
  return p->pBt->pPager;
}





static void checkOom(IntegrityCk *pCheck){
  pCheck->rc = 7;
  pCheck->mxErr = 0;
  if( pCheck->nErr==0 ) pCheck->nErr++;
}





static void checkProgress(IntegrityCk *pCheck){
  sqlite3 *db = pCheck->db;
  if( __atomic_load_n((&db->u1.isInterrupted),0) ){
    pCheck->rc = 9;
    pCheck->nErr++;
    pCheck->mxErr = 0;
  }

  if( db->xProgress ){
    ((void) (0));
    pCheck->nStep++;
    if( (pCheck->nStep % db->nProgressOps)==0
     && db->xProgress(db->pProgressArg)
    ){
      pCheck->rc = 9;
      pCheck->nErr++;
      pCheck->mxErr = 0;
    }
  }

}




static void checkAppendMsg(
  IntegrityCk *pCheck,
  const char *zFormat,
  ...
){
  va_list ap;
  checkProgress(pCheck);
  if( !pCheck->mxErr ) return;
  pCheck->mxErr--;
  pCheck->nErr++;
  __builtin_va_start(ap, zFormat);
  if( pCheck->errMsg.nChar ){
    sqlite3_str_append(&pCheck->errMsg, "\n", 1);
  }
  if( pCheck->zPfx ){
    sqlite3_str_appendf(&pCheck->errMsg, pCheck->zPfx,
                        pCheck->v0, pCheck->v1, pCheck->v2);
  }
  sqlite3_str_vappendf(&pCheck->errMsg, zFormat, ap);
  __builtin_va_end(ap);
  if( pCheck->errMsg.accError==7 ){
    checkOom(pCheck);
  }
}
# 83045 "c_tests/sqlite3.c"
static int getPageReferenced(IntegrityCk *pCheck, Pgno iPg){
  ((void) (0));
  ((void) (0));
  return (pCheck->aPgRef[iPg/8] & (1 << (iPg & 0x07)));
}




static void setPageReferenced(IntegrityCk *pCheck, Pgno iPg){
  ((void) (0));
  ((void) (0));
  pCheck->aPgRef[iPg/8] |= (1 << (iPg & 0x07));
}
# 83069 "c_tests/sqlite3.c"
static int checkRef(IntegrityCk *pCheck, Pgno iPage){
  if( iPage>pCheck->nCkPage || iPage==0 ){
    checkAppendMsg(pCheck, "invalid page number %u", iPage);
    return 1;
  }
  if( getPageReferenced(pCheck, iPage) ){
    checkAppendMsg(pCheck, "2nd reference to page %u", iPage);
    return 1;
  }
  setPageReferenced(pCheck, iPage);
  return 0;
}







static void checkPtrmap(
  IntegrityCk *pCheck,
  Pgno iChild,
  u8 eType,
  Pgno iParent
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=0 ){
    if( rc==7 || rc==(10 | (12<<8)) ) checkOom(pCheck);
    checkAppendMsg(pCheck, "Failed to read ptrmap key=%u", iChild);
    return;
  }

  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      "Bad ptr map entry key=%u expected=(%u,%u) got=(%u,%u)",
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}






static void checkList(
  IntegrityCk *pCheck,
  int isFreeList,
  Pgno iPage,
  u32 N
){
  int i;
  u32 expected = N;
  int nErrAtStart = pCheck->nErr;
  while( iPage!=0 && pCheck->mxErr ){
    DbPage *pOvflPage;
    unsigned char *pOvflData;
    if( checkRef(pCheck, iPage) ) break;
    N--;
    if( sqlite3PagerGet(pCheck->pPager, (Pgno)iPage, &pOvflPage, 0) ){
      checkAppendMsg(pCheck, "failed to get page %u", iPage);
      break;
    }
    pOvflData = (unsigned char *)sqlite3PagerGetData(pOvflPage);
    if( isFreeList ){
      u32 n = (u32)sqlite3Get4byte(&pOvflData[4]);

      if( pCheck->pBt->autoVacuum ){
        checkPtrmap(pCheck, iPage, 2, 0);
      }

      if( n>pCheck->pBt->usableSize/4-2 ){
        checkAppendMsg(pCheck,
           "freelist leaf count too big on page %u", iPage);
        N--;
      }else{
        for(i=0; i<(int)n; i++){
          Pgno iFreePage = sqlite3Get4byte(&pOvflData[8+i*4]);

          if( pCheck->pBt->autoVacuum ){
            checkPtrmap(pCheck, iFreePage, 2, 0);
          }

          checkRef(pCheck, iFreePage);
        }
        N -= n;
      }
    }

    else{




      if( pCheck->pBt->autoVacuum && N>0 ){
        i = sqlite3Get4byte(pOvflData);
        checkPtrmap(pCheck, i, 4, iPage);
      }
    }

    iPage = sqlite3Get4byte(pOvflData);
    sqlite3PagerUnref(pOvflPage);
  }
  if( N && nErrAtStart==pCheck->nErr ){
    checkAppendMsg(pCheck,
      "%s is %u but should be %u",
      isFreeList ? "size" : "overflow list length",
      expected-N, expected);
  }
}
# 83206 "c_tests/sqlite3.c"
static void btreeHeapInsert(u32 *aHeap, u32 x){
  u32 j, i;
  ((void) (0));
  i = ++aHeap[0];
  aHeap[i] = x;
  while( (j = i/2)>0 && aHeap[j]>aHeap[i] ){
    x = aHeap[j];
    aHeap[j] = aHeap[i];
    aHeap[i] = x;
    i = j;
  }
}
static int btreeHeapPull(u32 *aHeap, u32 *pOut){
  u32 j, i, x;
  if( (x = aHeap[0])==0 ) return 0;
  *pOut = aHeap[1];
  aHeap[1] = aHeap[x];
  aHeap[x] = 0xffffffff;
  aHeap[0]--;
  i = 1;
  while( (j = i*2)<=aHeap[0] ){
    if( aHeap[j]>aHeap[j+1] ) j++;
    if( aHeap[i]<aHeap[j] ) break;
    x = aHeap[i];
    aHeap[i] = aHeap[j];
    aHeap[j] = x;
    i = j;
  }
  return 1;
}
# 83252 "c_tests/sqlite3.c"
static int checkTreePage(
  IntegrityCk *pCheck,
  Pgno iPage,
  i64 *piMinKey,
  i64 maxKey
){
  MemPage *pPage = 0;
  int i;
  int rc;
  int depth = -1, d2;
  int pgno;
  int nFrag;
  int hdr;
  int cellStart;
  int nCell;
  int doCoverageCheck = 1;
  int keyCanBeEqual = 1;

  u8 *data;
  u8 *pCell;
  u8 *pCellIdx;
  BtShared *pBt;
  u32 pc;
  u32 usableSize;
  u32 contentOffset;
  u32 *heap = 0;
  u32 x, prev = 0;
  const char *saved_zPfx = pCheck->zPfx;
  int saved_v1 = pCheck->v1;
  int saved_v2 = pCheck->v2;
  u8 savedIsInit = 0;



  checkProgress(pCheck);
  if( pCheck->mxErr==0 ) goto end_of_check;
  pBt = pCheck->pBt;
  usableSize = pBt->usableSize;
  if( iPage==0 ) return 0;
  if( checkRef(pCheck, iPage) ) return 0;
  pCheck->zPfx = "Tree %u page %u: ";
  pCheck->v1 = iPage;
  if( (rc = btreeGetPage(pBt, iPage, &pPage, 0))!=0 ){
    checkAppendMsg(pCheck,
       "unable to get the page. error code=%d", rc);
    if( rc==(10 | (12<<8)) ) pCheck->rc = 7;
    goto end_of_check;
  }



  savedIsInit = pPage->isInit;
  pPage->isInit = 0;
  if( (rc = btreeInitPage(pPage))!=0 ){
    ((void) (0));
    checkAppendMsg(pCheck,
                   "btreeInitPage() returns error code %d", rc);
    goto end_of_check;
  }
  if( (rc = btreeComputeFreeSpace(pPage))!=0 ){
    ((void) (0));
    checkAppendMsg(pCheck, "free space corruption", rc);
    goto end_of_check;
  }
  data = pPage->aData;
  hdr = pPage->hdrOffset;


  pCheck->zPfx = "Tree %u page %u cell %u: ";
  contentOffset = (((((int)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);
  ((void) (0));



  nCell = ((&data[hdr+3])[0]<<8 | (&data[hdr+3])[1]);
  ((void) (0));
  if( pPage->leaf || pPage->intKey==0 ){
    pCheck->nRow += nCell;
  }



  cellStart = hdr + 12 - 4*pPage->leaf;
  ((void) (0));
  pCellIdx = &data[cellStart + 2*(nCell-1)];

  if( !pPage->leaf ){

    pgno = sqlite3Get4byte(&data[hdr+8]);

    if( pBt->autoVacuum ){
      pCheck->zPfx = "Tree %u page %u right child: ";
      checkPtrmap(pCheck, pgno, 5, iPage);
    }

    depth = checkTreePage(pCheck, pgno, &maxKey, maxKey);
    keyCanBeEqual = 0;
  }else{


    heap = pCheck->heap;
    heap[0] = 0;
  }



  for(i=nCell-1; i>=0 && pCheck->mxErr; i--){
    CellInfo info;


    pCheck->v2 = i;
    ((void) (0));
    pc = ((pCellIdx)[0]<<8 | (pCellIdx)[1]);
    pCellIdx -= 2;
    if( pc<contentOffset || pc>usableSize-4 ){
      checkAppendMsg(pCheck, "Offset %u out of range %u..%u",
                             pc, contentOffset, usableSize-4);
      doCoverageCheck = 0;
      continue;
    }
    pCell = &data[pc];
    pPage->xParseCell(pPage, pCell, &info);
    if( pc+info.nSize>usableSize ){
      checkAppendMsg(pCheck, "Extends off end of page");
      doCoverageCheck = 0;
      continue;
    }


    if( pPage->intKey ){
      if( keyCanBeEqual ? (info.nKey > maxKey) : (info.nKey >= maxKey) ){
        checkAppendMsg(pCheck, "Rowid %lld out of order", info.nKey);
      }
      maxKey = info.nKey;
      keyCanBeEqual = 0;
    }


    if( info.nPayload>info.nLocal ){
      u32 nPage;
      Pgno pgnoOvfl;
      ((void) (0));
      nPage = (info.nPayload - info.nLocal + usableSize - 5)/(usableSize - 4);
      pgnoOvfl = sqlite3Get4byte(&pCell[info.nSize - 4]);

      if( pBt->autoVacuum ){
        checkPtrmap(pCheck, pgnoOvfl, 3, iPage);
      }

      checkList(pCheck, 0, pgnoOvfl, nPage);
    }

    if( !pPage->leaf ){

      pgno = sqlite3Get4byte(pCell);

      if( pBt->autoVacuum ){
        checkPtrmap(pCheck, pgno, 5, iPage);
      }

      d2 = checkTreePage(pCheck, pgno, &maxKey, maxKey);
      keyCanBeEqual = 0;
      if( d2!=depth ){
        checkAppendMsg(pCheck, "Child page depth differs");
        depth = d2;
      }
    }else{

      btreeHeapInsert(heap, (pc<<16)|(pc+info.nSize-1));
    }
  }
  *piMinKey = maxKey;



  pCheck->zPfx = 0;
  if( doCoverageCheck && pCheck->mxErr>0 ){



    if( !pPage->leaf ){
      heap = pCheck->heap;
      heap[0] = 0;
      for(i=nCell-1; i>=0; i--){
        u32 size;
        pc = ((&data[cellStart+i*2])[0]<<8 | (&data[cellStart+i*2])[1]);
        size = pPage->xCellSize(pPage, &data[pc]);
        btreeHeapInsert(heap, (pc<<16)|(pc+size-1));
      }
    }
    ((void) (0));






    i = ((&data[hdr+1])[0]<<8 | (&data[hdr+1])[1]);
    while( i>0 ){
      int size, j;
      ((void) (0));
      size = ((&data[i+2])[0]<<8 | (&data[i+2])[1]);
      ((void) (0));
      btreeHeapInsert(heap, (((u32)i)<<16)|(i+size-1));




      j = ((&data[i])[0]<<8 | (&data[i])[1]);


      ((void) (0));
      ((void) (0));
      i = j;
    }
# 83480 "c_tests/sqlite3.c"
    nFrag = 0;
    prev = contentOffset - 1;
    while( btreeHeapPull(heap,&x) ){
      if( (prev&0xffff)>=(x>>16) ){
        checkAppendMsg(pCheck,
          "Multiple uses for byte %u of page %u", x>>16, iPage);
        break;
      }else{
        nFrag += (x>>16) - (prev&0xffff) - 1;
        prev = x;
      }
    }
    nFrag += usableSize - (prev&0xffff) - 1;





    if( heap[0]==0 && nFrag!=data[hdr+7] ){
      checkAppendMsg(pCheck,
          "Fragmentation of %u bytes reported as %u on page %u",
          nFrag, data[hdr+7], iPage);
    }
  }

end_of_check:
  if( !doCoverageCheck ) pPage->isInit = savedIsInit;
  releasePage(pPage);
  pCheck->zPfx = saved_zPfx;
  pCheck->v1 = saved_v1;
  pCheck->v2 = saved_v2;
  return depth+1;
}
# 83538 "c_tests/sqlite3.c"
static int sqlite3BtreeIntegrityCheck(
  sqlite3 *db,
  Btree *p,
  Pgno *aRoot,
  Mem *aCnt,
  int nRoot,
  int mxErr,
  int *pnErr,
  char **pzOut
){
  Pgno i;
  IntegrityCk sCheck;
  BtShared *pBt = p->pBt;
  u64 savedDbFlags = pBt->db->flags;
  char zErr[100];
  int bPartial = 0;
  int bCkFreelist = 1;
                      ;

  ((void) (0));
  ((void) (0));


  if( aRoot[0]==0 ){
    ((void) (0));
    bPartial = 1;
    if( aRoot[1]!=1 ) bCkFreelist = 0;
  }

  sqlite3BtreeEnter(p);
  ((void) (0));
                                                      ;
  ((void) (0));
  memset(&sCheck, 0, sizeof(sCheck));
  sCheck.db = db;
  sCheck.pBt = pBt;
  sCheck.pPager = pBt->pPager;
  sCheck.nCkPage = btreePagecount(sCheck.pBt);
  sCheck.mxErr = mxErr;
  sqlite3StrAccumInit(&sCheck.errMsg, 0, zErr, sizeof(zErr), 1000000000);
  sCheck.errMsg.printfFlags = 0x01;
  if( sCheck.nCkPage==0 ){
    goto integrity_ck_cleanup;
  }

  sCheck.aPgRef = sqlite3MallocZero((sCheck.nCkPage / 8)+ 1);
  if( !sCheck.aPgRef ){
    checkOom(&sCheck);
    goto integrity_ck_cleanup;
  }
  sCheck.heap = (u32*)sqlite3PageMalloc( pBt->pageSize );
  if( sCheck.heap==0 ){
    checkOom(&sCheck);
    goto integrity_ck_cleanup;
  }

  i = ((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1));
  if( i<=sCheck.nCkPage ) setPageReferenced(&sCheck, i);



  if( bCkFreelist ){
    sCheck.zPfx = "Freelist: ";
    checkList(&sCheck, 1, sqlite3Get4byte(&pBt->pPage1->aData[32]),
              sqlite3Get4byte(&pBt->pPage1->aData[36]));
    sCheck.zPfx = 0;
  }




  if( !bPartial ){
    if( pBt->autoVacuum ){
      Pgno mx = 0;
      Pgno mxInHdr;
      for(i=0; (int)i<nRoot; i++) if( mx<aRoot[i] ) mx = aRoot[i];
      mxInHdr = sqlite3Get4byte(&pBt->pPage1->aData[52]);
      if( mx!=mxInHdr ){
        checkAppendMsg(&sCheck,
          "max rootpage (%u) disagrees with header (%u)",
          mx, mxInHdr
        );
      }
    }else if( sqlite3Get4byte(&pBt->pPage1->aData[64])!=0 ){
      checkAppendMsg(&sCheck,
        "incremental_vacuum enabled with a max rootpage of zero"
      );
    }
  }

                                                ;
  pBt->db->flags &= ~(u64)0x00200000;
  for(i=0; (int)i<nRoot && sCheck.mxErr; i++){
    sCheck.nRow = 0;
    if( aRoot[i] ){
      i64 notUsed;

      if( pBt->autoVacuum && aRoot[i]>1 && !bPartial ){
        checkPtrmap(&sCheck, aRoot[i], 1, 0);
      }

      sCheck.v0 = aRoot[i];
      checkTreePage(&sCheck, aRoot[i], &notUsed, (0xffffffff|(((i64)0x7fffffff)<<32)));
    }
    sqlite3MemSetArrayInt64(aCnt, i, sCheck.nRow);
  }
  pBt->db->flags = savedDbFlags;



  if( !bPartial ){
    for(i=1; i<=sCheck.nCkPage && sCheck.mxErr; i++){
# 83658 "c_tests/sqlite3.c"
      if( getPageReferenced(&sCheck, i)==0 &&
         (ptrmapPageno(pBt, i)!=i || !pBt->autoVacuum) ){
        checkAppendMsg(&sCheck, "Page %u: never used", i);
      }
      if( getPageReferenced(&sCheck, i)!=0 &&
         (ptrmapPageno(pBt, i)==i && pBt->autoVacuum) ){
        checkAppendMsg(&sCheck, "Page %u: pointer map referenced", i);
      }

    }
  }



integrity_ck_cleanup:
  sqlite3PageFree(sCheck.heap);
  sqlite3_free(sCheck.aPgRef);
  *pnErr = sCheck.nErr;
  if( sCheck.nErr==0 ){
    sqlite3_str_reset(&sCheck.errMsg);
    *pzOut = 0;
  }else{
    *pzOut = sqlite3StrAccumFinish(&sCheck.errMsg);
  }

  ((void) (0));
  sqlite3BtreeLeave(p);
  return sCheck.rc;
}
# 83696 "c_tests/sqlite3.c"
static const char *sqlite3BtreeGetFilename(Btree *p){
  ((void) (0));
  return sqlite3PagerFilename(p->pBt->pPager, 1);
}
# 83709 "c_tests/sqlite3.c"
static const char *sqlite3BtreeGetJournalname(Btree *p){
  ((void) (0));
  return sqlite3PagerJournalname(p->pBt->pPager);
}





static int sqlite3BtreeTxnState(Btree *p){
  ((void) (0));
  return p ? p->inTrans : 0;
}
# 83732 "c_tests/sqlite3.c"
static int sqlite3BtreeCheckpoint(Btree *p, int eMode, int *pnLog, int *pnCkpt){
  int rc = 0;
  if( p ){
    BtShared *pBt = p->pBt;
    sqlite3BtreeEnter(p);
    if( pBt->inTransaction!=0 ){
      rc = 6;
    }else{
      rc = sqlite3PagerCheckpoint(pBt->pPager, p->db, eMode, pnLog, pnCkpt);
    }
    sqlite3BtreeLeave(p);
  }
  return rc;
}





static int sqlite3BtreeIsInBackup(Btree *p){
  ((void) (0));
  ((void) (0));
  return p->nBackup!=0;
}
# 83777 "c_tests/sqlite3.c"
static void *sqlite3BtreeSchema(Btree *p, int nBytes, void(*xFree)(void *)){
  BtShared *pBt = p->pBt;
  ((void) (0));
  sqlite3BtreeEnter(p);
  if( !pBt->pSchema && nBytes ){
    pBt->pSchema = sqlite3DbMallocZero(0, nBytes);
    pBt->xFreeSchema = xFree;
  }
  sqlite3BtreeLeave(p);
  return pBt->pSchema;
}






static int sqlite3BtreeSchemaLocked(Btree *p){
  int rc;
  (void)(p);
  ((void) (0));
  sqlite3BtreeEnter(p);
  rc = querySharedCacheTableLock(p, 1, 1);
  ((void) (0));
  sqlite3BtreeLeave(p);
  return rc;
}
# 83812 "c_tests/sqlite3.c"
static int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock){
  int rc = 0;
  ((void) (0));
  if( p->sharable ){
    u8 lockType = 1 + isWriteLock;
    ((void) (0));
    ((void) (0));

    sqlite3BtreeEnter(p);
    rc = querySharedCacheTableLock(p, iTab, lockType);
    if( rc==0 ){
      rc = setSharedCacheTableLock(p, iTab, lockType);
    }
    sqlite3BtreeLeave(p);
  }
  return rc;
}
# 83842 "c_tests/sqlite3.c"
static int sqlite3BtreePutData(BtCursor *pCsr, u32 offset, u32 amt, void *z){
  int rc;
  ((void) (0));
  ((void) (0));
  ((void) (0));

  rc = (pCsr->eState>=3 ? btreeRestoreCursorPosition(pCsr) : 0);
  if( rc!=0 ){
    return rc;
  }
  ((void) (0));
  if( pCsr->eState!=0 ){
    return 4;
  }
# 83865 "c_tests/sqlite3.c"
                 saveAllCursors(pCsr->pBt, pCsr->pgnoRoot, pCsr);
  ((void) (0));
# 83875 "c_tests/sqlite3.c"
  if( (pCsr->curFlags & 0x01)==0 ){
    return 8;
  }
  ((void) (0));

  ((void) (0));
  ((void) (0));
  ((void) (0));

  return accessPayload(pCsr, offset, amt, (unsigned char *)z, 1);
}




static void sqlite3BtreeIncrblobCursor(BtCursor *pCur){
  pCur->curFlags |= 0x10;
  pCur->pBtree->hasIncrblobCur = 1;
}







static int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion){
  BtShared *pBt = pBtree->pBt;
  int rc;

  ((void) (0));




  pBt->btsFlags &= ~0x0020;
  if( iVersion==1 ) pBt->btsFlags |= 0x0020;

  rc = sqlite3BtreeBeginTrans(pBtree, 0, 0);
  if( rc==0 ){
    u8 *aData = pBt->pPage1->aData;
    if( aData[18]!=(u8)iVersion || aData[19]!=(u8)iVersion ){
      rc = sqlite3BtreeBeginTrans(pBtree, 2, 0);
      if( rc==0 ){
        rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
        if( rc==0 ){
          aData[18] = (u8)iVersion;
          aData[19] = (u8)iVersion;
        }
      }
    }
  }

  pBt->btsFlags &= ~0x0020;
  return rc;
}





static int sqlite3BtreeCursorHasHint(BtCursor *pCsr, unsigned int mask){
  return (pCsr->hints & mask)!=0;
}




static int sqlite3BtreeIsReadonly(Btree *p){
  return (p->pBt->btsFlags & 0x0001)!=0;
}




static int sqlite3HeaderSizeBtree(void){ return (((sizeof(MemPage))+7)&~7); }





static void sqlite3BtreeClearCache(Btree *p){
  BtShared *pBt = p->pBt;
  if( pBt->inTransaction==0 ){
    sqlite3PagerClearCache(pBt->pPager);
  }
}





static int sqlite3BtreeSharable(Btree *p){
  return p->sharable;
}






static int sqlite3BtreeConnectionCount(Btree *p){
                         ;
  return p->pBt->nRef;
}
# 84004 "c_tests/sqlite3.c"
struct sqlite3_backup {
  sqlite3* pDestDb;
  Btree *pDest;
  u32 iDestSchema;
  int bDestLocked;

  Pgno iNext;
  sqlite3* pSrcDb;
  Btree *pSrc;

  int rc;




  Pgno nRemaining;
  Pgno nPagecount;

  int isAttached;
  sqlite3_backup *pNext;
};
# 84065 "c_tests/sqlite3.c"
static Btree *findBtree(sqlite3 *pErrorDb, sqlite3 *pDb, const char *zDb){
  int i = sqlite3FindDbName(pDb, zDb);

  if( i==1 ){
    Parse sParse;
    int rc = 0;
    sqlite3ParseObjectInit(&sParse,pDb);
    if( sqlite3OpenTempDatabase(&sParse) ){
      sqlite3ErrorWithMsg(pErrorDb, sParse.rc, "%s", sParse.zErrMsg);
      rc = 1;
    }
    sqlite3DbFree(pErrorDb, sParse.zErrMsg);
    sqlite3ParseObjectReset(&sParse);
    if( rc ){
      return 0;
    }
  }

  if( i<0 ){
    sqlite3ErrorWithMsg(pErrorDb, 1, "unknown database %s", zDb);
    return 0;
  }

  return pDb->aDb[i].pBt;
}





static int setDestPgsz(sqlite3_backup *p){
  int rc;
  rc = sqlite3BtreeSetPageSize(p->pDest,sqlite3BtreeGetPageSize(p->pSrc),0,0);
  return rc;
}







static int checkReadTransaction(sqlite3 *db, Btree *p){
  if( sqlite3BtreeTxnState(p)!=0 ){
    sqlite3ErrorWithMsg(db, 1, "destination database is in use");
    return 1;
  }
  return 0;
}
# 84123 "c_tests/sqlite3.c"
           sqlite3_backup *sqlite3_backup_init(
  sqlite3* pDestDb,
  const char *zDestDb,
  sqlite3* pSrcDb,
  const char *zSrcDb
){
  sqlite3_backup *p;
# 84146 "c_tests/sqlite3.c"
  sqlite3_mutex_enter(pSrcDb->mutex);
  sqlite3_mutex_enter(pDestDb->mutex);

  if( pSrcDb==pDestDb ){
    sqlite3ErrorWithMsg(
        pDestDb, 1, "source and destination must be distinct"
    );
    p = 0;
  }else {




    p = (sqlite3_backup *)sqlite3MallocZero(sizeof(sqlite3_backup));
    if( !p ){
      sqlite3Error(pDestDb, 7);
    }
  }


  if( p ){
    p->pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);
    p->pDest = findBtree(pDestDb, pDestDb, zDestDb);
    p->pDestDb = pDestDb;
    p->pSrcDb = pSrcDb;
    p->iNext = 1;
    p->isAttached = 0;

    if( 0==p->pSrc || 0==p->pDest
     || checkReadTransaction(pDestDb, p->pDest)!=0
     ){





      sqlite3_free(p);
      p = 0;
    }
  }
  if( p ){
    p->pSrc->nBackup++;
  }

  sqlite3_mutex_leave(pDestDb->mutex);
  sqlite3_mutex_leave(pSrcDb->mutex);
  return p;
}






static int isFatalError(int rc){
  return (rc!=0 && rc!=5 && (rc!=6));
}






static int backupOnePage(
  sqlite3_backup *p,
  Pgno iSrcPg,
  const u8 *zSrcData,
  int bUpdate
){
  Pager * const pDestPager = sqlite3BtreePager(p->pDest);
  const int nSrcPgsz = sqlite3BtreeGetPageSize(p->pSrc);
  int nDestPgsz = sqlite3BtreeGetPageSize(p->pDest);
  const int nCopy = ((nSrcPgsz)<(nDestPgsz)?(nSrcPgsz):(nDestPgsz));
  const i64 iEnd = (i64)iSrcPg*(i64)nSrcPgsz;
  int rc = 0;
  i64 iOff;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  for(iOff=iEnd-(i64)nSrcPgsz; rc==0 && iOff<iEnd; iOff+=nDestPgsz){
    DbPage *pDestPg = 0;
    Pgno iDest = (Pgno)(iOff/nDestPgsz)+1;
    if( iDest==((Pgno)((sqlite3PendingByte/((p->pDest->pBt)->pageSize))+1)) ) continue;
    if( 0==(rc = sqlite3PagerGet(pDestPager, iDest, &pDestPg, 0))
     && 0==(rc = sqlite3PagerWrite(pDestPg))
    ){
      const u8 *zIn = &zSrcData[iOff%nSrcPgsz];
      u8 *zDestData = sqlite3PagerGetData(pDestPg);
      u8 *zOut = &zDestData[iOff%nDestPgsz];
# 84252 "c_tests/sqlite3.c"
      memcpy(zOut, zIn, nCopy);
      ((u8 *)sqlite3PagerGetExtra(pDestPg))[0] = 0;
      if( iOff==0 && bUpdate==0 ){
        sqlite3Put4byte(&zOut[28], sqlite3BtreeLastPage(p->pSrc));
      }
    }
    sqlite3PagerUnref(pDestPg);
  }

  return rc;
}
# 84272 "c_tests/sqlite3.c"
static int backupTruncateFile(sqlite3_file *pFile, i64 iSize){
  i64 iCurrent;
  int rc = sqlite3OsFileSize(pFile, &iCurrent);
  if( rc==0 && iCurrent>iSize ){
    rc = sqlite3OsTruncate(pFile, iSize);
  }
  return rc;
}





static void attachBackupObject(sqlite3_backup *p){
  sqlite3_backup **pp;
  ((void) (0));
  pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
  p->pNext = *pp;
  *pp = p;
  p->isAttached = 1;
}




           int sqlite3_backup_step(sqlite3_backup *p, int nPage){
  int rc;
  int destMode;
  int pgszSrc = 0;
  int pgszDest = 0;




  sqlite3_mutex_enter(p->pSrcDb->mutex);
  sqlite3BtreeEnter(p->pSrc);
  if( p->pDestDb ){
    sqlite3_mutex_enter(p->pDestDb->mutex);
  }

  rc = p->rc;
  if( !isFatalError(rc) ){
    Pager * const pSrcPager = sqlite3BtreePager(p->pSrc);
    Pager * const pDestPager = sqlite3BtreePager(p->pDest);
    int ii;
    int nSrcPage = -1;
    int bCloseTrans = 0;




    if( p->pDestDb && p->pSrc->pBt->inTransaction==2 ){
      rc = 5;
    }else{
      rc = 0;
    }





    if( rc==0 && 0==sqlite3BtreeTxnState(p->pSrc) ){
      rc = sqlite3BtreeBeginTrans(p->pSrc, 0, 0);
      bCloseTrans = 1;
    }







    if( p->bDestLocked==0 && rc==0 && setDestPgsz(p)==7 ){
      rc = 7;
    }


    if( 0==rc && p->bDestLocked==0
     && 0==(rc = sqlite3BtreeBeginTrans(p->pDest, 2,
                                                (int*)&p->iDestSchema))
    ){
      p->bDestLocked = 1;
    }



    pgszSrc = sqlite3BtreeGetPageSize(p->pSrc);
    pgszDest = sqlite3BtreeGetPageSize(p->pDest);
    destMode = sqlite3PagerGetJournalMode(sqlite3BtreePager(p->pDest));
    if( 0==rc
     && (destMode==5 || sqlite3PagerIsMemdb(pDestPager))
     && pgszSrc!=pgszDest
    ){
      rc = 8;
    }




    nSrcPage = (int)sqlite3BtreeLastPage(p->pSrc);
    ((void) (0));
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
      const Pgno iSrcPg = p->iNext;
      if( iSrcPg!=((Pgno)((sqlite3PendingByte/((p->pSrc->pBt)->pageSize))+1)) ){
        DbPage *pSrcPg;
        rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg,0x02);
        if( rc==0 ){
          rc = backupOnePage(p, iSrcPg, sqlite3PagerGetData(pSrcPg), 0);
          sqlite3PagerUnref(pSrcPg);
        }
      }
      p->iNext++;
    }
    if( rc==0 ){
      p->nPagecount = nSrcPage;
      p->nRemaining = nSrcPage+1-p->iNext;
      if( p->iNext>(Pgno)nSrcPage ){
        rc = 101;
      }else if( !p->isAttached ){
        attachBackupObject(p);
      }
    }






    if( rc==101 ){
      if( nSrcPage==0 ){
        rc = sqlite3BtreeNewDb(p->pDest);
        nSrcPage = 1;
      }
      if( rc==0 || rc==101 ){
        rc = sqlite3BtreeUpdateMeta(p->pDest,1,p->iDestSchema+1);
      }
      if( rc==0 ){
        if( p->pDestDb ){
          sqlite3ResetAllSchemasOfConnection(p->pDestDb);
        }
        if( destMode==5 ){
          rc = sqlite3BtreeSetVersion(p->pDest, 2);
        }
      }
      if( rc==0 ){
        int nDestTruncate;
# 84430 "c_tests/sqlite3.c"
        ((void) (0));
        ((void) (0));
        if( pgszSrc<pgszDest ){
          int ratio = pgszDest/pgszSrc;
          nDestTruncate = (nSrcPage+ratio-1)/ratio;
          if( nDestTruncate==(int)((Pgno)((sqlite3PendingByte/((p->pDest->pBt)->pageSize))+1)) ){
            nDestTruncate--;
          }
        }else{
          nDestTruncate = nSrcPage * (pgszSrc/pgszDest);
        }
        ((void) (0));

        if( pgszSrc<pgszDest ){
# 84453 "c_tests/sqlite3.c"
          const i64 iSize = (i64)pgszSrc * (i64)nSrcPage;
          sqlite3_file * const pFile = sqlite3PagerFile(pDestPager);
          Pgno iPg;
          int nDstPage;
          i64 iOff;
          i64 iEnd;

          ((void) (0));
          ((void) (0));
# 84473 "c_tests/sqlite3.c"
          sqlite3PagerPagecount(pDestPager, &nDstPage);
          for(iPg=nDestTruncate; rc==0 && iPg<=(Pgno)nDstPage; iPg++){
            if( iPg!=((Pgno)((sqlite3PendingByte/((p->pDest->pBt)->pageSize))+1)) ){
              DbPage *pPg;
              rc = sqlite3PagerGet(pDestPager, iPg, &pPg, 0);
              if( rc==0 ){
                rc = sqlite3PagerWrite(pPg);
                sqlite3PagerUnref(pPg);
              }
            }
          }
          if( rc==0 ){
            rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 1);
          }


          iEnd = ((sqlite3PendingByte + pgszDest)<(iSize)?(sqlite3PendingByte + pgszDest):(iSize));
          for(
            iOff=sqlite3PendingByte+pgszSrc;
            rc==0 && iOff<iEnd;
            iOff+=pgszSrc
          ){
            PgHdr *pSrcPg = 0;
            const Pgno iSrcPg = (Pgno)((iOff/pgszSrc)+1);
            rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg, 0);
            if( rc==0 ){
              u8 *zData = sqlite3PagerGetData(pSrcPg);
              rc = sqlite3OsWrite(pFile, zData, pgszSrc, iOff);
            }
            sqlite3PagerUnref(pSrcPg);
          }
          if( rc==0 ){
            rc = backupTruncateFile(pFile, iSize);
          }


          if( rc==0 ){
            rc = sqlite3PagerSync(pDestPager, 0);
          }
        }else{
          sqlite3PagerTruncateImage(pDestPager, nDestTruncate);
          rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 0);
        }


        if( 0==rc
         && 0==(rc = sqlite3BtreeCommitPhaseTwo(p->pDest, 0))
        ){
          rc = 101;
        }
      }
    }






    if( bCloseTrans ){
                         ;
                         sqlite3BtreeCommitPhaseOne(p->pSrc, 0);
                         sqlite3BtreeCommitPhaseTwo(p->pSrc, 0);
      ((void) (0));
    }

    if( rc==(10 | (12<<8)) ){
      rc = 7;
    }
    p->rc = rc;
  }
  if( p->pDestDb ){
    sqlite3_mutex_leave(p->pDestDb->mutex);
  }
  sqlite3BtreeLeave(p->pSrc);
  sqlite3_mutex_leave(p->pSrcDb->mutex);
  return rc;
}




           int sqlite3_backup_finish(sqlite3_backup *p){
  sqlite3_backup **pp;
  sqlite3 *pSrcDb;
  int rc;


  if( p==0 ) return 0;
  pSrcDb = p->pSrcDb;
  sqlite3_mutex_enter(pSrcDb->mutex);
  sqlite3BtreeEnter(p->pSrc);
  if( p->pDestDb ){
    sqlite3_mutex_enter(p->pDestDb->mutex);
  }


  if( p->pDestDb ){
    p->pSrc->nBackup--;
  }
  if( p->isAttached ){
    pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
    ((void) (0));
    while( *pp!=p ){
      pp = &(*pp)->pNext;
      ((void) (0));
    }
    *pp = p->pNext;
  }


  sqlite3BtreeRollback(p->pDest, 0, 0);


  rc = (p->rc==101) ? 0 : p->rc;
  if( p->pDestDb ){
    sqlite3Error(p->pDestDb, rc);


    sqlite3LeaveMutexAndCloseZombie(p->pDestDb);
  }
  sqlite3BtreeLeave(p->pSrc);
  if( p->pDestDb ){



    sqlite3_free(p);
  }
  sqlite3LeaveMutexAndCloseZombie(pSrcDb);
  return rc;
}





           int sqlite3_backup_remaining(sqlite3_backup *p){






  return p->nRemaining;
}





           int sqlite3_backup_pagecount(sqlite3_backup *p){






  return p->nPagecount;
}
# 84644 "c_tests/sqlite3.c"
static __attribute__((noinline)) void backupUpdate(
  sqlite3_backup *p,
  Pgno iPage,
  const u8 *aData
){
  ((void) (0));
  do{
    ((void) (0));
    if( !isFatalError(p->rc) && iPage<p->iNext ){




      int rc;
      ((void) (0));
      sqlite3_mutex_enter(p->pDestDb->mutex);
      rc = backupOnePage(p, iPage, aData, 1);
      sqlite3_mutex_leave(p->pDestDb->mutex);
      ((void) (0));
      if( rc!=0 ){
        p->rc = rc;
      }
    }
  }while( (p = p->pNext)!=0 );
}
static void sqlite3BackupUpdate(sqlite3_backup *pBackup, Pgno iPage, const u8 *aData){
  if( pBackup ) backupUpdate(pBackup, iPage, aData);
}
# 84684 "c_tests/sqlite3.c"
static void sqlite3BackupRestart(sqlite3_backup *pBackup){
  sqlite3_backup *p;
  for(p=pBackup; p; p=p->pNext){
    ((void) (0));
    p->iNext = 1;
  }
}
# 84701 "c_tests/sqlite3.c"
static int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){
  int rc;
  sqlite3_file *pFd;
  sqlite3_backup b;
  sqlite3BtreeEnter(pTo);
  sqlite3BtreeEnter(pFrom);

  ((void) (0));
  pFd = sqlite3PagerFile(sqlite3BtreePager(pTo));
  if( pFd->pMethods ){
    i64 nByte = sqlite3BtreeGetPageSize(pFrom)*(i64)sqlite3BtreeLastPage(pFrom);
    rc = sqlite3OsFileControl(pFd, 11, &nByte);
    if( rc==12 ) rc = 0;
    if( rc ) goto copy_finished;
  }






  memset(&b, 0, sizeof(b));
  b.pSrcDb = pFrom->db;
  b.pSrc = pFrom;
  b.pDest = pTo;
  b.iNext = 1;







  sqlite3_backup_step(&b, 0x7FFFFFFF);
  ((void) (0));

  rc = sqlite3_backup_finish(&b);
  if( rc==0 ){
    pTo->pBt->btsFlags &= ~0x0002;
  }else{
    sqlite3PagerClearCache(sqlite3BtreePager(b.pDest));
  }

  ((void) (0));
copy_finished:
  sqlite3BtreeLeave(pFrom);
  sqlite3BtreeLeave(pTo);
  return rc;
}
# 84859 "c_tests/sqlite3.c"
static void vdbeMemRenderNum(int sz, char *zBuf, Mem *p){
  StrAccum acc;
  ((void) (0));
  ((void) (0));
  if( p->flags & 0x0004 ){
# 84872 "c_tests/sqlite3.c"
    p->n = sqlite3Int64ToText(p->u.i, zBuf);

  }else{
    sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);
    sqlite3_str_appendf(&acc, "%!.15g",
         (p->flags & 0x0020)!=0 ? (double)p->u.i : p->u.r);
    ((void) (0));
    zBuf[acc.nChar] = 0;
    p->n = acc.nChar;
  }
}
# 84956 "c_tests/sqlite3.c"
static int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){

  int rc;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( !(pMem->flags&0x0002) ){
    pMem->enc = desiredEnc;
    return 0;
  }
  if( pMem->enc==desiredEnc ){
    return 0;
  }
  ((void) (0));







  rc = sqlite3VdbeMemTranslate(pMem, (u8)desiredEnc);
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return rc;

}
# 84995 "c_tests/sqlite3.c"
static __attribute__((noinline)) int sqlite3VdbeMemGrow(Mem *pMem, int n, int bPreserve){
  ((void) (0));
  ((void) (0));
                         ;



  ((void) (0));
                                     ;

  ((void) (0));



  if( pMem->szMalloc>0 && bPreserve && pMem->z==pMem->zMalloc ){
    if( pMem->db ){
      pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);
    }else{
      pMem->zMalloc = sqlite3Realloc(pMem->z, n);
      if( pMem->zMalloc==0 ) sqlite3_free(pMem->z);
      pMem->z = pMem->zMalloc;
    }
    bPreserve = 0;
  }else{
    if( pMem->szMalloc>0 ) sqlite3DbFreeNN(pMem->db, pMem->zMalloc);
    pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n);
  }
  if( pMem->zMalloc==0 ){
    sqlite3VdbeMemSetNull(pMem);
    pMem->z = 0;
    pMem->szMalloc = 0;
    return 7;
  }else{
    pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);
  }

  if( bPreserve && pMem->z ){
    ((void) (0));
    memcpy(pMem->zMalloc, pMem->z, pMem->n);
  }
  if( (pMem->flags&0x1000)!=0 ){
    ((void) (0));
    pMem->xDel((void *)(pMem->z));
  }

  pMem->z = pMem->zMalloc;
  pMem->flags &= ~(0x1000|0x4000|0x2000);
  return 0;
}
# 85058 "c_tests/sqlite3.c"
static int sqlite3VdbeMemClearAndResize(Mem *pMem, int szNew){
  ((void) (0));
  ((void) (0));
  if( pMem->szMalloc<szNew ){
    return sqlite3VdbeMemGrow(pMem, szNew, 0);
  }
  ((void) (0));
  pMem->z = pMem->zMalloc;
  pMem->flags &= (0x0001|0x0004|0x0008|0x0020);
  return 0;
}
# 85077 "c_tests/sqlite3.c"
static void sqlite3VdbeMemZeroTerminateIfAble(Mem *pMem){
  if( (pMem->flags & (0x0002|0x0200|0x4000|0x2000))!=0x0002 ){

    return;
  }
  if( pMem->enc!=1 ) return;
  ((void) (0));
  if( pMem->flags & 0x1000 ){
    if( pMem->xDel==sqlite3_free
     && sqlite3_msize(pMem->z) >= (u64)(pMem->n+1)
    ){
      pMem->z[pMem->n] = 0;
      pMem->flags |= 0x0200;
      return;
    }
    if( pMem->xDel==sqlite3RCStrUnref ){

      pMem->flags |= 0x0200;
      return;
    }
  }else if( pMem->szMalloc >= pMem->n+1 ){
    pMem->z[pMem->n] = 0;
    pMem->flags |= 0x0200;
    return;
  }
}
# 85113 "c_tests/sqlite3.c"
static __attribute__((noinline)) int vdbeMemAddTerminator(Mem *pMem){
  if( sqlite3VdbeMemGrow(pMem, pMem->n+3, 1) ){
    return 7;
  }
  pMem->z[pMem->n] = 0;
  pMem->z[pMem->n+1] = 0;
  pMem->z[pMem->n+2] = 0;
  pMem->flags |= 0x0200;
  return 0;
}







static int sqlite3VdbeMemMakeWriteable(Mem *pMem){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( (pMem->flags & (0x0002|0x0010))!=0 ){
    if( (((pMem)->flags&0x0400)?sqlite3VdbeMemExpandBlob(pMem):0) ) return 7;
    if( pMem->szMalloc==0 || pMem->z!=pMem->zMalloc ){
      int rc = vdbeMemAddTerminator(pMem);
      if( rc ) return rc;
    }
  }
  pMem->flags &= ~0x4000;




  return 0;
}






static int sqlite3VdbeMemExpandBlob(Mem *pMem){
  int nByte;
  ((void) (0));
  ((void) (0));
  ((void) (0));
                                          ;
  ((void) (0));
  ((void) (0));


  nByte = pMem->n + pMem->u.nZero;
  if( nByte<=0 ){
    if( (pMem->flags & 0x0010)==0 ) return 0;
    nByte = 1;
  }
  if( sqlite3VdbeMemGrow(pMem, nByte, 1) ){
    return 7;
  }
  ((void) (0));
  ((void) (0));

  memset(&pMem->z[pMem->n], 0, pMem->u.nZero);
  pMem->n += pMem->u.nZero;
  pMem->flags &= ~(0x0400|0x0200);
  return 0;
}





static int sqlite3VdbeMemNulTerminate(Mem *pMem){
  ((void) (0));
  ((void) (0));
                                                                    ;
                                                   ;
  if( (pMem->flags & (0x0200|0x0002))!=0x0002 ){
    return 0;
  }else{
    return vdbeMemAddTerminator(pMem);
  }
}
# 85211 "c_tests/sqlite3.c"
static int sqlite3VdbeMemStringify(Mem *pMem, u8 enc, u8 bForce){
  const int nByte = 32;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  if( sqlite3VdbeMemClearAndResize(pMem, nByte) ){
    pMem->enc = 0;
    return 7;
  }

  vdbeMemRenderNum(nByte, pMem->z, pMem);
  ((void) (0));
  ((void) (0));
  pMem->enc = 1;
  pMem->flags |= 0x0002|0x0200;
  if( bForce ) pMem->flags &= ~(0x0004|0x0008|0x0020);
  sqlite3VdbeChangeEncoding(pMem, enc);
  return 0;
}
# 85246 "c_tests/sqlite3.c"
static int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){
  sqlite3_context ctx;
  Mem t;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  memset(&ctx, 0, sizeof(ctx));
  memset(&t, 0, sizeof(t));
  t.flags = 0x0001;
  t.db = pMem->db;
  ctx.pOut = &t;
  ctx.pMem = pMem;
  ctx.pFunc = pFunc;
  ctx.enc = ((t.db)->enc);
  pFunc->xFinalize(&ctx);
  ((void) (0));
  if( pMem->szMalloc>0 ) sqlite3DbFreeNN(pMem->db, pMem->zMalloc);
  memcpy(pMem, &t, sizeof(t));
  return ctx.isError;
}
# 85279 "c_tests/sqlite3.c"
static int sqlite3VdbeMemAggValue(Mem *pAccum, Mem *pOut, FuncDef *pFunc){
  sqlite3_context ctx;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  memset(&ctx, 0, sizeof(ctx));
  sqlite3VdbeMemSetNull(pOut);
  ctx.pOut = pOut;
  ctx.pMem = pAccum;
  ctx.pFunc = pFunc;
  ctx.enc = ((pAccum->db)->enc);
  pFunc->xValue(&ctx);
  return ctx.isError;
}
# 85306 "c_tests/sqlite3.c"
static __attribute__((noinline)) void vdbeMemClearExternAndSetNull(Mem *p){
  ((void) (0));
  ((void) (0));
  if( p->flags&0x8000 ){
    sqlite3VdbeMemFinalize(p, p->u.pDef);
    ((void) (0));
                                  ;
  }
  if( p->flags&0x1000 ){
    ((void) (0));
    p->xDel((void *)p->z);
  }
  p->flags = 0x0001;
}
# 85329 "c_tests/sqlite3.c"
static __attribute__((noinline)) void vdbeMemClear(Mem *p){
  if( (((p)->flags&(0x8000|0x1000))!=0) ){
    vdbeMemClearExternAndSetNull(p);
  }
  if( p->szMalloc ){
    sqlite3DbFreeNN(p->db, p->zMalloc);
    p->szMalloc = 0;
  }
  p->z = 0;
}
# 85350 "c_tests/sqlite3.c"
static void sqlite3VdbeMemRelease(Mem *p){
  ((void) (0));
  if( (((p)->flags&(0x8000|0x1000))!=0) || p->szMalloc ){
    vdbeMemClear(p);
  }
}




static void sqlite3VdbeMemReleaseMalloc(Mem *p){
  ((void) (0));
  if( p->szMalloc ) vdbeMemClear(p);
}
# 85376 "c_tests/sqlite3.c"
static __attribute__((noinline)) i64 memIntValue(const Mem *pMem){
  i64 value = 0;
  sqlite3Atoi64(pMem->z, &value, pMem->n, pMem->enc);
  return value;
}
static i64 sqlite3VdbeIntValue(const Mem *pMem){
  int flags;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  flags = pMem->flags;
  if( flags & (0x0004|0x0020) ){
                                   ;
    return pMem->u.i;
  }else if( flags & 0x0008 ){
    return sqlite3RealToI64(pMem->u.r);
  }else if( (flags & (0x0002|0x0010))!=0 && pMem->z!=0 ){
    return memIntValue(pMem);
  }else{
    return 0;
  }
}







static __attribute__((noinline)) double memRealValue(Mem *pMem){

  double val = (double)0;
  sqlite3AtoF(pMem->z, &val, pMem->n, pMem->enc);
  return val;
}
static double sqlite3VdbeRealValue(Mem *pMem){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pMem->flags & 0x0008 ){
    return pMem->u.r;
  }else if( pMem->flags & (0x0004|0x0020) ){
                                         ;
    return (double)pMem->u.i;
  }else if( pMem->flags & (0x0002|0x0010) ){
    return memRealValue(pMem);
  }else{

    return (double)0;
  }
}





static int sqlite3VdbeBooleanValue(Mem *pMem, int ifNull){
                                       ;
  if( pMem->flags & (0x0004|0x0020) ) return pMem->u.i!=0;
  if( pMem->flags & 0x0001 ) return ifNull;
  return sqlite3VdbeRealValue(pMem)!=0.0;
}





static void sqlite3VdbeIntegerAffinity(Mem *pMem){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pMem->flags & 0x0020 ){
    ((pMem)->flags = ((pMem)->flags&~(0x0dbf|0x0400))|0x0004);
  }else{
    i64 ix = sqlite3RealToI64(pMem->u.r);
# 85465 "c_tests/sqlite3.c"
    if( pMem->u.r==ix && ix>(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) && ix<(0xffffffff|(((i64)0x7fffffff)<<32)) ){
      pMem->u.i = ix;
      ((pMem)->flags = ((pMem)->flags&~(0x0dbf|0x0400))|0x0004);
    }
  }
}




static int sqlite3VdbeMemIntegerify(Mem *pMem){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  pMem->u.i = sqlite3VdbeIntValue(pMem);
  ((pMem)->flags = ((pMem)->flags&~(0x0dbf|0x0400))|0x0004);
  return 0;
}





static int sqlite3VdbeMemRealify(Mem *pMem){
  ((void) (0));
  ((void) (0));
  ((void) (0));

  pMem->u.r = sqlite3VdbeRealValue(pMem);
  ((pMem)->flags = ((pMem)->flags&~(0x0dbf|0x0400))|0x0008);
  return 0;
}
# 85509 "c_tests/sqlite3.c"
static int sqlite3RealSameAsInt(double r1, sqlite3_int64 i){
  double r2 = (double)i;
  return r1==0.0
      || (memcmp(&r1, &r2, sizeof(r1))==0
          && i >= -2251799813685248LL && i < 2251799813685248LL);
}





static i64 sqlite3RealToI64(double r){
  if( r<-9223372036854774784.0 ) return (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)));
  if( r>+9223372036854774784.0 ) return (0xffffffff|(((i64)0x7fffffff)<<32));
  return (i64)r;
}
# 85534 "c_tests/sqlite3.c"
static int sqlite3VdbeMemNumerify(Mem *pMem){
  ((void) (0));
                                   ;
                                    ;
                                       ;
                                    ;
  if( (pMem->flags & (0x0004|0x0008|0x0020|0x0001))==0 ){
    int rc;
    sqlite3_int64 ix;
    ((void) (0));
    ((void) (0));
    rc = sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);
    if( ((rc==0 || rc==1) && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)<=1)
     || sqlite3RealSameAsInt(pMem->u.r, (ix = sqlite3RealToI64(pMem->u.r)))
    ){
      pMem->u.i = ix;
      ((pMem)->flags = ((pMem)->flags&~(0x0dbf|0x0400))|0x0004);
    }else{
      ((pMem)->flags = ((pMem)->flags&~(0x0dbf|0x0400))|0x0008);
    }
  }
  ((void) (0));
  pMem->flags &= ~(0x0002|0x0010|0x0400);
  return 0;
}
# 85567 "c_tests/sqlite3.c"
static int sqlite3VdbeMemCast(Mem *pMem, u8 aff, u8 encoding){
  if( pMem->flags & 0x0001 ) return 0;
  switch( aff ){
    case 0x41: {
      if( (pMem->flags & 0x0010)==0 ){
        sqlite3ValueApplyAffinity(pMem, 0x42, encoding);
        ((void) (0));
        if( pMem->flags & 0x0002 ) ((pMem)->flags = ((pMem)->flags&~(0x0dbf|0x0400))|0x0010);
      }else{
        pMem->flags &= ~(0x0dbf&~0x0010);
      }
      break;
    }
    case 0x43: {
      sqlite3VdbeMemNumerify(pMem);
      break;
    }
    case 0x44: {
      sqlite3VdbeMemIntegerify(pMem);
      break;
    }
    case 0x45: {
      sqlite3VdbeMemRealify(pMem);
      break;
    }
    default: {
      int rc;
      ((void) (0));
      ((void) (0));
      pMem->flags |= (pMem->flags&0x0010)>>3;
      sqlite3ValueApplyAffinity(pMem, 0x42, encoding);
      ((void) (0));
      pMem->flags &= ~(0x0004|0x0008|0x0020|0x0010|0x0400);
      if( encoding!=1 ) pMem->n &= ~1;
      rc = sqlite3VdbeChangeEncoding(pMem, encoding);
      if( rc ) return rc;
      sqlite3VdbeMemZeroTerminateIfAble(pMem);
    }
  }
  return 0;
}






static void sqlite3VdbeMemInit(Mem *pMem, sqlite3 *db, u16 flags){
  ((void) (0));
  pMem->flags = flags;
  pMem->db = db;
  pMem->szMalloc = 0;
}
# 85634 "c_tests/sqlite3.c"
static void sqlite3VdbeMemSetNull(Mem *pMem){
  if( (((pMem)->flags&(0x8000|0x1000))!=0) ){
    vdbeMemClearExternAndSetNull(pMem);
  }else{
    pMem->flags = 0x0001;
  }
}
static void sqlite3ValueSetNull(sqlite3_value *p){
  sqlite3VdbeMemSetNull((Mem*)p);
}






static void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){
  sqlite3VdbeMemRelease(pMem);
  pMem->flags = 0x0010|0x0400;
  pMem->n = 0;
  if( n<0 ) n = 0;
  pMem->u.nZero = n;
  pMem->enc = 1;
  pMem->z = 0;
}
# 85680 "c_tests/sqlite3.c"
static __attribute__((noinline)) void vdbeReleaseAndSetInt64(Mem *pMem, i64 val){
  sqlite3VdbeMemSetNull(pMem);
  pMem->u.i = val;
  pMem->flags = 0x0004;
}





static void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){
  if( (((pMem)->flags&(0x8000|0x1000))!=0) ){
    vdbeReleaseAndSetInt64(pMem, val);
  }else{
    pMem->u.i = val;
    pMem->flags = 0x0004;
  }
}




static void sqlite3MemSetArrayInt64(sqlite3_value *aMem, int iIdx, i64 val){
  sqlite3VdbeMemSetInt64(&aMem[iIdx], val);
}


static void sqlite3NoopDestructor(void *p){ (void)(p); }





static void sqlite3VdbeMemSetPointer(
  Mem *pMem,
  void *pPtr,
  const char *zPType,
  void (*xDestructor)(void*)
){
  ((void) (0));
  vdbeMemClear(pMem);
  pMem->u.zPType = zPType ? zPType : "";
  pMem->z = pPtr;
  pMem->flags = 0x0001|0x1000|0x0800|0x0200;
  pMem->eSubtype = 'p';
  pMem->xDel = xDestructor ? xDestructor : sqlite3NoopDestructor;
}






static void sqlite3VdbeMemSetDouble(Mem *pMem, double val){
  sqlite3VdbeMemSetNull(pMem);
  if( !sqlite3IsNaN(val) ){
    pMem->u.r = val;
    pMem->flags = 0x0008;
  }
}
# 85760 "c_tests/sqlite3.c"
static int sqlite3VdbeMemSetRowSet(Mem *pMem){
  sqlite3 *db = pMem->db;
  RowSet *p;
  ((void) (0));
  ((void) (0));
  sqlite3VdbeMemRelease(pMem);
  p = sqlite3RowSetInit(db);
  if( p==0 ) return 7;
  pMem->z = (char*)p;
  pMem->flags = 0x0010|0x1000;
  pMem->xDel = sqlite3RowSetDelete;
  return 0;
}





static int sqlite3VdbeMemTooBig(Mem *p){
  ((void) (0));
  if( p->flags & (0x0002|0x0010) ){
    int n = p->n;
    if( p->flags & 0x0400 ){
      n += p->u.nZero;
    }
    return n>p->db->aLimit[0];
  }
  return 0;
}
# 85837 "c_tests/sqlite3.c"
static __attribute__((noinline)) void vdbeClrCopy(Mem *pTo, const Mem *pFrom, int eType){
  vdbeMemClearExternAndSetNull(pTo);
  ((void) (0));
  sqlite3VdbeMemShallowCopy(pTo, pFrom, eType);
}
static void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){
  ((void) (0));
  ((void) (0));
  if( (((pTo)->flags&(0x8000|0x1000))!=0) ){ vdbeClrCopy(pTo,pFrom,srcType); return; }
  memcpy(pTo, pFrom, __builtin_offsetof(Mem, db));
  if( (pFrom->flags&0x2000)==0 ){
    pTo->flags &= ~(0x1000|0x2000|0x4000);
    ((void) (0));
    pTo->flags |= srcType;
  }
}





static int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){
  int rc = 0;

  ((void) (0));
  if( (((pTo)->flags&(0x8000|0x1000))!=0) ) vdbeMemClearExternAndSetNull(pTo);
  memcpy(pTo, pFrom, __builtin_offsetof(Mem, db));
  pTo->flags &= ~0x1000;
  if( pTo->flags&(0x0002|0x0010) ){
    if( 0==(pFrom->flags&0x2000) ){
      pTo->flags |= 0x4000;
      rc = sqlite3VdbeMemMakeWriteable(pTo);
    }
  }

  return rc;
}







static void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){
  ((void) (0));
  ((void) (0));
  ((void) (0));

  sqlite3VdbeMemRelease(pTo);
  memcpy(pTo, pFrom, sizeof(Mem));
  pFrom->flags = 0x0001;
  pFrom->szMalloc = 0;
}
# 85914 "c_tests/sqlite3.c"
static int sqlite3VdbeMemSetStr(
  Mem *pMem,
  const char *z,
  i64 n,
  u8 enc,
  void (*xDel)(void*)
){
  i64 nByte = n;
  int iLimit;
  u16 flags;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  if( !z ){
    sqlite3VdbeMemSetNull(pMem);
    return 0;
  }

  if( pMem->db ){
    iLimit = pMem->db->aLimit[0];
  }else{
    iLimit = 1000000000;
  }
  if( nByte<0 ){
    ((void) (0));
    if( enc==1 ){
      nByte = strlen(z);
    }else{
      for(nByte=0; nByte<=iLimit && (z[nByte] | z[nByte+1]); nByte+=2){}
    }
    flags= 0x0002|0x0200;
  }else if( enc==0 ){
    flags = 0x0010;
    enc = 1;
  }else{
    flags = 0x0002;
  }
  if( nByte>iLimit ){
    if( xDel && xDel!=((sqlite3_destructor_type)-1) ){
      if( xDel==((sqlite3_destructor_type)sqlite3RowSetClear) ){
        sqlite3DbFree(pMem->db, (void*)z);
      }else{
        xDel((void*)z);
      }
    }
    sqlite3VdbeMemSetNull(pMem);
    return sqlite3ErrorToParser(pMem->db, 18);
  }





  if( xDel==((sqlite3_destructor_type)-1) ){
    i64 nAlloc = nByte;
    if( flags&0x0200 ){
      nAlloc += (enc==1?1:2);
    }
                         ;
                          ;
                          ;
    if( sqlite3VdbeMemClearAndResize(pMem, (int)((nAlloc)>(32)?(nAlloc):(32))) ){
      return 7;
    }
    ((void) (0));
    memcpy(pMem->z, z, nAlloc);
  }else{
    sqlite3VdbeMemRelease(pMem);
    pMem->z = (char *)z;
    if( xDel==((sqlite3_destructor_type)sqlite3RowSetClear) ){
      pMem->zMalloc = pMem->z;
      pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);
    }else{
      pMem->xDel = xDel;
      flags |= ((xDel==((sqlite3_destructor_type)0))?0x2000:0x1000);
    }
  }

  pMem->n = (int)(nByte & 0x7fffffff);
  pMem->flags = flags;
  pMem->enc = enc;


  if( enc>1 && sqlite3VdbeMemHandleBom(pMem) ){
    return 7;
  }



  return 0;
}
# 86025 "c_tests/sqlite3.c"
static int sqlite3VdbeMemFromBtree(
  BtCursor *pCur,
  u32 offset,
  u32 amt,
  Mem *pMem
){
  int rc;
  pMem->flags = 0x0001;
  if( sqlite3BtreeMaxRecordSize(pCur)<offset+amt ){
    return sqlite3CorruptError(86034);
  }
  if( 0==(rc = sqlite3VdbeMemClearAndResize(pMem, amt+1)) ){
    rc = sqlite3BtreePayload(pCur, offset, amt, pMem->z);
    if( rc==0 ){
      pMem->z[amt] = 0;
      pMem->flags = 0x0010;
      pMem->n = (int)amt;
    }else{
      sqlite3VdbeMemRelease(pMem);
    }
  }
  return rc;
}
static int sqlite3VdbeMemFromBtreeZeroOffset(
  BtCursor *pCur,
  u32 amt,
  Mem *pMem
){
  u32 available = 0;
  int rc = 0;

  ((void) (0));
  ((void) (0));



  ((void) (0));
  pMem->z = (char *)sqlite3BtreePayloadFetch(pCur, &available);
  ((void) (0));

  if( amt<=available ){
    pMem->flags = 0x0010|0x4000;
    pMem->n = (int)amt;
  }else{
    rc = sqlite3VdbeMemFromBtree(pCur, 0, amt, pMem);
  }

  return rc;
}






static __attribute__((noinline)) const void *valueToText(sqlite3_value* pVal, u8 enc){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pVal->flags & (0x0010|0x0002) ){
    if( (((pVal)->flags&0x0400)?sqlite3VdbeMemExpandBlob(pVal):0) ) return 0;
    pVal->flags |= 0x0002;
    if( pVal->enc != (enc & ~8) ){
      sqlite3VdbeChangeEncoding(pVal, enc & ~8);
    }
    if( (enc & 8)!=0 && 1==(1&((int)(long int)(pVal->z))) ){
      ((void) (0));
      if( sqlite3VdbeMemMakeWriteable(pVal)!=0 ){
        return 0;
      }
    }
    sqlite3VdbeMemNulTerminate(pVal);
  }else{
    sqlite3VdbeMemStringify(pVal, enc, 0);
    ((void) (0));
  }
  ((void) (0));

  if( pVal->enc==(enc & ~8) ){
    ((void) (0));
    return pVal->z;
  }else{
    return 0;
  }
}
# 86123 "c_tests/sqlite3.c"
static const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){
  if( !pVal ) return 0;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( (pVal->flags&(0x0002|0x0200))==(0x0002|0x0200) && pVal->enc==enc ){
    ((void) (0));
    return pVal->z;
  }
  if( pVal->flags&0x0001 ){
    return 0;
  }
  return valueToText(pVal, enc);
}







static int sqlite3ValueIsOfClass(const sqlite3_value *pVal, void(*xFree)(void*)){
  if( (pVal!=0)
   && ((pVal->flags & (0x0002|0x0010))!=0)
   && (pVal->flags & 0x1000)!=0
   && pVal->xDel==xFree
  ){
    return 1;
  }else{
    return 0;
  }
}




static sqlite3_value *sqlite3ValueNew(sqlite3 *db){
  Mem *p = sqlite3DbMallocZero(db, sizeof(*p));
  if( p ){
    p->flags = 0x0001;
    p->db = db;
  }
  return p;
}





struct ValueNewStat4Ctx {
  Parse *pParse;
  Index *pIdx;
  UnpackedRecord **ppRec;
  int iVal;
};
# 86190 "c_tests/sqlite3.c"
static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p){
# 86227 "c_tests/sqlite3.c"
  (void)(p);

  return sqlite3ValueNew(db);
}
# 86353 "c_tests/sqlite3.c"
static int valueFromExpr(
  sqlite3 *db,
  const Expr *pExpr,
  u8 enc,
  u8 affinity,
  sqlite3_value **ppVal,
  struct ValueNewStat4Ctx *pCtx
){
  int op;
  char *zVal = 0;
  sqlite3_value *pVal = 0;
  int negInt = 1;
  const char *zNeg = "";
  int rc = 0;

  ((void) (0));
  while( (op = pExpr->op)==173 || op==181 ) pExpr = pExpr->pLeft;
  if( op==176 ) op = pExpr->op2;





  ((void) (0));

  if( op==36 ){
    u8 aff;
    ((void) (0));
    aff = sqlite3AffinityType(pExpr->u.zToken,0);
    rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);
                             ;
    if( *ppVal ){





      ((void) (0));

      sqlite3VdbeMemCast(*ppVal, aff, enc);
      sqlite3ValueApplyAffinity(*ppVal, affinity, enc);
    }
    return rc;
  }




  if( op==174 ){
    Expr *pLeft = pExpr->pLeft;
    if( (pLeft->op==156 || pLeft->op==154) ){
      if( (((pLeft)->flags&(u32)(0x000800))!=0)
       || pLeft->u.zToken[0]!='0' || (pLeft->u.zToken[1] & ~0x20)!='X'
      ){
        pExpr = pLeft;
        op = pExpr->op;
        negInt = -1;
        zNeg = "-";
      }
    }
  }

  if( op==118 || op==154 || op==156 ){
    pVal = valueNew(db, pCtx);
    if( pVal==0 ) goto no_mem;
    if( (((pExpr)->flags&(u32)(0x000800))!=0) ){
      sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue*negInt);
    }else{
      i64 iVal;
      if( op==156 && 0==sqlite3DecOrHexToI64(pExpr->u.zToken, &iVal) ){
        sqlite3VdbeMemSetInt64(pVal, iVal*negInt);
      }else{
        zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr->u.zToken);
        if( zVal==0 ) goto no_mem;
        sqlite3ValueSetStr(pVal, -1, zVal, 1, ((sqlite3_destructor_type)sqlite3RowSetClear));
      }
    }
    if( affinity==0x41 ){
      if( op==154 ){
        ((void) (0));
        sqlite3AtoF(pVal->z, &pVal->u.r, pVal->n, 1);
        pVal->flags = 0x0008;
      }else if( op==156 ){



        sqlite3ValueApplyAffinity(pVal, 0x43, 1);
      }
    }else{
      sqlite3ValueApplyAffinity(pVal, affinity, 1);
    }
    ((void) (0));
    if( pVal->flags & (0x0004|0x0020|0x0008) ){
                                       ;
                                        ;
      pVal->flags &= ~0x0002;
    }
    if( enc!=1 ){
      rc = sqlite3VdbeChangeEncoding(pVal, enc);
    }
  }else if( op==174 ) {

    if( 0==valueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal,pCtx)
     && pVal!=0
    ){
      sqlite3VdbeMemNumerify(pVal);
      if( pVal->flags & 0x0008 ){
        pVal->u.r = -pVal->u.r;
      }else if( pVal->u.i==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ){

        pVal->u.r = -(double)(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)));



        ((pVal)->flags = ((pVal)->flags&~(0x0dbf|0x0400))|0x0008);
      }else{
        pVal->u.i = -pVal->u.i;
      }
      sqlite3ValueApplyAffinity(pVal, affinity, enc);
    }
  }else if( op==122 ){
    pVal = valueNew(db, pCtx);
    if( pVal==0 ) goto no_mem;
    sqlite3VdbeMemSetNull(pVal);
  }

  else if( op==155 ){
    int nVal;
    ((void) (0));
    ((void) (0));
    ((void) (0));
    pVal = valueNew(db, pCtx);
    if( !pVal ) goto no_mem;
    zVal = &pExpr->u.zToken[2];
    nVal = sqlite3Strlen30(zVal)-1;
    ((void) (0));
    sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal/2,
                         0, ((sqlite3_destructor_type)sqlite3RowSetClear));
  }






  else if( op==171 ){
    ((void) (0));
    pVal = valueNew(db, pCtx);
    if( pVal ){
      pVal->flags = 0x0004;
      pVal->u.i = pExpr->u.zToken[4]==0;
      sqlite3ValueApplyAffinity(pVal, affinity, enc);
    }
  }

  *ppVal = pVal;
  return rc;

no_mem:



    sqlite3OomFault(db);
  sqlite3DbFree(db, zVal);
  ((void) (0));



  ((void) (0)); sqlite3ValueFree(pVal);

  return 7;
}
# 86536 "c_tests/sqlite3.c"
static int sqlite3ValueFromExpr(
  sqlite3 *db,
  const Expr *pExpr,
  u8 enc,
  u8 affinity,
  sqlite3_value **ppVal
){
  return pExpr ? valueFromExpr(db, pExpr, enc, affinity, ppVal, 0) : 0;
}
# 86765 "c_tests/sqlite3.c"
static void sqlite3ValueSetStr(
  sqlite3_value *v,
  int n,
  const void *z,
  u8 enc,
  void (*xDel)(void*)
){
  if( v ) sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel);
}




static void sqlite3ValueFree(sqlite3_value *v){
  if( !v ) return;
  sqlite3VdbeMemRelease((Mem *)v);
  sqlite3DbFreeNN(((Mem*)v)->db, v);
}






static __attribute__((noinline)) int valueBytes(sqlite3_value *pVal, u8 enc){
  return valueToText(pVal, enc)!=0 ? pVal->n : 0;
}
static int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){
  Mem *p = (Mem*)pVal;
  ((void) (0));
  if( (p->flags & 0x0002)!=0 && pVal->enc==enc ){
    return p->n;
  }
  if( (p->flags & 0x0002)!=0 && enc!=1 && pVal->enc!=1 ){
    return p->n;
  }
  if( (p->flags & 0x0010)!=0 ){
    if( p->flags & 0x0400 ){
      return p->n + p->u.nZero;
    }else{
      return p->n;
    }
  }
  if( p->flags & 0x0001 ) return 0;
  return valueBytes(pVal, enc);
}
# 86832 "c_tests/sqlite3.c"
static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef);
static void vdbeFreeOpArray(sqlite3 *, Op *, int);




static Vdbe *sqlite3VdbeCreate(Parse *pParse){
  sqlite3 *db = pParse->db;
  Vdbe *p;
  p = sqlite3DbMallocRawNN(db, sizeof(Vdbe) );
  if( p==0 ) return 0;
  memset(&p->aOp, 0, sizeof(Vdbe)-__builtin_offsetof(Vdbe, aOp));
  p->db = db;
  if( db->pVdbe ){
    db->pVdbe->ppVPrev = &p->pVNext;
  }
  p->pVNext = db->pVdbe;
  p->ppVPrev = &db->pVdbe;
  db->pVdbe = p;
  ((void) (0));
  p->pParse = pParse;
  pParse->pVdbe = p;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  sqlite3VdbeAddOp2(p, 8, 0, 1);
  return p;
}




static Parse *sqlite3VdbeParser(Vdbe *p){
  return p->pParse;
}




static void sqlite3VdbeError(Vdbe *p, const char *zFormat, ...){
  va_list ap;
  sqlite3DbFree(p->db, p->zErrMsg);
  __builtin_va_start(ap, zFormat);
  p->zErrMsg = sqlite3VMPrintf(p->db, zFormat, ap);
  __builtin_va_end(ap);
}




static void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, u8 prepFlags){
  if( p==0 ) return;
  p->prepFlags = prepFlags;
  if( (prepFlags & 0x80)==0 ){
    p->expmask = 0;
  }
  ((void) (0));
  p->zSql = sqlite3DbStrNDup(p->db, z, n);
}
# 86940 "c_tests/sqlite3.c"
static void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){
  Vdbe tmp, *pTmp, **ppTmp;
  char *zTmp;
  ((void) (0));
  tmp = *pA;
  *pA = *pB;
  *pB = tmp;
  pTmp = pA->pVNext;
  pA->pVNext = pB->pVNext;
  pB->pVNext = pTmp;
  ppTmp = pA->ppVPrev;
  pA->ppVPrev = pB->ppVPrev;
  pB->ppVPrev = ppTmp;
  zTmp = pA->zSql;
  pA->zSql = pB->zSql;
  pB->zSql = zTmp;





  pB->expmask = pA->expmask;
  pB->prepFlags = pA->prepFlags;
  memcpy(pB->aCounter, pA->aCounter, sizeof(pB->aCounter));
  pB->aCounter[5]++;
}
# 86977 "c_tests/sqlite3.c"
static int growOpArray(Vdbe *v, int nOp){
  VdbeOp *pNew;
  Parse *p = v->pParse;
# 86992 "c_tests/sqlite3.c"
  sqlite3_int64 nNew = (v->nOpAlloc ? 2*(sqlite3_int64)v->nOpAlloc
                        : (sqlite3_int64)(1024/sizeof(Op)));
  (void)(nOp);



  if( nNew > p->db->aLimit[5] ){
    sqlite3OomFault(p->db);
    return 7;
  }

  ((void) (0));
  ((void) (0));
  pNew = sqlite3DbRealloc(p->db, v->aOp, nNew*sizeof(Op));
  if( pNew ){
    p->szOpAlloc = sqlite3DbMallocSize(p->db, pNew);
    v->nOpAlloc = p->szOpAlloc/sizeof(Op);
    v->aOp = pNew;
  }
  return (pNew ? 0 : 7);
}
# 87040 "c_tests/sqlite3.c"
static __attribute__((noinline)) int growOp3(Vdbe *p, int op, int p1, int p2, int p3){
  ((void) (0));
  if( growOpArray(p, 1) ) return 1;
  ((void) (0));
  return sqlite3VdbeAddOp3(p, op, p1, p2, p3);
}
static __attribute__((noinline)) int addOp4IntSlow(
  Vdbe *p,
  int op,
  int p1,
  int p2,
  int p3,
  int p4
){
  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  if( p->db->mallocFailed==0 ){
    VdbeOp *pOp = &p->aOp[addr];
    pOp->p4type = (-3);
    pOp->p4.i = p4;
  }
  return addr;
}
# 87076 "c_tests/sqlite3.c"
static int sqlite3VdbeAddOp0(Vdbe *p, int op){
  return sqlite3VdbeAddOp3(p, op, 0, 0, 0);
}
static int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){
  return sqlite3VdbeAddOp3(p, op, p1, 0, 0);
}
static int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){
  return sqlite3VdbeAddOp3(p, op, p1, p2, 0);
}
static int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){
  int i;
  VdbeOp *pOp;

  i = p->nOp;
  ((void) (0));
  ((void) (0));
  if( p->nOpAlloc<=i ){
    return growOp3(p, op, p1, p2, p3);
  }
  ((void) (0));
  p->nOp++;
  pOp = &p->aOp[i];
  ((void) (0));
  pOp->opcode = (u8)op;
  pOp->p5 = 0;
  pOp->p1 = p1;
  pOp->p2 = p2;
  pOp->p3 = p3;
  pOp->p4.p = 0;
  pOp->p4type = 0;
# 87128 "c_tests/sqlite3.c"
  return i;
}
static int sqlite3VdbeAddOp4Int(
  Vdbe *p,
  int op,
  int p1,
  int p2,
  int p3,
  int p4
){
  int i;
  VdbeOp *pOp;

  i = p->nOp;
  if( p->nOpAlloc<=i ){
    return addOp4IntSlow(p, op, p1, p2, p3, p4);
  }
  p->nOp++;
  pOp = &p->aOp[i];
  ((void) (0));
  pOp->opcode = (u8)op;
  pOp->p5 = 0;
  pOp->p1 = p1;
  pOp->p2 = p2;
  pOp->p3 = p3;
  pOp->p4.i = p4;
  pOp->p4type = (-3);
# 87177 "c_tests/sqlite3.c"
  return i;
}



static int sqlite3VdbeGoto(Vdbe *p, int iDest){
  return sqlite3VdbeAddOp3(p, 9, 0, iDest, 0);
}




static int sqlite3VdbeLoadString(Vdbe *p, int iDest, const char *zStr){
  return sqlite3VdbeAddOp4(p, 118, 0, iDest, 0, zStr, 0);
}
# 87204 "c_tests/sqlite3.c"
static void sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes, ...){
  va_list ap;
  int i;
  char c;
  __builtin_va_start(ap, zTypes);
  for(i=0; (c = zTypes[i])!=0; i++){
    if( c=='s' ){
      const char *z = __builtin_va_arg(ap, const char*);
      sqlite3VdbeAddOp4(p, z==0 ? 76 : 118, 0, iDest+i, 0, z, 0);
    }else if( c=='i' ){
      sqlite3VdbeAddOp2(p, 72, __builtin_va_arg(ap, int), iDest+i);
    }else{
      goto skip_op_resultrow;
    }
  }
  sqlite3VdbeAddOp2(p, 85, iDest, i);
skip_op_resultrow:
  __builtin_va_end(ap);
}




static int sqlite3VdbeAddOp4(
  Vdbe *p,
  int op,
  int p1,
  int p2,
  int p3,
  const char *zP4,
  int p4type
){
  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  sqlite3VdbeChangeP4(p, addr, zP4, p4type);
  return addr;
}
# 87251 "c_tests/sqlite3.c"
static int sqlite3VdbeAddFunctionCall(
  Parse *pParse,
  int p1,
  int p2,
  int p3,
  int nArg,
  const FuncDef *pFunc,
  int eCallCtx
){
  Vdbe *v = pParse->pVdbe;
  int addr;
  sqlite3_context *pCtx;
  ((void) (0));
  pCtx = sqlite3DbMallocRawNN(pParse->db, (__builtin_offsetof(sqlite3_context, argv)+(nArg)*sizeof(sqlite3_value*)));
  if( pCtx==0 ){
    ((void) (0));
    freeEphemeralFunction(pParse->db, (FuncDef*)pFunc);
    return 0;
  }
  pCtx->pOut = 0;
  pCtx->pFunc = (FuncDef*)pFunc;
  pCtx->pVdbe = 0;
  pCtx->isError = 0;
  pCtx->argc = nArg;
  pCtx->iOp = sqlite3VdbeCurrentAddr(v);
  addr = sqlite3VdbeAddOp4(v, eCallCtx ? 66 : 67,
                           p1, p2, p3, (char*)pCtx, (-15));
  sqlite3VdbeChangeP5(v, eCallCtx & 0x00002e);
  sqlite3MayAbort(pParse);
  return addr;
}





static int sqlite3VdbeAddOp4Dup8(
  Vdbe *p,
  int op,
  int p1,
  int p2,
  int p3,
  const u8 *zP4,
  int p4type
){
  char *p4copy = sqlite3DbMallocRawNN(sqlite3VdbeDb(p), 8);
  if( p4copy ) memcpy(p4copy, zP4, 8);
  return sqlite3VdbeAddOp4(p, op, p1, p2, p3, p4copy, p4type);
}






static int sqlite3VdbeExplainParent(Parse *pParse){
  VdbeOp *pOp;
  if( pParse->addrExplain==0 ) return 0;
  pOp = sqlite3VdbeGetOp(pParse->pVdbe, pParse->addrExplain);
  return pOp->p2;
}
# 87330 "c_tests/sqlite3.c"
static int sqlite3VdbeExplain(Parse *pParse, u8 bPush, const char *zFmt, ...){
  int addr = 0;



  if( pParse->explain==2 || 0 )

  {
    char *zMsg;
    Vdbe *v;
    va_list ap;
    int iThis;
    __builtin_va_start(ap, zFmt);
    zMsg = sqlite3VMPrintf(pParse->db, zFmt, ap);
    __builtin_va_end(ap);
    v = pParse->pVdbe;
    iThis = v->nOp;
    addr = sqlite3VdbeAddOp4(v, 189, iThis, pParse->addrExplain, 0,
                      zMsg, (-6));
                                                                            ;
    if( bPush){
      pParse->addrExplain = iThis;
    }
                                                 ;
  }
  return addr;
}




static void sqlite3VdbeExplainPop(Parse *pParse){
                                    ;
  pParse->addrExplain = sqlite3VdbeExplainParent(pParse);
}
# 87375 "c_tests/sqlite3.c"
static void sqlite3VdbeAddParseSchemaOp(Vdbe *p, int iDb, char *zWhere, u16 p5){
  int j;
  sqlite3VdbeAddOp4(p, 150, iDb, 0, 0, zWhere, (-6));
  sqlite3VdbeChangeP5(p, p5);
  for(j=0; j<p->db->nDb; j++) sqlite3VdbeUsesBtree(p, j);
  sqlite3MayAbort(p->pParse);
}



static void sqlite3VdbeEndCoroutine(Vdbe *v, int regYield){
  sqlite3VdbeAddOp1(v, 69, regYield);







  v->pParse->nTempReg = 0;
  v->pParse->nRangeReg = 0;
}
# 87423 "c_tests/sqlite3.c"
static int sqlite3VdbeMakeLabel(Parse *pParse){
  return --pParse->nLabel;
}






static __attribute__((noinline)) void resizeResolveLabel(Parse *p, Vdbe *v, int j){
  int nNewSize = 10 - p->nLabel;
  p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel,
                     nNewSize*sizeof(p->aLabel[0]));
  if( p->aLabel==0 ){
    p->nLabelAlloc = 0;
  }else{




    if( nNewSize>=100 && (nNewSize/100)>(p->nLabelAlloc/100) ){
      sqlite3ProgressCheck(p);
    }
    p->nLabelAlloc = nNewSize;
    p->aLabel[j] = v->nOp;
  }
}
static void sqlite3VdbeResolveLabel(Vdbe *v, int x){
  Parse *p = v->pParse;
  int j = (~(x));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  if( p->nLabelAlloc + p->nLabel < 0 ){
    resizeResolveLabel(p,v,j);
  }else{
    ((void) (0));
    p->aLabel[j] = v->nOp;
  }
}




static void sqlite3VdbeRunOnlyOnce(Vdbe *p){
  sqlite3VdbeAddOp2(p, 167, 1, 1);
}




static void sqlite3VdbeReusable(Vdbe *p){
  int i;
  for(i=1; (i<p->nOp); i++){
    if( (p->aOp[i].opcode==167) ){
      p->aOp[1].opcode = 188;
      break;
    }
  }
}
# 87684 "c_tests/sqlite3.c"
static void resolveP2Values(Vdbe *p, int *pMaxVtabArgs){
  int nMaxVtabArgs = *pMaxVtabArgs;
  Op *pOp;
  Parse *pParse = p->pParse;
  int *aLabel = pParse->aLabel;

  ((void) (0));
  p->readOnly = 1;
  p->bIsReader = 0;
  pOp = &p->aOp[p->nOp-1];
  ((void) (0));
  while( 1 ){






    if( pOp->opcode<=65 ){


      switch( pOp->opcode ){
        case 2: {
          if( pOp->p2!=0 ) p->readOnly = 0;
                         __attribute__((fallthrough));
        }
        case 1:
        case 0: {
          p->bIsReader = 1;
          break;
        }

        case 3:

        case 5:
        case 4: {
          p->readOnly = 0;
          p->bIsReader = 1;
          break;
        }
        case 8: {
          ((void) (0));
          goto resolve_p2_values_loop_exit;
        }

        case 7: {
          if( pOp->p2>nMaxVtabArgs ) nMaxVtabArgs = pOp->p2;
          break;
        }
        case 6: {
          int n;



          ((void) (0));
          ((void) (0));
          ((void) (0));
          n = pOp[-1].p1;
          if( n>nMaxVtabArgs ) nMaxVtabArgs = n;

                         __attribute__((fallthrough));
        }

        default: {
          if( pOp->p2<0 ){



            ((void) (0));
            ((void) (0));
            ((void) (0));
            pOp->p2 = aLabel[(~(pOp->p2))];
          }



          ((void) (0));



          ((void) (0));

          break;
        }
      }



      ((void) (0));
    }
    ((void) (0));
    pOp--;
  }
resolve_p2_values_loop_exit:
  if( aLabel ){
    sqlite3DbNNFreeNN(p->db, pParse->aLabel);
    pParse->aLabel = 0;
  }
  pParse->nLabel = 0;
  *pMaxVtabArgs = nMaxVtabArgs;
  ((void) (0));
}
# 87878 "c_tests/sqlite3.c"
static int sqlite3VdbeCurrentAddr(Vdbe *p){
  ((void) (0));
  return p->nOp;
}
# 87935 "c_tests/sqlite3.c"
static VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg){
  VdbeOp *aOp = p->aOp;
  ((void) (0));


  ((void) (0));

  resolveP2Values(p, pnMaxArg);
  *pnOp = p->nOp;
  p->aOp = 0;
  return aOp;
}
# 87955 "c_tests/sqlite3.c"
static VdbeOp *sqlite3VdbeAddOpList(
  Vdbe *p,
  int nOp,
  VdbeOpList const *aOp,
  int iLineno
){
  int i;
  VdbeOp *pOut, *pFirst;
  ((void) (0));
  ((void) (0));
  if( p->nOp + nOp > p->nOpAlloc && growOpArray(p, nOp) ){
    return 0;
  }
  pFirst = pOut = &p->aOp[p->nOp];
  for(i=0; i<nOp; i++, aOp++, pOut++){
    pOut->opcode = aOp->opcode;
    pOut->p1 = aOp->p1;
    pOut->p2 = aOp->p2;
    ((void) (0));
    if( (sqlite3OpcodeProperty[aOp->opcode] & 0x01)!=0 && aOp->p2>0 ){
      pOut->p2 += p->nOp;
    }
    pOut->p3 = aOp->p3;
    pOut->p4type = 0;
    pOut->p4.p = 0;
    pOut->p5 = 0;






    (void)iLineno;






  }
  p->nOp += nOp;
  return pFirst;
}
# 88094 "c_tests/sqlite3.c"
static void sqlite3VdbeChangeOpcode(Vdbe *p, int addr, u8 iNewOpcode){
  ((void) (0));
  sqlite3VdbeGetOp(p,addr)->opcode = iNewOpcode;
}
static void sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){
  ((void) (0));
  sqlite3VdbeGetOp(p,addr)->p1 = val;
}
static void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){
  ((void) (0));
  sqlite3VdbeGetOp(p,addr)->p2 = val;
}
static void sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){
  ((void) (0));
  sqlite3VdbeGetOp(p,addr)->p3 = val;
}
static void sqlite3VdbeChangeP5(Vdbe *p, u16 p5){
  ((void) (0));
  if( p->nOp>0 ) p->aOp[p->nOp-1].p5 = p5;
}






static void sqlite3VdbeTypeofColumn(Vdbe *p, int iDest){
  VdbeOp *pOp = sqlite3VdbeGetLastOp(p);



  if( pOp->p3==iDest && pOp->opcode==95 ){
    pOp->p5 |= 0x80;
  }
}





static void sqlite3VdbeJumpHere(Vdbe *p, int addr){
  sqlite3VdbeChangeP2(p, addr, p->nOp);
}
# 88151 "c_tests/sqlite3.c"
static void sqlite3VdbeJumpHereOrPopInst(Vdbe *p, int addr){
  if( addr==p->nOp-1 ){
    ((void) (0));


    ((void) (0));



    p->nOp--;
  }else{
    sqlite3VdbeChangeP2(p, addr, p->nOp);
  }
}






static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){
  ((void) (0));
  if( (pDef->funcFlags & 0x0010)!=0 ){
    sqlite3DbNNFreeNN(db, pDef);
  }
}




static __attribute__((noinline)) void freeP4Mem(sqlite3 *db, Mem *p){
  if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);
  sqlite3DbNNFreeNN(db, p);
}
static __attribute__((noinline)) void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p){
  ((void) (0));
  freeEphemeralFunction(db, p->pFunc);
  sqlite3DbNNFreeNN(db, p);
}
static void freeP4(sqlite3 *db, int p4type, void *p4){
  ((void) (0));
  switch( p4type ){
    case (-15): {
      freeP4FuncCtx(db, (sqlite3_context*)p4);
      break;
    }
    case (-12):
    case (-13):
    case (-6):
    case (-14): {
      if( p4 ) sqlite3DbNNFreeNN(db, p4);
      break;
    }
    case (-8): {
      if( db->pnBytesFreed==0 ) sqlite3KeyInfoUnref((KeyInfo*)p4);
      break;
    }






    case (-7): {
      freeEphemeralFunction(db, (FuncDef*)p4);
      break;
    }
    case (-10): {
      if( db->pnBytesFreed==0 ){
        sqlite3ValueFree((sqlite3_value*)p4);
      }else{
        freeP4Mem(db, (Mem*)p4);
      }
      break;
    }
    case (-11) : {
      if( db->pnBytesFreed==0 ) sqlite3VtabUnlock((VTable *)p4);
      break;
    }
    case (-16): {
      if( db->pnBytesFreed==0 ) sqlite3DeleteTable(db, (Table*)p4);
      break;
    }
    case (-17): {
      SubrtnSig *pSig = (SubrtnSig*)p4;
      sqlite3DbFree(db, pSig->zAff);
      sqlite3DbFree(db, pSig);
      break;
    }
  }
}






static void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){
  ((void) (0));
  ((void) (0));
  if( aOp ){
    Op *pOp = &aOp[nOp-1];
    while(1){
      if( pOp->p4type <= (-6) ) freeP4(db, pOp->p4type, pOp->p4.p);



      if( pOp==aOp ) break;
      pOp--;
    }
    sqlite3DbNNFreeNN(db, aOp);
  }
}






static void sqlite3VdbeLinkSubProgram(Vdbe *pVdbe, SubProgram *p){
  p->pNext = pVdbe->pProgram;
  pVdbe->pProgram = p;
}




static int sqlite3VdbeHasSubProgram(Vdbe *pVdbe){
  return pVdbe->pProgram!=0;
}




static int sqlite3VdbeChangeToNoop(Vdbe *p, int addr){
  VdbeOp *pOp;
  if( p->db->mallocFailed ) return 0;
  ((void) (0));
  pOp = &p->aOp[addr];
  freeP4(p->db, pOp->p4type, pOp->p4.p);
  pOp->p4type = 0;
  pOp->p4.z = 0;
  pOp->opcode = 188;
  return 1;
}





static int sqlite3VdbeDeletePriorOpcode(Vdbe *p, u8 op){
  if( p->nOp>0 && p->aOp[p->nOp-1].opcode==op ){
    return sqlite3VdbeChangeToNoop(p, p->nOp-1);
  }else{
    return 0;
  }
}
# 88360 "c_tests/sqlite3.c"
static void __attribute__((noinline)) vdbeChangeP4Full(
  Vdbe *p,
  Op *pOp,
  const char *zP4,
  int n
){
  if( pOp->p4type ){
    ((void) (0));
    pOp->p4type = 0;
    pOp->p4.p = 0;
  }
  if( n<0 ){
    sqlite3VdbeChangeP4(p, (int)(pOp - p->aOp), zP4, n);
  }else{
    if( n==0 ) n = sqlite3Strlen30(zP4);
    pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n);
    pOp->p4type = (-6);
  }
}
static void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){
  Op *pOp;
  sqlite3 *db;
  ((void) (0));
  db = p->db;
  ((void) (0));
  ((void) (0));
  if( db->mallocFailed ){
    if( n!=(-11) ) freeP4(db, n, (void*)*(char**)&zP4);
    return;
  }
  ((void) (0));
  ((void) (0));
  if( addr<0 ){
    addr = p->nOp - 1;
  }
  pOp = &p->aOp[addr];
  if( n>=0 || pOp->p4type ){
    vdbeChangeP4Full(p, pOp, zP4, n);
    return;
  }
  if( n==(-3) ){


    pOp->p4.i = ((int)(long int)(zP4));
    pOp->p4type = (-3);
  }else if( zP4!=0 ){
    ((void) (0));
    pOp->p4.p = (void*)zP4;
    pOp->p4type = (signed char)n;
    if( n==(-11) ) sqlite3VtabLock((VTable*)zP4);
  }
}
# 88422 "c_tests/sqlite3.c"
static void sqlite3VdbeAppendP4(Vdbe *p, void *pP4, int n){
  VdbeOp *pOp;
  ((void) (0));
  ((void) (0));
  if( p->db->mallocFailed ){
    freeP4(p->db, n, pP4);
  }else{
    ((void) (0));
    ((void) (0));
    pOp = &p->aOp[p->nOp-1];
    ((void) (0));
    pOp->p4type = n;
    pOp->p4.p = pP4;
  }
}





static void sqlite3VdbeSetP4KeyInfo(Parse *pParse, Index *pIdx){
  Vdbe *v = pParse->pVdbe;
  KeyInfo *pKeyInfo;
  ((void) (0));
  ((void) (0));
  pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx);
  if( pKeyInfo ) sqlite3VdbeAppendP4(v, pKeyInfo, (-8));
}
# 88508 "c_tests/sqlite3.c"
static VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){


  static VdbeOp dummy;
  ((void) (0));
  ((void) (0));
  if( p->db->mallocFailed ){
    return (VdbeOp*)&dummy;
  }else{
    return &p->aOp[addr];
  }
}



static VdbeOp *sqlite3VdbeGetLastOp(Vdbe *p){
  return sqlite3VdbeGetOp(p, p->nOp - 1);
}
# 88718 "c_tests/sqlite3.c"
static char *sqlite3VdbeDisplayP4(sqlite3 *db, Op *pOp){
  char *zP4 = 0;
  StrAccum x;

  sqlite3StrAccumInit(&x, 0, 0, 0, 1000000000);
  switch( pOp->p4type ){
    case (-8): {
      int j;
      KeyInfo *pKeyInfo = pOp->p4.pKeyInfo;
      ((void) (0));
      sqlite3_str_appendf(&x, "k(%d", pKeyInfo->nKeyField);
      for(j=0; j<pKeyInfo->nKeyField; j++){
        CollSeq *pColl = pKeyInfo->aColl[j];
        const char *zColl = pColl ? pColl->zName : "";
        if( strcmp(zColl, "BINARY")==0 ) zColl = "B";
        sqlite3_str_appendf(&x, ",%s%s%s",
               (pKeyInfo->aSortFlags[j] & 0x01) ? "-" : "",
               (pKeyInfo->aSortFlags[j] & 0x02)? "N." : "",
               zColl);
      }
      sqlite3_str_append(&x, ")", 1);
      break;
    }






    case (-2): {
      static const char *const encnames[] = {"?", "8", "16LE", "16BE"};
      CollSeq *pColl = pOp->p4.pColl;
      ((void) (0));
      sqlite3_str_appendf(&x, "%.18s-%s", pColl->zName,
                          encnames[pColl->enc]);
      break;
    }
    case (-7): {
      FuncDef *pDef = pOp->p4.pFunc;
      sqlite3_str_appendf(&x, "%s(%d)", pDef->zName, pDef->nArg);
      break;
    }
    case (-15): {
      FuncDef *pDef = pOp->p4.pCtx->pFunc;
      sqlite3_str_appendf(&x, "%s(%d)", pDef->zName, pDef->nArg);
      break;
    }
    case (-13): {
      sqlite3_str_appendf(&x, "%lld", *pOp->p4.pI64);
      break;
    }
    case (-3): {
      sqlite3_str_appendf(&x, "%d", pOp->p4.i);
      break;
    }
    case (-12): {
      sqlite3_str_appendf(&x, "%.16g", *pOp->p4.pReal);
      break;
    }
    case (-10): {
      Mem *pMem = pOp->p4.pMem;
      if( pMem->flags & 0x0002 ){
        zP4 = pMem->z;
      }else if( pMem->flags & (0x0004|0x0020) ){
        sqlite3_str_appendf(&x, "%lld", pMem->u.i);
      }else if( pMem->flags & 0x0008 ){
        sqlite3_str_appendf(&x, "%.16g", pMem->u.r);
      }else if( pMem->flags & 0x0001 ){
        zP4 = "NULL";
      }else{
        ((void) (0));
        zP4 = "(blob)";
      }
      break;
    }

    case (-11): {
      sqlite3_vtab *pVtab = pOp->p4.pVtab->pVtab;
      sqlite3_str_appendf(&x, "vtab:%p", pVtab);
      break;
    }

    case (-14): {
      u32 i;
      u32 *ai = pOp->p4.ai;
      u32 n = ai[0];

      for(i=1; i<=n; i++){
        sqlite3_str_appendf(&x, "%c%u", (i==1 ? '[' : ','), ai[i]);
      }
      sqlite3_str_append(&x, "]", 1);
      break;
    }
    case (-4): {
      zP4 = "program";
      break;
    }
    case (-5): {
      zP4 = pOp->p4.pTab->zName;
      break;
    }
    case (-17): {
      SubrtnSig *pSig = pOp->p4.pSubrtnSig;
      sqlite3_str_appendf(&x, "subrtnsig:%d,%s", pSig->selId, pSig->zAff);
      break;
    }
    default: {
      zP4 = pOp->p4.z;
    }
  }
  if( zP4 ) sqlite3_str_appendall(&x, zP4);
  if( (x.accError & 7)!=0 ){
    sqlite3OomFault(db);
  }
  return sqlite3StrAccumFinish(&x);
}
# 88844 "c_tests/sqlite3.c"
static void sqlite3VdbeUsesBtree(Vdbe *p, int i){
  ((void) (0));
  ((void) (0));
  ((p->btreeMask)|=(((yDbMask)1)<<(i)));
  if( i!=1 && sqlite3BtreeSharable(p->db->aDb[i].pBt) ){
    ((p->lockMask)|=(((yDbMask)1)<<(i)));
  }
}
# 88875 "c_tests/sqlite3.c"
static void sqlite3VdbeEnter(Vdbe *p){
  int i;
  sqlite3 *db;
  Db *aDb;
  int nDb;
  if( ((p->lockMask)==0) ) return;
  db = p->db;
  aDb = db->aDb;
  nDb = db->nDb;
  for(i=0; i<nDb; i++){
    if( i!=1 && (((p->lockMask)&(((yDbMask)1)<<(i)))!=0) && (aDb[i].pBt!=0) ){
      sqlite3BtreeEnter(aDb[i].pBt);
    }
  }
}






static __attribute__((noinline)) void vdbeLeave(Vdbe *p){
  int i;
  sqlite3 *db;
  Db *aDb;
  int nDb;
  db = p->db;
  aDb = db->aDb;
  nDb = db->nDb;
  for(i=0; i<nDb; i++){
    if( i!=1 && (((p->lockMask)&(((yDbMask)1)<<(i)))!=0) && (aDb[i].pBt!=0) ){
      sqlite3BtreeLeave(aDb[i].pBt);
    }
  }
}
static void sqlite3VdbeLeave(Vdbe *p){
  if( ((p->lockMask)==0) ) return;
  vdbeLeave(p);
}
# 88964 "c_tests/sqlite3.c"
static void initMemArray(Mem *p, int N, sqlite3 *db, u16 flags){
  ((void) (0));
  if( N>0 ){
    do{
      p->flags = flags;
      p->db = db;
      p->szMalloc = 0;




      p++;
    }while( (--N)>0 );
  }
}
# 88988 "c_tests/sqlite3.c"
static void releaseMemArray(Mem *p, int N){
  if( p && N ){
    Mem *pEnd = &p[N];
    sqlite3 *db = p->db;
    ((void) (0));
    if( db->pnBytesFreed ){
      do{
        if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);
      }while( (++p)<pEnd );
      return;
    }
    do{
      ((void) (0));
      ((void) (0));
# 89015 "c_tests/sqlite3.c"
                                    ;
                                    ;
      if( p->flags&(0x8000|0x1000) ){
                                                                              ;
        sqlite3VdbeMemRelease(p);
        p->flags = 0x0000;
      }else if( p->szMalloc ){
        sqlite3DbNNFreeNN(db, p->zMalloc);
        p->szMalloc = 0;
        p->flags = 0x0000;
      }





    }while( (++p)<pEnd );
  }
}
# 89056 "c_tests/sqlite3.c"
static void sqlite3VdbeFrameMemDel(void *pArg){
  VdbeFrame *pFrame = (VdbeFrame*)pArg;
  ((void) (0));
  pFrame->pParent = pFrame->v->pDelFrame;
  pFrame->v->pDelFrame = pFrame;
}
# 89071 "c_tests/sqlite3.c"
static int sqlite3VdbeNextOpcode(
  Vdbe *p,
  Mem *pSub,
  int eMode,
  int *piPc,
  int *piAddr,
  Op **paOp
){
  int nRow;
  int nSub = 0;
  SubProgram **apSub = 0;
  int i;
  int rc = 0;
  Op *aOp = 0;
  int iPc;
# 89094 "c_tests/sqlite3.c"
  nRow = p->nOp;
  if( pSub!=0 ){
    if( pSub->flags&0x0010 ){


      nSub = pSub->n/sizeof(Vdbe*);
      apSub = (SubProgram **)pSub->z;
    }
    for(i=0; i<nSub; i++){
      nRow += apSub[i]->nOp;
    }
  }
  iPc = *piPc;
  while(1){
    i = iPc++;
    if( i>=nRow ){
      p->rc = 0;
      rc = 101;
      break;
    }
    if( i<p->nOp ){


      aOp = p->aOp;
    }else{


      int j;
      i -= p->nOp;
      ((void) (0));
      ((void) (0));
      for(j=0; i>=apSub[j]->nOp; j++){
        i -= apSub[j]->nOp;
        ((void) (0));
      }
      aOp = apSub[j]->aOp;
    }






    if( pSub!=0 && aOp[i].p4type==(-4) ){
      int nByte = (nSub+1)*sizeof(SubProgram*);
      int j;
      for(j=0; j<nSub; j++){
        if( apSub[j]==aOp[i].p4.pProgram ) break;
      }
      if( j==nSub ){
        p->rc = sqlite3VdbeMemGrow(pSub, nByte, nSub!=0);
        if( p->rc!=0 ){
          rc = 1;
          break;
        }
        apSub = (SubProgram **)pSub->z;
        apSub[nSub++] = aOp[i].p4.pProgram;
        ((pSub)->flags = ((pSub)->flags&~(0x0dbf|0x0400))|0x0010);
        pSub->n = nSub*sizeof(SubProgram*);
        nRow += aOp[i].p4.pProgram->nOp;
      }
    }
    if( eMode==0 ) break;
# 89165 "c_tests/sqlite3.c"
    {
      ((void) (0));
      if( aOp[i].opcode==189 ) break;
      if( aOp[i].opcode==8 && iPc>1 ) break;
    }
  }
  *piPc = iPc;
  *piAddr = i;
  *paOp = aOp;
  return rc;
}







static void sqlite3VdbeFrameDelete(VdbeFrame *p){
  int i;
  Mem *aMem = ((Mem *)&((u8 *)p)[(((sizeof(VdbeFrame))+7)&~7)]);
  VdbeCursor **apCsr = (VdbeCursor **)&aMem[p->nChildMem];
  ((void) (0));
  for(i=0; i<p->nChildCsr; i++){
    if( apCsr[i] ) sqlite3VdbeFreeCursorNN(p->v, apCsr[i]);
  }
  releaseMemArray(aMem, p->nChildMem);
  sqlite3VdbeDeleteAuxData(p->v->db, &p->pAuxData, -1, 0);
  sqlite3DbFree(p->v->db, p);
}
# 89215 "c_tests/sqlite3.c"
static int sqlite3VdbeList(
  Vdbe *p
){
  Mem *pSub = 0;
  sqlite3 *db = p->db;
  int i;
  int rc = 0;
  Mem *pMem = &p->aMem[1];
  int bListSubprogs = (p->explain==1 || (db->flags & 0x01000000)!=0);
  Op *aOp;
  Op *pOp;

  ((void) (0));
  ((void) (0));
  ((void) (0));





  releaseMemArray(pMem, 8);

  if( p->rc==7 ){


    sqlite3OomFault(db);
    return 1;
  }

  if( bListSubprogs ){




    ((void) (0));
    pSub = &p->aMem[9];
  }else{
    pSub = 0;
  }


  rc = sqlite3VdbeNextOpcode(p, pSub, p->explain==2, &p->pc, &i, &aOp);

  if( rc==0 ){
    pOp = aOp + i;
    if( __atomic_load_n((&db->u1.isInterrupted),0) ){
      p->rc = 9;
      rc = 1;
      sqlite3VdbeError(p, sqlite3ErrStr(p->rc));
    }else{
      char *zP4 = sqlite3VdbeDisplayP4(db, pOp);
      if( p->explain==2 ){
        sqlite3VdbeMemSetInt64(pMem, pOp->p1);
        sqlite3VdbeMemSetInt64(pMem+1, pOp->p2);
        sqlite3VdbeMemSetInt64(pMem+2, pOp->p3);
        sqlite3VdbeMemSetStr(pMem+3, zP4, -1, 1, sqlite3_free);
        ((void) (0));
      }else{
        sqlite3VdbeMemSetInt64(pMem+0, i);
        sqlite3VdbeMemSetStr(pMem+1, (char*)sqlite3OpcodeName(pOp->opcode),
                             -1, 1, ((sqlite3_destructor_type)0));
        sqlite3VdbeMemSetInt64(pMem+2, pOp->p1);
        sqlite3VdbeMemSetInt64(pMem+3, pOp->p2);
        sqlite3VdbeMemSetInt64(pMem+4, pOp->p3);

        sqlite3VdbeMemSetInt64(pMem+6, pOp->p5);






        sqlite3VdbeMemSetNull(pMem+7);

        sqlite3VdbeMemSetStr(pMem+5, zP4, -1, 1, sqlite3_free);
        ((void) (0));
      }
      p->pResultRow = pMem;
      if( db->mallocFailed ){
        p->rc = 7;
        rc = 1;
      }else{
        p->rc = 0;
        rc = 100;
      }
    }
  }
  return rc;
}
# 89359 "c_tests/sqlite3.c"
struct ReusableSpace {
  u8 *pSpace;
  sqlite3_int64 nFree;
  sqlite3_int64 nNeeded;
};
# 89379 "c_tests/sqlite3.c"
static void *allocSpace(
  struct ReusableSpace *p,
  void *pBuf,
  sqlite3_int64 nByte
){
  ((void) (0));
  if( pBuf==0 ){
    nByte = (nByte);
    if( nByte <= p->nFree ){
      p->nFree -= nByte;
      pBuf = &p->pSpace[p->nFree];
    }else{
      p->nNeeded += nByte;
    }
  }
  ((void) (0));
  return pBuf;
}





static void sqlite3VdbeRewind(Vdbe *p){



  ((void) (0));
  ((void) (0));





  ((void) (0));

  p->eVdbeState = 1;






  p->pc = -1;
  p->rc = 0;
  p->errorAction = 2;
  p->nChange = 0;
  p->cacheCtr = 1;
  p->minWriteFileFormat = 255;
  p->iStatement = 0;
  p->nFkConstraint = 0;






}
# 89456 "c_tests/sqlite3.c"
static void sqlite3VdbeMakeReady(
  Vdbe *p,
  Parse *pParse
){
  sqlite3 *db;
  int nVar;
  int nMem;
  int nCursor;
  int nArg;
  int n;
  struct ReusableSpace x;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  p->pVList = pParse->pVList;
  pParse->pVList = 0;
  db = p->db;
  ((void) (0));
  nVar = pParse->nVar;
  nMem = pParse->nMem;
  nCursor = pParse->nTab;
  nArg = pParse->nMaxArg;






  nMem += nCursor;
  if( nCursor==0 && nMem>0 ) nMem++;





  n = (sizeof(Op)*p->nOp);
  x.pSpace = &((u8*)p->aOp)[n];
  ((void) (0));
  x.nFree = ((pParse->szOpAlloc - n)&~7);
  ((void) (0));
  ((void) (0));

  resolveP2Values(p, &nArg);
  p->usesStmtJournal = (u8)(pParse->isMultiWrite && pParse->mayAbort);
  if( pParse->explain ){
    if( nMem<10 ) nMem = 10;
    p->explain = pParse->explain;
    p->nResColumn = 12 - 4*p->explain;
  }
  p->expired = 0;
# 89521 "c_tests/sqlite3.c"
  x.nNeeded = 0;
  p->aMem = allocSpace(&x, 0, nMem*sizeof(Mem));
  p->aVar = allocSpace(&x, 0, nVar*sizeof(Mem));
  p->apArg = allocSpace(&x, 0, nArg*sizeof(Mem*));
  p->apCsr = allocSpace(&x, 0, nCursor*sizeof(VdbeCursor*));
  if( x.nNeeded ){
    x.pSpace = p->pFree = sqlite3DbMallocRawNN(db, x.nNeeded);
    x.nFree = x.nNeeded;
    if( !db->mallocFailed ){
      p->aMem = allocSpace(&x, p->aMem, nMem*sizeof(Mem));
      p->aVar = allocSpace(&x, p->aVar, nVar*sizeof(Mem));
      p->apArg = allocSpace(&x, p->apArg, nArg*sizeof(Mem*));
      p->apCsr = allocSpace(&x, p->apCsr, nCursor*sizeof(VdbeCursor*));
    }
  }




  if( db->mallocFailed ){
    p->nVar = 0;
    p->nCursor = 0;
    p->nMem = 0;
  }else{
    p->nCursor = nCursor;
    p->nVar = (ynVar)nVar;
    initMemArray(p->aVar, nVar, db, 0x0001);
    p->nMem = nMem;
    initMemArray(p->aMem, nMem, db, 0x0000);
    memset(p->apCsr, 0, nCursor*sizeof(VdbeCursor*));
  }
  sqlite3VdbeRewind(p);
}





static void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){
  if( pCx ) sqlite3VdbeFreeCursorNN(p,pCx);
}
static __attribute__((noinline)) void freeCursorWithCache(Vdbe *p, VdbeCursor *pCx){
  VdbeTxtBlbCache *pCache = pCx->pCache;
  ((void) (0));
  pCx->colCache = 0;
  pCx->pCache = 0;
  if( pCache->pCValue ){
    sqlite3RCStrUnref(pCache->pCValue);
    pCache->pCValue = 0;
  }
  sqlite3DbFree(p->db, pCache);
  sqlite3VdbeFreeCursorNN(p, pCx);
}
static void sqlite3VdbeFreeCursorNN(Vdbe *p, VdbeCursor *pCx){
  if( pCx->colCache ){
    freeCursorWithCache(p, pCx);
    return;
  }
  switch( pCx->eCurType ){
    case 1: {
      sqlite3VdbeSorterClose(p->db, pCx);
      break;
    }
    case 0: {
      ((void) (0));
      sqlite3BtreeCloseCursor(pCx->uc.pCursor);
      break;
    }

    case 2: {
      sqlite3_vtab_cursor *pVCur = pCx->uc.pVCur;
      const sqlite3_module *pModule = pVCur->pVtab->pModule;
      ((void) (0));
      pVCur->pVtab->nRef--;
      pModule->xClose(pVCur);
      break;
    }

  }
}




static void closeCursorsInFrame(Vdbe *p){
  int i;
  for(i=0; i<p->nCursor; i++){
    VdbeCursor *pC = p->apCsr[i];
    if( pC ){
      sqlite3VdbeFreeCursorNN(p, pC);
      p->apCsr[i] = 0;
    }
  }
}






static int sqlite3VdbeFrameRestore(VdbeFrame *pFrame){
  Vdbe *v = pFrame->v;
  closeCursorsInFrame(v);
  v->aOp = pFrame->aOp;
  v->nOp = pFrame->nOp;
  v->aMem = pFrame->aMem;
  v->nMem = pFrame->nMem;
  v->apCsr = pFrame->apCsr;
  v->nCursor = pFrame->nCursor;
  v->db->lastRowid = pFrame->lastRowid;
  v->nChange = pFrame->nChange;
  v->db->nChange = pFrame->nDbChange;
  sqlite3VdbeDeleteAuxData(v->db, &v->pAuxData, -1, 0);
  v->pAuxData = pFrame->pAuxData;
  pFrame->pAuxData = 0;
  return pFrame->pc;
}
# 89647 "c_tests/sqlite3.c"
static void closeAllCursors(Vdbe *p){
  if( p->pFrame ){
    VdbeFrame *pFrame;
    for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);
    sqlite3VdbeFrameRestore(pFrame);
    p->pFrame = 0;
    p->nFrame = 0;
  }
  ((void) (0));
  closeCursorsInFrame(p);
  releaseMemArray(p->aMem, p->nMem);
  while( p->pDelFrame ){
    VdbeFrame *pDel = p->pDelFrame;
    p->pDelFrame = pDel->pParent;
    sqlite3VdbeFrameDelete(pDel);
  }


  if( p->pAuxData ) sqlite3VdbeDeleteAuxData(p->db, &p->pAuxData, -1, 0);
  ((void) (0));
}







static void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){
  int n;
  sqlite3 *db = p->db;

  if( p->nResAlloc ){
    releaseMemArray(p->aColName, p->nResAlloc*2);
    sqlite3DbFree(db, p->aColName);
  }
  n = nResColumn*2;
  p->nResColumn = p->nResAlloc = (u16)nResColumn;
  p->aColName = (Mem*)sqlite3DbMallocRawNN(db, sizeof(Mem)*n );
  if( p->aColName==0 ) return;
  initMemArray(p->aColName, n, db, 0x0001);
}
# 89700 "c_tests/sqlite3.c"
static int sqlite3VdbeSetColName(
  Vdbe *p,
  int idx,
  int var,
  const char *zName,
  void (*xDel)(void*)
){
  int rc;
  Mem *pColName;
  ((void) (0));
  ((void) (0));
  if( p->db->mallocFailed ){
    ((void) (0));
    return 7;
  }
  ((void) (0));
  pColName = &(p->aColName[idx+var*p->nResAlloc]);
  rc = sqlite3VdbeMemSetStr(pColName, zName, -1, 1, xDel);
  ((void) (0));
  return rc;
}







static int vdbeCommit(sqlite3 *db, Vdbe *p){
  int i;
  int nTrans = 0;


  int rc = 0;
  int needXcommit = 0;
# 89749 "c_tests/sqlite3.c"
  rc = sqlite3VtabSync(db, p);







  for(i=0; rc==0 && i<db->nDb; i++){
    Btree *pBt = db->aDb[i].pBt;
    if( sqlite3BtreeTxnState(pBt)==2 ){



      static const u8 aMJNeeded[] = {
                        1,
                        1,
                        0,
                        1,
                        0,
                        0
      };
      Pager *pPager;
      needXcommit = 1;
      sqlite3BtreeEnter(pBt);
      pPager = sqlite3BtreePager(pBt);
      if( db->aDb[i].safety_level!=0x01
       && aMJNeeded[sqlite3PagerGetJournalMode(pPager)]
       && sqlite3PagerIsMemdb(pPager)==0
      ){
        ((void) (0));
        nTrans++;
      }
      rc = sqlite3PagerExclusiveLock(pPager);
      sqlite3BtreeLeave(pBt);
    }
  }
  if( rc!=0 ){
    return rc;
  }


  if( needXcommit && db->xCommitCallback ){
    rc = db->xCommitCallback(db->pCommitArg);
    if( rc ){
      return (19 | (2<<8));
    }
  }
# 89807 "c_tests/sqlite3.c"
  if( 0==sqlite3Strlen30(sqlite3BtreeGetFilename(db->aDb[0].pBt))
   || nTrans<=1
  ){
    if( needXcommit ){
      for(i=0; rc==0 && i<db->nDb; i++){
        Btree *pBt = db->aDb[i].pBt;
        if( sqlite3BtreeTxnState(pBt)>=2 ){
          rc = sqlite3BtreeCommitPhaseOne(pBt, 0);
        }
      }
    }






    for(i=0; rc==0 && i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      int txn = sqlite3BtreeTxnState(pBt);
      if( txn!=0 ){
        ((void) (0));
        rc = sqlite3BtreeCommitPhaseTwo(pBt, 0);
      }
    }
    if( rc==0 ){
      sqlite3VtabCommit(db);
    }
  }






  else{
    sqlite3_vfs *pVfs = db->pVfs;
    char *zSuper = 0;
    char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt);
    sqlite3_file *pSuperJrnl = 0;
    i64 offset = 0;
    int res;
    int retryCount = 0;
    int nMainFile;


    nMainFile = sqlite3Strlen30(zMainFile);
    zSuper = sqlite3MPrintf(db, "%.4c%s%.16c", 0,zMainFile,0);
    if( zSuper==0 ) return 7;
    zSuper += 4;
    do {
      u32 iRandom;
      if( retryCount ){
        if( retryCount>100 ){
          sqlite3_log(13, "MJ delete: %s", zSuper);
          sqlite3OsDelete(pVfs, zSuper, 0);
          break;
        }else if( retryCount==1 ){
          sqlite3_log(13, "MJ collide: %s", zSuper);
        }
      }
      retryCount++;
      sqlite3_randomness(sizeof(iRandom), &iRandom);
      sqlite3_snprintf(13, &zSuper[nMainFile], "-mj%06X9%02X",
                               (iRandom>>8)&0xffffff, iRandom&0xff);


      ((void) (0));
                                           ;
      rc = sqlite3OsAccess(pVfs, zSuper, 0, &res);
    }while( rc==0 && res );
    if( rc==0 ){

      rc = sqlite3OsOpenMalloc(pVfs, zSuper, &pSuperJrnl,
          0x00000002|0x00000004|
          0x00000010|0x00004000, 0
      );
    }
    if( rc!=0 ){
      sqlite3DbFree(db, zSuper-4);
      return rc;
    }







    for(i=0; i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( sqlite3BtreeTxnState(pBt)==2 ){
        char const *zFile = sqlite3BtreeGetJournalname(pBt);
        if( zFile==0 ){
          continue;
        }
        ((void) (0));
        rc = sqlite3OsWrite(pSuperJrnl, zFile, sqlite3Strlen30(zFile)+1,offset);
        offset += sqlite3Strlen30(zFile)+1;
        if( rc!=0 ){
          sqlite3OsCloseFree(pSuperJrnl);
          sqlite3OsDelete(pVfs, zSuper, 0);
          sqlite3DbFree(db, zSuper-4);
          return rc;
        }
      }
    }




    if( 0==(sqlite3OsDeviceCharacteristics(pSuperJrnl)&0x00000400)
     && 0!=(rc = sqlite3OsSync(pSuperJrnl, 0x00002))
    ){
      sqlite3OsCloseFree(pSuperJrnl);
      sqlite3OsDelete(pVfs, zSuper, 0);
      sqlite3DbFree(db, zSuper-4);
      return rc;
    }
# 89937 "c_tests/sqlite3.c"
    for(i=0; rc==0 && i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        rc = sqlite3BtreeCommitPhaseOne(pBt, zSuper);
      }
    }
    sqlite3OsCloseFree(pSuperJrnl);
    ((void) (0));
    if( rc!=0 ){
      sqlite3DbFree(db, zSuper-4);
      return rc;
    }





    rc = sqlite3OsDelete(pVfs, zSuper, 1);
    sqlite3DbFree(db, zSuper-4);
    zSuper = 0;
    if( rc ){
      return rc;
    }
# 89968 "c_tests/sqlite3.c"
                                 ;
    sqlite3BeginBenignMalloc();
    for(i=0; i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        sqlite3BtreeCommitPhaseTwo(pBt, 1);
      }
    }
    sqlite3EndBenignMalloc();
                                ;

    sqlite3VtabCommit(db);
  }


  return rc;
}
# 90028 "c_tests/sqlite3.c"
static __attribute__((noinline)) int vdbeCloseStatement(Vdbe *p, int eOp){
  sqlite3 *const db = p->db;
  int rc = 0;
  int i;
  const int iSavepoint = p->iStatement-1;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  for(i=0; i<db->nDb; i++){
    int rc2 = 0;
    Btree *pBt = db->aDb[i].pBt;
    if( pBt ){
      if( eOp==2 ){
        rc2 = sqlite3BtreeSavepoint(pBt, 2, iSavepoint);
      }
      if( rc2==0 ){
        rc2 = sqlite3BtreeSavepoint(pBt, 1, iSavepoint);
      }
      if( rc==0 ){
        rc = rc2;
      }
    }
  }
  db->nStatement--;
  p->iStatement = 0;

  if( rc==0 ){
    if( eOp==2 ){
      rc = sqlite3VtabSavepoint(db, 2, iSavepoint);
    }
    if( rc==0 ){
      rc = sqlite3VtabSavepoint(db, 1, iSavepoint);
    }
  }




  if( eOp==2 ){
    db->nDeferredCons = p->nStmtDefCons;
    db->nDeferredImmCons = p->nStmtDefImmCons;
  }
  return rc;
}
static int sqlite3VdbeCloseStatement(Vdbe *p, int eOp){
  if( p->db->nStatement && p->iStatement ){
    return vdbeCloseStatement(p, eOp);
  }
  return 0;
}
# 90093 "c_tests/sqlite3.c"
static __attribute__((noinline)) int vdbeFkError(Vdbe *p){
  p->rc = (19 | (3<<8));
  p->errorAction = 2;
  sqlite3VdbeError(p, "FOREIGN KEY constraint failed");
  if( (p->prepFlags & 0x80)==0 ) return 1;
  return (19 | (3<<8));
}
static int sqlite3VdbeCheckFkImmediate(Vdbe *p){
  if( p->nFkConstraint==0 ) return 0;
  return vdbeFkError(p);
}
static int sqlite3VdbeCheckFkDeferred(Vdbe *p){
  sqlite3 *db = p->db;
  if( (db->nDeferredCons+db->nDeferredImmCons)==0 ) return 0;
  return vdbeFkError(p);
}
# 90124 "c_tests/sqlite3.c"
static int sqlite3VdbeHalt(Vdbe *p){
  int rc;
  sqlite3 *db = p->db;
# 90144 "c_tests/sqlite3.c"
  ((void) (0));
  if( db->mallocFailed ){
    p->rc = 7;
  }
  closeAllCursors(p);
                        ;



  if( p->bIsReader ){
    int mrc;
    int eStatementOp = 0;
    int isSpecialError;


    sqlite3VdbeEnter(p);


    if( p->rc ){
      mrc = p->rc & 0xff;
      isSpecialError = mrc==7
                    || mrc==10
                    || mrc==9
                    || mrc==13;
    }else{
      mrc = isSpecialError = 0;
    }
    if( isSpecialError ){
# 90184 "c_tests/sqlite3.c"
      if( !p->readOnly || mrc!=9 ){
        if( (mrc==7 || mrc==13) && p->usesStmtJournal ){
          eStatementOp = 2;
        }else{



          sqlite3RollbackAll(db, (4 | (2<<8)));
          sqlite3CloseSavepoints(db);
          db->autoCommit = 1;
          p->nChange = 0;
        }
      }
    }


    if( p->rc==0 || (p->errorAction==3 && !isSpecialError) ){
      (void)sqlite3VdbeCheckFkImmediate(p);
    }







    if( !((db)->nVTrans>0 && (db)->aVTrans==0)
     && db->autoCommit
     && db->nVdbeWrite==(p->readOnly==0)
    ){
      if( p->rc==0 || (p->errorAction==3 && !isSpecialError) ){
        rc = sqlite3VdbeCheckFkDeferred(p);
        if( rc!=0 ){
          if( (p->readOnly) ){
            sqlite3VdbeLeave(p);
            return 1;
          }
          rc = (19 | (3<<8));
        }else if( db->flags & ((u64)(0x00002)<<32) ){
          rc = 11;
          db->flags &= ~((u64)(0x00002)<<32);
        }else{




          rc = vdbeCommit(db, p);
        }
        if( rc==5 && p->readOnly ){
          sqlite3VdbeLeave(p);
          return 5;
        }else if( rc!=0 ){
          sqlite3SystemError(db, rc);
          p->rc = rc;
          sqlite3RollbackAll(db, 0);
          p->nChange = 0;
        }else{
          db->nDeferredCons = 0;
          db->nDeferredImmCons = 0;
          db->flags &= ~(u64)0x00080000;
          sqlite3CommitInternalChanges(db);
        }
      }else if( p->rc==17 && db->nVdbeActive>1 ){
        p->nChange = 0;
      }else{
        sqlite3RollbackAll(db, 0);
        p->nChange = 0;
      }
      db->nStatement = 0;
    }else if( eStatementOp==0 ){
      if( p->rc==0 || p->errorAction==3 ){
        eStatementOp = 1;
      }else if( p->errorAction==2 ){
        eStatementOp = 2;
      }else{
        sqlite3RollbackAll(db, (4 | (2<<8)));
        sqlite3CloseSavepoints(db);
        db->autoCommit = 1;
        p->nChange = 0;
      }
    }







    if( eStatementOp ){
      rc = sqlite3VdbeCloseStatement(p, eStatementOp);
      if( rc ){
        if( p->rc==0 || (p->rc&0xff)==19 ){
          p->rc = rc;
          sqlite3DbFree(db, p->zErrMsg);
          p->zErrMsg = 0;
        }
        sqlite3RollbackAll(db, (4 | (2<<8)));
        sqlite3CloseSavepoints(db);
        db->autoCommit = 1;
        p->nChange = 0;
      }
    }




    if( p->changeCntOn ){
      if( eStatementOp!=2 ){
        sqlite3VdbeSetChanges(db, p->nChange);
      }else{
        sqlite3VdbeSetChanges(db, 0);
      }
      p->nChange = 0;
    }


    sqlite3VdbeLeave(p);
  }


  db->nVdbeActive--;
  if( !p->readOnly ) db->nVdbeWrite--;
  if( p->bIsReader ) db->nVdbeRead--;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  p->eVdbeState = 3;
                        ;
  if( db->mallocFailed ){
    p->rc = 7;
  }





  if( db->autoCommit ){
                                 ;
  }

  ((void) (0));
  return (p->rc==5 ? 5 : 0);
}






static void sqlite3VdbeResetStepResult(Vdbe *p){
  p->rc = 0;
}
# 90345 "c_tests/sqlite3.c"
static int sqlite3VdbeTransferError(Vdbe *p){
  sqlite3 *db = p->db;
  int rc = p->rc;
  if( p->zErrMsg ){
    db->bBenignMalloc++;
    sqlite3BeginBenignMalloc();
    if( db->pErr==0 ) db->pErr = sqlite3ValueNew(db);
    sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, 1, ((sqlite3_destructor_type)-1));
    sqlite3EndBenignMalloc();
    db->bBenignMalloc--;
  }else if( db->pErr ){
    sqlite3ValueSetNull(db->pErr);
  }
  db->errCode = rc;
  db->errByteOffset = -1;
  return rc;
}
# 90395 "c_tests/sqlite3.c"
static int sqlite3VdbeReset(Vdbe *p){




  sqlite3 *db;
  db = p->db;





  if( p->eVdbeState==2 ) sqlite3VdbeHalt(p);






  if( p->pc>=0 ){
                       ;
    if( db->pErr || p->zErrMsg ){
      sqlite3VdbeTransferError(p);
    }else{
      db->errCode = p->rc;
    }
  }
# 90433 "c_tests/sqlite3.c"
  if( p->zErrMsg ){
    sqlite3DbFree(db, p->zErrMsg);
    p->zErrMsg = 0;
  }
  p->pResultRow = 0;
# 90479 "c_tests/sqlite3.c"
  return p->rc & db->errMask;
}





static int sqlite3VdbeFinalize(Vdbe *p){
  int rc = 0;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( p->eVdbeState>=1 ){
    rc = sqlite3VdbeReset(p);
    ((void) (0));
  }
  sqlite3VdbeDelete(p);
  return rc;
}
# 90515 "c_tests/sqlite3.c"
static void sqlite3VdbeDeleteAuxData(sqlite3 *db, AuxData **pp, int iOp, int mask){
  while( *pp ){
    AuxData *pAux = *pp;
    if( (iOp<0)
     || (pAux->iAuxOp==iOp
          && pAux->iAuxArg>=0
          && (pAux->iAuxArg>31 || !(mask & (((unsigned int)1)<<(pAux->iAuxArg)))))
    ){
                                   ;
      if( pAux->xDeleteAux ){
        pAux->xDeleteAux(pAux->pAux);
      }
      *pp = pAux->pNextAux;
      sqlite3DbFree(db, pAux);
    }else{
      pp= &pAux->pNextAux;
    }
  }
}
# 90543 "c_tests/sqlite3.c"
static void sqlite3VdbeClearObject(sqlite3 *db, Vdbe *p){
  SubProgram *pSub, *pNext;
  ((void) (0));
  ((void) (0));
  if( p->aColName ){
    releaseMemArray(p->aColName, p->nResAlloc*2);
    sqlite3DbNNFreeNN(db, p->aColName);
  }
  for(pSub=p->pProgram; pSub; pSub=pNext){
    pNext = pSub->pNext;
    vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);
    sqlite3DbFree(db, pSub);
  }
  if( p->eVdbeState!=0 ){
    releaseMemArray(p->aVar, p->nVar);
    if( p->pVList ) sqlite3DbNNFreeNN(db, p->pVList);
    if( p->pFree ) sqlite3DbNNFreeNN(db, p->pFree);
  }
  vdbeFreeOpArray(db, p->aOp, p->nOp);
  if( p->zSql ) sqlite3DbNNFreeNN(db, p->zSql);
# 90582 "c_tests/sqlite3.c"
}




static void sqlite3VdbeDelete(Vdbe *p){
  sqlite3 *db;

  ((void) (0));
  db = p->db;
  ((void) (0));
  ((void) (0));
  sqlite3VdbeClearObject(db, p);
  if( db->pnBytesFreed==0 ){
    ((void) (0));
    *p->ppVPrev = p->pVNext;
    if( p->pVNext ){
      p->pVNext->ppVPrev = p->ppVPrev;
    }
  }
  sqlite3DbNNFreeNN(db, p);
}






static int __attribute__((noinline)) sqlite3VdbeFinishMoveto(VdbeCursor *p){
  int res, rc;



  ((void) (0));
  ((void) (0));
  ((void) (0));
  rc = sqlite3BtreeTableMoveto(p->uc.pCursor, p->movetoTarget, 0, &res);
  if( rc ) return rc;
  if( res!=0 ) return sqlite3CorruptError(90620);



  p->deferredMoveto = 0;
  p->cacheStatus = 0;
  return 0;
}
# 90636 "c_tests/sqlite3.c"
static int __attribute__((noinline)) sqlite3VdbeHandleMovedCursor(VdbeCursor *p){
  int isDifferentRow, rc;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  rc = sqlite3BtreeCursorRestore(p->uc.pCursor, &isDifferentRow);
  p->cacheStatus = 0;
  if( isDifferentRow ) p->nullRow = 1;
  return rc;
}





static int sqlite3VdbeCursorRestore(VdbeCursor *p){
  ((void) (0));
  if( sqlite3BtreeCursorHasMoved(p->uc.pCursor) ){
    return sqlite3VdbeHandleMovedCursor(p);
  }
  return 0;
}
# 90777 "c_tests/sqlite3.c"
static const u8 sqlite3SmallTypeSizes[128] = {

            0, 1, 2, 3, 4, 6, 8, 8, 0, 0,
            0, 0, 0, 0, 1, 1, 2, 2, 3, 3,
            4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
            9, 9, 10, 10, 11, 11, 12, 12, 13, 13,
           14, 14, 15, 15, 16, 16, 17, 17, 18, 18,
           19, 19, 20, 20, 21, 21, 22, 22, 23, 23,
           24, 24, 25, 25, 26, 26, 27, 27, 28, 28,
           29, 29, 30, 30, 31, 31, 32, 32, 33, 33,
           34, 34, 35, 35, 36, 36, 37, 37, 38, 38,
           39, 39, 40, 40, 41, 41, 42, 42, 43, 43,
           44, 44, 45, 45, 46, 46, 47, 47, 48, 48,
           49, 49, 50, 50, 51, 51, 52, 52, 53, 53,
           54, 54, 55, 55, 56, 56, 57, 57
};




static u32 sqlite3VdbeSerialTypeLen(u32 serial_type){
  if( serial_type>=128 ){
    return (serial_type-12)/2;
  }else{
    ((void) (0));

    return sqlite3SmallTypeSizes[serial_type];
  }
}
static u8 sqlite3VdbeOneByteSerialTypeLen(u8 serial_type){
  ((void) (0));
  return sqlite3SmallTypeSizes[serial_type];
}
# 90880 "c_tests/sqlite3.c"
static void serialGet(
  const unsigned char *buf,
  u32 serial_type,
  Mem *pMem
){
  u64 x = (((u32)(buf)[0]<<24)|((buf)[1]<<16)|((buf)[2]<<8)|(buf)[3]);
  u32 y = (((u32)(buf+4)[0]<<24)|((buf+4)[1]<<16)|((buf+4)[2]<<8)|(buf+4)[3]);
  x = (x<<32) + y;
  if( serial_type==6 ){


    pMem->u.i = *(i64*)&x;
    pMem->flags = 0x0004;
                           ;
  }else{
# 90909 "c_tests/sqlite3.c"
    ((void) (0));
                           ;
    memcpy(&pMem->u.r, &x, sizeof(x));
    pMem->flags = (((x)&(((u64)0x7ff)<<52))==(((u64)0x7ff)<<52) && ((x)&((((u64)1)<<52)-1))!=0) ? 0x0001 : 0x0008;
  }
}
static int serialGet7(
  const unsigned char *buf,
  Mem *pMem
){
  u64 x = (((u32)(buf)[0]<<24)|((buf)[1]<<16)|((buf)[2]<<8)|(buf)[3]);
  u32 y = (((u32)(buf+4)[0]<<24)|((buf+4)[1]<<16)|((buf+4)[2]<<8)|(buf+4)[3]);
  x = (x<<32) + y;
  ((void) (0));
                         ;
  memcpy(&pMem->u.r, &x, sizeof(x));
  if( (((x)&(((u64)0x7ff)<<52))==(((u64)0x7ff)<<52) && ((x)&((((u64)1)<<52)-1))!=0) ){
    pMem->flags = 0x0001;
    return 1;
  }
  pMem->flags = 0x0008;
  return 0;
}
static void sqlite3VdbeSerialGet(
  const unsigned char *buf,
  u32 serial_type,
  Mem *pMem
){
  switch( serial_type ){
    case 10: {

      pMem->flags = 0x0001|0x0400;
      pMem->n = 0;
      pMem->u.nZero = 0;
      return;
    }
    case 11:
    case 0: {

      pMem->flags = 0x0001;
      return;
    }
    case 1: {


      pMem->u.i = ((i8)(buf)[0]);
      pMem->flags = 0x0004;
                             ;
      return;
    }
    case 2: {


      pMem->u.i = (256*(i8)((buf)[0])|(buf)[1]);
      pMem->flags = 0x0004;
                             ;
      return;
    }
    case 3: {


      pMem->u.i = (65536*(i8)((buf)[0])|((buf)[1]<<8)|(buf)[2]);
      pMem->flags = 0x0004;
                             ;
      return;
    }
    case 4: {


      pMem->u.i = (16777216*(i8)((buf)[0])|((buf)[1]<<16)|((buf)[2]<<8)|(buf)[3]);




      pMem->flags = 0x0004;
                             ;
      return;
    }
    case 5: {


      pMem->u.i = (((u32)(buf+2)[0]<<24)|((buf+2)[1]<<16)|((buf+2)[2]<<8)|(buf+2)[3]) + (((i64)1)<<32)*(256*(i8)((buf)[0])|(buf)[1]);
      pMem->flags = 0x0004;
                             ;
      return;
    }
    case 6:
    case 7: {


      serialGet(buf,serial_type,pMem);
      return;
    }
    case 8:
    case 9: {


      pMem->u.i = serial_type-8;
      pMem->flags = 0x0004;
      return;
    }
    default: {




      static const u16 aFlag[] = { 0x0010|0x4000, 0x0002|0x4000 };
      pMem->z = (char *)buf;
      pMem->n = (serial_type-12)/2;
      pMem->flags = aFlag[serial_type&1];
      return;
    }
  }
  return;
}







static UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(
  KeyInfo *pKeyInfo
){
  UnpackedRecord *p;
  u64 nByte;
  ((void) (0));
  nByte = (sizeof(UnpackedRecord)) + sizeof(Mem)*(pKeyInfo->nKeyField+1);
  p = (UnpackedRecord *)sqlite3DbMallocRaw(pKeyInfo->db, nByte);
  if( !p ) return 0;
  p->aMem = (Mem*)&((char*)p)[(sizeof(UnpackedRecord))];
  p->pKeyInfo = pKeyInfo;
  p->nField = pKeyInfo->nKeyField + 1;
  return p;
}






static void sqlite3VdbeRecordUnpack(
  int nKey,
  const void *pKey,
  UnpackedRecord *p
){
  const unsigned char *aKey = (const unsigned char *)pKey;
  u32 d;
  u32 idx;
  u16 u;
  u32 szHdr;
  Mem *pMem = p->aMem;
  KeyInfo *pKeyInfo = p->pKeyInfo;

  p->default_rc = 0;
  ((void) (0));
  idx = (u8)((*(aKey)<(u8)0x80)?((szHdr)=(u32)*(aKey)),1:sqlite3GetVarint32((aKey),(u32 *)&(szHdr)));
  d = szHdr;
  u = 0;
  while( idx<szHdr && d<=(u32)nKey ){
    u32 serial_type;

    idx += (u8)((*(&aKey[idx])<(u8)0x80)?((serial_type)=(u32)*(&aKey[idx])),1:sqlite3GetVarint32((&aKey[idx]),(u32 *)&(serial_type)));
    pMem->enc = pKeyInfo->enc;
    pMem->db = pKeyInfo->db;

    pMem->szMalloc = 0;
    pMem->z = 0;
    sqlite3VdbeSerialGet(&aKey[d], serial_type, pMem);
    d += sqlite3VdbeSerialTypeLen(serial_type);
    if( (++u)>=p->nField ) break;
    pMem++;
  }
  if( d>(u32)nKey && u ){
    ((void) (0));



    sqlite3VdbeMemSetNull(pMem-(u<p->nField));
  }
                                          ;
                                         ;
  ((void) (0));
  p->nField = u;
}
# 91259 "c_tests/sqlite3.c"
static __attribute__((noinline)) int vdbeCompareMemStringWithEncodingChange(
  const Mem *pMem1,
  const Mem *pMem2,
  const CollSeq *pColl,
  u8 *prcErr
){
  int rc;
  const void *v1, *v2;
  Mem c1;
  Mem c2;
  sqlite3VdbeMemInit(&c1, pMem1->db, 0x0001);
  sqlite3VdbeMemInit(&c2, pMem1->db, 0x0001);
  sqlite3VdbeMemShallowCopy(&c1, pMem1, 0x4000);
  sqlite3VdbeMemShallowCopy(&c2, pMem2, 0x4000);
  v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);
  v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);
  if( (v1==0 || v2==0) ){
    if( prcErr ) *prcErr = 7;
    rc = 0;
  }else{
    rc = pColl->xCmp(pColl->pUser, c1.n, v1, c2.n, v2);
  }
  sqlite3VdbeMemReleaseMalloc(&c1);
  sqlite3VdbeMemReleaseMalloc(&c2);
  return rc;
}
static int vdbeCompareMemString(
  const Mem *pMem1,
  const Mem *pMem2,
  const CollSeq *pColl,
  u8 *prcErr
){
  if( pMem1->enc==pColl->enc ){


    return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);
  }else{
    return vdbeCompareMemStringWithEncodingChange(pMem1,pMem2,pColl,prcErr);
  }
}





static int isAllZero(const char *z, int n){
  int i;
  for(i=0; i<n; i++){
    if( z[i] ) return 0;
  }
  return 1;
}






static __attribute__((noinline)) int sqlite3BlobCompare(const Mem *pB1, const Mem *pB2){
  int c;
  int n1 = pB1->n;
  int n2 = pB2->n;





  ((void) (0));
  ((void) (0));

  if( (pB1->flags|pB2->flags) & 0x0400 ){
    if( pB1->flags & pB2->flags & 0x0400 ){
      return pB1->u.nZero - pB2->u.nZero;
    }else if( pB1->flags & 0x0400 ){
      if( !isAllZero(pB2->z, pB2->n) ) return -1;
      return pB1->u.nZero - n2;
    }else{
      if( !isAllZero(pB1->z, pB1->n) ) return +1;
      return n1 - pB2->u.nZero;
    }
  }
  c = memcmp(pB1->z, pB2->z, n1>n2 ? n2 : n1);
  if( c ) return c;
  return n1 - n2;
}
# 91360 "c_tests/sqlite3.c"
static int sqlite3IntFloatCompare(i64 i, double r){
  if( sqlite3IsNaN(r) ){


    return 1;
  }else{
    i64 y;
    if( r<-9223372036854775808.0 ) return +1;
    if( r>=9223372036854775808.0 ) return -1;
    y = (i64)r;
    if( i<y ) return -1;
    if( i>y ) return +1;
                                       ;
                                       ;
                                       ;
    return (((double)i)<r) ? -1 : (((double)i)>r);
  }
}
# 91388 "c_tests/sqlite3.c"
static int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){
  int f1, f2;
  int combined_flags;

  f1 = pMem1->flags;
  f2 = pMem2->flags;
  combined_flags = f1|f2;
  ((void) (0));




  if( combined_flags&0x0001 ){
    return (f2&0x0001) - (f1&0x0001);
  }



  if( combined_flags&(0x0004|0x0008|0x0020) ){
                                        ;
                                         ;
                                            ;
    if( (f1 & f2 & (0x0004|0x0020))!=0 ){
                                   ;
                                       ;
      if( pMem1->u.i < pMem2->u.i ) return -1;
      if( pMem1->u.i > pMem2->u.i ) return +1;
      return 0;
    }
    if( (f1 & f2 & 0x0008)!=0 ){
      if( pMem1->u.r < pMem2->u.r ) return -1;
      if( pMem1->u.r > pMem2->u.r ) return +1;
      return 0;
    }
    if( (f1&(0x0004|0x0020))!=0 ){
                              ;
                                  ;
      if( (f2&0x0008)!=0 ){
        return sqlite3IntFloatCompare(pMem1->u.i, pMem2->u.r);
      }else if( (f2&(0x0004|0x0020))!=0 ){
        if( pMem1->u.i < pMem2->u.i ) return -1;
        if( pMem1->u.i > pMem2->u.i ) return +1;
        return 0;
      }else{
        return -1;
      }
    }
    if( (f1&0x0008)!=0 ){
      if( (f2&(0x0004|0x0020))!=0 ){
                                ;
                                    ;
        return -sqlite3IntFloatCompare(pMem2->u.i, pMem1->u.r);
      }else{
        return -1;
      }
    }
    return +1;
  }




  if( combined_flags&0x0002 ){
    if( (f1 & 0x0002)==0 ){
      return 1;
    }
    if( (f2 & 0x0002)==0 ){
      return -1;
    }

    ((void) (0));
    ((void) (0));






    ((void) (0));

    if( pColl ){
      return vdbeCompareMemString(pMem1, pMem2, pColl, 0);
    }


  }


  return sqlite3BlobCompare(pMem1, pMem2);
}
# 91487 "c_tests/sqlite3.c"
static i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey){
  u32 y;
  ((void) (0));
  switch( serial_type ){
    case 0:
    case 1:
                              ;
      return ((i8)(aKey)[0]);
    case 2:
                              ;
      return (256*(i8)((aKey)[0])|(aKey)[1]);
    case 3:
                              ;
      return (65536*(i8)((aKey)[0])|((aKey)[1]<<8)|(aKey)[2]);
    case 4: {
                              ;
      y = (((u32)(aKey)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);
      return (i64)*(int*)&y;
    }
    case 5: {
                              ;
      return (((u32)(aKey+2)[0]<<24)|((aKey+2)[1]<<16)|((aKey+2)[2]<<8)|(aKey+2)[3]) + (((i64)1)<<32)*(256*(i8)((aKey)[0])|(aKey)[1]);
    }
    case 6: {
      u64 x = (((u32)(aKey)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);
                              ;
      x = (x<<32) | (((u32)(aKey+4)[0]<<24)|((aKey+4)[1]<<16)|((aKey+4)[2]<<8)|(aKey+4)[3]);
      return (i64)*(i64*)&x;
    }
  }

  return (serial_type - 8);
}
# 91542 "c_tests/sqlite3.c"
static int sqlite3VdbeRecordCompareWithSkip(
  int nKey1, const void *pKey1,
  UnpackedRecord *pPKey2,
  int bSkip
){
  u32 d1;
  int i;
  u32 szHdr1;
  u32 idx1;
  int rc = 0;
  Mem *pRhs = pPKey2->aMem;
  KeyInfo *pKeyInfo;
  const unsigned char *aKey1 = (const unsigned char *)pKey1;
  Mem mem1;




  if( bSkip ){
    u32 s1 = aKey1[1];
    if( s1<0x80 ){
      idx1 = 2;
    }else{
      idx1 = 1 + sqlite3GetVarint32(&aKey1[1], &s1);
    }
    szHdr1 = aKey1[0];
    d1 = szHdr1 + sqlite3VdbeSerialTypeLen(s1);
    i = 1;
    pRhs++;
  }else{
    if( (szHdr1 = aKey1[0])<0x80 ){
      idx1 = 1;
    }else{
      idx1 = sqlite3GetVarint32(aKey1, &szHdr1);
    }
    d1 = szHdr1;
    i = 0;
  }
  if( d1>(unsigned)nKey1 ){
    pPKey2->errCode = (u8)sqlite3CorruptError(91581);
    return 0;
  }


  ((void) (0));

  ((void) (0));
  ((void) (0));
  ((void) (0));
  while( 1 ){
    u32 serial_type;


    if( pRhs->flags & (0x0004|0x0020) ){
                                       ;
                                           ;
      serial_type = aKey1[idx1];
                                 ;
      if( serial_type>=10 ){
        rc = serial_type==10 ? -1 : +1;
      }else if( serial_type==0 ){
        rc = -1;
      }else if( serial_type==7 ){
        serialGet7(&aKey1[d1], &mem1);
        rc = -sqlite3IntFloatCompare(pRhs->u.i, mem1.u.r);
      }else{
        i64 lhs = vdbeRecordDecodeInt(serial_type, &aKey1[d1]);
        i64 rhs = pRhs->u.i;
        if( lhs<rhs ){
          rc = -1;
        }else if( lhs>rhs ){
          rc = +1;
        }
      }
    }


    else if( pRhs->flags & 0x0008 ){
      serial_type = aKey1[idx1];
      if( serial_type>=10 ){




        rc = serial_type==10 ? -1 : +1;
      }else if( serial_type==0 ){
        rc = -1;
      }else{
        if( serial_type==7 ){
          if( serialGet7(&aKey1[d1], &mem1) ){
            rc = -1;
          }else if( mem1.u.r<pRhs->u.r ){
            rc = -1;
          }else if( mem1.u.r>pRhs->u.r ){
            rc = +1;
          }else{
            ((void) (0));
          }
        }else{
          sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);
          rc = sqlite3IntFloatCompare(mem1.u.i, pRhs->u.r);
        }
      }
    }


    else if( pRhs->flags & 0x0002 ){
      serial_type=(u32)*(&aKey1[idx1]);if(serial_type>=0x80)sqlite3GetVarint32((&aKey1[idx1]),(u32*)&(serial_type));
                                 ;
      if( serial_type<12 ){
        rc = -1;
      }else if( !(serial_type & 0x01) ){
        rc = +1;
      }else{
        mem1.n = (serial_type - 12) / 2;
                                                ;
                                                  ;
        if( (d1+mem1.n) > (unsigned)nKey1
         || (pKeyInfo = pPKey2->pKeyInfo)->nAllField<=i
        ){
          pPKey2->errCode = (u8)sqlite3CorruptError(91662);
          return 0;
        }else if( pKeyInfo->aColl[i] ){
          mem1.enc = pKeyInfo->enc;
          mem1.db = pKeyInfo->db;
          mem1.flags = 0x0002;
          mem1.z = (char*)&aKey1[d1];
          rc = vdbeCompareMemString(
              &mem1, pRhs, pKeyInfo->aColl[i], &pPKey2->errCode
          );
        }else{
          int nCmp = ((mem1.n)<(pRhs->n)?(mem1.n):(pRhs->n));
          rc = memcmp(&aKey1[d1], pRhs->z, nCmp);
          if( rc==0 ) rc = mem1.n - pRhs->n;
        }
      }
    }


    else if( pRhs->flags & 0x0010 ){
      ((void) (0));
      serial_type=(u32)*(&aKey1[idx1]);if(serial_type>=0x80)sqlite3GetVarint32((&aKey1[idx1]),(u32*)&(serial_type));
                                 ;
      if( serial_type<12 || (serial_type & 0x01) ){
        rc = -1;
      }else{
        int nStr = (serial_type - 12) / 2;
                                              ;
                                                ;
        if( (d1+nStr) > (unsigned)nKey1 ){
          pPKey2->errCode = (u8)sqlite3CorruptError(91692);
          return 0;
        }else if( pRhs->flags & 0x0400 ){
          if( !isAllZero((const char*)&aKey1[d1],nStr) ){
            rc = 1;
          }else{
            rc = nStr - pRhs->u.nZero;
          }
        }else{
          int nCmp = ((nStr)<(pRhs->n)?(nStr):(pRhs->n));
          rc = memcmp(&aKey1[d1], pRhs->z, nCmp);
          if( rc==0 ) rc = nStr - pRhs->n;
        }
      }
    }


    else{
      serial_type = aKey1[idx1];
      if( serial_type==0
       || serial_type==10
       || (serial_type==7 && serialGet7(&aKey1[d1], &mem1)!=0)
      ){
        ((void) (0));
      }else{
        rc = 1;
      }
    }

    if( rc!=0 ){
      int sortFlags = pPKey2->pKeyInfo->aSortFlags[i];
      if( sortFlags ){
        if( (sortFlags & 0x02)==0
         || ((sortFlags & 0x01)
           !=(serial_type==0 || (pRhs->flags&0x0001)))
        ){
          rc = -rc;
        }
      }
      ((void) (0));
      ((void) (0));
      return rc;
    }

    i++;
    if( i==pPKey2->nField ) break;
    pRhs++;
    d1 += sqlite3VdbeSerialTypeLen(serial_type);
    if( d1>(unsigned)nKey1 ) break;
    idx1 += sqlite3VarintLen(serial_type);
    if( idx1>=(unsigned)szHdr1 ){
      pPKey2->errCode = (u8)sqlite3CorruptError(91743);
      return 0;
    }
  }




  ((void) (0));




  ((void) (0));



  pPKey2->eqSeen = 1;
  return pPKey2->default_rc;
}
static int sqlite3VdbeRecordCompare(
  int nKey1, const void *pKey1,
  UnpackedRecord *pPKey2
){
  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 0);
}
# 91780 "c_tests/sqlite3.c"
static int vdbeRecordCompareInt(
  int nKey1, const void *pKey1,
  UnpackedRecord *pPKey2
){
  const u8 *aKey = &((const u8*)pKey1)[*(const u8*)pKey1 & 0x3F];
  int serial_type = ((const u8*)pKey1)[1];
  int res;
  u32 y;
  u64 x;
  i64 v;
  i64 lhs;

                                                                  ;
  ((void) (0));
  switch( serial_type ){
    case 1: {
      lhs = ((i8)(aKey)[0]);
                       ;
      break;
    }
    case 2: {
      lhs = (256*(i8)((aKey)[0])|(aKey)[1]);
                       ;
      break;
    }
    case 3: {
      lhs = (65536*(i8)((aKey)[0])|((aKey)[1]<<8)|(aKey)[2]);
                       ;
      break;
    }
    case 4: {
      y = (((u32)(aKey)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);
      lhs = (i64)*(int*)&y;
                       ;
      break;
    }
    case 5: {
      lhs = (((u32)(aKey+2)[0]<<24)|((aKey+2)[1]<<16)|((aKey+2)[2]<<8)|(aKey+2)[3]) + (((i64)1)<<32)*(256*(i8)((aKey)[0])|(aKey)[1]);
                       ;
      break;
    }
    case 6: {
      x = (((u32)(aKey)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);
      x = (x<<32) | (((u32)(aKey+4)[0]<<24)|((aKey+4)[1]<<16)|((aKey+4)[2]<<8)|(aKey+4)[3]);
      lhs = *(i64*)&x;
                       ;
      break;
    }
    case 8:
      lhs = 0;
      break;
    case 9:
      lhs = 1;
      break;







    case 0: case 7:
      return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);

    default:
      return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);
  }

  ((void) (0));
  v = pPKey2->u.i;
  if( v>lhs ){
    res = pPKey2->r1;
  }else if( v<lhs ){
    res = pPKey2->r2;
  }else if( pPKey2->nField>1 ){


    res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
  }else{


    res = pPKey2->default_rc;
    pPKey2->eqSeen = 1;
  }

  ((void) (0));
  return res;
}







static int vdbeRecordCompareString(
  int nKey1, const void *pKey1,
  UnpackedRecord *pPKey2
){
  const u8 *aKey1 = (const u8*)pKey1;
  int serial_type;
  int res;

  ((void) (0));
  ((void) (0));
  ((void) (0));
                                                                  ;
  serial_type = (signed char)(aKey1[1]);

vrcs_restart:
  if( serial_type<12 ){
    if( serial_type<0 ){
      sqlite3GetVarint32(&aKey1[1], (u32*)&serial_type);
      if( serial_type>=12 ) goto vrcs_restart;
      ((void) (0));
    }
    res = pPKey2->r1;
  }else if( !(serial_type & 0x01) ){
    res = pPKey2->r2;
  }else{
    int nCmp;
    int nStr;
    int szHdr = aKey1[0];

    nStr = (serial_type-12) / 2;
    if( (szHdr + nStr) > nKey1 ){
      pPKey2->errCode = (u8)sqlite3CorruptError(91906);
      return 0;
    }
    nCmp = ((pPKey2->n)<(nStr)?(pPKey2->n):(nStr));
    res = memcmp(&aKey1[szHdr], pPKey2->u.z, nCmp);

    if( res>0 ){
      res = pPKey2->r2;
    }else if( res<0 ){
      res = pPKey2->r1;
    }else{
      res = nStr - pPKey2->n;
      if( res==0 ){
        if( pPKey2->nField>1 ){
          res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
        }else{
          res = pPKey2->default_rc;
          pPKey2->eqSeen = 1;
        }
      }else if( res>0 ){
        res = pPKey2->r2;
      }else{
        res = pPKey2->r1;
      }
    }
  }

  ((void) (0));



  return res;
}






static RecordCompare sqlite3VdbeFindCompare(UnpackedRecord *p){
# 91959 "c_tests/sqlite3.c"
  ((void) (0));
  if( p->pKeyInfo->nAllField<=13 ){
    int flags = p->aMem[0].flags;
    if( p->pKeyInfo->aSortFlags[0] ){
      if( p->pKeyInfo->aSortFlags[0] & 0x02 ){
        return sqlite3VdbeRecordCompare;
      }
      p->r1 = 1;
      p->r2 = -1;
    }else{
      p->r1 = -1;
      p->r2 = 1;
    }
    if( (flags & 0x0004) ){
      p->u.i = p->aMem[0].u.i;
      return vdbeRecordCompareInt;
    }
                                ;
                                ;
                                ;
    if( (flags & (0x0008|0x0020|0x0001|0x0010))==0
     && p->pKeyInfo->aColl[0]==0
    ){
      ((void) (0));
      p->u.z = p->aMem[0].z;
      p->n = p->aMem[0].n;
      return vdbeRecordCompareString;
    }
  }

  return sqlite3VdbeRecordCompare;
}
# 92000 "c_tests/sqlite3.c"
static int sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid){
  i64 nCellKey = 0;
  int rc;
  u32 szHdr;
  u32 typeRowid;
  u32 lenRowid;
  Mem m, v;






  ((void) (0));
  nCellKey = sqlite3BtreePayloadSize(pCur);
  ((void) (0));


  sqlite3VdbeMemInit(&m, db, 0);
  rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);
  if( rc ){
    return rc;
  }


  szHdr=(u32)*((u8*)m.z);if(szHdr>=0x80)sqlite3GetVarint32(((u8*)m.z),(u32*)&(szHdr));
                      ;
                             ;
                              ;
  ((void) (0));
  if( (szHdr<3 || szHdr>(unsigned)m.n) ){
    goto idx_rowid_corruption;
  }



  typeRowid=(u32)*((u8*)&m.z[szHdr-1]);if(typeRowid>=0x80)sqlite3GetVarint32(((u8*)&m.z[szHdr-1]),(u32*)&(typeRowid));
                          ;
                          ;
                          ;
                          ;
                          ;
                          ;
                          ;
                          ;
  if( (typeRowid<1 || typeRowid>9 || typeRowid==7) ){
    goto idx_rowid_corruption;
  }
  lenRowid = sqlite3SmallTypeSizes[typeRowid];
                                      ;
  if( ((u32)m.n<szHdr+lenRowid) ){
    goto idx_rowid_corruption;
  }


  sqlite3VdbeSerialGet((u8*)&m.z[m.n-lenRowid], typeRowid, &v);
  *rowid = v.u.i;
  sqlite3VdbeMemReleaseMalloc(&m);
  return 0;



idx_rowid_corruption:
                           ;
  sqlite3VdbeMemReleaseMalloc(&m);
  return sqlite3CorruptError(92065);
}
# 92079 "c_tests/sqlite3.c"
static int sqlite3VdbeIdxKeyCompare(
  sqlite3 *db,
  VdbeCursor *pC,
  UnpackedRecord *pUnpacked,
  int *res
){
  i64 nCellKey = 0;
  int rc;
  BtCursor *pCur;
  Mem m;

  ((void) (0));
  pCur = pC->uc.pCursor;
  ((void) (0));
  nCellKey = sqlite3BtreePayloadSize(pCur);


  if( nCellKey<=0 || nCellKey>0x7fffffff ){
    *res = 0;
    return sqlite3CorruptError(92098);
  }
  sqlite3VdbeMemInit(&m, db, 0);
  rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);
  if( rc ){
    return rc;
  }
  *res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, pUnpacked, 0);
  sqlite3VdbeMemReleaseMalloc(&m);
  return 0;
}





static void sqlite3VdbeSetChanges(sqlite3 *db, i64 nChange){
  ((void) (0));
  db->nChange = nChange;
  db->nTotalChange += nChange;
}





static void sqlite3VdbeCountChanges(Vdbe *v){
  v->changeCntOn = 1;
}
# 92146 "c_tests/sqlite3.c"
static void sqlite3ExpirePreparedStatements(sqlite3 *db, int iCode){
  Vdbe *p;
  for(p = db->pVdbe; p; p=p->pVNext){
    p->expired = iCode+1;
  }
}




static sqlite3 *sqlite3VdbeDb(Vdbe *v){
  return v->db;
}




static u8 sqlite3VdbePrepareFlags(Vdbe *v){
  return v->prepFlags;
}
# 92175 "c_tests/sqlite3.c"
static sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v, int iVar, u8 aff){
  ((void) (0));
  if( v ){
    Mem *pMem = &v->aVar[iVar-1];
    ((void) (0));

    if( 0==(pMem->flags & 0x0001) ){
      sqlite3_value *pRet = sqlite3ValueNew(v->db);
      if( pRet ){
        sqlite3VdbeMemCopy((Mem *)pRet, pMem);
        sqlite3ValueApplyAffinity(pRet, aff, 1);
      }
      return pRet;
    }
  }
  return 0;
}






static void sqlite3VdbeSetVarmask(Vdbe *v, int iVar){
  ((void) (0));
  ((void) (0));

  if( iVar>=32 ){
    v->expmask |= 0x80000000;
  }else{
    v->expmask |= ((u32)1 << (iVar-1));
  }
}
# 92219 "c_tests/sqlite3.c"
static int sqlite3NotPureFunc(sqlite3_context *pCtx){
  const VdbeOp *pOp;



  pOp = pCtx->pVdbe->aOp + pCtx->iOp;
  if( pOp->opcode==66 ){
    const char *zContext;
    char *zMsg;
    if( pOp->p5 & 0x000004 ){
      zContext = "a CHECK constraint";
    }else if( pOp->p5 & 0x000008 ){
      zContext = "a generated column";
    }else{
      zContext = "an index";
    }
    zMsg = sqlite3_mprintf("non-deterministic use of %s() in %s",
                           pCtx->pFunc->zName, zContext);
    sqlite3_result_error(pCtx, zMsg, -1);
    sqlite3_free(zMsg);
    return 0;
  }
  return 1;
}
# 92265 "c_tests/sqlite3.c"
static void sqlite3VtabImportErrmsg(Vdbe *p, sqlite3_vtab *pVtab){
  if( pVtab->zErrMsg ){
    sqlite3 *db = p->db;
    sqlite3DbFree(db, p->zErrMsg);
    p->zErrMsg = sqlite3DbStrDup(db, pVtab->zErrMsg);
    sqlite3_free(pVtab->zErrMsg);
    pVtab->zErrMsg = 0;
  }
}
# 92429 "c_tests/sqlite3.c"
           int sqlite3_expired(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  return p==0 || p->expired;
}







static int vdbeSafety(Vdbe *p){
  if( p->db==0 ){
    sqlite3_log(21, "API called with finalized prepared statement");
    return 1;
  }else{
    return 0;
  }
}
static int vdbeSafetyNotNull(Vdbe *p){
  if( p==0 ){
    sqlite3_log(21, "API called with NULL prepared statement");
    return 1;
  }else{
    return vdbeSafety(p);
  }
}






static __attribute__((noinline)) void invokeProfileCallback(sqlite3 *db, Vdbe *p){
  sqlite3_int64 iNow;
  sqlite3_int64 iElapse;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  sqlite3OsCurrentTimeInt64(db->pVfs, &iNow);
  iElapse = (iNow - p->startTime)*1000000;

  if( db->xProfile ){
    db->xProfile(db->pProfileArg, p->zSql, iElapse);
  }

  if( db->mTrace & 0x02 ){
    db->trace.xV2(0x02, db->pTraceArg, p, (void*)&iElapse);
  }
  p->startTime = 0;
}
# 92499 "c_tests/sqlite3.c"
           int sqlite3_finalize(sqlite3_stmt *pStmt){
  int rc;
  if( pStmt==0 ){


    rc = 0;
  }else{
    Vdbe *v = (Vdbe*)pStmt;
    sqlite3 *db = v->db;
    if( vdbeSafety(v) ) return sqlite3MisuseError(92508);
    sqlite3_mutex_enter(db->mutex);
    if( ((v)->startTime)>0 ){ invokeProfileCallback(db,v); };
    ((void) (0));
    rc = sqlite3VdbeReset(v);
    sqlite3VdbeDelete(v);
    rc = sqlite3ApiExit(db, rc);
    sqlite3LeaveMutexAndCloseZombie(db);
  }
  return rc;
}
# 92528 "c_tests/sqlite3.c"
           int sqlite3_reset(sqlite3_stmt *pStmt){
  int rc;
  if( pStmt==0 ){
    rc = 0;
  }else{
    Vdbe *v = (Vdbe*)pStmt;
    sqlite3 *db = v->db;
    sqlite3_mutex_enter(db->mutex);
    if( ((v)->startTime)>0 ){ invokeProfileCallback(db,v); };
    rc = sqlite3VdbeReset(v);
    sqlite3VdbeRewind(v);
    ((void) (0));
    rc = sqlite3ApiExit(db, rc);
    sqlite3_mutex_leave(db->mutex);
  }
  return rc;
}




           int sqlite3_clear_bindings(sqlite3_stmt *pStmt){
  int i;
  int rc = 0;
  Vdbe *p = (Vdbe*)pStmt;

  sqlite3_mutex *mutex;







  mutex = p->db->mutex;

  sqlite3_mutex_enter(mutex);
  for(i=0; i<p->nVar; i++){
    sqlite3VdbeMemRelease(&p->aVar[i]);
    p->aVar[i].flags = 0x0001;
  }
  ((void) (0));
  if( p->expmask ){
    p->expired = 1;
  }
  sqlite3_mutex_leave(mutex);
  return rc;
}






           const void *sqlite3_value_blob(sqlite3_value *pVal){
  Mem *p = (Mem*)pVal;
  if( p->flags & (0x0010|0x0002) ){
    if( (((p)->flags&0x0400)?sqlite3VdbeMemExpandBlob(p):0)!=0 ){
      ((void) (0));
      return 0;
    }
    p->flags |= 0x0010;
    return p->n ? p->z : 0;
  }else{
    return sqlite3_value_text(pVal);
  }
}
           int sqlite3_value_bytes(sqlite3_value *pVal){
  return sqlite3ValueBytes(pVal, 1);
}
           int sqlite3_value_bytes16(sqlite3_value *pVal){
  return sqlite3ValueBytes(pVal, 2);
}
           double sqlite3_value_double(sqlite3_value *pVal){
  return sqlite3VdbeRealValue((Mem*)pVal);
}
           int sqlite3_value_int(sqlite3_value *pVal){
  return (int)sqlite3VdbeIntValue((Mem*)pVal);
}
           sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){
  return sqlite3VdbeIntValue((Mem*)pVal);
}
           unsigned int sqlite3_value_subtype(sqlite3_value *pVal){
  Mem *pMem = (Mem*)pVal;
  return ((pMem->flags & 0x0800) ? pMem->eSubtype : 0);
}
           void *sqlite3_value_pointer(sqlite3_value *pVal, const char *zPType){
  Mem *p = (Mem*)pVal;
  if( (p->flags&(0x0dbf|0x0200|0x0800)) ==
                 (0x0001|0x0200|0x0800)
   && zPType!=0
   && p->eSubtype=='p'
   && strcmp(p->u.zPType, zPType)==0
  ){
    return (void*)p->z;
  }else{
    return 0;
  }
}
           const unsigned char *sqlite3_value_text(sqlite3_value *pVal){
  return (const unsigned char *)sqlite3ValueText(pVal, 1);
}

           const void *sqlite3_value_text16(sqlite3_value* pVal){
  return sqlite3ValueText(pVal, 2);
}
           const void *sqlite3_value_text16be(sqlite3_value *pVal){
  return sqlite3ValueText(pVal, 3);
}
           const void *sqlite3_value_text16le(sqlite3_value *pVal){
  return sqlite3ValueText(pVal, 2);
}





           int sqlite3_value_type(sqlite3_value* pVal){
  static const u8 aType[] = {
     4,
     5,
     3,
     5,
     1,
     5,
     1,
     5,
     2,
     5,
     2,
     5,
     1,
     5,
     1,
     5,
     4,
     5,
     3,
     5,
     1,
     5,
     1,
     5,
     2,
     5,
     2,
     5,
     1,
     5,
     1,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     4,
     5,
     3,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
  };
# 92727 "c_tests/sqlite3.c"
  return aType[pVal->flags&0x003f];
}
           int sqlite3_value_encoding(sqlite3_value *pVal){
  return pVal->enc;
}


           int sqlite3_value_nochange(sqlite3_value *pVal){
  return (pVal->flags&(0x0001|0x0400))==(0x0001|0x0400);
}


           int sqlite3_value_frombind(sqlite3_value *pVal){
  return (pVal->flags&0x0040)!=0;
}



           sqlite3_value *sqlite3_value_dup(const sqlite3_value *pOrig){
  sqlite3_value *pNew;
  if( pOrig==0 ) return 0;
  pNew = sqlite3_malloc( sizeof(*pNew) );
  if( pNew==0 ) return 0;
  memset(pNew, 0, sizeof(*pNew));
  memcpy(pNew, pOrig, __builtin_offsetof(Mem, db));
  pNew->flags &= ~0x1000;
  pNew->db = 0;
  if( pNew->flags&(0x0002|0x0010) ){
    pNew->flags &= ~(0x2000|0x1000);
    pNew->flags |= 0x4000;
    if( sqlite3VdbeMemMakeWriteable(pNew)!=0 ){
      sqlite3ValueFree(pNew);
      pNew = 0;
    }
  }else if( pNew->flags & 0x0001 ){

    pNew->flags &= ~(0x0200|0x0800);
  }
  return pNew;
}




           void sqlite3_value_free(sqlite3_value *pOld){
  sqlite3ValueFree(pOld);
}
# 92787 "c_tests/sqlite3.c"
static void setResultStrOrError(
  sqlite3_context *pCtx,
  const char *z,
  int n,
  u8 enc,
  void (*xDel)(void*)
){
  Mem *pOut = pCtx->pOut;
  int rc = sqlite3VdbeMemSetStr(pOut, z, n, enc, xDel);
  if( rc ){
    if( rc==18 ){
      sqlite3_result_error_toobig(pCtx);
    }else{


      ((void) (0));
      sqlite3_result_error_nomem(pCtx);
    }
    return;
  }
  sqlite3VdbeChangeEncoding(pOut, pCtx->enc);
  if( sqlite3VdbeMemTooBig(pOut) ){
    sqlite3_result_error_toobig(pCtx);
  }
}
static int invokeValueDestructor(
  const void *p,
  void (*xDel)(void*),
  sqlite3_context *pCtx
){
  ((void) (0));
  if( xDel==0 ){

  }else if( xDel==((sqlite3_destructor_type)-1) ){

  }else{
    xDel((void*)p);
  }





  ((void) (0));
  sqlite3_result_error_toobig(pCtx);

  return 18;
}
           void sqlite3_result_blob(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){






  ((void) (0));
  ((void) (0));
  setResultStrOrError(pCtx, z, n, 0, xDel);
}
           void sqlite3_result_blob64(
  sqlite3_context *pCtx,
  const void *z,
  sqlite3_uint64 n,
  void (*xDel)(void *)
){
  ((void) (0));






  ((void) (0));
  if( n>0x7fffffff ){
    (void)invokeValueDestructor(z, xDel, pCtx);
  }else{
    setResultStrOrError(pCtx, z, (int)n, 0, xDel);
  }
}
           void sqlite3_result_double(sqlite3_context *pCtx, double rVal){



  ((void) (0));
  sqlite3VdbeMemSetDouble(pCtx->pOut, rVal);
}
           void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){



  ((void) (0));
  pCtx->isError = 1;
  sqlite3VdbeMemSetStr(pCtx->pOut, z, n, 1, ((sqlite3_destructor_type)-1));
}

           void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){



  ((void) (0));
  pCtx->isError = 1;
  sqlite3VdbeMemSetStr(pCtx->pOut, z, n, 2, ((sqlite3_destructor_type)-1));
}

           void sqlite3_result_int(sqlite3_context *pCtx, int iVal){



  ((void) (0));
  sqlite3VdbeMemSetInt64(pCtx->pOut, (i64)iVal);
}
           void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){



  ((void) (0));
  sqlite3VdbeMemSetInt64(pCtx->pOut, iVal);
}
           void sqlite3_result_null(sqlite3_context *pCtx){



  ((void) (0));
  sqlite3VdbeMemSetNull(pCtx->pOut);
}
           void sqlite3_result_pointer(
  sqlite3_context *pCtx,
  void *pPtr,
  const char *zPType,
  void (*xDestructor)(void*)
){
  Mem *pOut;






  pOut = pCtx->pOut;
  ((void) (0));
  sqlite3VdbeMemRelease(pOut);
  pOut->flags = 0x0001;
  sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor);
}
           void sqlite3_result_subtype(sqlite3_context *pCtx, unsigned int eSubtype){
  Mem *pOut;
# 92953 "c_tests/sqlite3.c"
  pOut = pCtx->pOut;
  ((void) (0));
  pOut->eSubtype = eSubtype & 0xff;
  pOut->flags |= 0x0800;
}
           void sqlite3_result_text(
  sqlite3_context *pCtx,
  const char *z,
  int n,
  void (*xDel)(void *)
){






  ((void) (0));
  setResultStrOrError(pCtx, z, n, 1, xDel);
}
           void sqlite3_result_text64(
  sqlite3_context *pCtx,
  const char *z,
  sqlite3_uint64 n,
  void (*xDel)(void *),
  unsigned char enc
){






  ((void) (0));
  ((void) (0));
  if( enc!=1 ){
    if( enc==4 ) enc = 2;
    n &= ~(u64)1;
  }
  if( n>0x7fffffff ){
    (void)invokeValueDestructor(z, xDel, pCtx);
  }else{
    setResultStrOrError(pCtx, z, (int)n, enc, xDel);
    sqlite3VdbeMemZeroTerminateIfAble(pCtx->pOut);
  }
}

           void sqlite3_result_text16(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){
  ((void) (0));
  setResultStrOrError(pCtx, z, n & ~(u64)1, 2, xDel);
}
           void sqlite3_result_text16be(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){
  ((void) (0));
  setResultStrOrError(pCtx, z, n & ~(u64)1, 3, xDel);
}
           void sqlite3_result_text16le(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){
  ((void) (0));
  setResultStrOrError(pCtx, z, n & ~(u64)1, 2, xDel);
}

           void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){
  Mem *pOut;
# 93038 "c_tests/sqlite3.c"
  pOut = pCtx->pOut;
  ((void) (0));
  sqlite3VdbeMemCopy(pOut, pValue);
  sqlite3VdbeChangeEncoding(pOut, pCtx->enc);
  if( sqlite3VdbeMemTooBig(pOut) ){
    sqlite3_result_error_toobig(pCtx);
  }
}
           void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){
  sqlite3_result_zeroblob64(pCtx, n>0 ? n : 0);
}
           int sqlite3_result_zeroblob64(sqlite3_context *pCtx, u64 n){
  Mem *pOut;




  pOut = pCtx->pOut;
  ((void) (0));
  if( n>(u64)pOut->db->aLimit[0] ){
    sqlite3_result_error_toobig(pCtx);
    return 18;
  }

  sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);
  return 0;



}
           void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){



  pCtx->isError = errCode ? errCode : -1;



  if( pCtx->pOut->flags & 0x0001 ){
    setResultStrOrError(pCtx, sqlite3ErrStr(errCode), -1, 1,
                        ((sqlite3_destructor_type)0));
  }
}


           void sqlite3_result_error_toobig(sqlite3_context *pCtx){



  ((void) (0));
  pCtx->isError = 18;
  sqlite3VdbeMemSetStr(pCtx->pOut, "string or blob too big", -1,
                       1, ((sqlite3_destructor_type)0));
}


           void sqlite3_result_error_nomem(sqlite3_context *pCtx){



  ((void) (0));
  sqlite3VdbeMemSetNull(pCtx->pOut);
  pCtx->isError = 7;
  sqlite3OomFault(pCtx->pOut->db);
}






static void sqlite3ResultIntReal(sqlite3_context *pCtx){
  ((void) (0));
  if( pCtx->pOut->flags & 0x0004 ){
    pCtx->pOut->flags &= ~0x0004;
    pCtx->pOut->flags |= 0x0020;
  }
}







static int doWalCallbacks(sqlite3 *db){
  int rc = 0;

  int i;
  for(i=0; i<db->nDb; i++){
    Btree *pBt = db->aDb[i].pBt;
    if( pBt ){
      int nEntry;
      sqlite3BtreeEnter(pBt);
      nEntry = sqlite3PagerWalCallback(sqlite3BtreePager(pBt));
      sqlite3BtreeLeave(pBt);
      if( nEntry>0 && db->xWalCallback && rc==0 ){
        rc = db->xWalCallback(db->pWalArg, db, db->aDb[i].zDbSName, nEntry);
      }
    }
  }

  return rc;
}
# 93153 "c_tests/sqlite3.c"
static int sqlite3Step(Vdbe *p){
  sqlite3 *db;
  int rc;

  ((void) (0));
  db = p->db;
  if( p->eVdbeState!=2 ){
    restart_step:
    if( p->eVdbeState==1 ){
      if( p->expired ){
        p->rc = 17;
        rc = 1;
        if( (p->prepFlags & 0x80)!=0 ){





          rc = sqlite3VdbeTransferError(p);
        }
        goto end_of_step;
      }





      if( db->nVdbeActive==0 ){
        __atomic_store_n((&db->u1.isInterrupted),(0),0);
      }

      ((void) (0));




      if( (db->mTrace & (0x02|0x80))!=0
          && !db->init.busy && p->zSql ){
        sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);
      }else{
        ((void) (0));
      }


      db->nVdbeActive++;
      if( p->readOnly==0 ) db->nVdbeWrite++;
      if( p->bIsReader ) db->nVdbeRead++;
      p->pc = 0;
      p->eVdbeState = 2;
    }else

    if( (p->eVdbeState==3) ){
# 93228 "c_tests/sqlite3.c"
      sqlite3_reset((sqlite3_stmt*)p);

      ((void) (0));
      goto restart_step;
    }
  }





  if( p->explain ){
    rc = sqlite3VdbeList(p);
  }else

  {
    db->nVdbeExec++;
    rc = sqlite3VdbeExec(p);
    db->nVdbeExec--;
  }

  if( rc==100 ){
    ((void) (0));
    ((void) (0));
    db->errCode = 100;
    return 100;
  }else{


    if( ((p)->startTime)>0 ){ invokeProfileCallback(db,p); };

    p->pResultRow = 0;
    if( rc==101 && db->autoCommit ){
      ((void) (0));
      p->rc = doWalCallbacks(db);
      if( p->rc!=0 ){
        rc = 1;
      }
    }else if( rc!=101 && (p->prepFlags & 0x80)!=0 ){




      rc = sqlite3VdbeTransferError(p);
    }
  }

  db->errCode = rc;
  if( 7==sqlite3ApiExit(p->db, p->rc) ){
    p->rc = 7;
    if( (p->prepFlags & 0x80)!=0 ) rc = p->rc;
  }
end_of_step:


  ((void) (0));



  return (rc&db->errMask);
}






           int sqlite3_step(sqlite3_stmt *pStmt){
  int rc = 0;
  Vdbe *v = (Vdbe*)pStmt;
  int cnt = 0;
  sqlite3 *db;

  if( vdbeSafetyNotNull(v) ){
    return sqlite3MisuseError(93302);
  }
  db = v->db;
  sqlite3_mutex_enter(db->mutex);
  while( (rc = sqlite3Step(v))==17
         && cnt++ < 50 ){
    int savedPc = v->pc;
    rc = sqlite3Reprepare(v);
    if( rc!=0 ){
# 93319 "c_tests/sqlite3.c"
      const char *zErr = (const char *)sqlite3_value_text(db->pErr);
      sqlite3DbFree(db, v->zErrMsg);
      if( !db->mallocFailed ){
        v->zErrMsg = sqlite3DbStrDup(db, zErr);
        v->rc = rc = sqlite3ApiExit(db, rc);
      } else {
        v->zErrMsg = 0;
        v->rc = rc = 7;
      }
      break;
    }
    sqlite3_reset(pStmt);
    if( savedPc>=0 ){




      v->minWriteFileFormat = 254;
    }
    ((void) (0));
  }
  sqlite3_mutex_leave(db->mutex);
  return rc;
}






           void *sqlite3_user_data(sqlite3_context *p){



  ((void) (0));
  return p->pFunc->pUserData;
}
# 93367 "c_tests/sqlite3.c"
           sqlite3 *sqlite3_context_db_handle(sqlite3_context *p){



  ((void) (0));

  return p->pOut->db;
}
# 93390 "c_tests/sqlite3.c"
           int sqlite3_vtab_nochange(sqlite3_context *p){



  ((void) (0));

  return sqlite3_value_nochange(p->pOut);
}
# 93406 "c_tests/sqlite3.c"
static void sqlite3VdbeValueListFree(void *pToDelete){
  sqlite3_free(pToDelete);
}





static int valueFromValueList(
  sqlite3_value *pVal,
  sqlite3_value **ppOut,
  int bNext
){
  int rc;
  ValueList *pRhs;

  *ppOut = 0;
  if( pVal==0 ) return sqlite3MisuseError(93423);
  if( (pVal->flags & 0x1000)==0 || pVal->xDel!=sqlite3VdbeValueListFree ){
    return 1;
  }else{
    ((void) (0));

    ((void) (0));
    ((void) (0));
    pRhs = (ValueList*)pVal->z;
  }
  if( bNext ){
    rc = sqlite3BtreeNext(pRhs->pCsr, 0);
  }else{
    int dummy = 0;
    rc = sqlite3BtreeFirst(pRhs->pCsr, &dummy);
    ((void) (0));
    if( sqlite3BtreeEof(pRhs->pCsr) ) rc = 101;
  }
  if( rc==0 ){
    u32 sz;
    Mem sMem;
    memset(&sMem, 0, sizeof(sMem));
    sz = sqlite3BtreePayloadSize(pRhs->pCsr);
    rc = sqlite3VdbeMemFromBtreeZeroOffset(pRhs->pCsr,(int)sz,&sMem);
    if( rc==0 ){
      u8 *zBuf = (u8*)sMem.z;
      u32 iSerial;
      sqlite3_value *pOut = pRhs->pOut;
      int iOff = 1 + (u8)((*(&zBuf[1])<(u8)0x80)?((iSerial)=(u32)*(&zBuf[1])),1:sqlite3GetVarint32((&zBuf[1]),(u32 *)&(iSerial)));
      sqlite3VdbeSerialGet(&zBuf[iOff], iSerial, pOut);
      pOut->enc = ((pOut->db)->enc);
      if( (pOut->flags & 0x4000)!=0 && sqlite3VdbeMemMakeWriteable(pOut) ){
        rc = 7;
      }else{
        *ppOut = pOut;
      }
    }
    sqlite3VdbeMemRelease(&sMem);
  }
  return rc;
}





           int sqlite3_vtab_in_first(sqlite3_value *pVal, sqlite3_value **ppOut){
  return valueFromValueList(pVal, ppOut, 0);
}





           int sqlite3_vtab_in_next(sqlite3_value *pVal, sqlite3_value **ppOut){
  return valueFromValueList(pVal, ppOut, 1);
}
# 93488 "c_tests/sqlite3.c"
static sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context *p){
  int rc;

  sqlite3_int64 *piTime = &p->pVdbe->iCurrentTime;
  ((void) (0));




  if( *piTime==0 ){
    rc = sqlite3OsCurrentTimeInt64(p->pOut->db->pVfs, piTime);
    if( rc ) *piTime = 0;
  }
  return *piTime;
}





static __attribute__((noinline)) void *createAggContext(sqlite3_context *p, int nByte){
  Mem *pMem = p->pMem;
  ((void) (0));
  if( nByte<=0 ){
    sqlite3VdbeMemSetNull(pMem);
    pMem->z = 0;
  }else{
    sqlite3VdbeMemClearAndResize(pMem, nByte);
    pMem->flags = 0x8000;
    pMem->u.pDef = p->pFunc;
    if( pMem->z ){
      memset(pMem->z, 0, nByte);
    }
  }
  return (void*)pMem->z;
}






           void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){
  ((void) (0));
  ((void) (0));
                     ;
  if( (p->pMem->flags & 0x8000)==0 ){
    return createAggContext(p, nByte);
  }else{
    return (void*)p->pMem->z;
  }
}
# 93551 "c_tests/sqlite3.c"
           void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){
  AuxData *pAuxData;




  ((void) (0));



  ((void) (0));

  for(pAuxData=pCtx->pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){
    if( pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){
      return pAuxData->pAux;
    }
  }
  return 0;
}
# 93582 "c_tests/sqlite3.c"
           void sqlite3_set_auxdata(
  sqlite3_context *pCtx,
  int iArg,
  void *pAux,
  void (*xDelete)(void*)
){
  AuxData *pAuxData;
  Vdbe *pVdbe;




  pVdbe= pCtx->pVdbe;
  ((void) (0));



  ((void) (0));


  for(pAuxData=pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){
    if( pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){
      break;
    }
  }
  if( pAuxData==0 ){
    pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData));
    if( !pAuxData ) goto failed;
    pAuxData->iAuxOp = pCtx->iOp;
    pAuxData->iAuxArg = iArg;
    pAuxData->pNextAux = pVdbe->pAuxData;
    pVdbe->pAuxData = pAuxData;
    if( pCtx->isError==0 ) pCtx->isError = -1;
  }else if( pAuxData->xDeleteAux ){
    pAuxData->xDeleteAux(pAuxData->pAux);
  }

  pAuxData->pAux = pAux;
  pAuxData->xDeleteAux = xDelete;
  return;

failed:
  if( xDelete ){
    xDelete(pAux);
  }
}
# 93639 "c_tests/sqlite3.c"
           int sqlite3_aggregate_count(sqlite3_context *p){
  ((void) (0));
  return p->pMem->n;
}





           int sqlite3_column_count(sqlite3_stmt *pStmt){
  Vdbe *pVm = (Vdbe *)pStmt;
  if( pVm==0 ) return 0;
  return pVm->nResColumn;
}





           int sqlite3_data_count(sqlite3_stmt *pStmt){
  Vdbe *pVm = (Vdbe *)pStmt;
  if( pVm==0 || pVm->pResultRow==0 ) return 0;
  return pVm->nResColumn;
}




static const Mem *columnNullValue(void){
# 93677 "c_tests/sqlite3.c"
  static const Mem nullMem



    = {
                            {0},
                            (char*)0,
                            (int)0,
                            (u16)0x0001,
                            (u8)0,
                            (u8)0,
                            (sqlite3*)0,
                            (int)0,
                            (u32)0,
                            (char*)0,
                            (void(*)(void*))0,





      };
  return &nullMem;
}







static Mem *columnMem(sqlite3_stmt *pStmt, int i){
  Vdbe *pVm;
  Mem *pOut;

  pVm = (Vdbe *)pStmt;
  if( pVm==0 ) return (Mem*)columnNullValue();
  ((void) (0));
  sqlite3_mutex_enter(pVm->db->mutex);
  if( pVm->pResultRow!=0 && i<pVm->nResColumn && i>=0 ){
    pOut = &pVm->pResultRow[i];
  }else{
    sqlite3Error(pVm->db, 25);
    pOut = (Mem*)columnNullValue();
  }
  return pOut;
}
# 93743 "c_tests/sqlite3.c"
static void columnMallocFailure(sqlite3_stmt *pStmt)
{





  Vdbe *p = (Vdbe *)pStmt;
  if( p ){
    ((void) (0));
    ((void) (0));
    p->rc = sqlite3ApiExit(p->db, p->rc);
    sqlite3_mutex_leave(p->db->mutex);
  }
}





           const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){
  const void *val;
  val = sqlite3_value_blob( columnMem(pStmt,i) );




  columnMallocFailure(pStmt);
  return val;
}
           int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_bytes( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_bytes16( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           double sqlite3_column_double(sqlite3_stmt *pStmt, int i){
  double val = sqlite3_value_double( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           int sqlite3_column_int(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_int( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){
  sqlite_int64 val = sqlite3_value_int64( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){
  const unsigned char *val = sqlite3_value_text( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){
  Mem *pOut = columnMem(pStmt, i);
  if( pOut->flags&0x2000 ){
    pOut->flags &= ~0x2000;
    pOut->flags |= 0x4000;
  }
  columnMallocFailure(pStmt);
  return (sqlite3_value *)pOut;
}

           const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){
  const void *val = sqlite3_value_text16( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}

           int sqlite3_column_type(sqlite3_stmt *pStmt, int i){
  int iType = sqlite3_value_type( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return iType;
}




static const char * const azExplainColNames8[] = {
   "addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment",
   "id", "parent", "notused", "detail"
};
static const u16 azExplainColNames16data[] = {
             'a', 'd', 'd', 'r', 0,
             'o', 'p', 'c', 'o', 'd', 'e', 0,
             'p', '1', 0,
             'p', '2', 0,
             'p', '3', 0,
             'p', '4', 0,
             'p', '5', 0,
             'c', 'o', 'm', 'm', 'e', 'n', 't', 0,
             'i', 'd', 0,
             'p', 'a', 'r', 'e', 'n', 't', 0,
             'n', 'o', 't', 'u', 's', 'e', 'd', 0,
             'd', 'e', 't', 'a', 'i', 'l', 0
};
static const u8 iExplainColNames16[] = {
  0, 5, 12, 15, 18, 21, 24, 27,
  35, 38, 45, 53
};
# 93867 "c_tests/sqlite3.c"
static const void *columnName(
  sqlite3_stmt *pStmt,
  int N,
  int useUtf16,
  int useType
){
  const void *ret;
  Vdbe *p;
  int n;
  sqlite3 *db;






  if( N<0 ) return 0;
  ret = 0;
  p = (Vdbe *)pStmt;
  db = p->db;
  ((void) (0));
  sqlite3_mutex_enter(db->mutex);

  if( p->explain ){
    if( useType>0 ) goto columnName_end;
    n = p->explain==1 ? 8 : 4;
    if( N>=n ) goto columnName_end;
    if( useUtf16 ){
      int i = iExplainColNames16[N + 8*p->explain - 8];
      ret = (void*)&azExplainColNames16data[i];
    }else{
      ret = (void*)azExplainColNames8[N + 8*p->explain - 8];
    }
    goto columnName_end;
  }
  n = p->nResColumn;
  if( N<n ){
    u8 prior_mallocFailed = db->mallocFailed;
    N += useType*n;

    if( useUtf16 ){
      ret = sqlite3_value_text16((sqlite3_value*)&p->aColName[N]);
    }else

    {
      ret = sqlite3_value_text((sqlite3_value*)&p->aColName[N]);
    }



    ((void) (0));
    if( db->mallocFailed > prior_mallocFailed ){
      sqlite3OomClear(db);
      ret = 0;
    }
  }
columnName_end:
  sqlite3_mutex_leave(db->mutex);
  return ret;
}





           const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, 0);
}

           const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, 0);
}
# 93955 "c_tests/sqlite3.c"
           const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, 1);
}

           const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, 1);
}
# 94036 "c_tests/sqlite3.c"
static int vdbeUnbind(Vdbe *p, unsigned int i){
  Mem *pVar;
  if( vdbeSafetyNotNull(p) ){
    return sqlite3MisuseError(94039);
  }
  sqlite3_mutex_enter(p->db->mutex);
  if( p->eVdbeState!=1 ){
    sqlite3Error(p->db, sqlite3MisuseError(94043));
    sqlite3_mutex_leave(p->db->mutex);
    sqlite3_log(21,
        "bind on a busy prepared statement: [%s]", p->zSql);
    return sqlite3MisuseError(94047);
  }
  if( i>=(unsigned int)p->nVar ){
    sqlite3Error(p->db, 25);
    sqlite3_mutex_leave(p->db->mutex);
    return 25;
  }
  pVar = &p->aVar[i];
  sqlite3VdbeMemRelease(pVar);
  pVar->flags = 0x0001;
  p->db->errCode = 0;
# 94068 "c_tests/sqlite3.c"
  ((void) (0));
  if( p->expmask!=0 && (p->expmask & (i>=31 ? 0x80000000 : (u32)1<<i))!=0 ){
    p->expired = 1;
  }
  return 0;
}




static int bindText(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  i64 nData,
  void (*xDel)(void*),
  u8 encoding
){
  Vdbe *p = (Vdbe *)pStmt;
  Mem *pVar;
  int rc;

  rc = vdbeUnbind(p, (u32)(i-1));
  if( rc==0 ){
    ((void) (0));
    if( zData!=0 ){
      pVar = &p->aVar[i-1];
      rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel);
      if( rc==0 ){
        if( encoding==0 ){
          pVar->enc = ((p->db)->enc);
        }else{
          rc = sqlite3VdbeChangeEncoding(pVar, ((p->db)->enc));
        }
      }
      if( rc ){
        sqlite3Error(p->db, rc);
        rc = sqlite3ApiExit(p->db, rc);
      }
    }
    sqlite3_mutex_leave(p->db->mutex);
  }else if( xDel!=((sqlite3_destructor_type)0) && xDel!=((sqlite3_destructor_type)-1) ){
    xDel((void*)zData);
  }
  return rc;
}





           int sqlite3_bind_blob(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  int nData,
  void (*xDel)(void*)
){



  return bindText(pStmt, i, zData, nData, xDel, 0);
}
           int sqlite3_bind_blob64(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  sqlite3_uint64 nData,
  void (*xDel)(void*)
){
  ((void) (0));
  return bindText(pStmt, i, zData, nData, xDel, 0);
}
           int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, (u32)(i-1));
  if( rc==0 ){
    ((void) (0));
    sqlite3VdbeMemSetDouble(&p->aVar[i-1], rValue);
    sqlite3_mutex_leave(p->db->mutex);
  }
  return rc;
}
           int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){
  return sqlite3_bind_int64(p, i, (i64)iValue);
}
           int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, (u32)(i-1));
  if( rc==0 ){
    ((void) (0));
    sqlite3VdbeMemSetInt64(&p->aVar[i-1], iValue);
    sqlite3_mutex_leave(p->db->mutex);
  }
  return rc;
}
           int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){
  int rc;
  Vdbe *p = (Vdbe*)pStmt;
  rc = vdbeUnbind(p, (u32)(i-1));
  if( rc==0 ){
    ((void) (0));
    sqlite3_mutex_leave(p->db->mutex);
  }
  return rc;
}
           int sqlite3_bind_pointer(
  sqlite3_stmt *pStmt,
  int i,
  void *pPtr,
  const char *zPTtype,
  void (*xDestructor)(void*)
){
  int rc;
  Vdbe *p = (Vdbe*)pStmt;
  rc = vdbeUnbind(p, (u32)(i-1));
  if( rc==0 ){
    ((void) (0));
    sqlite3VdbeMemSetPointer(&p->aVar[i-1], pPtr, zPTtype, xDestructor);
    sqlite3_mutex_leave(p->db->mutex);
  }else if( xDestructor ){
    xDestructor(pPtr);
  }
  return rc;
}
           int sqlite3_bind_text(
  sqlite3_stmt *pStmt,
  int i,
  const char *zData,
  int nData,
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, 1);
}
           int sqlite3_bind_text64(
  sqlite3_stmt *pStmt,
  int i,
  const char *zData,
  sqlite3_uint64 nData,
  void (*xDel)(void*),
  unsigned char enc
){
  ((void) (0));
  if( enc!=1 ){
    if( enc==4 ) enc = 2;
    nData &= ~(u64)1;
  }
  return bindText(pStmt, i, zData, nData, xDel, enc);
}

           int sqlite3_bind_text16(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  int n,
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, n & ~(u64)1, xDel, 2);
}

           int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){
  int rc;
  switch( sqlite3_value_type((sqlite3_value*)pValue) ){
    case 1: {
      rc = sqlite3_bind_int64(pStmt, i, pValue->u.i);
      break;
    }
    case 2: {
      ((void) (0));
      rc = sqlite3_bind_double(pStmt, i,
          (pValue->flags & 0x0008) ? pValue->u.r : (double)pValue->u.i
      );
      break;
    }
    case 4: {
      if( pValue->flags & 0x0400 ){
        rc = sqlite3_bind_zeroblob(pStmt, i, pValue->u.nZero);
      }else{
        rc = sqlite3_bind_blob(pStmt, i, pValue->z, pValue->n,((sqlite3_destructor_type)-1));
      }
      break;
    }
    case 3: {
      rc = bindText(pStmt,i, pValue->z, pValue->n, ((sqlite3_destructor_type)-1),
                              pValue->enc);
      break;
    }
    default: {
      rc = sqlite3_bind_null(pStmt, i);
      break;
    }
  }
  return rc;
}
           int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, (u32)(i-1));
  if( rc==0 ){
    ((void) (0));

    sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);



    sqlite3_mutex_leave(p->db->mutex);
  }
  return rc;
}
           int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;



  sqlite3_mutex_enter(p->db->mutex);
  if( n>(u64)p->db->aLimit[0] ){
    rc = 18;
  }else{
    ((void) (0));
    rc = sqlite3_bind_zeroblob(pStmt, i, n);
  }
  rc = sqlite3ApiExit(p->db, rc);
  sqlite3_mutex_leave(p->db->mutex);
  return rc;
}





           int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  return p ? p->nVar : 0;
}







           const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){
  Vdbe *p = (Vdbe*)pStmt;
  if( p==0 ) return 0;
  return sqlite3VListNumToName(p->pVList, i);
}






static int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName){
  if( p==0 || zName==0 ) return 0;
  return sqlite3VListNameToNum(p->pVList, zName, nName);
}
           int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){
  return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName));
}




static int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  int i;
  ((void) (0));
  ((void) (0));
  sqlite3_mutex_enter(pTo->db->mutex);
  for(i=0; i<pFrom->nVar; i++){
    sqlite3VdbeMemMove(&pTo->aVar[i], &pFrom->aVar[i]);
  }
  sqlite3_mutex_leave(pTo->db->mutex);
  return 0;
}
# 94361 "c_tests/sqlite3.c"
           int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  if( pFrom->nVar!=pTo->nVar ){
    return 1;
  }
  ((void) (0));
  if( pTo->expmask ){
    pTo->expired = 1;
  }
  ((void) (0));
  if( pFrom->expmask ){
    pFrom->expired = 1;
  }
  return sqlite3TransferBindings(pFromStmt, pToStmt);
}
# 94385 "c_tests/sqlite3.c"
           sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)->db : 0;
}





           int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)->readOnly : 1;
}





           int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)->explain : 0;
}




           int sqlite3_stmt_explain(sqlite3_stmt *pStmt, int eMode){
  Vdbe *v = (Vdbe*)pStmt;
  int rc;



  sqlite3_mutex_enter(v->db->mutex);
  if( ((int)v->explain)==eMode ){
    rc = 0;
  }else if( eMode<0 || eMode>2 ){
    rc = 1;
  }else if( (v->prepFlags & 0x80)==0 ){
    rc = 1;
  }else if( v->eVdbeState!=1 ){
    rc = 5;
  }else if( v->nMem>=10 && (eMode!=2 || v->haveEqpOps) ){

    v->explain = eMode;
    rc = 0;
  }else{
    v->explain = eMode;
    rc = sqlite3Reprepare(v);
    v->haveEqpOps = eMode==2;
  }
  if( v->explain ){
    v->nResColumn = 12 - 4*v->explain;
  }else{
    v->nResColumn = v->nResAlloc;
  }
  sqlite3_mutex_leave(v->db->mutex);
  return rc;
}




           int sqlite3_stmt_busy(sqlite3_stmt *pStmt){
  Vdbe *v = (Vdbe*)pStmt;
  return v!=0 && v->eVdbeState==2;
}







           sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){
  sqlite3_stmt *pNext;






  sqlite3_mutex_enter(pDb->mutex);
  if( pStmt==0 ){
    pNext = (sqlite3_stmt*)pDb->pVdbe;
  }else{
    pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pVNext;
  }
  sqlite3_mutex_leave(pDb->mutex);
  return pNext;
}




           int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){
  Vdbe *pVdbe = (Vdbe*)pStmt;
  u32 v;
# 94487 "c_tests/sqlite3.c"
  if( op==99 ){
    sqlite3 *db = pVdbe->db;
    sqlite3_mutex_enter(db->mutex);
    v = 0;
    db->pnBytesFreed = (int*)&v;
    ((void) (0));
    db->lookaside.pEnd = db->lookaside.pStart;
    sqlite3VdbeDelete(pVdbe);
    db->pnBytesFreed = 0;
    db->lookaside.pEnd = db->lookaside.pTrueEnd;
    sqlite3_mutex_leave(db->mutex);
  }else{
    v = pVdbe->aCounter[op];
    if( resetFlag ) pVdbe->aCounter[op] = 0;
  }
  return (int)v;
}




           const char *sqlite3_sql(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe *)pStmt;
  return p ? p->zSql : 0;
}
# 94522 "c_tests/sqlite3.c"
           char *sqlite3_expanded_sql(sqlite3_stmt *pStmt){



  char *z = 0;
  const char *zSql = sqlite3_sql(pStmt);
  if( zSql ){
    Vdbe *p = (Vdbe *)pStmt;
    sqlite3_mutex_enter(p->db->mutex);
    z = sqlite3VdbeExpandSql(p, zSql);
    sqlite3_mutex_leave(p->db->mutex);
  }
  return z;

}
# 95034 "c_tests/sqlite3.c"
static i64 findNextHostParameter(const char *zSql, i64 *pnToken){
  int tokenType;
  i64 nTotal = 0;
  i64 n;

  *pnToken = 0;
  while( zSql[0] ){
    n = sqlite3GetToken((u8*)zSql, &tokenType);
    ((void) (0));
    if( tokenType==157 ){
      *pnToken = n;
      break;
    }
    nTotal += n;
    zSql += n;
  }
  return nTotal;
}
# 95077 "c_tests/sqlite3.c"
static char *sqlite3VdbeExpandSql(
  Vdbe *p,
  const char *zRawSql
){
  sqlite3 *db;
  int idx = 0;
  int nextIndex = 1;
  i64 n;
  i64 nToken;
  int i;
  Mem *pVar;
  StrAccum out;

  Mem utf8;


  db = p->db;
  sqlite3StrAccumInit(&out, 0, 0, 0, db->aLimit[0]);
  if( db->nVdbeExec>1 ){
    while( *zRawSql ){
      const char *zStart = zRawSql;
      while( *(zRawSql++)!='\n' && *zRawSql );
      sqlite3_str_append(&out, "-- ", 3);
      ((void) (0));
      sqlite3_str_append(&out, zStart, (int)(zRawSql-zStart));
    }
  }else if( p->nVar==0 ){
    sqlite3_str_append(&out, zRawSql, sqlite3Strlen30(zRawSql));
  }else{
    while( zRawSql[0] ){
      n = findNextHostParameter(zRawSql, &nToken);
      ((void) (0));
      sqlite3_str_append(&out, zRawSql, n);
      zRawSql += n;
      ((void) (0));
      if( nToken==0 ) break;
      if( zRawSql[0]=='?' ){
        if( nToken>1 ){
          ((void) (0));
          sqlite3GetInt32(&zRawSql[1], &idx);
        }else{
          idx = nextIndex;
        }
      }else{
        ((void) (0));

                                   ;
                                   ;
                                   ;
                                   ;
        idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken);
        ((void) (0));
      }
      zRawSql += nToken;
      nextIndex = ((idx + 1)>(nextIndex)?(idx + 1):(nextIndex));
      ((void) (0));
      pVar = &p->aVar[idx-1];
      if( pVar->flags & 0x0001 ){
        sqlite3_str_append(&out, "NULL", 4);
      }else if( pVar->flags & (0x0004|0x0020) ){
        sqlite3_str_appendf(&out, "%lld", pVar->u.i);
      }else if( pVar->flags & 0x0008 ){
        sqlite3_str_appendf(&out, "%!.15g", pVar->u.r);
      }else if( pVar->flags & 0x0002 ){
        int nOut;

        u8 enc = ((db)->enc);
        if( enc!=1 ){
          memset(&utf8, 0, sizeof(utf8));
          utf8.db = db;
          sqlite3VdbeMemSetStr(&utf8, pVar->z, pVar->n, enc, ((sqlite3_destructor_type)0));
          if( 7==sqlite3VdbeChangeEncoding(&utf8, 1) ){
            out.accError = 7;
            out.nAlloc = 0;
          }
          pVar = &utf8;
        }

        nOut = pVar->n;






        sqlite3_str_appendf(&out, "'%.*q'", nOut, pVar->z);






        if( enc!=1 ) sqlite3VdbeMemRelease(&utf8);

      }else if( pVar->flags & 0x0400 ){
        sqlite3_str_appendf(&out, "zeroblob(%d)", pVar->u.nZero);
      }else{
        int nOut;
        ((void) (0));
        sqlite3_str_append(&out, "x'", 2);
        nOut = pVar->n;



        for(i=0; i<nOut; i++){
          sqlite3_str_appendf(&out, "%02x", pVar->z[i]&0xff);
        }
        sqlite3_str_append(&out, "'", 1);





      }
    }
  }
  if( out.accError ) sqlite3_str_reset(&out);
  return sqlite3StrAccumFinish(&out);
}
# 95542 "c_tests/sqlite3.c"
static VdbeCursor *allocateCursor(
  Vdbe *p,
  int iCur,
  int nField,
  u8 eCurType
){
# 95566 "c_tests/sqlite3.c"
  Mem *pMem = iCur>0 ? &p->aMem[p->nMem-iCur] : p->aMem;

  i64 nByte;
  VdbeCursor *pCx = 0;
  nByte = ((((__builtin_offsetof(VdbeCursor, aType))+7)&~7) + ((nField)+1)*sizeof(u64));
  ((void) (0));
  if( eCurType==0 ) nByte += sqlite3BtreeCursorSize();

  ((void) (0));
  if( p->apCsr[iCur] ){
    sqlite3VdbeFreeCursorNN(p, p->apCsr[iCur]);
    p->apCsr[iCur] = 0;
  }





  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pMem->szMalloc<nByte ){
    if( pMem->szMalloc>0 ){
      sqlite3DbFreeNN(pMem->db, pMem->zMalloc);
    }
    pMem->z = pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, nByte);
    if( pMem->zMalloc==0 ){
      pMem->szMalloc = 0;
      return 0;
    }
    pMem->szMalloc = (int)nByte;
  }

  p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->zMalloc;
  memset(pCx, 0, __builtin_offsetof(VdbeCursor, pAltCursor));
  pCx->eCurType = eCurType;
  pCx->nField = nField;
  pCx->aOffset = &pCx->aType[nField];
  if( eCurType==0 ){
    ((void) (0));
    pCx->uc.pCursor = (BtCursor*)&pMem->z[((((__builtin_offsetof(VdbeCursor, aType))+7)&~7) + ((nField)+1)*sizeof(u64))];
    sqlite3BtreeCursorZero(pCx->uc.pCursor);
  }
  return pCx;
}







static int alsoAnInt(Mem *pRec, double rValue, i64 *piValue){
  i64 iValue;
  iValue = sqlite3RealToI64(rValue);
  if( sqlite3RealSameAsInt(rValue,iValue) ){
    *piValue = iValue;
    return 1;
  }
  return 0==sqlite3Atoi64(pRec->z, piValue, pRec->n, pRec->enc);
}
# 95643 "c_tests/sqlite3.c"
static void applyNumericAffinity(Mem *pRec, int bTryForInt){
  double rValue;
  u8 enc = pRec->enc;
  int rc;
  ((void) (0));
  rc = sqlite3AtoF(pRec->z, &rValue, pRec->n, enc);
  if( rc<=0 ) return;
  if( rc==1 && alsoAnInt(pRec, rValue, &pRec->u.i) ){
    pRec->flags |= 0x0004;
  }else{
    pRec->u.r = rValue;
    pRec->flags |= 0x0008;
    if( bTryForInt ) sqlite3VdbeIntegerAffinity(pRec);
  }




  pRec->flags &= ~0x0002;
}
# 95687 "c_tests/sqlite3.c"
static void applyAffinity(
  Mem *pRec,
  char affinity,
  u8 enc
){
  if( affinity>=0x43 ){
    ((void) (0));

    if( (pRec->flags & 0x0004)==0 ){
      if( (pRec->flags & (0x0008|0x0020))==0 ){
        if( pRec->flags & 0x0002 ) applyNumericAffinity(pRec,1);
      }else if( affinity<=0x45 ){
        sqlite3VdbeIntegerAffinity(pRec);
      }
    }
  }else if( affinity==0x42 ){





    if( 0==(pRec->flags&0x0002) ){
      if( (pRec->flags&(0x0008|0x0004|0x0020)) ){
                                         ;
                                          ;
                                             ;
        sqlite3VdbeMemStringify(pRec, enc, 1);
      }
    }
    pRec->flags &= ~(0x0008|0x0004|0x0020);
  }
}







           int sqlite3_value_numeric_type(sqlite3_value *pVal){
  int eType = sqlite3_value_type(pVal);
  if( eType==3 ){
    Mem *pMem = (Mem*)pVal;
    applyNumericAffinity(pMem, 0);
    eType = sqlite3_value_type(pVal);
  }
  return eType;
}





static void sqlite3ValueApplyAffinity(
  sqlite3_value *pVal,
  u8 affinity,
  u8 enc
){
  applyAffinity((Mem *)pVal, affinity, enc);
}







static u16 __attribute__((noinline)) computeNumericType(Mem *pMem){
  int rc;
  sqlite3_int64 ix;
  ((void) (0));
  ((void) (0));
  if( (((pMem)->flags&0x0400)?sqlite3VdbeMemExpandBlob(pMem):0) ){
    pMem->u.i = 0;
    return 0x0004;
  }
  rc = sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);
  if( rc<=0 ){
    if( rc==0 && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)<=1 ){
      pMem->u.i = ix;
      return 0x0004;
    }else{
      return 0x0008;
    }
  }else if( rc==1 && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)==0 ){
    pMem->u.i = ix;
    return 0x0004;
  }
  return 0x0008;
}
# 95785 "c_tests/sqlite3.c"
static u16 numericType(Mem *pMem){
  ((void) (0));

  if( pMem->flags & (0x0004|0x0008|0x0020|0x0001) ){
                                     ;
                                      ;
                                         ;
    return pMem->flags & (0x0004|0x0008|0x0020|0x0001);
  }
  ((void) (0));
                                   ;
                                    ;
  return computeNumericType(pMem);
  return 0;
}
# 95954 "c_tests/sqlite3.c"
static __attribute__((noinline)) Mem *out2PrereleaseWithClear(Mem *pOut){
  sqlite3VdbeMemSetNull(pOut);
  pOut->flags = 0x0004;
  return pOut;
}
static Mem *out2Prerelease(Vdbe *p, VdbeOp *pOp){
  Mem *pOut;
  ((void) (0));
  ((void) (0));
  pOut = &p->aMem[pOp->p2];
                           ;
  if( (((pOut)->flags&(0x8000|0x1000))!=0) ){
    return out2PrereleaseWithClear(pOut);
  }else{
    pOut->flags = 0x0004;
    return pOut;
  }
}





static u64 filterHash(const Mem *aMem, const Op *pOp){
  int i, mx;
  u64 h = 0;

  ((void) (0));
  for(i=pOp->p3, mx=i+pOp->p4.i; i<mx; i++){
    const Mem *p = &aMem[i];
    if( p->flags & (0x0004|0x0020) ){
      h += p->u.i;
    }else if( p->flags & 0x0008 ){
      h += sqlite3VdbeIntValue(p);
    }else if( p->flags & (0x0002|0x0010) ){



      h += 4093 + (p->flags & (0x0002|0x0010));
    }
  }
  return h;
}
# 96006 "c_tests/sqlite3.c"
static __attribute__((noinline)) int vdbeColumnFromOverflow(
  VdbeCursor *pC,
  int iCol,
  u32 t,
  i64 iOffset,
  u32 cacheStatus,
  u32 colCacheCtr,
  Mem *pDest
){
  int rc;
  sqlite3 *db = pDest->db;
  int encoding = pDest->enc;
  int len = sqlite3VdbeSerialTypeLen(t);
  ((void) (0));
  if( len>db->aLimit[0] ) return 18;
  if( len > 4000 && pC->pKeyInfo==0 ){
# 96032 "c_tests/sqlite3.c"
    VdbeTxtBlbCache *pCache;
    char *pBuf;
    if( pC->colCache==0 ){
      pC->pCache = sqlite3DbMallocZero(db, sizeof(VdbeTxtBlbCache) );
      if( pC->pCache==0 ) return 7;
      pC->colCache = 1;
    }
    pCache = pC->pCache;
    if( pCache->pCValue==0
     || pCache->iCol!=iCol
     || pCache->cacheStatus!=cacheStatus
     || pCache->colCacheCtr!=colCacheCtr
     || pCache->iOffset!=sqlite3BtreeOffset(pC->uc.pCursor)
    ){
      if( pCache->pCValue ) sqlite3RCStrUnref(pCache->pCValue);
      pBuf = pCache->pCValue = sqlite3RCStrNew( len+3 );
      if( pBuf==0 ) return 7;
      rc = sqlite3BtreePayload(pC->uc.pCursor, iOffset, len, pBuf);
      if( rc ) return rc;
      pBuf[len] = 0;
      pBuf[len+1] = 0;
      pBuf[len+2] = 0;
      pCache->iCol = iCol;
      pCache->cacheStatus = cacheStatus;
      pCache->colCacheCtr = colCacheCtr;
      pCache->iOffset = sqlite3BtreeOffset(pC->uc.pCursor);
    }else{
      pBuf = pCache->pCValue;
    }
    ((void) (0));
    sqlite3RCStrRef(pBuf);
    if( t&1 ){
      rc = sqlite3VdbeMemSetStr(pDest, pBuf, len, encoding,
                                sqlite3RCStrUnref);
      pDest->flags |= 0x0200;
    }else{
      rc = sqlite3VdbeMemSetStr(pDest, pBuf, len, 0,
                                sqlite3RCStrUnref);
    }
  }else{
    rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, iOffset, len, pDest);
    if( rc ) return rc;
    sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest);
    if( (t&1)!=0 && encoding==1 ){
      pDest->z[len] = 0;
      pDest->flags |= 0x0200;
    }
  }
  pDest->flags &= ~0x4000;
  return rc;
}




static __attribute__((noinline)) void sqlite3VdbeLogAbort(
  Vdbe *p,
  int rc,
  Op *pOp,
  Op *aOp
){
  const char *zSql = p->zSql;
  const char *zPrefix = "";
  int pc;
  char zXtra[100];

  if( p->pFrame ){
    ((void) (0));
    if( aOp[0].p4.z!=0 ){
      ((void) (0));


      sqlite3_snprintf(sizeof(zXtra), zXtra,"/* %s */ ",aOp[0].p4.z+3);
      zPrefix = zXtra;
    }else{
      zPrefix = "/* unknown trigger */ ";
    }
  }
  pc = (int)(pOp - aOp);
  sqlite3_log(rc, "statement aborts at %d: %s; [%s%s]",
                   pc, p->zErrMsg, zPrefix, zSql);
}




static const char *vdbeMemTypeName(Mem *pMem){
  static const char *azTypes[] = {
                           "INT",
                           "REAL",
                           "TEXT",
                           "BLOB",
                           "NULL"
  };
  return azTypes[sqlite3_value_type(pMem)-1];
}





static int sqlite3VdbeExec(
  Vdbe *p
){
  Op *aOp = p->aOp;
  Op *pOp = aOp;





  int rc = 0;
  sqlite3 *db = p->db;
  u8 resetSchemaOnFault = 0;
  u8 encoding = ((db)->enc);
  int iCompare = 0;
  u64 nVmStep = 0;

  u64 nProgressLimit;

  Mem *aMem = p->aMem;
  Mem *pIn1 = 0;
  Mem *pIn2 = 0;
  Mem *pIn3 = 0;
  Mem *pOut = 0;
  u32 colCacheCtr = 0;






  ((void) (0));
  if( ((p->lockMask)!=0) ){
    sqlite3VdbeEnter(p);
  }

  if( db->xProgress ){
    u32 iPrior = p->aCounter[4];
    ((void) (0));
    nProgressLimit = db->nProgressOps - (iPrior % db->nProgressOps);
  }else{
    nProgressLimit = (0xffffffff|(((u64)0xffffffff)<<32));
  }

  if( p->rc==7 ){


    goto no_mem;
  }
  ((void) (0));
                              ;
  p->rc = 0;
  ((void) (0));
  p->iCurrentTime = 0;
  ((void) (0));
  db->busyHandler.nBusy = 0;
  if( __atomic_load_n((&db->u1.isInterrupted),0) ) goto abort_due_to_interrupt;
                          ;
# 96218 "c_tests/sqlite3.c"
  for(pOp=&aOp[p->pc]; 1; pOp++){


    ((void) (0));

    ((void) (0));
    nVmStep++;
# 96301 "c_tests/sqlite3.c"
    switch( pOp->opcode ){
# 96350 "c_tests/sqlite3.c"
case 9: {
# 96365 "c_tests/sqlite3.c"
jump_to_p2_and_check_for_interrupt:
  pOp = &aOp[pOp->p2 - 1];
# 96378 "c_tests/sqlite3.c"
check_for_interrupt:
  if( __atomic_load_n((&db->u1.isInterrupted),0) ) goto abort_due_to_interrupt;







  while( nVmStep>=nProgressLimit && db->xProgress!=0 ){
    ((void) (0));
    nProgressLimit += db->nProgressOps;
    if( db->xProgress(db->pProgressArg) ){
      nProgressLimit = (0xffffffff|(((u64)0xffffffff)<<32));
      rc = 9;
      goto abort_due_to_error;
    }
  }


  break;
}






case 10: {
  ((void) (0));
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
                           ;
  pIn1->flags = 0x0004;
  pIn1->u.i = (int)(pOp-aOp);
                               ;
  goto jump_to_p2_and_check_for_interrupt;
}
# 96439 "c_tests/sqlite3.c"
case 68: {
  pIn1 = &aMem[pOp->p1];
  if( pIn1->flags & 0x0004 ){
    if( pOp->p3 ){ ; }
    pOp = &aOp[pIn1->u.i];
  }else if( (pOp->p3) ){
                         ;
  }
  break;
}
# 96461 "c_tests/sqlite3.c"
case 11: {
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pOut = &aMem[pOp->p1];
  ((void) (0));
  pOut->u.i = pOp->p3 - 1;
  pOut->flags = 0x0004;
  if( pOp->p2==0 ) break;



jump_to_p2:
  ((void) (0));
  ((void) (0));
  pOp = &aOp[pOp->p2 - 1];
  break;
}
# 96490 "c_tests/sqlite3.c"
case 69: {
  VdbeOp *pCaller;
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  ((void) (0));
  pCaller = &aOp[pIn1->u.i];
  ((void) (0));
  ((void) (0));
  pIn1->u.i = (int)(pOp - p->aOp) - 1;
  pOp = &aOp[pCaller->p2 - 1];
  break;
}
# 96516 "c_tests/sqlite3.c"
case 12: {
  int pcDest;
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  pIn1->flags = 0x0004;
  pcDest = (int)pIn1->u.i;
  pIn1->u.i = (int)(pOp - aOp);
                               ;
  pOp = &aOp[pcDest];
  break;
}
# 96536 "c_tests/sqlite3.c"
case 70: {
  pIn3 = &aMem[pOp->p3];



  if( (pIn3->flags & 0x0001)==0 ) break;

                 __attribute__((fallthrough));
}
# 96580 "c_tests/sqlite3.c"
case 71: {
  VdbeFrame *pFrame;
  int pcx;




  ((void) (0));






  ((void) (0));

  if( p->pFrame && pOp->p1==0 ){

    pFrame = p->pFrame;
    p->pFrame = pFrame->pParent;
    p->nFrame--;
    sqlite3VdbeSetChanges(db, p->nChange);
    pcx = sqlite3VdbeFrameRestore(pFrame);
    if( pOp->p2==4 ){





      pcx = p->aOp[pcx].p2-1;
    }
    aOp = p->aOp;
    aMem = p->aMem;
    pOp = &aOp[pcx];
    break;
  }
  p->rc = pOp->p1;
  p->errorAction = (u8)pOp->p2;
  ((void) (0));
  if( p->rc ){
    if( pOp->p3>0 && pOp->p4type==0 ){
      const char *zErr;
      ((void) (0));
      zErr = sqlite3ValueText(&aMem[pOp->p3], 1);
      sqlite3VdbeError(p, "%s", zErr);
    }else if( pOp->p5 ){
      static const char * const azType[] = { "NOT NULL", "UNIQUE", "CHECK",
                                             "FOREIGN KEY" };
                            ;
                            ;
                            ;
                            ;
      sqlite3VdbeError(p, "%s constraint failed", azType[pOp->p5-1]);
      if( pOp->p4.z ){
        p->zErrMsg = sqlite3MPrintf(db, "%z: %s", p->zErrMsg, pOp->p4.z);
      }
    }else{
      sqlite3VdbeError(p, "%s", pOp->p4.z);
    }
    sqlite3VdbeLogAbort(p, pOp->p1, pOp, aOp);
  }
  rc = sqlite3VdbeHalt(p);
  ((void) (0));
  if( rc==5 ){
    p->rc = 5;
  }else{
    ((void) (0));
    ((void) (0));
    rc = p->rc ? 1 : 101;
  }
  goto vdbe_return;
}






case 72: {
  pOut = out2Prerelease(p, pOp);
  pOut->u.i = pOp->p1;
  break;
}







case 73: {
  pOut = out2Prerelease(p, pOp);
  ((void) (0));
  pOut->u.i = *pOp->p4.pI64;
  break;
}
# 96684 "c_tests/sqlite3.c"
case 154: {
  pOut = out2Prerelease(p, pOp);
  pOut->flags = 0x0008;
  ((void) (0));
  pOut->u.r = *pOp->p4.pReal;
  break;
}
# 96701 "c_tests/sqlite3.c"
case 118: {
  ((void) (0));
  pOut = out2Prerelease(p, pOp);
  pOp->p1 = sqlite3Strlen30(pOp->p4.z);


  if( encoding!=1 ){
    rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, 1, ((sqlite3_destructor_type)0));
    ((void) (0));
    if( rc ) goto too_big;
    if( 0!=sqlite3VdbeChangeEncoding(pOut, encoding) ) goto no_mem;
    ((void) (0));
    ((void) (0));
    pOut->szMalloc = 0;
    pOut->flags |= 0x2000;
    if( pOp->p4type==(-6) ){
      sqlite3DbFree(db, pOp->p4.z);
    }
    pOp->p4type = (-6);
    pOp->p4.z = pOut->z;
    pOp->p1 = pOut->n;
  }

  if( pOp->p1>db->aLimit[0] ){
    goto too_big;
  }
  pOp->opcode = 74;
  ((void) (0));

                 __attribute__((fallthrough));
}
# 96745 "c_tests/sqlite3.c"
case 74: {
  ((void) (0));
  pOut = out2Prerelease(p, pOp);
  pOut->flags = 0x0002|0x2000|0x0200;
  pOut->z = pOp->p4.z;
  pOut->n = pOp->p1;
  pOut->enc = encoding;
                           ;

  if( pOp->p3>0 ){
    ((void) (0));
    pIn3 = &aMem[pOp->p3];
    ((void) (0));
    if( pIn3->u.i==pOp->p5 ) pOut->flags = 0x0010|0x2000|0x0200;
  }

  break;
}
# 96798 "c_tests/sqlite3.c"
case 75:
case 76: {
  int cnt;
  u16 nullFlag;
  pOut = out2Prerelease(p, pOp);
  cnt = pOp->p3-pOp->p2;
  ((void) (0));
  pOut->flags = nullFlag = pOp->p1 ? (0x0001|0x0100) : 0x0001;
  pOut->n = 0;



  while( cnt>0 ){
    pOut++;
                             ;
    sqlite3VdbeMemSetNull(pOut);
    pOut->flags = nullFlag;
    pOut->n = 0;
    cnt--;
  }
  break;
}
# 96829 "c_tests/sqlite3.c"
case 77: {
  ((void) (0));
  pOut = &aMem[pOp->p1];
  pOut->flags = (pOut->flags&~(0x0000|0x003f))|0x0001;
  break;
}
# 96843 "c_tests/sqlite3.c"
case 78: {
  ((void) (0));
  pOut = out2Prerelease(p, pOp);
  if( pOp->p4.z==0 ){
    sqlite3VdbeMemSetZeroBlob(pOut, pOp->p1);
    if( sqlite3VdbeMemExpandBlob(pOut) ) goto no_mem;
  }else{
    sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);
  }
  pOut->enc = encoding;
                           ;
  break;
}






case 79: {
  Mem *pVar;

  ((void) (0));
  pVar = &p->aVar[pOp->p1 - 1];
  if( sqlite3VdbeMemTooBig(pVar) ){
    goto too_big;
  }
  pOut = &aMem[pOp->p2];
  if( (((pOut)->flags&(0x8000|0x1000))!=0) ) sqlite3VdbeMemSetNull(pOut);
  memcpy(pOut, pVar, __builtin_offsetof(Mem, db));
  pOut->flags &= ~(0x1000|0x4000);
  pOut->flags |= 0x2000|0x0040;
                           ;
  break;
}
# 96888 "c_tests/sqlite3.c"
case 80: {
  int n;
  int p1;
  int p2;

  n = pOp->p3;
  p1 = pOp->p1;
  p2 = pOp->p2;
  ((void) (0));
  ((void) (0));

  pIn1 = &aMem[p1];
  pOut = &aMem[p2];
  do{
    ((void) (0));
    ((void) (0));
    ((void) (0));
                             ;
    sqlite3VdbeMemMove(pOut, pIn1);
# 96918 "c_tests/sqlite3.c"
    if( ((pOut)->flags&0x4000)!=0 && sqlite3VdbeMemMakeWriteable(pOut) ){ goto no_mem;};
                              ;
    pIn1++;
    pOut++;
  }while( --n );
  break;
}
# 96939 "c_tests/sqlite3.c"
case 81: {
  int n;

  n = pOp->p3;
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  ((void) (0));
  while( 1 ){
                             ;
    sqlite3VdbeMemShallowCopy(pOut, pIn1, 0x4000);
    if( ((pOut)->flags&0x4000)!=0 && sqlite3VdbeMemMakeWriteable(pOut) ){ goto no_mem;};
    if( (pOut->flags & 0x0800)!=0 && (pOp->p5 & 0x0002)!=0 ){
      pOut->flags &= ~0x0800;
    }



                                           ;
    if( (n--)==0 ) break;
    pOut++;
    pIn1++;
  }
  break;
}
# 96977 "c_tests/sqlite3.c"
case 82: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  ((void) (0));
  sqlite3VdbeMemShallowCopy(pOut, pIn1, 0x4000);





  break;
}
# 96998 "c_tests/sqlite3.c"
case 83: {
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  pOut = &aMem[pOp->p2];
  sqlite3VdbeMemSetInt64(pOut, pIn1->u.i);
  break;
}
# 97017 "c_tests/sqlite3.c"
case 84: {
  if( (rc = sqlite3VdbeCheckFkImmediate(p))!=0 ){
    goto abort_due_to_error;
  }
  break;
}
# 97033 "c_tests/sqlite3.c"
case 85: {
  ((void) (0));
  ((void) (0));
  ((void) (0));

  p->cacheCtr = (p->cacheCtr + 2)|1;
  p->pResultRow = &aMem[pOp->p1];
# 97056 "c_tests/sqlite3.c"
  if( db->mallocFailed ) goto no_mem;
  if( db->mTrace & 0x04 ){
    db->trace.xV2(0x04, db->pTraceArg, p, 0);
  }
  p->pc = (int)(pOp - aOp) + 1;
  rc = 100;
  goto vdbe_return;
}
# 97078 "c_tests/sqlite3.c"
case 112: {
  i64 nByte;
  u16 flags1;
  u16 flags2;

  pIn1 = &aMem[pOp->p1];
  pIn2 = &aMem[pOp->p2];
  pOut = &aMem[pOp->p3];
                        ;
  ((void) (0));
  flags1 = pIn1->flags;
                               ;
                                    ;
  if( (flags1 | pIn2->flags) & 0x0001 ){
    sqlite3VdbeMemSetNull(pOut);
    break;
  }
  if( (flags1 & (0x0002|0x0010))==0 ){
    if( sqlite3VdbeMemStringify(pIn1,encoding,0) ) goto no_mem;
    flags1 = pIn1->flags & ~0x0002;
  }else if( (flags1 & 0x0400)!=0 ){
    if( sqlite3VdbeMemExpandBlob(pIn1) ) goto no_mem;
    flags1 = pIn1->flags & ~0x0002;
  }
  flags2 = pIn2->flags;
  if( (flags2 & (0x0002|0x0010))==0 ){
    if( sqlite3VdbeMemStringify(pIn2,encoding,0) ) goto no_mem;
    flags2 = pIn2->flags & ~0x0002;
  }else if( (flags2 & 0x0400)!=0 ){
    if( sqlite3VdbeMemExpandBlob(pIn2) ) goto no_mem;
    flags2 = pIn2->flags & ~0x0002;
  }
  nByte = pIn1->n;
  nByte += pIn2->n;
  if( nByte>db->aLimit[0] ){
    goto too_big;
  }



  if( sqlite3VdbeMemGrow(pOut, (int)nByte+2, pOut==pIn2) ){
    goto no_mem;
  }
  ((pOut)->flags = ((pOut)->flags&~(0x0dbf|0x0400))|0x0002);
  if( pOut!=pIn2 ){
    memcpy(pOut->z, pIn2->z, pIn2->n);
    ((void) (0));
    pIn2->flags = flags2;
  }
  memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);
  ((void) (0));
  pIn1->flags = flags1;
  if( encoding>1 ) nByte &= ~1;
  pOut->z[nByte]=0;
  pOut->z[nByte+1] = 0;
  pOut->flags |= 0x0200;
  pOut->n = (int)nByte;
  pOut->enc = encoding;
                           ;
  break;
}
# 97178 "c_tests/sqlite3.c"
case 107:
case 108:
case 109:
case 110:
case 111: {
  u16 type1;
  u16 type2;
  i64 iA;
  i64 iB;
  double rA;
  double rB;

  pIn1 = &aMem[pOp->p1];
  type1 = pIn1->flags;
  pIn2 = &aMem[pOp->p2];
  type2 = pIn2->flags;
  pOut = &aMem[pOp->p3];
  if( (type1 & type2 & 0x0004)!=0 ){
int_math:
    iA = pIn1->u.i;
    iB = pIn2->u.i;
    switch( pOp->opcode ){
      case 107: if( sqlite3AddInt64(&iB,iA) ) goto fp_math; break;
      case 108: if( sqlite3SubInt64(&iB,iA) ) goto fp_math; break;
      case 109: if( sqlite3MulInt64(&iB,iA) ) goto fp_math; break;
      case 110: {
        if( iA==0 ) goto arithmetic_result_is_null;
        if( iA==-1 && iB==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ) goto fp_math;
        iB /= iA;
        break;
      }
      default: {
        if( iA==0 ) goto arithmetic_result_is_null;
        if( iA==-1 ) iA = 1;
        iB %= iA;
        break;
      }
    }
    pOut->u.i = iB;
    ((pOut)->flags = ((pOut)->flags&~(0x0dbf|0x0400))|0x0004);
  }else if( ((type1 | type2) & 0x0001)!=0 ){
    goto arithmetic_result_is_null;
  }else{
    type1 = numericType(pIn1);
    type2 = numericType(pIn2);
    if( (type1 & type2 & 0x0004)!=0 ) goto int_math;
fp_math:
    rA = sqlite3VdbeRealValue(pIn1);
    rB = sqlite3VdbeRealValue(pIn2);
    switch( pOp->opcode ){
      case 107: rB += rA; break;
      case 108: rB -= rA; break;
      case 109: rB *= rA; break;
      case 110: {

        if( rA==(double)0 ) goto arithmetic_result_is_null;
        rB /= rA;
        break;
      }
      default: {
        iA = sqlite3VdbeIntValue(pIn1);
        iB = sqlite3VdbeIntValue(pIn2);
        if( iA==0 ) goto arithmetic_result_is_null;
        if( iA==-1 ) iA = 1;
        rB = (double)(iB % iA);
        break;
      }
    }




    if( sqlite3IsNaN(rB) ){
      goto arithmetic_result_is_null;
    }
    pOut->u.r = rB;
    ((pOut)->flags = ((pOut)->flags&~(0x0dbf|0x0400))|0x0008);

  }
  break;

arithmetic_result_is_null:
  sqlite3VdbeMemSetNull(pOut);
  break;
}
# 97279 "c_tests/sqlite3.c"
case 86: {
  ((void) (0));
  if( pOp->p1 ){
    sqlite3VdbeMemSetInt64(&aMem[pOp->p1], 0);
  }
  break;
}
# 97317 "c_tests/sqlite3.c"
case 103:
case 104:
case 105:
case 106: {
  i64 iA;
  u64 uA;
  i64 iB;
  u8 op;

  pIn1 = &aMem[pOp->p1];
  pIn2 = &aMem[pOp->p2];
  pOut = &aMem[pOp->p3];
  if( (pIn1->flags | pIn2->flags) & 0x0001 ){
    sqlite3VdbeMemSetNull(pOut);
    break;
  }
  iA = sqlite3VdbeIntValue(pIn2);
  iB = sqlite3VdbeIntValue(pIn1);
  op = pOp->opcode;
  if( op==103 ){
    iA &= iB;
  }else if( op==104 ){
    iA |= iB;
  }else if( iB!=0 ){
    ((void) (0));


    if( iB<0 ){
      ((void) (0));
      op = 2*105 + 1 - op;
      iB = iB>(-64) ? -iB : 64;
    }

    if( iB>=64 ){
      iA = (iA>=0 || op==105) ? 0 : -1;
    }else{
      memcpy(&uA, &iA, sizeof(uA));
      if( op==105 ){
        uA <<= iB;
      }else{
        uA >>= iB;

        if( iA<0 ) uA |= ((((u64)0xffffffff)<<32)|0xffffffff) << (64-iB);
      }
      memcpy(&iA, &uA, sizeof(iA));
    }
  }
  pOut->u.i = iA;
  ((pOut)->flags = ((pOut)->flags&~(0x0dbf|0x0400))|0x0004);
  break;
}
# 97377 "c_tests/sqlite3.c"
case 87: {
  pIn1 = &aMem[pOp->p1];
                           ;
  sqlite3VdbeMemIntegerify(pIn1);
  *(u64*)&pIn1->u.i += (u64)pOp->p2;
  break;
}
# 97392 "c_tests/sqlite3.c"
case 13: {
  pIn1 = &aMem[pOp->p1];
  if( (pIn1->flags & 0x0004)==0 ){
    applyAffinity(pIn1, 0x43, encoding);
    if( (pIn1->flags & 0x0004)==0 ){
                           ;
      if( pOp->p2==0 ){
        rc = 20;
        goto abort_due_to_error;
      }else{
        goto jump_to_p2;
      }
    }
  }
                       ;
  ((pIn1)->flags = ((pIn1)->flags&~(0x0dbf|0x0400))|0x0004);
  break;
}
# 97421 "c_tests/sqlite3.c"
case 88: {
  pIn1 = &aMem[pOp->p1];
  if( pIn1->flags & (0x0004|0x0020) ){
                                     ;
                                         ;
    sqlite3VdbeMemRealify(pIn1);
                                 ;
  }
  break;
}
# 97449 "c_tests/sqlite3.c"
case 89: {
  ((void) (0));
                                      ;
                                      ;
                                         ;
                                         ;
                                      ;
  pIn1 = &aMem[pOp->p1];
                           ;
  rc = (((pIn1)->flags&0x0400)?sqlite3VdbeMemExpandBlob(pIn1):0);
  if( rc ) goto abort_due_to_error;
  rc = sqlite3VdbeMemCast(pIn1, pOp->p2, encoding);
  if( rc ) goto abort_due_to_error;
                           ;
                               ;
  break;
}
# 97560 "c_tests/sqlite3.c"
case 54:
case 53:
case 57:
case 56:
case 55:
case 58: {
  int res, res2;
  char affinity;
  u16 flags1;
  u16 flags3;

  pIn1 = &aMem[pOp->p1];
  pIn3 = &aMem[pOp->p3];
  flags1 = pIn1->flags;
  flags3 = pIn3->flags;
  if( (flags1 & flags3 & 0x0004)!=0 ){

    if( pIn3->u.i > pIn1->u.i ){
      if( sqlite3aGTb[pOp->opcode] ){
                                                         ;
        goto jump_to_p2;
      }
      iCompare = +1;

    }else if( pIn3->u.i < pIn1->u.i ){
      if( sqlite3aLTb[pOp->opcode] ){
                                                         ;
        goto jump_to_p2;
      }
      iCompare = -1;

    }else{
      if( sqlite3aEQb[pOp->opcode] ){
                                                         ;
        goto jump_to_p2;
      }
      iCompare = 0;

    }
                                                     ;
    break;
  }
  if( (flags1 | flags3)&0x0001 ){

    if( pOp->p5 & 0x80 ){




      ((void) (0));
      ((void) (0));
                                                  ;
      if( (flags1&flags3&0x0001)!=0
       && (flags3&0x0100)==0
      ){
        res = 0;
      }else{
        res = ((flags3 & 0x0001) ? -1 : +1);
      }
    }else{




                          ;
      if( pOp->p5 & 0x10 ){
        goto jump_to_p2;
      }
      iCompare = 1;

      break;
    }
  }else{


    affinity = pOp->p5 & 0x47;
    if( affinity>=0x43 ){
      if( (flags1 | flags3)&0x0002 ){
        if( (flags1 & (0x0004|0x0020|0x0008|0x0002))==0x0002 ){
          applyNumericAffinity(pIn1,0);
          ((void) (0));
          flags3 = pIn3->flags;
        }
        if( (flags3 & (0x0004|0x0020|0x0008|0x0002))==0x0002 ){
          applyNumericAffinity(pIn3,0);
        }
      }
    }else if( affinity==0x42 && ((flags1 | flags3) & 0x0002)!=0 ){
      if( (flags1 & 0x0002)!=0 ){
        pIn1->flags &= ~(0x0004|0x0008|0x0020);
      }else if( (flags1&(0x0004|0x0008|0x0020))!=0 ){
                                         ;
                                          ;
                                             ;
        sqlite3VdbeMemStringify(pIn1, encoding, 1);
                                                             ;
        flags1 = (pIn1->flags & ~0x0dbf) | (flags1 & 0x0dbf);
        if( (pIn1==pIn3) ) flags3 = flags1 | 0x0002;
      }
      if( (flags3 & 0x0002)!=0 ){
        pIn3->flags &= ~(0x0004|0x0008|0x0020);
      }else if( (flags3&(0x0004|0x0008|0x0020))!=0 ){
                                         ;
                                          ;
                                             ;
        sqlite3VdbeMemStringify(pIn3, encoding, 1);
                                                             ;
        flags3 = (pIn3->flags & ~0x0dbf) | (flags3 & 0x0dbf);
      }
    }
    ((void) (0));
    res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl);
  }







  ((void) (0)); ((void) (0)); ((void) (0));
  ((void) (0)); ((void) (0));
  if( res<0 ){
    res2 = sqlite3aLTb[pOp->opcode];
  }else if( res==0 ){
    res2 = sqlite3aEQb[pOp->opcode];
  }else{
    res2 = sqlite3aGTb[pOp->opcode];
  }
  iCompare = res;



  ((void) (0));
  pIn3->flags = flags3;
  ((void) (0));
  pIn1->flags = flags1;

                                                         ;
  if( res2 ){
    goto jump_to_p2;
  }
  break;
}
# 97717 "c_tests/sqlite3.c"
case 59: {
# 97729 "c_tests/sqlite3.c"
  ((void) (0));
                                 ;
  if( iCompare==0 ) goto jump_to_p2;
  break;
}
# 97747 "c_tests/sqlite3.c"
case 90: {
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  break;
}
# 97777 "c_tests/sqlite3.c"
case 91: {
  int n;
  int i;
  int p1;
  int p2;
  const KeyInfo *pKeyInfo;
  u32 idx;
  CollSeq *pColl;
  int bRev;
  u32 *aPermute;

  if( (pOp->p5 & 0x01)==0 ){
    aPermute = 0;
  }else{
    ((void) (0));
    ((void) (0));
    ((void) (0));
    aPermute = pOp[-1].p4.ai + 1;
    ((void) (0));
  }
  n = pOp->p3;
  pKeyInfo = pOp->p4.pKeyInfo;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  p1 = pOp->p1;
  p2 = pOp->p2;
# 97815 "c_tests/sqlite3.c"
  for(i=0; i<n; i++){
    idx = aPermute ? aPermute[i] : (u32)i;
    ((void) (0));
    ((void) (0));
                                         ;
                                         ;
    ((void) (0));
    pColl = pKeyInfo->aColl[i];
    bRev = (pKeyInfo->aSortFlags[i] & 0x01);
    iCompare = sqlite3MemCompare(&aMem[p1+idx], &aMem[p2+idx], pColl);

    if( iCompare ){
      if( (pKeyInfo->aSortFlags[i] & 0x02)
       && ((aMem[p1+idx].flags & 0x0001) || (aMem[p2+idx].flags & 0x0001))
      ){
        iCompare = -iCompare;
      }
      if( bRev ) iCompare = -iCompare;
      break;
    }
  }
  ((void) (0));
  break;
}
# 97848 "c_tests/sqlite3.c"
case 14: {
  ((void) (0));
  ((void) (0));
  if( iCompare<0 ){
                        ; pOp = &aOp[pOp->p1 - 1];
  }else if( iCompare==0 ){
                        ; pOp = &aOp[pOp->p2 - 1];
  }else{
                        ; pOp = &aOp[pOp->p3 - 1];
  }
  break;
}
# 97881 "c_tests/sqlite3.c"
case 44:
case 43: {
  int v1;
  int v2;

  v1 = sqlite3VdbeBooleanValue(&aMem[pOp->p1], 2);
  v2 = sqlite3VdbeBooleanValue(&aMem[pOp->p2], 2);
  if( pOp->opcode==44 ){
    static const unsigned char and_logic[] = { 0, 0, 0, 0, 1, 2, 0, 2, 2 };
    v1 = and_logic[v1*3+v2];
  }else{
    static const unsigned char or_logic[] = { 0, 1, 2, 1, 1, 1, 2, 1, 2 };
    v1 = or_logic[v1*3+v2];
  }
  pOut = &aMem[pOp->p3];
  if( v1==2 ){
    ((pOut)->flags = ((pOut)->flags&~(0x0dbf|0x0400))|0x0001);
  }else{
    pOut->u.i = v1;
    ((pOut)->flags = ((pOut)->flags&~(0x0dbf|0x0400))|0x0004);
  }
  break;
}
# 97925 "c_tests/sqlite3.c"
case 92: {
  ((void) (0));
  ((void) (0));
  ((void) (0));
  sqlite3VdbeMemSetInt64(&aMem[pOp->p2],
      sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3) ^ pOp->p4.i);
  break;
}
# 97941 "c_tests/sqlite3.c"
case 19: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  if( (pIn1->flags & 0x0001)==0 ){
    sqlite3VdbeMemSetInt64(pOut, !sqlite3VdbeBooleanValue(pIn1,0));
  }else{
    sqlite3VdbeMemSetNull(pOut);
  }
  break;
}
# 97959 "c_tests/sqlite3.c"
case 115: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  sqlite3VdbeMemSetNull(pOut);
  if( (pIn1->flags & 0x0001)==0 ){
    pOut->flags = 0x0004;
    pOut->u.i = ~sqlite3VdbeIntValue(pIn1);
  }
  break;
}
# 97993 "c_tests/sqlite3.c"
case 15: {
  u32 iAddr;
  ((void) (0));
  if( p->pFrame ){
    iAddr = (int)(pOp - p->aOp);
    if( (p->pFrame->aOnce[iAddr/8] & (1<<(iAddr & 7)))!=0 ){
                           ;
      goto jump_to_p2;
    }
    p->pFrame->aOnce[iAddr/8] |= 1<<(iAddr & 7);
  }else{
    if( p->aOp[0].p1==pOp->p1 ){
                           ;
      goto jump_to_p2;
    }
  }
                       ;
  pOp->p1 = p->aOp[0].p1;
  break;
}







case 16: {
  int c;
  c = sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3);
                          ;
  if( c ) goto jump_to_p2;
  break;
}







case 17: {
  int c;
  c = !sqlite3VdbeBooleanValue(&aMem[pOp->p1], !pOp->p3);
                          ;
  if( c ) goto jump_to_p2;
  break;
}






case 51: {
  pIn1 = &aMem[pOp->p1];
                                                  ;
  if( (pIn1->flags & 0x0001)!=0 ){
    goto jump_to_p2;
  }
  break;
}
# 98087 "c_tests/sqlite3.c"
case 18: {
  VdbeCursor *pC;
  u16 typeMask;
  u32 serialType;

  ((void) (0));
  ((void) (0));
  if( pOp->p1>=0 ){
    pC = p->apCsr[pOp->p1];
    ((void) (0));
    ((void) (0));
    if( pOp->p3<pC->nHdrParsed ){
      serialType = pC->aType[pOp->p3];
      if( serialType>=12 ){
        if( serialType&1 ){
          typeMask = 0x04;
        }else{
          typeMask = 0x08;
        }
      }else{
        static const unsigned char aMask[] = {
           0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x2,
           0x01, 0x01, 0x10, 0x10
        };
                                 ;
                                 ;
                                 ;
                                 ;
                                 ;
                                 ;
                                 ;
                                 ;
                                 ;
                                 ;
                                  ;
                                  ;
        typeMask = aMask[serialType];
      }
    }else{
      typeMask = 1 << (pOp->p4.i - 1);
                                ;
                                ;
                                ;
                                ;
                                ;
    }
  }else{
    ((void) (0));
    typeMask = 1 << (sqlite3_value_type((sqlite3_value*)&aMem[pOp->p3])-1);
                              ;
                              ;
                              ;
                              ;
                              ;
  }
                                              ;
  if( typeMask & pOp->p5 ){
    goto jump_to_p2;
  }
  break;
}
# 98156 "c_tests/sqlite3.c"
case 93: {
  if( (aMem[pOp->p1].flags & 0x0001)!=0
   || (aMem[pOp->p3].flags & 0x0001)!=0
  ){
    sqlite3VdbeMemSetNull(aMem + pOp->p2);
  }else{
    sqlite3VdbeMemSetInt64(aMem + pOp->p2, 0);
  }
  break;
}






case 52: {
  pIn1 = &aMem[pOp->p1];
                                                  ;
  if( (pIn1->flags & 0x0001)==0 ){
    goto jump_to_p2;
  }
  break;
}
# 98191 "c_tests/sqlite3.c"
case 20: {
  VdbeCursor *pC;
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  if( pC && pC->nullRow ){
    sqlite3VdbeMemSetNull(aMem + pOp->p3);
    goto jump_to_p2;
  }
  break;
}
# 98262 "c_tests/sqlite3.c"
case 95: {
  u32 p2;
  VdbeCursor *pC;
  BtCursor *pCrsr;
  u32 *aOffset;
  int len;
  int i;
  Mem *pDest;
  Mem sMem;
  const u8 *zData;
  const u8 *zHdr;
  const u8 *zEndHdr;
  u64 offset64;
  u32 t;
  Mem *pReg;

  ((void) (0));
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  p2 = (u32)pOp->p2;

op_column_restart:
  ((void) (0));
  ((void) (0));

  aOffset = pC->aOffset;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pC->cacheStatus!=p->cacheCtr ){
    if( pC->nullRow ){
      if( pC->eCurType==3 && pC->seekResult>0 ){


        pReg = &aMem[pC->seekResult];
        ((void) (0));
        ((void) (0));
        pC->payloadSize = pC->szRow = pReg->n;
        pC->aRow = (u8*)pReg->z;
      }else{
        pDest = &aMem[pOp->p3];
                                  ;
        sqlite3VdbeMemSetNull(pDest);
        goto op_column_out;
      }
    }else{
      pCrsr = pC->uc.pCursor;
      if( pC->deferredMoveto ){
        u32 iMap;
        ((void) (0));
        if( pC->ub.aAltMap && (iMap = pC->ub.aAltMap[1+p2])>0 ){
          pC = pC->pAltCursor;
          p2 = iMap - 1;
          goto op_column_restart;
        }
        rc = sqlite3VdbeFinishMoveto(pC);
        if( rc ) goto abort_due_to_error;
      }else if( sqlite3BtreeCursorHasMoved(pCrsr) ){
        rc = sqlite3VdbeHandleMovedCursor(pC);
        if( rc ) goto abort_due_to_error;
        goto op_column_restart;
      }
      ((void) (0));
      ((void) (0));
      ((void) (0));
      pC->payloadSize = sqlite3BtreePayloadSize(pCrsr);
      pC->aRow = sqlite3BtreePayloadFetch(pCrsr, &pC->szRow);
      ((void) (0));
      ((void) (0));
    }
    pC->cacheStatus = p->cacheCtr;
    if( (aOffset[0] = pC->aRow[0])<0x80 ){
      pC->iHdrOffset = 1;
    }else{
      pC->iHdrOffset = sqlite3GetVarint32(pC->aRow, aOffset);
    }
    pC->nHdrParsed = 0;

    if( pC->szRow<aOffset[0] ){




      pC->aRow = 0;
      pC->szRow = 0;
# 98359 "c_tests/sqlite3.c"
      if( aOffset[0] > 98307 || aOffset[0] > pC->payloadSize ){
        goto op_column_corrupt;
      }
    }else{
# 98376 "c_tests/sqlite3.c"
      zData = pC->aRow;
      ((void) (0));
                               ;
      goto op_column_read_header;
    }
  }else if( sqlite3BtreeCursorHasMoved(pC->uc.pCursor) ){
    rc = sqlite3VdbeHandleMovedCursor(pC);
    if( rc ) goto abort_due_to_error;
    goto op_column_restart;
  }




  if( pC->nHdrParsed<=p2 ){



    if( pC->iHdrOffset<aOffset[0] ){

      if( pC->aRow==0 ){
        memset(&sMem, 0, sizeof(sMem));
        rc = sqlite3VdbeMemFromBtreeZeroOffset(pC->uc.pCursor,aOffset[0],&sMem);
        if( rc!=0 ) goto abort_due_to_error;
        zData = (u8*)sMem.z;
      }else{
        zData = pC->aRow;
      }


    op_column_read_header:
      i = pC->nHdrParsed;
      offset64 = aOffset[i];
      zHdr = zData + pC->iHdrOffset;
      zEndHdr = zData + aOffset[0];
                               ;
      do{
        if( (pC->aType[i] = t = zHdr[0])<0x80 ){
          zHdr++;
          offset64 += sqlite3VdbeOneByteSerialTypeLen(t);
        }else{
          zHdr += sqlite3GetVarint32(zHdr, &t);
          pC->aType[i] = t;
          offset64 += sqlite3VdbeSerialTypeLen(t);
        }
        aOffset[++i] = (u32)(offset64 & 0xffffffff);
      }while( (u32)i<=p2 && zHdr<zEndHdr );






      if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize))
       || (offset64 > pC->payloadSize)
      ){
        if( aOffset[0]==0 ){
          i = 0;
          zHdr = zEndHdr;
        }else{
          if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem);
          goto op_column_corrupt;
        }
      }

      pC->nHdrParsed = i;
      pC->iHdrOffset = (u32)(zHdr - zData);
      if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem);
    }else{
      t = 0;
    }





    if( pC->nHdrParsed<=p2 ){
      pDest = &aMem[pOp->p3];
                                ;
      if( pOp->p4type==(-10) ){
        sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, 0x2000);
      }else{
        sqlite3VdbeMemSetNull(pDest);
      }
      goto op_column_out;
    }
  }else{
    t = pC->aType[p2];
  }





  ((void) (0));
  ((void) (0));
  pDest = &aMem[pOp->p3];
                            ;
  ((void) (0));
  if( (((pDest)->flags&(0x8000|0x1000))!=0) ){
    sqlite3VdbeMemSetNull(pDest);
  }
  ((void) (0));
  if( pC->szRow>=aOffset[p2+1] ){


    zData = pC->aRow + aOffset[p2];
    if( t<12 ){
      sqlite3VdbeSerialGet(zData, t, pDest);
    }else{




      static const u16 aFlag[] = { 0x0010, 0x0002|0x0200 };
      pDest->n = len = (t-12)/2;
      pDest->enc = encoding;
      if( pDest->szMalloc < len+2 ){
        if( len>db->aLimit[0] ) goto too_big;
        pDest->flags = 0x0001;
        if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem;
      }else{
        pDest->z = pDest->zMalloc;
      }
      memcpy(pDest->z, zData, len);
      pDest->z[len] = 0;
      pDest->z[len+1] = 0;
      pDest->flags = aFlag[t&1];
    }
  }else{
    u8 p5;
    pDest->enc = encoding;
    ((void) (0));

    if( ((p5 = (pOp->p5 & 0xc0))!=0
          && (p5==0x80
              || (t>=12 && ((t&1)==0 || p5==0xc0))
             )
        )
     || sqlite3VdbeSerialTypeLen(t)==0
    ){
# 98530 "c_tests/sqlite3.c"
      sqlite3VdbeSerialGet((u8*)sqlite3CtypeMap, t, pDest);
    }else{
      rc = vdbeColumnFromOverflow(pC, p2, t, aOffset[p2],
                p->cacheCtr, colCacheCtr, pDest);
      if( rc ){
        if( rc==7 ) goto no_mem;
        if( rc==18 ) goto too_big;
        goto abort_due_to_error;
      }
    }
  }

op_column_out:
                            ;
                                ;
  break;

op_column_corrupt:
  if( aOp[0].p3>0 ){
    pOp = &aOp[aOp[0].p3-1];
    break;
  }else{
    rc = sqlite3CorruptError(98552);
    goto abort_due_to_error;
  }
}
# 98592 "c_tests/sqlite3.c"
case 96: {
  Table *pTab;
  Column *aCol;
  int i;
  int nCol;

  ((void) (0));
  pTab = pOp->p4.pTab;
  ((void) (0));
  ((void) (0));
  aCol = pTab->aCol;
  pIn1 = &aMem[pOp->p1];
  if( pOp->p3<2 ){
    ((void) (0));
    i = 0;
    nCol = pTab->nCol;
  }else{
    i = pOp->p3-2;
    nCol = i+1;
    ((void) (0));
    ((void) (0));
    ((void) (0));
  }
  for(; i<nCol; i++){
    if( (aCol[i].colFlags & 0x0060)!=0 && pOp->p3<2 ){
      if( (aCol[i].colFlags & 0x0020)!=0 ) continue;
      if( pOp->p3 ){ pIn1++; continue; }
    }
    ((void) (0));
    applyAffinity(pIn1, aCol[i].affinity, encoding);
    if( (pIn1->flags & 0x0001)==0 ){
      switch( aCol[i].eCType ){
        case 2: {
          if( (pIn1->flags & 0x0010)==0 ) goto vdbe_type_error;
          break;
        }
        case 4:
        case 3: {
          if( (pIn1->flags & 0x0004)==0 ) goto vdbe_type_error;
          break;
        }
        case 6: {
          if( (pIn1->flags & 0x0002)==0 ) goto vdbe_type_error;
          break;
        }
        case 5: {
                                                                      ;
          ((void) (0));
          if( pIn1->flags & 0x0004 ){




                                                    ;
                                                    ;
                                                     ;
                                                     ;
            if( pIn1->u.i<=140737488355327LL && pIn1->u.i>=-140737488355328LL){
              pIn1->flags |= 0x0020;
              pIn1->flags &= ~0x0004;
            }else{
              pIn1->u.r = (double)pIn1->u.i;
              pIn1->flags |= 0x0008;
              pIn1->flags &= ~0x0004;
            }
          }else if( (pIn1->flags & (0x0008|0x0020))==0 ){
            goto vdbe_type_error;
          }
          break;
        }
        default: {

          break;
        }
      }
    }
                                          ;
    pIn1++;
  }
  ((void) (0));
  break;

vdbe_type_error:
  sqlite3VdbeError(p, "cannot store %s value in %s column %s.%s",
     vdbeMemTypeName(pIn1), sqlite3StdType[aCol[i].eCType-1],
     pTab->zName, aCol[i].zCnName);
  rc = (19 |(12<<8));
  goto abort_due_to_error;
}
# 98691 "c_tests/sqlite3.c"
case 97: {
  const char *zAffinity;

  zAffinity = pOp->p4.z;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pIn1 = &aMem[pOp->p1];
  while( 1 ){
    ((void) (0));
    ((void) (0));
    applyAffinity(pIn1, zAffinity[0], encoding);
    if( zAffinity[0]==0x45 && (pIn1->flags & 0x0004)!=0 ){




                                              ;
                                              ;
                                               ;
                                               ;
      if( pIn1->u.i<=140737488355327LL && pIn1->u.i>=-140737488355328LL ){
        pIn1->flags |= 0x0020;
        pIn1->flags &= ~0x0004;
      }else{
        pIn1->u.r = (double)pIn1->u.i;
        pIn1->flags |= 0x0008;
        pIn1->flags &= ~(0x0004|0x0002);
      }
    }
                                          ;
    zAffinity++;
    if( zAffinity[0]==0 ) break;
    pIn1++;
  }
  break;
}
# 98756 "c_tests/sqlite3.c"
case 98: {
  Mem *pRec;
  u64 nData;
  int nHdr;
  i64 nByte;
  i64 nZero;
  int nVarint;
  u32 serial_type;
  Mem *pData0;
  Mem *pLast;
  int nField;
  char *zAffinity;
  u32 len;
  u8 *zHdr;
  u8 *zPayload;
# 98787 "c_tests/sqlite3.c"
  nData = 0;
  nHdr = 0;
  nZero = 0;
  nField = pOp->p1;
  zAffinity = pOp->p4.z;
  ((void) (0));
  pData0 = &aMem[nField];
  nField = pOp->p2;
  pLast = &pData0[nField-1];


  ((void) (0));
  pOut = &aMem[pOp->p3];
                           ;



  ((void) (0));
  if( zAffinity ){
    pRec = pData0;
    do{
      applyAffinity(pRec, zAffinity[0], encoding);
      if( zAffinity[0]==0x45 && (pRec->flags & 0x0004) ){
        pRec->flags |= 0x0020;
        pRec->flags &= ~(0x0004);
      }
                                            ;
      zAffinity++;
      pRec++;
      ((void) (0));
    }while( zAffinity[0] );
  }
# 98860 "c_tests/sqlite3.c"
  pRec = pLast;
  do{
    ((void) (0));
    if( pRec->flags & 0x0001 ){
      if( pRec->flags & 0x0400 ){







        ((void) (0));

        pRec->uTemp = 10;
      }else{
        pRec->uTemp = 0;
      }
      nHdr++;
    }else if( pRec->flags & (0x0004|0x0020) ){

      i64 i = pRec->u.i;
      u64 uu;
                                       ;
                                           ;
      if( i<0 ){
        uu = ~i;
      }else{
        uu = i;
      }
      nHdr++;
                         ; ;
                           ; ;
                             ; ;
                                ; ;
                                       ; ;
      if( uu<=127 ){
        if( (i&1)==i && p->minWriteFileFormat>=4 ){
          pRec->uTemp = 8+(u32)uu;
        }else{
          nData++;
          pRec->uTemp = 1;
        }
      }else if( uu<=32767 ){
        nData += 2;
        pRec->uTemp = 2;
      }else if( uu<=8388607 ){
        nData += 3;
        pRec->uTemp = 3;
      }else if( uu<=2147483647 ){
        nData += 4;
        pRec->uTemp = 4;
      }else if( uu<=140737488355327LL ){
        nData += 6;
        pRec->uTemp = 5;
      }else{
        nData += 8;
        if( pRec->flags & 0x0020 ){



          pRec->u.r = (double)pRec->u.i;
          pRec->flags &= ~0x0020;
          pRec->flags |= 0x0008;
          pRec->uTemp = 7;
        }else{
          pRec->uTemp = 6;
        }
      }
    }else if( pRec->flags & 0x0008 ){
      nHdr++;
      nData += 8;
      pRec->uTemp = 7;
    }else{
      ((void) (0));
      ((void) (0));
      len = (u32)pRec->n;
      serial_type = (len*2) + 12 + ((pRec->flags & 0x0002)!=0);
      if( pRec->flags & 0x0400 ){
        serial_type += (u32)pRec->u.nZero*2;
        if( nData ){
          if( sqlite3VdbeMemExpandBlob(pRec) ) goto no_mem;
          len += pRec->u.nZero;
        }else{
          nZero += pRec->u.nZero;
        }
      }
      nData += len;
      nHdr += sqlite3VarintLen(serial_type);
      pRec->uTemp = serial_type;
    }
    if( pRec==pData0 ) break;
    pRec--;
  }while(1);





                       ;
                       ;
  if( nHdr<=126 ){

    nHdr += 1;
  }else{

    nVarint = sqlite3VarintLen(nHdr);
    nHdr += nVarint;
    if( nVarint<sqlite3VarintLen(nHdr) ) nHdr++;
  }
  nByte = nHdr+nData;






  if( nByte+nZero<=pOut->szMalloc ){


    pOut->z = pOut->zMalloc;
  }else{


    if( nByte+nZero>db->aLimit[0] ){
      goto too_big;
    }
    if( sqlite3VdbeMemClearAndResize(pOut, (int)nByte) ){
      goto no_mem;
    }
  }
  pOut->n = (int)nByte;
  pOut->flags = 0x0010;
  if( nZero ){
    pOut->u.nZero = nZero;
    pOut->flags |= 0x0400;
  }
                           ;
  zHdr = (u8 *)pOut->z;
  zPayload = zHdr + nHdr;


  if( nHdr<0x80 ){
    *(zHdr++) = nHdr;
  }else{
    zHdr += sqlite3PutVarint(zHdr,nHdr);
  }
  ((void) (0));
  pRec = pData0;
  while( 1 ){
    serial_type = pRec->uTemp;




    if( serial_type<=7 ){
      *(zHdr++) = serial_type;
      if( serial_type==0 ){

      }else{
        u64 v;
        if( serial_type==7 ){
          ((void) (0));
          memcpy(&v, &pRec->u.r, sizeof(v));
                                 ;
        }else{
          v = pRec->u.i;
        }
        len = sqlite3SmallTypeSizes[serial_type];
        ((void) (0));
        switch( len ){
          default: zPayload[7] = (u8)(v&0xff); v >>= 8;
                   zPayload[6] = (u8)(v&0xff); v >>= 8;
                                  __attribute__((fallthrough));
          case 6: zPayload[5] = (u8)(v&0xff); v >>= 8;
                   zPayload[4] = (u8)(v&0xff); v >>= 8;
                                  __attribute__((fallthrough));
          case 4: zPayload[3] = (u8)(v&0xff); v >>= 8;
                                  __attribute__((fallthrough));
          case 3: zPayload[2] = (u8)(v&0xff); v >>= 8;
                                  __attribute__((fallthrough));
          case 2: zPayload[1] = (u8)(v&0xff); v >>= 8;
                                  __attribute__((fallthrough));
          case 1: zPayload[0] = (u8)(v&0xff);
        }
        zPayload += len;
      }
    }else if( serial_type<0x80 ){
      *(zHdr++) = serial_type;
      if( serial_type>=14 && pRec->n>0 ){
        ((void) (0));
        memcpy(zPayload, pRec->z, pRec->n);
        zPayload += pRec->n;
      }
    }else{
      zHdr += sqlite3PutVarint(zHdr, serial_type);
      if( pRec->n ){
        ((void) (0));
        ((void) (0));
        memcpy(zPayload, pRec->z, pRec->n);
        zPayload += pRec->n;
      }
    }
    if( pRec==pLast ) break;
    pRec++;
  }
  ((void) (0));
  ((void) (0));

  ((void) (0));
                               ;
  break;
}
# 99084 "c_tests/sqlite3.c"
case 99: {
  i64 nEntry;
  BtCursor *pCrsr;

  ((void) (0));
  pCrsr = p->apCsr[pOp->p1]->uc.pCursor;
  ((void) (0));
  if( pOp->p3 ){
    nEntry = sqlite3BtreeRowCountEst(pCrsr);
  }else{
    nEntry = 0;
    rc = sqlite3BtreeCount(db, pCrsr, &nEntry);
    if( rc ) goto abort_due_to_error;
  }
  pOut = out2Prerelease(p, pOp);
  pOut->u.i = nEntry;
  goto check_for_interrupt;
}
# 99110 "c_tests/sqlite3.c"
case 0: {
  int p1;
  char *zName;
  int nName;
  Savepoint *pNew;
  Savepoint *pSavepoint;
  Savepoint *pTmp;
  int iSavepoint;
  int ii;

  p1 = pOp->p1;
  zName = pOp->p4.z;




  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( p1==0 ){
    if( db->nVdbeWrite>0 ){



      sqlite3VdbeError(p, "cannot open savepoint - SQL statements in progress");
      rc = 5;
    }else{
      nName = sqlite3Strlen30(zName);






      ((void) (0));
      rc = sqlite3VtabSavepoint(db, 0,
                                db->nStatement+db->nSavepoint);
      if( rc!=0 ) goto abort_due_to_error;



      pNew = sqlite3DbMallocRawNN(db, sizeof(Savepoint)+nName+1);
      if( pNew ){
        pNew->zName = (char *)&pNew[1];
        memcpy(pNew->zName, zName, nName+1);



        if( db->autoCommit ){
          db->autoCommit = 0;
          db->isTransactionSavepoint = 1;
        }else{
          db->nSavepoint++;
        }


        pNew->pNext = db->pSavepoint;
        db->pSavepoint = pNew;
        pNew->nDeferredCons = db->nDeferredCons;
        pNew->nDeferredImmCons = db->nDeferredImmCons;
      }
    }
  }else{
    ((void) (0));
    iSavepoint = 0;



    for(
      pSavepoint = db->pSavepoint;
      pSavepoint && sqlite3StrICmp(pSavepoint->zName, zName);
      pSavepoint = pSavepoint->pNext
    ){
      iSavepoint++;
    }
    if( !pSavepoint ){
      sqlite3VdbeError(p, "no such savepoint: %s", zName);
      rc = 1;
    }else if( db->nVdbeWrite>0 && p1==1 ){



      sqlite3VdbeError(p, "cannot release savepoint - "
                          "SQL statements in progress");
      rc = 5;
    }else{





      int isTransaction = pSavepoint->pNext==0 && db->isTransactionSavepoint;
      if( isTransaction && p1==1 ){
        if( (rc = sqlite3VdbeCheckFkDeferred(p))!=0 ){
          goto vdbe_return;
        }
        db->autoCommit = 1;
        if( sqlite3VdbeHalt(p)==5 ){
          p->pc = (int)(pOp - aOp);
          db->autoCommit = 0;
          p->rc = rc = 5;
          goto vdbe_return;
        }
        rc = p->rc;
        if( rc ){
          db->autoCommit = 0;
        }else{
          db->isTransactionSavepoint = 0;
        }
      }else{
        int isSchemaChange;
        iSavepoint = db->nSavepoint - iSavepoint - 1;
        if( p1==2 ){
          isSchemaChange = (db->mDbFlags & 0x0001)!=0;
          for(ii=0; ii<db->nDb; ii++){
            rc = sqlite3BtreeTripAllCursors(db->aDb[ii].pBt,
                                       (4 | (2<<8)),
                                       isSchemaChange==0);
            if( rc!=0 ) goto abort_due_to_error;
          }
        }else{
          ((void) (0));
          isSchemaChange = 0;
        }
        for(ii=0; ii<db->nDb; ii++){
          rc = sqlite3BtreeSavepoint(db->aDb[ii].pBt, p1, iSavepoint);
          if( rc!=0 ){
            goto abort_due_to_error;
          }
        }
        if( isSchemaChange ){
          sqlite3ExpirePreparedStatements(db, 0);
          sqlite3ResetAllSchemasOfConnection(db);
          db->mDbFlags |= 0x0001;
        }
      }
      if( rc ) goto abort_due_to_error;



      while( db->pSavepoint!=pSavepoint ){
        pTmp = db->pSavepoint;
        db->pSavepoint = pTmp->pNext;
        sqlite3DbFree(db, pTmp);
        db->nSavepoint--;
      }





      if( p1==1 ){
        ((void) (0));
        db->pSavepoint = pSavepoint->pNext;
        sqlite3DbFree(db, pSavepoint);
        if( !isTransaction ){
          db->nSavepoint--;
        }
      }else{
        ((void) (0));
        db->nDeferredCons = pSavepoint->nDeferredCons;
        db->nDeferredImmCons = pSavepoint->nDeferredImmCons;
      }

      if( !isTransaction || p1==2 ){
        rc = sqlite3VtabSavepoint(db, p1, iSavepoint);
        if( rc!=0 ) goto abort_due_to_error;
      }
    }
  }
  if( rc ) goto abort_due_to_error;
  if( p->eVdbeState==3 ){
    rc = 101;
    goto vdbe_return;
  }
  break;
}
# 99300 "c_tests/sqlite3.c"
case 1: {
  int desiredAutoCommit;
  int iRollback;

  desiredAutoCommit = pOp->p1;
  iRollback = pOp->p2;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( desiredAutoCommit!=db->autoCommit ){
    if( iRollback ){
      ((void) (0));
      sqlite3RollbackAll(db, (4 | (2<<8)));
      db->autoCommit = 1;
    }else if( desiredAutoCommit && db->nVdbeWrite>0 ){



      sqlite3VdbeError(p, "cannot commit transaction - "
                          "SQL statements in progress");
      rc = 5;
      goto abort_due_to_error;
    }else if( (rc = sqlite3VdbeCheckFkDeferred(p))!=0 ){
      goto vdbe_return;
    }else{
      db->autoCommit = (u8)desiredAutoCommit;
    }
    if( sqlite3VdbeHalt(p)==5 ){
      p->pc = (int)(pOp - aOp);
      db->autoCommit = (u8)(1-desiredAutoCommit);
      p->rc = rc = 5;
      goto vdbe_return;
    }
    sqlite3CloseSavepoints(db);
    if( p->rc==0 ){
      rc = 101;
    }else{
      rc = 1;
    }
    goto vdbe_return;
  }else{
    sqlite3VdbeError(p,
        (!desiredAutoCommit)?"cannot start a transaction within a transaction":(
        (iRollback)?"cannot rollback - no transaction is active":
                   "cannot commit - no transaction is active"));

    rc = 1;
    goto abort_due_to_error;
  }
                 ((void) (0));
}
# 99389 "c_tests/sqlite3.c"
case 2: {
  Btree *pBt;
  Db *pDb;
  int iMeta = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pOp->p2 && (db->flags & (0x00100000|((u64)(0x00002)<<32)))!=0 ){
    if( db->flags & 0x00100000 ){

      rc = 8;
    }else{


      rc = 11;
    }
    goto abort_due_to_error;
  }
  pDb = &db->aDb[pOp->p1];
  pBt = pDb->pBt;

  if( pBt ){
    rc = sqlite3BtreeBeginTrans(pBt, pOp->p2, &iMeta);
                                        ;
                                        ;
    if( rc!=0 ){
      if( (rc&0xff)==5 ){
        p->pc = (int)(pOp - aOp);
        p->rc = rc;
        goto vdbe_return;
      }
      goto abort_due_to_error;
    }

    if( p->usesStmtJournal
     && pOp->p2
     && (db->autoCommit==0 || db->nVdbeRead>1)
    ){
      ((void) (0));
      if( p->iStatement==0 ){
        ((void) (0));
        db->nStatement++;
        p->iStatement = db->nSavepoint + db->nStatement;
      }

      rc = sqlite3VtabSavepoint(db, 0, p->iStatement-1);
      if( rc==0 ){
        rc = sqlite3BtreeBeginStmt(pBt, p->iStatement);
      }




      p->nStmtDefCons = db->nDeferredCons;
      p->nStmtDefImmCons = db->nDeferredImmCons;
    }
  }
  ((void) (0));
  if( rc==0
   && pOp->p5
   && (iMeta!=pOp->p3 || pDb->pSchema->iGeneration!=pOp->p4.i)
  ){





    sqlite3DbFree(db, p->zErrMsg);
    p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed");
# 99475 "c_tests/sqlite3.c"
    if( db->aDb[pOp->p1].pSchema->schema_cookie!=iMeta ){
      sqlite3ResetOneSchema(db, pOp->p1);
    }
    p->expired = 1;
    rc = 17;




    p->changeCntOn = 0;
  }
  if( rc ) goto abort_due_to_error;
  break;
}
# 99502 "c_tests/sqlite3.c"
case 100: {
  int iMeta;
  int iDb;
  int iCookie;

  ((void) (0));
  iDb = pOp->p1;
  iCookie = pOp->p3;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  sqlite3BtreeGetMeta(db->aDb[iDb].pBt, iCookie, (u32 *)&iMeta);
  pOut = out2Prerelease(p, pOp);
  pOut->u.i = iMeta;
  break;
}
# 99536 "c_tests/sqlite3.c"
case 101: {
  Db *pDb;

                                   ;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pDb = &db->aDb[pOp->p1];
  ((void) (0));
  ((void) (0));

  rc = sqlite3BtreeUpdateMeta(pDb->pBt, pOp->p2, pOp->p3);
  if( pOp->p2==1 ){

    *(u32*)&pDb->pSchema->schema_cookie = *(u32*)&pOp->p3 - pOp->p5;
    db->mDbFlags |= 0x0001;
    sqlite3FkClearTriggerCache(db, pOp->p1);
  }else if( pOp->p2==2 ){

    pDb->pSchema->file_format = pOp->p3;
  }
  if( pOp->p1==1 ){


    sqlite3ExpirePreparedStatements(db, 0);
    p->expired = 0;
  }
  if( rc ) goto abort_due_to_error;
  break;
}
# 99652 "c_tests/sqlite3.c"
case 102: {
  int nField;
  KeyInfo *pKeyInfo;
  u32 p2;
  int iDb;
  int wrFlag;
  Btree *pX;
  VdbeCursor *pCur;
  Db *pDb;

  ((void) (0));
  ((void) (0));
  pCur = p->apCsr[pOp->p1];
  if( pCur && pCur->pgnoRoot==(u32)pOp->p2 ){
    ((void) (0));
    ((void) (0));
    sqlite3BtreeClearCursor(pCur->uc.pCursor);
    goto open_cursor_set_hints;
  }


case 113:
case 114:

  ((void) (0));
  ((void) (0));
  ((void) (0));


  if( p->expired==1 ){
    rc = (4 | (2<<8));
    goto abort_due_to_error;
  }

  nField = 0;
  pKeyInfo = 0;
  p2 = (u32)pOp->p2;
  iDb = pOp->p3;
  ((void) (0));
  ((void) (0));
  pDb = &db->aDb[iDb];
  pX = pDb->pBt;
  ((void) (0));
  if( pOp->opcode==114 ){
    ((void) (0));
    wrFlag = 0x00000004 | (pOp->p5 & 0x08);
    ((void) (0));
    if( pDb->pSchema->file_format < p->minWriteFileFormat ){
      p->minWriteFileFormat = pDb->pSchema->file_format;
    }
    if( pOp->p5 & 0x10 ){
      ((void) (0));
      ((void) (0));
      pIn2 = &aMem[p2];
      ((void) (0));
      ((void) (0));
      sqlite3VdbeMemIntegerify(pIn2);
      p2 = (int)pIn2->u.i;




      ((void) (0));
    }
  }else{
    wrFlag = 0;
    ((void) (0));
  }
  if( pOp->p4type==(-8) ){
    pKeyInfo = pOp->p4.pKeyInfo;
    ((void) (0));
    ((void) (0));
    nField = pKeyInfo->nAllField;
  }else if( pOp->p4type==(-3) ){
    nField = pOp->p4.i;
  }
  ((void) (0));
  ((void) (0));
                       ;
  pCur = allocateCursor(p, pOp->p1, nField, 0);
  if( pCur==0 ) goto no_mem;
  pCur->iDb = iDb;
  pCur->nullRow = 1;
  pCur->isOrdered = 1;
  pCur->pgnoRoot = p2;



  rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor);
  pCur->pKeyInfo = pKeyInfo;




  pCur->isTable = pOp->p4type!=(-8);

open_cursor_set_hints:
  ((void) (0));
  ((void) (0));
                                      ;
                                     ;
  sqlite3BtreeCursorHintFlags(pCur->uc.pCursor,
                               (pOp->p5 & (0x01|0x02)));
  if( rc ) goto abort_due_to_error;
  break;
}
# 99767 "c_tests/sqlite3.c"
case 116: {
  VdbeCursor *pOrig;
  VdbeCursor *pCx;

  pOrig = p->apCsr[pOp->p2];
  ((void) (0));
  ((void) (0));

  pCx = allocateCursor(p, pOp->p1, pOrig->nField, 0);
  if( pCx==0 ) goto no_mem;
  pCx->nullRow = 1;
  pCx->isEphemeral = 1;
  pCx->pKeyInfo = pOrig->pKeyInfo;
  pCx->isTable = pOrig->isTable;
  pCx->pgnoRoot = pOrig->pgnoRoot;
  pCx->isOrdered = pOrig->isOrdered;
  pCx->ub.pBtx = pOrig->ub.pBtx;
  pCx->noReuse = 1;
  pOrig->noReuse = 1;
  rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 0x00000004,
                          pCx->pKeyInfo, pCx->uc.pCursor);



  ((void) (0));
  break;
}
# 99829 "c_tests/sqlite3.c"
case 117:
case 119: {
  VdbeCursor *pCx;
  KeyInfo *pKeyInfo;

  static const int vfsFlags =
      0x00000002 |
      0x00000004 |
      0x00000010 |
      0x00000008 |
      0x00000400;
  ((void) (0));
  ((void) (0));
  if( pOp->p3>0 ){


    ((void) (0));
    ((void) (0));
    ((void) (0));
    aMem[pOp->p3].n = 0;
    aMem[pOp->p3].z = "";
  }
  pCx = p->apCsr[pOp->p1];
  if( pCx && !pCx->noReuse && (pOp->p2<=pCx->nField) ){



    ((void) (0));
    pCx->seqCount = 0;
    pCx->cacheStatus = 0;
    rc = sqlite3BtreeClearTable(pCx->ub.pBtx, pCx->pgnoRoot, 0);
  }else{
    pCx = allocateCursor(p, pOp->p1, pOp->p2, 0);
    if( pCx==0 ) goto no_mem;
    pCx->isEphemeral = 1;
    rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->ub.pBtx,
                          1 | 4 | pOp->p5,
                          vfsFlags);
    if( rc==0 ){
      rc = sqlite3BtreeBeginTrans(pCx->ub.pBtx, 1, 0);
      if( rc==0 ){





        if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){
          ((void) (0));
          rc = sqlite3BtreeCreateTable(pCx->ub.pBtx, &pCx->pgnoRoot,
              2 | pOp->p5);
          if( rc==0 ){
            ((void) (0));
            ((void) (0));
            ((void) (0));
            rc = sqlite3BtreeCursor(pCx->ub.pBtx, pCx->pgnoRoot, 0x00000004,
                pKeyInfo, pCx->uc.pCursor);
          }
          pCx->isTable = 0;
        }else{
          pCx->pgnoRoot = 1;
          rc = sqlite3BtreeCursor(pCx->ub.pBtx, 1, 0x00000004,
              0, pCx->uc.pCursor);
          pCx->isTable = 1;
        }
      }
      pCx->isOrdered = (pOp->p5!=8);
      ((void) (0));
      if( rc ){
        ((void) (0));
        sqlite3BtreeClose(pCx->ub.pBtx);
        p->apCsr[pOp->p1] = 0;
      }else{
        ((void) (0));
      }
    }
  }
  if( rc ) goto abort_due_to_error;
  pCx->nullRow = 1;
  break;
}
# 99920 "c_tests/sqlite3.c"
case 120: {
  VdbeCursor *pCx;

  ((void) (0));
  ((void) (0));
  pCx = allocateCursor(p, pOp->p1, pOp->p2, 1);
  if( pCx==0 ) goto no_mem;
  pCx->pKeyInfo = pOp->p4.pKeyInfo;
  ((void) (0));
  ((void) (0));
  rc = sqlite3VdbeSorterInit(db, pOp->p3, pCx);
  if( rc ) goto abort_due_to_error;
  break;
}
# 99942 "c_tests/sqlite3.c"
case 121: {
  VdbeCursor *pC;
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  if( (pC->seqCount++)==0 ){
    goto jump_to_p2;
  }
  break;
}
# 99970 "c_tests/sqlite3.c"
case 122: {
  VdbeCursor *pCx;

  ((void) (0));
  ((void) (0));
  pCx = allocateCursor(p, pOp->p1, pOp->p3, 3);
  if( pCx==0 ) goto no_mem;
  pCx->nullRow = 1;
  pCx->seekResult = pOp->p2;
  pCx->isTable = 1;




  pCx->uc.pCursor = sqlite3BtreeFakeValidCursor();
  ((void) (0));
  break;
}






case 123: {
  ((void) (0));
  sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);
  p->apCsr[pOp->p1] = 0;
  break;
}
# 100111 "c_tests/sqlite3.c"
case 21:
case 22:
case 23:
case 24: {
  int res;
  int oc;
  VdbeCursor *pC;
  UnpackedRecord r;
  int nField;
  i64 iKey;
  int eqOnly;

  ((void) (0));
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  oc = pOp->opcode;
  eqOnly = 0;
  pC->nullRow = 0;




  pC->deferredMoveto = 0;
  pC->cacheStatus = 0;
  if( pC->isTable ){
    u16 flags3, newType;

    ((void) (0));





    pIn3 = &aMem[pOp->p3];
    flags3 = pIn3->flags;
    if( (flags3 & (0x0004|0x0008|0x0020|0x0002))==0x0002 ){
      applyNumericAffinity(pIn3, 0);
    }
    iKey = sqlite3VdbeIntValue(pIn3);
    newType = pIn3->flags;
    pIn3->flags = flags3;



    if( (newType & (0x0004|0x0020))==0 ){
      int c;
      if( (newType & 0x0008)==0 ){
        if( (newType & 0x0001) || oc>=23 ){
                              ;
          goto jump_to_p2;
        }else{
          rc = sqlite3BtreeLast(pC->uc.pCursor, &res);
          if( rc!=0 ) goto abort_due_to_error;
          goto seek_not_found;
        }
      }
      c = sqlite3IntFloatCompare(iKey, pIn3->u.r);
# 100183 "c_tests/sqlite3.c"
      if( c>0 ){
        ((void) (0));
        ((void) (0));
        ((void) (0));
        if( (oc & 0x0001)==(24 & 0x0001) ) oc--;
      }



      else if( c<0 ){
        ((void) (0));
        ((void) (0));
        ((void) (0));
        if( (oc & 0x0001)==(21 & 0x0001) ) oc++;
      }
    }
    rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)iKey, 0, &res);
    pC->movetoTarget = iKey;
    if( rc!=0 ){
      goto abort_due_to_error;
    }
  }else{





    if( sqlite3BtreeCursorHasHint(pC->uc.pCursor, 0x00000002) ){
      eqOnly = 1;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
    }

    nField = pOp->p4.i;
    ((void) (0));
    ((void) (0));
    r.pKeyInfo = pC->pKeyInfo;
    r.nField = (u16)nField;
# 100235 "c_tests/sqlite3.c"
    r.default_rc = ((1 & (oc - 21)) ? -1 : +1);
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));

    r.aMem = &aMem[pOp->p3];
# 100251 "c_tests/sqlite3.c"
    r.eqSeen = 0;
    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &res);
    if( rc!=0 ){
      goto abort_due_to_error;
    }
    if( eqOnly && r.eqSeen==0 ){
      ((void) (0));
      goto seek_not_found;
    }
  }



  if( oc>=23 ){ ((void) (0));
    if( res<0 || (res==0 && oc==24) ){
      res = 0;
      rc = sqlite3BtreeNext(pC->uc.pCursor, 0);
      if( rc!=0 ){
        if( rc==101 ){
          rc = 0;
          res = 1;
        }else{
          goto abort_due_to_error;
        }
      }
    }else{
      res = 0;
    }
  }else{
    ((void) (0));
    if( res>0 || (res==0 && oc==21) ){
      res = 0;
      rc = sqlite3BtreePrevious(pC->uc.pCursor, 0);
      if( rc!=0 ){
        if( rc==101 ){
          rc = 0;
          res = 1;
        }else{
          goto abort_due_to_error;
        }
      }
    }else{



      res = sqlite3BtreeEof(pC->uc.pCursor);
    }
  }
seek_not_found:
  ((void) (0));
                           ;
  if( res ){
    goto jump_to_p2;
  }else if( eqOnly ){
    ((void) (0));
    pOp++;
  }
  break;
}
# 100380 "c_tests/sqlite3.c"
case 125: {
  VdbeCursor *pC;
  int res;
  int nStep;
  UnpackedRecord r;

  ((void) (0));




  ((void) (0));
# 100408 "c_tests/sqlite3.c"
  ((void) (0));
  pC = p->apCsr[pOp[1].p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( !sqlite3BtreeCursorIsValidNN(pC->uc.pCursor) ){





    break;
  }
  nStep = pOp->p1;
  ((void) (0));
  r.pKeyInfo = pC->pKeyInfo;
  r.nField = (u16)pOp[1].p4.i;
  r.default_rc = 0;
  r.aMem = &aMem[pOp[1].p3];
# 100436 "c_tests/sqlite3.c"
  res = 0;
  while(1){
    rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);
    if( rc ) goto abort_due_to_error;
    if( res>0 && pOp->p5==0 ){
      seekscan_search_fail:






                          ;
      pOp++;
      goto jump_to_p2;
    }
    if( res>=0 ){






                          ;
      goto jump_to_p2;
      break;
    }
    if( nStep<=0 ){





                          ;
      break;
    }
    nStep--;
    pC->cacheStatus = 0;
    rc = sqlite3BtreeNext(pC->uc.pCursor, 0);
    if( rc ){
      if( rc==101 ){
        rc = 0;
        goto seekscan_search_fail;
      }else{
        goto abort_due_to_error;
      }
    }
  }

  break;
}
# 100503 "c_tests/sqlite3.c"
case 126: {
  VdbeCursor *pC;
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  if( pC->seekHit<pOp->p2 ){





    pC->seekHit = pOp->p2;
  }else if( pC->seekHit>pOp->p3 ){





    pC->seekHit = pOp->p3;
  }
  break;
}







case 25: {
  VdbeCursor *pCur;

  ((void) (0));
  pCur = p->apCsr[pOp->p1];
                                              ;
  if( pCur==0 || pCur->nullRow ){
    goto jump_to_p2_and_check_for_interrupt;
  }
  break;
}
# 100635 "c_tests/sqlite3.c"
case 26: {
  VdbeCursor *pC;
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));





  if( pC->seekHit>=pOp->p4.i ) break;

                 __attribute__((fallthrough));
}
case 27:
case 28:
case 29: {
  int alreadyExists;
  int ii;
  VdbeCursor *pC;
  UnpackedRecord *pIdxKey;
  UnpackedRecord r;





  ((void) (0));
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));



  r.aMem = &aMem[pOp->p3];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  r.nField = (u16)pOp->p4.i;
  if( r.nField>0 ){

    r.pKeyInfo = pC->pKeyInfo;
    r.default_rc = 0;
# 100686 "c_tests/sqlite3.c"
    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &pC->seekResult);
  }else{

    ((void) (0));
    ((void) (0));
    rc = (((r.aMem)->flags&0x0400)?sqlite3VdbeMemExpandBlob(r.aMem):0);
    ((void) (0));
    if( rc ) goto no_mem;
    pIdxKey = sqlite3VdbeAllocUnpackedRecord(pC->pKeyInfo);
    if( pIdxKey==0 ) goto no_mem;
    sqlite3VdbeRecordUnpack(r.aMem->n, r.aMem->z, pIdxKey);
    pIdxKey->default_rc = 0;
    rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, pIdxKey, &pC->seekResult);
    sqlite3DbFreeNN(db, pIdxKey);
  }
  if( rc!=0 ){
    goto abort_due_to_error;
  }
  alreadyExists = (pC->seekResult==0);
  pC->nullRow = 1-alreadyExists;
  pC->deferredMoveto = 0;
  pC->cacheStatus = 0;
  if( pOp->opcode==29 ){
                                       ;
    if( alreadyExists ) goto jump_to_p2;
  }else{
    if( !alreadyExists ){
                          ;
      goto jump_to_p2;
    }
    if( pOp->opcode==27 ){



      for(ii=0; ii<r.nField; ii++){
        if( r.aMem[ii].flags & 0x0001 ){
                              ;
          goto jump_to_p2;
        }
      }
    }
                        ;
    if( pOp->opcode==26 ){
      pC->seekHit = pOp->p4.i;
    }
  }
  break;
}
# 100782 "c_tests/sqlite3.c"
case 30: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  int res;
  u64 iKey;

  pIn3 = &aMem[pOp->p3];
                                   ;
                                       ;
                                    ;
                                                        ;
  if( (pIn3->flags & (0x0004|0x0020))==0 ){





    Mem x = pIn3[0];
    applyAffinity(&x, 0x43, encoding);
    if( (x.flags & 0x0004)==0 ) goto jump_to_p2;
    iKey = x.u.i;
    goto notExistsWithKey;
  }

                 __attribute__((fallthrough));
case 31:
  pIn3 = &aMem[pOp->p3];
  ((void) (0));
  ((void) (0));
  iKey = pIn3->u.i;
notExistsWithKey:
  pC = p->apCsr[pOp->p1];
  ((void) (0));



  ((void) (0));
  ((void) (0));
  pCrsr = pC->uc.pCursor;
  ((void) (0));
  res = 0;
  rc = sqlite3BtreeTableMoveto(pCrsr, iKey, 0, &res);
  ((void) (0));
  pC->movetoTarget = iKey;
  pC->nullRow = 0;
  pC->cacheStatus = 0;
  pC->deferredMoveto = 0;
                           ;
  pC->seekResult = res;
  if( res!=0 ){
    ((void) (0));
    if( pOp->p2==0 ){
      rc = sqlite3CorruptError(100834);
    }else{
      goto jump_to_p2;
    }
  }
  if( rc ) goto abort_due_to_error;
  break;
}
# 100851 "c_tests/sqlite3.c"
case 127: {
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pOut = out2Prerelease(p, pOp);
  pOut->u.i = p->apCsr[pOp->p1]->seqCount++;
  break;
}
# 100876 "c_tests/sqlite3.c"
case 128: {
  i64 v;
  VdbeCursor *pC;
  int res;
  int cnt;

  Mem *pMem;
  VdbeFrame *pFrame;


  v = 0;
  res = 0;
  pOut = out2Prerelease(p, pOp);
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  {
# 100909 "c_tests/sqlite3.c"
    ((void) (0));
# 100921 "c_tests/sqlite3.c"
    if( !pC->useRandomRowid ){
      rc = sqlite3BtreeLast(pC->uc.pCursor, &res);
      if( rc!=0 ){
        goto abort_due_to_error;
      }
      if( res ){
        v = 1;
      }else{
        ((void) (0));
        v = sqlite3BtreeIntegerKey(pC->uc.pCursor);
        if( v>=(i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff ) ){
          pC->useRandomRowid = 1;
        }else{
          v++;
        }
      }
    }


    if( pOp->p3 ){

      ((void) (0));
      if( p->pFrame ){
        for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);

        ((void) (0));
        pMem = &pFrame->aMem[pOp->p3];
      }else{

        ((void) (0));
        pMem = &aMem[pOp->p3];
                                 ;
      }
      ((void) (0));

                                   ;
      sqlite3VdbeMemIntegerify(pMem);
      ((void) (0));
      if( pMem->u.i==(i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff ) || pC->useRandomRowid ){
        rc = 13;
        goto abort_due_to_error;
      }
      if( v<pMem->u.i+1 ){
        v = pMem->u.i + 1;
      }
      pMem->u.i = v;
    }

    if( pC->useRandomRowid ){




      ((void) (0));

      cnt = 0;
      do{
        sqlite3_randomness(sizeof(v), &v);
        v &= ((i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )>>1); v++;
      }while( ((rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)v,
                                                 0, &res))==0)
            && (res==0)
            && (++cnt<100));
      if( rc ) goto abort_due_to_error;
      if( res==0 ){
        rc = 13;
        goto abort_due_to_error;
      }
      ((void) (0));
    }
    pC->deferredMoveto = 0;
    pC->cacheStatus = 0;
  }
  pOut->u.i = v;
  break;
}
# 101035 "c_tests/sqlite3.c"
case 129: {
  Mem *pData;
  Mem *pKey;
  VdbeCursor *pC;
  int seekResult;
  const char *zDb;
  Table *pTab;
  BtreePayload x;

  pData = &aMem[pOp->p2];
  ((void) (0));
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
                                ;
                                    ;

  pKey = &aMem[pOp->p3];
  ((void) (0));
  ((void) (0));
                               ;
  x.nKey = pKey->u.i;

  if( pOp->p4type==(-5) && ((db)->xUpdateCallback) ){
    ((void) (0));
    zDb = db->aDb[pC->iDb].zDbSName;
    pTab = pOp->p4.pTab;
    ((void) (0));
  }else{
    pTab = 0;
    zDb = 0;
  }
# 101087 "c_tests/sqlite3.c"
  ((void) (0));
  if( pOp->p5 & 0x01 ){
    p->nChange++;
    if( pOp->p5 & 0x20 ) db->lastRowid = x.nKey;
  }
  ((void) (0));
  x.pData = pData->z;
  x.nData = pData->n;
  seekResult = ((pOp->p5 & 0x10) ? pC->seekResult : 0);
  if( pData->flags & 0x0400 ){
    x.nZero = pData->u.nZero;
  }else{
    x.nZero = 0;
  }
  x.pKey = 0;
  ((void) (0));
  rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
      (pOp->p5 & (0x08|0x02|0x80)),
      seekResult
  );
  pC->deferredMoveto = 0;
  pC->cacheStatus = 0;
  colCacheCtr++;


  if( rc ) goto abort_due_to_error;
  if( pTab ){
    ((void) (0));
    ((void) (0));
    db->xUpdateCallback(db->pUpdateArg,
           (pOp->p5 & 0x04) ? 23 : 18,
           zDb, pTab->zName, x.nKey);
  }
  break;
}
# 101134 "c_tests/sqlite3.c"
case 130: {
  VdbeCursor *pDest;
  VdbeCursor *pSrc;
  i64 iKey;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pDest = p->apCsr[pOp->p1];
  pSrc = p->apCsr[pOp->p2];
  iKey = pOp->p3 ? aMem[pOp->p3].u.i : 0;
  rc = sqlite3BtreeTransferRow(pDest->uc.pCursor, pSrc->uc.pCursor, iKey);
  if( rc!=0 ) goto abort_due_to_error;
  break;
};
# 101190 "c_tests/sqlite3.c"
case 131: {
  VdbeCursor *pC;
  const char *zDb;
  Table *pTab;
  int opflags;

  opflags = pOp->p2;
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
                                    ;
# 101224 "c_tests/sqlite3.c"
  if( pOp->p4type==(-5) && ((db)->xUpdateCallback) ){
    ((void) (0));
    ((void) (0));
    zDb = db->aDb[pC->iDb].zDbSName;
    pTab = pOp->p4.pTab;
    if( (pOp->p5 & 0x02)!=0 && pC->isTable ){
      pC->movetoTarget = sqlite3BtreeIntegerKey(pC->uc.pCursor);
    }
  }else{
    zDb = 0;
    pTab = 0;
  }
# 101255 "c_tests/sqlite3.c"
  ((void) (0));
  ((void) (0));
  ((void) (0));
# 101273 "c_tests/sqlite3.c"
  rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);
  pC->cacheStatus = 0;
  colCacheCtr++;
  pC->seekResult = 0;
  if( rc ) goto abort_due_to_error;


  if( opflags & 0x01 ){
    p->nChange++;
    if( db->xUpdateCallback && (pTab!=0) && (((pTab)->tabFlags & 0x00000080)==0) ){
      db->xUpdateCallback(db->pUpdateArg, 9, zDb, pTab->zName,
          pC->movetoTarget);
      ((void) (0));
    }
  }

  break;
}







case 132: {
  sqlite3VdbeSetChanges(db, p->nChange);
  p->nChange = 0;
  break;
}
# 101319 "c_tests/sqlite3.c"
case 133: {
  VdbeCursor *pC;
  int res;
  int nKeyCol;

  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  pIn3 = &aMem[pOp->p3];
  nKeyCol = pOp->p4.i;
  res = 0;
  rc = sqlite3VdbeSorterCompare(pC, pIn3, nKeyCol, &res);
                           ;
  if( rc ) goto abort_due_to_error;
  if( res ) goto jump_to_p2;
  break;
};
# 101349 "c_tests/sqlite3.c"
case 134: {
  VdbeCursor *pC;

  pOut = &aMem[pOp->p2];
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  rc = sqlite3VdbeSorterRowkey(pC, pOut);
  ((void) (0));
  ((void) (0));
  if( rc ) goto abort_due_to_error;
  p->apCsr[pOp->p3]->cacheStatus = 0;
  break;
}
# 101391 "c_tests/sqlite3.c"
case 135: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  u32 n;

  pOut = out2Prerelease(p, pOp);

  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pCrsr = pC->uc.pCursor;
# 101415 "c_tests/sqlite3.c"
  ((void) (0));
  ((void) (0));

  n = sqlite3BtreePayloadSize(pCrsr);
  if( n>(u32)db->aLimit[0] ){
    goto too_big;
  }
                  ;
  rc = sqlite3VdbeMemFromBtreeZeroOffset(pCrsr, n, pOut);
  if( rc ) goto abort_due_to_error;
  if( !pOp->p3 ) if( ((pOut)->flags&0x4000)!=0 && sqlite3VdbeMemMakeWriteable(pOut) ){ goto no_mem;};
                           ;
                               ;
  break;
}
# 101441 "c_tests/sqlite3.c"
case 136: {
  VdbeCursor *pC;
  i64 v;
  sqlite3_vtab *pVtab;
  const sqlite3_module *pModule;

  pOut = out2Prerelease(p, pOp);
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  if( pC->nullRow ){
    pOut->flags = 0x0001;
    break;
  }else if( pC->deferredMoveto ){
    v = pC->movetoTarget;

  }else if( pC->eCurType==2 ){
    ((void) (0));
    pVtab = pC->uc.pVCur->pVtab;
    pModule = pVtab->pModule;
    ((void) (0));
    rc = pModule->xRowid(pC->uc.pVCur, &v);
    sqlite3VtabImportErrmsg(p, pVtab);
    if( rc ) goto abort_due_to_error;

  }else{
    ((void) (0));
    ((void) (0));
    rc = sqlite3VdbeCursorRestore(pC);
    if( rc ) goto abort_due_to_error;
    if( pC->nullRow ){
      pOut->flags = 0x0001;
      break;
    }
    v = sqlite3BtreeIntegerKey(pC->uc.pCursor);
  }
  pOut->u.i = v;
  break;
}
# 101491 "c_tests/sqlite3.c"
case 137: {
  VdbeCursor *pC;

  ((void) (0));
  pC = p->apCsr[pOp->p1];
  if( pC==0 ){


    pC = allocateCursor(p, pOp->p1, 1, 3);
    if( pC==0 ) goto no_mem;
    pC->seekResult = 0;
    pC->isTable = 1;
    pC->noReuse = 1;
    pC->uc.pCursor = sqlite3BtreeFakeValidCursor();
  }
  pC->nullRow = 1;
  pC->cacheStatus = 0;
  if( pC->eCurType==0 ){
    ((void) (0));
    sqlite3BtreeClearCursor(pC->uc.pCursor);
  }



  break;
}
# 101540 "c_tests/sqlite3.c"
case 138:
case 32: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  int res;

  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  pCrsr = pC->uc.pCursor;
  res = 0;
  ((void) (0));



  if( pOp->opcode==138 ){
    ((void) (0));
    pC->seekResult = -1;
    if( sqlite3BtreeCursorIsValidNN(pCrsr) ){
      break;
    }
  }
  rc = sqlite3BtreeLast(pCrsr, &res);
  pC->nullRow = (u8)res;
  pC->deferredMoveto = 0;
  pC->cacheStatus = 0;
  if( rc ) goto abort_due_to_error;
  if( pOp->p2>0 ){
                             ;
    if( res ) goto jump_to_p2;
  }
  break;
}
# 101583 "c_tests/sqlite3.c"
case 33: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  int res;
  i64 sz;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  pCrsr = pC->uc.pCursor;
  ((void) (0));
  rc = sqlite3BtreeFirst(pCrsr, &res);
  if( rc ) goto abort_due_to_error;
  if( res!=0 ){
    sz = -1;
  }else{
    sz = sqlite3BtreeRowCountEst(pCrsr);
    ((void) (0));
    sz = sqlite3LogEst((u64)sz);
  }
  res = sz>=pOp->p3 && sz<=pOp->p4.i;
                           ;
  if( res ) goto jump_to_p2;
  break;
}
# 101634 "c_tests/sqlite3.c"
case 34:
case 35: {




  p->aCounter[2]++;

                 __attribute__((fallthrough));
}
# 101659 "c_tests/sqlite3.c"
case 36: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  int res;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  res = 1;



  if( ((pC)->eCurType==1) ){
    rc = sqlite3VdbeSorterRewind(pC, &res);
  }else{
    ((void) (0));
    pCrsr = pC->uc.pCursor;
    ((void) (0));
    rc = sqlite3BtreeFirst(pCrsr, &res);
    pC->deferredMoveto = 0;
    pC->cacheStatus = 0;
  }
  if( rc ) goto abort_due_to_error;
  pC->nullRow = (u8)res;
  if( pOp->p2>0 ){
                             ;
    if( res ) goto jump_to_p2;
  }
  break;
}







case 37: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  int res;

  ((void) (0));
  ((void) (0));

  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  pCrsr = pC->uc.pCursor;
  ((void) (0));
  rc = sqlite3BtreeIsEmpty(pCrsr, &res);
  if( rc ) goto abort_due_to_error;
                           ;
  if( res ) goto jump_to_p2;
  break;
}
# 101774 "c_tests/sqlite3.c"
case 38: {
  VdbeCursor *pC;

  pC = p->apCsr[pOp->p1];
  ((void) (0));
  rc = sqlite3VdbeSorterNext(db, pC);
  goto next_tail;

case 39:
  ((void) (0));
  ((void) (0));


  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  rc = sqlite3BtreePrevious(pC->uc.pCursor, pOp->p3);
  goto next_tail;

case 40:
  ((void) (0));
  ((void) (0));


  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));



  rc = sqlite3BtreeNext(pC->uc.pCursor, pOp->p3);

next_tail:
  pC->cacheStatus = 0;
                                  ;
  if( rc==0 ){
    pC->nullRow = 0;
    p->aCounter[pOp->p5]++;



    goto jump_to_p2_and_check_for_interrupt;
  }
  if( rc!=101 ) goto abort_due_to_error;
  rc = 0;
  pC->nullRow = 1;
  goto check_for_interrupt;
}
# 101857 "c_tests/sqlite3.c"
case 139: {
  VdbeCursor *pC;
  BtreePayload x;

  ((void) (0));
  pC = p->apCsr[pOp->p1];
                                    ;
  ((void) (0));
  ((void) (0));
  pIn2 = &aMem[pOp->p2];
  ((void) (0));
  if( pOp->p5 & 0x01 ) p->nChange++;
  ((void) (0));
  ((void) (0));
  rc = (((pIn2)->flags&0x0400)?sqlite3VdbeMemExpandBlob(pIn2):0);
  if( rc ) goto abort_due_to_error;
  x.nKey = pIn2->n;
  x.pKey = pIn2->z;
  x.aMem = aMem + pOp->p3;
  x.nMem = (u16)pOp->p4.i;
  rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
       (pOp->p5 & (0x08|0x02|0x80)),
      ((pOp->p5 & 0x10) ? pC->seekResult : 0)
      );
  ((void) (0));
  pC->cacheStatus = 0;
  if( rc) goto abort_due_to_error;
  break;
}
# 101894 "c_tests/sqlite3.c"
case 140: {
  VdbeCursor *pC;

  ((void) (0));
  pC = p->apCsr[pOp->p1];
                                    ;
  ((void) (0));
  ((void) (0));
  pIn2 = &aMem[pOp->p2];
  ((void) (0));
  ((void) (0));
  rc = (((pIn2)->flags&0x0400)?sqlite3VdbeMemExpandBlob(pIn2):0);
  if( rc ) goto abort_due_to_error;
  rc = sqlite3VdbeSorterWrite(pC, pIn2);
  if( rc) goto abort_due_to_error;
  break;
}
# 101927 "c_tests/sqlite3.c"
case 141: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  int res;
  UnpackedRecord r;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
                                    ;
  pCrsr = pC->uc.pCursor;
  ((void) (0));
  r.pKeyInfo = pC->pKeyInfo;
  r.nField = (u16)pOp->p3;
  r.default_rc = 0;
  r.aMem = &aMem[pOp->p2];
  rc = sqlite3BtreeIndexMoveto(pCrsr, &r, &res);
  if( rc ) goto abort_due_to_error;
  if( res==0 ){
    rc = sqlite3BtreeDelete(pCrsr, 0x04);
    if( rc ) goto abort_due_to_error;
  }else if( pOp->p5 && !sqlite3WritableSchema(db) ){
    rc = sqlite3ReportError((11 | (3<<8)), 101952, "index corruption");
    goto abort_due_to_error;
  }
  ((void) (0));
  pC->cacheStatus = 0;
  pC->seekResult = 0;
  break;
}
# 101989 "c_tests/sqlite3.c"
case 142:
case 143: {
  VdbeCursor *pC;
  VdbeCursor *pTabCur;
  i64 rowid;

  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));



  rc = sqlite3VdbeCursorRestore(pC);




  if( rc!=0 ) goto abort_due_to_error;

  if( !pC->nullRow ){
    rowid = 0;
    rc = sqlite3VdbeIdxRowid(db, pC->uc.pCursor, &rowid);
    if( rc!=0 ){
      goto abort_due_to_error;
    }
    if( pOp->opcode==142 ){
      ((void) (0));
      pTabCur = p->apCsr[pOp->p3];
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      pTabCur->nullRow = 0;
      pTabCur->movetoTarget = rowid;
      pTabCur->deferredMoveto = 1;
      pTabCur->cacheStatus = 0;
      ((void) (0));
      ((void) (0));
      pTabCur->ub.aAltMap = pOp->p4.ai;
      ((void) (0));
      pTabCur->pAltCursor = pC;
    }else{
      pOut = out2Prerelease(p, pOp);
      pOut->u.i = rowid;
    }
  }else{
    ((void) (0));
    sqlite3VdbeMemSetNull(&aMem[pOp->p2]);
  }
  break;
}







case 144: {
  VdbeCursor *pC;

  ((void) (0));
  pC = p->apCsr[pOp->p1];
  if( pC->deferredMoveto ){
    rc = sqlite3VdbeFinishMoveto(pC);
    if( rc ) goto abort_due_to_error;
  }
  break;
}
# 102108 "c_tests/sqlite3.c"
case 41:
case 42:
case 45:
case 46: {
  VdbeCursor *pC;
  int res;
  UnpackedRecord r;

  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  r.pKeyInfo = pC->pKeyInfo;
  r.nField = (u16)pOp->p4.i;
  if( pOp->opcode<45 ){
    ((void) (0));
    r.default_rc = -1;
  }else{
    ((void) (0));
    r.default_rc = 0;
  }
  r.aMem = &aMem[pOp->p3];
# 102145 "c_tests/sqlite3.c"
  {
    i64 nCellKey = 0;
    BtCursor *pCur;
    Mem m;

    ((void) (0));
    pCur = pC->uc.pCursor;
    ((void) (0));
    nCellKey = sqlite3BtreePayloadSize(pCur);


    if( nCellKey<=0 || nCellKey>0x7fffffff ){
      rc = sqlite3CorruptError(102157);
      goto abort_due_to_error;
    }
    sqlite3VdbeMemInit(&m, db, 0);
    rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);
    if( rc ) goto abort_due_to_error;
    res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, &r, 0);
    sqlite3VdbeMemReleaseMalloc(&m);
  }


  ((void) (0));
  if( (pOp->opcode&1)==(45&1) ){
    ((void) (0));
    res = -res;
  }else{
    ((void) (0));
    res++;
  }
                          ;
  ((void) (0));
  if( res>0 ) goto jump_to_p2;
  break;
}
# 102209 "c_tests/sqlite3.c"
case 145: {
  int iMoved;
  int iDb;

                                   ;
  ((void) (0));
  ((void) (0));
  pOut = out2Prerelease(p, pOp);
  pOut->flags = 0x0001;
  if( db->nVdbeRead > db->nVDestroy+1 ){
    rc = 6;
    p->errorAction = 2;
    goto abort_due_to_error;
  }else{
    iDb = pOp->p3;
    ((void) (0));
    iMoved = 0;
    rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);
    pOut->flags = 0x0004;
    pOut->u.i = iMoved;
    if( rc ) goto abort_due_to_error;

    if( iMoved!=0 ){
      sqlite3RootPageMoved(db, iDb, iMoved, pOp->p1);

      ((void) (0));
      resetSchemaOnFault = iDb+1;
    }

  }
  break;
}
# 102259 "c_tests/sqlite3.c"
case 146: {
  i64 nChange;

                                   ;
  nChange = 0;
  ((void) (0));
  ((void) (0));
  rc = sqlite3BtreeClearTable(db->aDb[pOp->p2].pBt, (u32)pOp->p1, &nChange);
  if( pOp->p3 ){
    p->nChange += nChange;
    if( pOp->p3>0 ){
      ((void) (0));
                                         ;
      aMem[pOp->p3].u.i += nChange;
    }
  }
  if( rc ) goto abort_due_to_error;
  break;
}
# 102287 "c_tests/sqlite3.c"
case 147: {
  VdbeCursor *pC;

  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  if( ((pC)->eCurType==1) ){
    sqlite3VdbeSorterReset(db, pC->uc.pSorter);
  }else{
    ((void) (0));
    ((void) (0));
    rc = sqlite3BtreeClearTableOfCursor(pC->uc.pCursor);
    if( rc ) goto abort_due_to_error;
  }
  break;
}
# 102313 "c_tests/sqlite3.c"
case 148: {
  Pgno pgno;
  Db *pDb;

                                   ;
  pOut = out2Prerelease(p, pOp);
  pgno = 0;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pDb = &db->aDb[pOp->p1];
  ((void) (0));
  rc = sqlite3BtreeCreateTable(pDb->pBt, &pgno, pOp->p3);
  if( rc ) goto abort_due_to_error;
  pOut->u.i = pgno;
  break;
}
# 102345 "c_tests/sqlite3.c"
case 149: {
  char *zErr;

  sqlite3_xauth xAuth;

  u8 mTrace;
  int savedAnalysisLimit;

                                   ;
  db->nSqlExec++;
  zErr = 0;

  xAuth = db->xAuth;

  mTrace = db->mTrace;
  savedAnalysisLimit = db->nAnalysisLimit;
  if( pOp->p1 & 0x0001 ){

    db->xAuth = 0;

    db->mTrace = 0;
  }
  if( pOp->p1 & 0x0002 ){
    db->nAnalysisLimit = pOp->p2;
  }
  rc = sqlite3_exec(db, pOp->p4.z, 0, 0, &zErr);
  db->nSqlExec--;

  db->xAuth = xAuth;

  db->mTrace = mTrace;
  db->nAnalysisLimit = savedAnalysisLimit;
  if( zErr || rc ){
    sqlite3VdbeError(p, "%s", zErr);
    sqlite3_free(zErr);
    if( rc==7 ) goto no_mem;
    goto abort_due_to_error;
  }
  break;
}
# 102395 "c_tests/sqlite3.c"
case 150: {
  int iDb;
  const char *zSchema;
  char *zSql;
  InitData initData;
# 102411 "c_tests/sqlite3.c"
  iDb = pOp->p1;
  ((void) (0));
  ((void) (0));




  if( pOp->p4.z==0 ){
    sqlite3SchemaClear(db->aDb[iDb].pSchema);
    db->mDbFlags &= ~0x0010;
    rc = sqlite3InitOne(db, iDb, &p->zErrMsg, pOp->p5);
    db->mDbFlags |= 0x0001;
    p->expired = 0;
  }else

  {
    zSchema = "sqlite_master";
    initData.db = db;
    initData.iDb = iDb;
    initData.pzErrMsg = &p->zErrMsg;
    initData.mInitFlags = 0;
    initData.mxPage = sqlite3BtreeLastPage(db->aDb[iDb].pBt);
    zSql = sqlite3MPrintf(db,
       "SELECT*FROM\"%w\".%s WHERE %s ORDER BY rowid",
       db->aDb[iDb].zDbSName, zSchema, pOp->p4.z);
    if( zSql==0 ){
      rc = 7;
    }else{
      ((void) (0));
      db->init.busy = 1;
      initData.rc = 0;
      initData.nInitRow = 0;
      ((void) (0));
      rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);
      if( rc==0 ) rc = initData.rc;
      if( rc==0 && initData.nInitRow==0 ){



        rc = sqlite3CorruptError(102450);
      }
      sqlite3DbFreeNN(db, zSql);
      db->init.busy = 0;
    }
  }
  if( rc ){
    sqlite3ResetAllSchemasOfConnection(db);
    if( rc==7 ){
      goto no_mem;
    }
    goto abort_due_to_error;
  }
  break;
}
# 102473 "c_tests/sqlite3.c"
case 151: {
  ((void) (0));
  rc = sqlite3AnalysisLoad(db, pOp->p1);
  if( rc ) goto abort_due_to_error;
  break;
}
# 102489 "c_tests/sqlite3.c"
case 152: {
                                   ;
  sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);
  break;
}
# 102503 "c_tests/sqlite3.c"
case 153: {
                                   ;
  sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);
  break;
}
# 102517 "c_tests/sqlite3.c"
case 155: {
                                   ;
  sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);
  break;
}
# 102544 "c_tests/sqlite3.c"
case 156: {
  int nRoot;
  Pgno *aRoot;
  int nErr;
  char *z;
  Mem *pnErr;

  ((void) (0));
  ((void) (0));
  nRoot = pOp->p2;
  aRoot = pOp->p4.ai;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pnErr = &aMem[pOp->p1];
  ((void) (0));
  ((void) (0));
  pIn1 = &aMem[pOp->p1+1];
  ((void) (0));
  ((void) (0));
  rc = sqlite3BtreeIntegrityCheck(db, db->aDb[pOp->p5].pBt, &aRoot[1],
      &aMem[pOp->p3], nRoot, (int)pnErr->u.i+1, &nErr, &z);
  sqlite3VdbeMemSetNull(pIn1);
  if( nErr==0 ){
    ((void) (0));
  }else if( rc ){
    sqlite3_free(z);
    goto abort_due_to_error;
  }else{
    pnErr->u.i -= nErr-1;
    sqlite3VdbeMemSetStr(pIn1, z, -1, 1, sqlite3_free);
  }
                           ;
  sqlite3VdbeChangeEncoding(pIn1, encoding);
  goto check_for_interrupt;
}
# 102591 "c_tests/sqlite3.c"
case 157: {
  pIn1 = &aMem[pOp->p1];
  pIn2 = &aMem[pOp->p2];
  ((void) (0));
  if( (pIn1->flags & 0x0010)==0 ){
    if( sqlite3VdbeMemSetRowSet(pIn1) ) goto no_mem;
  }
  ((void) (0));
  sqlite3RowSetInsert((RowSet*)pIn1->z, pIn2->u.i);
  break;
}
# 102611 "c_tests/sqlite3.c"
case 47: {
  i64 val;

  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  if( (pIn1->flags & 0x0010)==0
   || sqlite3RowSetNext((RowSet*)pIn1->z, &val)==0
  ){

    sqlite3VdbeMemSetNull(pIn1);
                        ;
    goto jump_to_p2_and_check_for_interrupt;
  }else{

                        ;
    sqlite3VdbeMemSetInt64(&aMem[pOp->p3], val);
  }
  goto check_for_interrupt;
}
# 102654 "c_tests/sqlite3.c"
case 48: {
  int iSet;
  int exists;

  pIn1 = &aMem[pOp->p1];
  pIn3 = &aMem[pOp->p3];
  iSet = pOp->p4.i;
  ((void) (0));




  if( (pIn1->flags & 0x0010)==0 ){
    if( sqlite3VdbeMemSetRowSet(pIn1) ) goto no_mem;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( iSet ){
    exists = sqlite3RowSetTest((RowSet*)pIn1->z, iSet, pIn3->u.i);
                                ;
    if( exists ) goto jump_to_p2;
  }
  if( iSet>=0 ){
    sqlite3RowSetInsert((RowSet*)pIn1->z, pIn3->u.i);
  }
  break;
}
# 102703 "c_tests/sqlite3.c"
case 49: {
  int nMem;
  i64 nByte;
  Mem *pRt;
  Mem *pMem;
  Mem *pEnd;
  VdbeFrame *pFrame;
  SubProgram *pProgram;
  void *t;

  pProgram = pOp->p4.pProgram;
  pRt = &aMem[pOp->p3];
  ((void) (0));
# 102728 "c_tests/sqlite3.c"
  if( pOp->p5 ){
    t = pProgram->token;
    for(pFrame=p->pFrame; pFrame && pFrame->token!=t; pFrame=pFrame->pParent);
    if( pFrame ) break;
  }

  if( p->nFrame>=db->aLimit[10] ){
    rc = 1;
    sqlite3VdbeError(p, "too many levels of trigger recursion");
    goto abort_due_to_error;
  }





  if( (pRt->flags&0x0010)==0 ){





    nMem = pProgram->nMem + pProgram->nCsr;
    ((void) (0));
    if( pProgram->nCsr==0 ) nMem++;
    nByte = (((sizeof(VdbeFrame))+7)&~7)
              + nMem * sizeof(Mem)
              + pProgram->nCsr * sizeof(VdbeCursor*)
              + (7 + (i64)pProgram->nOp)/8;
    pFrame = sqlite3DbMallocZero(db, nByte);
    if( !pFrame ){
      goto no_mem;
    }
    sqlite3VdbeMemRelease(pRt);
    pRt->flags = 0x0010|0x1000;
    pRt->z = (char*)pFrame;
    pRt->n = (int)nByte;
    pRt->xDel = sqlite3VdbeFrameMemDel;

    pFrame->v = p;
    pFrame->nChildMem = nMem;
    pFrame->nChildCsr = pProgram->nCsr;
    pFrame->pc = (int)(pOp - aOp);
    pFrame->aMem = p->aMem;
    pFrame->nMem = p->nMem;
    pFrame->apCsr = p->apCsr;
    pFrame->nCursor = p->nCursor;
    pFrame->aOp = p->aOp;
    pFrame->nOp = p->nOp;
    pFrame->token = pProgram->token;




    pEnd = &((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame))+7)&~7)])[pFrame->nChildMem];
    for(pMem=((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame))+7)&~7)]); pMem!=pEnd; pMem++){
      pMem->flags = 0x0000;
      pMem->db = db;
    }
  }else{
    pFrame = (VdbeFrame*)pRt->z;
    ((void) (0));
    ((void) (0));

    ((void) (0));
    ((void) (0));
  }

  p->nFrame++;
  pFrame->pParent = p->pFrame;
  pFrame->lastRowid = db->lastRowid;
  pFrame->nChange = p->nChange;
  pFrame->nDbChange = p->db->nChange;
  ((void) (0));
  pFrame->pAuxData = p->pAuxData;
  p->pAuxData = 0;
  p->nChange = 0;
  p->pFrame = pFrame;
  p->aMem = aMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame))+7)&~7)]);
  p->nMem = pFrame->nChildMem;
  p->nCursor = (u16)pFrame->nChildCsr;
  p->apCsr = (VdbeCursor **)&aMem[p->nMem];
  pFrame->aOnce = (u8*)&p->apCsr[pProgram->nCsr];
  memset(pFrame->aOnce, 0, (pProgram->nOp + 7)/8);
  p->aOp = aOp = pProgram->aOp;
  p->nOp = pProgram->nOp;
# 102825 "c_tests/sqlite3.c"
  pOp = &aOp[-1];
  goto check_for_interrupt;
}
# 102841 "c_tests/sqlite3.c"
case 158: {
  VdbeFrame *pFrame;
  Mem *pIn;
  pOut = out2Prerelease(p, pOp);
  pFrame = p->pFrame;
  pIn = &pFrame->aMem[pOp->p1 + pFrame->aOp[pFrame->pc].p1];
  sqlite3VdbeMemShallowCopy(pOut, pIn, 0x4000);
  break;
}
# 102862 "c_tests/sqlite3.c"
case 159: {
  if( pOp->p1 ){
    db->nDeferredCons += pOp->p2;
  }else{
    if( db->flags & 0x00080000 ){
      db->nDeferredImmCons += pOp->p2;
    }else{
      p->nFkConstraint += pOp->p2;
    }
  }
  break;
}
# 102887 "c_tests/sqlite3.c"
case 50: {
  if( pOp->p1 ){
                                                                       ;
    if( db->nDeferredCons==0 && db->nDeferredImmCons==0 ) goto jump_to_p2;
  }else{
                                                                      ;
    if( p->nFkConstraint==0 && db->nDeferredImmCons==0 ) goto jump_to_p2;
  }
  break;
}
# 102911 "c_tests/sqlite3.c"
case 160: {
  VdbeFrame *pFrame;
  if( p->pFrame ){
    for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);
    pIn1 = &pFrame->aMem[pOp->p1];
  }else{
    pIn1 = &aMem[pOp->p1];
  }
  ((void) (0));
  sqlite3VdbeMemIntegerify(pIn1);
  pIn2 = &aMem[pOp->p2];
  sqlite3VdbeMemIntegerify(pIn2);
  if( pIn1->u.i<pIn2->u.i){
    pIn1->u.i = pIn2->u.i;
  }
  break;
}
# 102940 "c_tests/sqlite3.c"
case 60: {
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
                                  ;
  if( pIn1->u.i>0 ){
    pIn1->u.i -= pOp->p3;
    goto jump_to_p2;
  }
  break;
}
# 102969 "c_tests/sqlite3.c"
case 161: {
  i64 x;
  pIn1 = &aMem[pOp->p1];
  pIn3 = &aMem[pOp->p3];
  pOut = out2Prerelease(p, pOp);
  ((void) (0));
  ((void) (0));
  x = pIn1->u.i;
  if( x<=0 || sqlite3AddInt64(&x, pIn3->u.i>0?pIn3->u.i:0) ){







    pOut->u.i = -1;
  }else{
    pOut->u.i = x;
  }
  break;
}
# 103000 "c_tests/sqlite3.c"
case 61: {
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
                                 ;
  if( pIn1->u.i ){
     if( pIn1->u.i>0 ) pIn1->u.i--;
     goto jump_to_p2;
  }
  break;
}







case 62: {
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  if( pIn1->u.i>(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ) pIn1->u.i--;
                                  ;
  if( pIn1->u.i==0 ) goto jump_to_p2;
  break;
}
# 103066 "c_tests/sqlite3.c"
case 162:
case 163: {
  int n;
  sqlite3_context *pCtx;
  u64 nAlloc;

  ((void) (0));
  n = pOp->p5;
  ((void) (0));
  ((void) (0));
  ((void) (0));
# 103085 "c_tests/sqlite3.c"
  nAlloc = ((__builtin_offsetof(sqlite3_context, argv)+(n)*sizeof(sqlite3_value*)));
  pCtx = sqlite3DbMallocRawNN(db, nAlloc + sizeof(Mem));
  if( pCtx==0 ) goto no_mem;
  pCtx->pOut = (Mem*)((u8*)pCtx + nAlloc);
  ((void) (0));

  sqlite3VdbeMemInit(pCtx->pOut, db, 0x0001);
  pCtx->pMem = 0;
  pCtx->pFunc = pOp->p4.pFunc;
  pCtx->iOp = (int)(pOp - aOp);
  pCtx->pVdbe = p;
  pCtx->skipFlag = 0;
  pCtx->isError = 0;
  pCtx->enc = encoding;
  pCtx->argc = n;
  pOp->p4type = (-15);
  pOp->p4.pCtx = pCtx;


  ((void) (0));

  pOp->opcode = 164;

                 __attribute__((fallthrough));
}
case 164: {
  int i;
  sqlite3_context *pCtx;
  Mem *pMem;

  ((void) (0));
  pCtx = pOp->p4.pCtx;
  pMem = &aMem[pOp->p3];
# 103134 "c_tests/sqlite3.c"
  if( pCtx->pMem != pMem ){
    pCtx->pMem = pMem;
    for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[pOp->p2+i];
  }
# 103146 "c_tests/sqlite3.c"
  pMem->n++;
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pOp->p1 ){
    (pCtx->pFunc->xInverse)(pCtx,pCtx->argc,pCtx->argv);
  }else

  (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv);

  if( pCtx->isError ){
    if( pCtx->isError>0 ){
      sqlite3VdbeError(p, "%s", sqlite3_value_text(pCtx->pOut));
      rc = pCtx->isError;
    }
    if( pCtx->skipFlag ){
      ((void) (0));
      i = pOp[-1].p1;
      if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1);
      pCtx->skipFlag = 0;
    }
    sqlite3VdbeMemRelease(pCtx->pOut);
    pCtx->pOut->flags = 0x0001;
    pCtx->isError = 0;
    if( rc ) goto abort_due_to_error;
  }
  ((void) (0));
  ((void) (0));
  break;
}
# 103204 "c_tests/sqlite3.c"
case 165:
case 166: {
  Mem *pMem;
  ((void) (0));
  ((void) (0));
  pMem = &aMem[pOp->p1];
  ((void) (0));

  if( pOp->p3 ){
                                       ;
    rc = sqlite3VdbeMemAggValue(pMem, &aMem[pOp->p3], pOp->p4.pFunc);
    pMem = &aMem[pOp->p3];
  }else

  {
    rc = sqlite3VdbeMemFinalize(pMem, pOp->p4.pFunc);
  }

  if( rc ){
    sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem));
    goto abort_due_to_error;
  }
  sqlite3VdbeChangeEncoding(pMem, encoding);
                           ;
                                        ;
  break;
}
# 103244 "c_tests/sqlite3.c"
case 3: {
  int i;
  int aRes[3];
  Mem *pMem;

  ((void) (0));
  aRes[0] = 0;
  aRes[1] = aRes[2] = -1;
  ((void) (0));





  rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, &aRes[1], &aRes[2]);
  if( rc ){
    if( rc!=5 ) goto abort_due_to_error;
    rc = 0;
    aRes[0] = 1;
  }
  for(i=0, pMem = &aMem[pOp->p3]; i<3; i++, pMem++){
    sqlite3VdbeMemSetInt64(pMem, (i64)aRes[i]);
  }
  break;
};
# 103283 "c_tests/sqlite3.c"
case 4: {
  Btree *pBt;
  Pager *pPager;
  int eNew;
  int eOld;

  const char *zFilename;


  pOut = out2Prerelease(p, pOp);
  eNew = pOp->p3;
  ((void) (0));







  ((void) (0));
  ((void) (0));

  pBt = db->aDb[pOp->p1].pBt;
  pPager = sqlite3BtreePager(pBt);
  eOld = sqlite3PagerGetJournalMode(pPager);
  if( eNew==(-1) ) eNew = eOld;
  ((void) (0));
  if( !sqlite3PagerOkToChangeJournalMode(pPager) ) eNew = eOld;


  zFilename = sqlite3PagerFilename(pPager, 1);




  if( eNew==5
   && (sqlite3Strlen30(zFilename)==0
       || !sqlite3PagerWalSupported(pPager))
  ){
    eNew = eOld;
  }

  if( (eNew!=eOld)
   && (eOld==5 || eNew==5)
  ){
    if( !db->autoCommit || db->nVdbeRead>1 ){
      rc = 1;
      sqlite3VdbeError(p,
          "cannot change %s wal mode from within a transaction",
          (eNew==5 ? "into" : "out of")
      );
      goto abort_due_to_error;
    }else{

      if( eOld==5 ){





        rc = sqlite3PagerCloseWal(pPager, db);
        if( rc==0 ){
          sqlite3PagerSetJournalMode(pPager, eNew);
        }
      }else if( eOld==4 ){


        sqlite3PagerSetJournalMode(pPager, 2);
      }




      ((void) (0));
      if( rc==0 ){
        rc = sqlite3BtreeSetVersion(pBt, (eNew==5 ? 2 : 1));
      }
    }
  }


  if( rc ) eNew = eOld;
  eNew = sqlite3PagerSetJournalMode(pPager, eNew);

  pOut->flags = 0x0002|0x2000|0x0200;
  pOut->z = (char *)sqlite3JournalModename(eNew);
  pOut->n = sqlite3Strlen30(pOut->z);
  pOut->enc = 1;
  sqlite3VdbeChangeEncoding(pOut, encoding);
  if( rc ) goto abort_due_to_error;
  break;
};
# 103387 "c_tests/sqlite3.c"
case 5: {
  ((void) (0));
  rc = sqlite3RunVacuum(&p->zErrMsg, db, pOp->p1,
                        pOp->p2 ? &aMem[pOp->p2] : 0);
  if( rc ) goto abort_due_to_error;
  break;
}
# 103403 "c_tests/sqlite3.c"
case 63: {
  Btree *pBt;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  pBt = db->aDb[pOp->p1].pBt;
  rc = sqlite3BtreeIncrVacuum(pBt);
                                    ;
  if( rc ){
    if( rc!=101 ) goto abort_due_to_error;
    rc = 0;
    goto jump_to_p2;
  }
  break;
}
# 103437 "c_tests/sqlite3.c"
case 167: {
  ((void) (0));
  if( !pOp->p1 ){
    sqlite3ExpirePreparedStatements(db, pOp->p2);
  }else{
    p->expired = pOp->p2+1;
  }
  break;
}






case 168: {
  VdbeCursor *pC;
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  sqlite3BtreeCursorPin(pC->uc.pCursor);
  break;
}






case 169: {
  VdbeCursor *pC;
  ((void) (0));
  pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  sqlite3BtreeCursorUnpin(pC->uc.pCursor);
  break;
}
# 103493 "c_tests/sqlite3.c"
case 170: {
  u8 isWriteLock = (u8)pOp->p3;
  if( isWriteLock || 0==(db->flags&((u64)(0x00004)<<32)) ){
    int p1 = pOp->p1;
    ((void) (0));
    ((void) (0));
    ((void) (0));
    rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);
    if( rc ){
      if( (rc&0xFF)==6 ){
        const char *z = pOp->p4.z;
        sqlite3VdbeError(p, "database table is locked: %s", z);
      }
      goto abort_due_to_error;
    }
  }
  break;
}
# 103523 "c_tests/sqlite3.c"
case 171: {
  VTable *pVTab;
  pVTab = pOp->p4.pVtab;
  rc = sqlite3VtabBegin(db, pVTab);
  if( pVTab ) sqlite3VtabImportErrmsg(p, pVTab->pVtab);
  if( rc ) goto abort_due_to_error;
  break;
}
# 103539 "c_tests/sqlite3.c"
case 172: {
  Mem sMem;
  const char *zTab;

  memset(&sMem, 0, sizeof(sMem));
  sMem.db = db;


  ((void) (0));
  ((void) (0));
  rc = sqlite3VdbeMemCopy(&sMem, &aMem[pOp->p2]);
  ((void) (0));
  zTab = (const char*)sqlite3_value_text(&sMem);
  ((void) (0));
  if( zTab ){
    rc = sqlite3VtabCallCreate(db, pOp->p1, zTab, &p->zErrMsg);
  }
  sqlite3VdbeMemRelease(&sMem);
  if( rc ) goto abort_due_to_error;
  break;
}
# 103568 "c_tests/sqlite3.c"
case 173: {
  db->nVDestroy++;
  rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);
  db->nVDestroy--;
  ((void) (0));
  if( rc ) goto abort_due_to_error;
  break;
}
# 103585 "c_tests/sqlite3.c"
case 174: {
  VdbeCursor *pCur;
  sqlite3_vtab_cursor *pVCur;
  sqlite3_vtab *pVtab;
  const sqlite3_module *pModule;

  ((void) (0));
  pCur = p->apCsr[pOp->p1];
  if( pCur!=0
   && (pCur->eCurType==2)
   && (pCur->uc.pVCur->pVtab==pOp->p4.pVtab->pVtab)
  ){

    break;
  }
  pVCur = 0;
  pVtab = pOp->p4.pVtab->pVtab;
  if( pVtab==0 || (pVtab->pModule==0) ){
    rc = 6;
    goto abort_due_to_error;
  }
  pModule = pVtab->pModule;
  rc = pModule->xOpen(pVtab, &pVCur);
  sqlite3VtabImportErrmsg(p, pVtab);
  if( rc ) goto abort_due_to_error;


  pVCur->pVtab = pVtab;


  pCur = allocateCursor(p, pOp->p1, 0, 2);
  if( pCur ){
    pCur->uc.pVCur = pVCur;
    pVtab->nRef++;
  }else{
    ((void) (0));
    pModule->xClose(pVCur);
    goto no_mem;
  }
  break;
}
# 103638 "c_tests/sqlite3.c"
case 175: {
  Table *pTab;
  sqlite3_vtab *pVtab;
  const sqlite3_module *pModule;
  char *zErr = 0;

  pOut = &aMem[pOp->p2];
  sqlite3VdbeMemSetNull(pOut);
  ((void) (0));
  pTab = pOp->p4.pTab;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pTab->u.vtab.p==0 ) break;
  pVtab = pTab->u.vtab.p->pVtab;
  ((void) (0));
  pModule = pVtab->pModule;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  sqlite3VtabLock(pTab->u.vtab.p);
  ((void) (0));
  rc = pModule->xIntegrity(pVtab, db->aDb[pOp->p1].zDbSName, pTab->zName,
                           pOp->p3, &zErr);
  sqlite3VtabUnlock(pTab->u.vtab.p);
  if( rc ){
    sqlite3_free(zErr);
    goto abort_due_to_error;
  }
  if( zErr ){
    sqlite3VdbeMemSetStr(pOut, zErr, -1, 1, sqlite3_free);
  }
  break;
}
# 103685 "c_tests/sqlite3.c"
case 176: {
  VdbeCursor *pC;
  ValueList *pRhs;

  pC = p->apCsr[pOp->p1];
  pRhs = sqlite3_malloc64( sizeof(*pRhs) );
  if( pRhs==0 ) goto no_mem;
  pRhs->pCsr = pC->uc.pCursor;
  pRhs->pOut = &aMem[pOp->p3];
  pOut = out2Prerelease(p, pOp);
  pOut->flags = 0x0001;
  sqlite3VdbeMemSetPointer(pOut, pRhs, "ValueList", sqlite3VdbeValueListFree);
  break;
}
# 103722 "c_tests/sqlite3.c"
case 6: {
  int nArg;
  int iQuery;
  const sqlite3_module *pModule;
  Mem *pQuery;
  Mem *pArgc;
  sqlite3_vtab_cursor *pVCur;
  sqlite3_vtab *pVtab;
  VdbeCursor *pCur;
  int res;
  int i;
  Mem **apArg;

  pQuery = &aMem[pOp->p3];
  pArgc = &pQuery[1];
  pCur = p->apCsr[pOp->p1];
  ((void) (0));
                                 ;
  ((void) (0));
  ((void) (0));
  pVCur = pCur->uc.pVCur;
  pVtab = pVCur->pVtab;
  pModule = pVtab->pModule;


  ((void) (0));
  nArg = (int)pArgc->u.i;
  iQuery = (int)pQuery->u.i;


  apArg = p->apArg;
  ((void) (0));
  for(i = 0; i<nArg; i++){
    apArg[i] = &pArgc[i+1];
  }
  rc = pModule->xFilter(pVCur, iQuery, pOp->p4.z, nArg, apArg);
  sqlite3VtabImportErrmsg(p, pVtab);
  if( rc ) goto abort_due_to_error;
  res = pModule->xEof(pVCur);
  pCur->nullRow = 0;
                           ;
  if( res ) goto jump_to_p2;
  break;
}
# 103783 "c_tests/sqlite3.c"
case 177: {
  sqlite3_vtab *pVtab;
  const sqlite3_module *pModule;
  Mem *pDest;
  sqlite3_context sContext;
  FuncDef nullFunc;

  VdbeCursor *pCur = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  pDest = &aMem[pOp->p3];
                            ;
  if( pCur->nullRow ){
    sqlite3VdbeMemSetNull(pDest);
    break;
  }
  ((void) (0));
  pVtab = pCur->uc.pVCur->pVtab;
  pModule = pVtab->pModule;
  ((void) (0));
  memset(&sContext, 0, sizeof(sContext));
  sContext.pOut = pDest;
  sContext.enc = encoding;
  nullFunc.pUserData = 0;
  nullFunc.funcFlags = 0x001000000;
  sContext.pFunc = &nullFunc;
  ((void) (0));
  if( pOp->p5 & 0x01 ){
    sqlite3VdbeMemSetNull(pDest);
    pDest->flags = 0x0001|0x0400;
    pDest->u.nZero = 0;
  }else{
    ((pDest)->flags = ((pDest)->flags&~(0x0dbf|0x0400))|0x0001);
  }
  rc = pModule->xColumn(pCur->uc.pVCur, &sContext, pOp->p2);
  sqlite3VtabImportErrmsg(p, pVtab);
  if( sContext.isError>0 ){
    sqlite3VdbeError(p, "%s", sqlite3_value_text(pDest));
    rc = sContext.isError;
  }
  sqlite3VdbeChangeEncoding(pDest, encoding);
                                ;
                            ;

  if( rc ) goto abort_due_to_error;
  break;
}
# 103839 "c_tests/sqlite3.c"
case 64: {
  sqlite3_vtab *pVtab;
  const sqlite3_module *pModule;
  int res;
  VdbeCursor *pCur;

  pCur = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  if( pCur->nullRow ){
    break;
  }
  pVtab = pCur->uc.pVCur->pVtab;
  pModule = pVtab->pModule;
  ((void) (0));







  rc = pModule->xNext(pCur->uc.pVCur);
  sqlite3VtabImportErrmsg(p, pVtab);
  if( rc ) goto abort_due_to_error;
  res = pModule->xEof(pCur->uc.pVCur);
                         ;
  if( !res ){

    goto jump_to_p2_and_check_for_interrupt;
  }
  goto check_for_interrupt;
}
# 103881 "c_tests/sqlite3.c"
case 178: {
  sqlite3_vtab *pVtab;
  Mem *pName;
  int isLegacy;

  isLegacy = (db->flags & 0x04000000);
  db->flags |= 0x04000000;
  pVtab = pOp->p4.pVtab->pVtab;
  pName = &aMem[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
                                ;
  ((void) (0));
                                     ;
                                        ;
                                        ;
  rc = sqlite3VdbeChangeEncoding(pName, 1);
  if( rc ) goto abort_due_to_error;
  rc = pVtab->pModule->xRename(pVtab, pName->z);
  if( isLegacy==0 ) db->flags &= ~(u64)0x04000000;
  sqlite3VtabImportErrmsg(p, pVtab);
  p->expired = 0;
  if( rc ) goto abort_due_to_error;
  break;
}
# 103937 "c_tests/sqlite3.c"
case 7: {
  sqlite3_vtab *pVtab;
  const sqlite3_module *pModule;
  int nArg;
  int i;
  sqlite_int64 rowid = 0;
  Mem **apArg;
  Mem *pX;

  ((void) (0));


  ((void) (0));
  if( db->mallocFailed ) goto no_mem;
                                   ;
  pVtab = pOp->p4.pVtab->pVtab;
  if( pVtab==0 || (pVtab->pModule==0) ){
    rc = 6;
    goto abort_due_to_error;
  }
  pModule = pVtab->pModule;
  nArg = pOp->p2;
  ((void) (0));
  if( (pModule->xUpdate) ){
    u8 vtabOnConflict = db->vtabOnConflict;
    apArg = p->apArg;
    pX = &aMem[pOp->p3];
    ((void) (0));
    for(i=0; i<nArg; i++){
      ((void) (0));
                             ;
      apArg[i] = pX;
      pX++;
    }
    db->vtabOnConflict = pOp->p5;
    rc = pModule->xUpdate(pVtab, nArg, apArg, &rowid);
    db->vtabOnConflict = vtabOnConflict;
    sqlite3VtabImportErrmsg(p, pVtab);
    if( rc==0 && pOp->p1 ){
      ((void) (0));
      db->lastRowid = rowid;
    }
    if( (rc&0xff)==19 && pOp->p4.pVtab->bConstraint ){
      if( pOp->p5==4 ){
        rc = 0;
      }else{
        p->errorAction = ((pOp->p5==5) ? 2 : pOp->p5);
      }
    }else{
      p->nChange++;
    }
    if( rc ) goto abort_due_to_error;
  }
  break;
}







case 179: {
  pOut = out2Prerelease(p, pOp);
  pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);
  break;
}
# 104016 "c_tests/sqlite3.c"
case 180: {
  unsigned int newMax;
  Btree *pBt;

  pOut = out2Prerelease(p, pOp);
  pBt = db->aDb[pOp->p1].pBt;
  newMax = 0;
  if( pOp->p3 ){
    newMax = sqlite3BtreeLastPage(pBt);
    if( newMax < (unsigned)pOp->p3 ) newMax = (unsigned)pOp->p3;
  }
  pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax);
  break;
}
# 104078 "c_tests/sqlite3.c"
case 66:
case 67: {
  int i;
  sqlite3_context *pCtx;

  ((void) (0));
  pCtx = pOp->p4.pCtx;





  pOut = &aMem[pOp->p3];
  if( pCtx->pOut != pOut ){
    pCtx->pVdbe = p;
    pCtx->pOut = pOut;
    pCtx->enc = encoding;
    for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[pOp->p2+i];
  }
  ((void) (0));

                           ;






  ((pOut)->flags = ((pOut)->flags&~(0x0dbf|0x0400))|0x0001);
  ((void) (0));
  (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);


  if( pCtx->isError ){
    if( pCtx->isError>0 ){
      sqlite3VdbeError(p, "%s", sqlite3_value_text(pOut));
      rc = pCtx->isError;
    }
    sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);
    pCtx->isError = 0;
    if( rc ) goto abort_due_to_error;
  }

  ((void) (0));


  ((void) (0));

                               ;
                           ;
  break;
}






case 181: {
  pIn1 = &aMem[pOp->p1];
  pIn1->flags &= ~0x0800;
  break;
}







case 182: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  if( pIn1->flags & 0x0800 ){
    sqlite3VdbeMemSetInt64(pOut, pIn1->eSubtype);
  }else{
    sqlite3VdbeMemSetNull(pOut);
  }
  break;
}







case 183: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  if( pIn1->flags & 0x0001 ){
    pOut->flags &= ~0x0800;
  }else{
    ((void) (0));
    pOut->flags |= 0x0800;
    pOut->eSubtype = (u8)(pIn1->u.i & 0xff);
  }
  break;
}







case 184: {
  u64 h;

  ((void) (0));
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  ((void) (0));
  h = filterHash(aMem, pOp);
# 104201 "c_tests/sqlite3.c"
  h %= (pIn1->n*8);
  pIn1->z[h/8] |= 1<<(h&7);
  break;
}
# 104220 "c_tests/sqlite3.c"
case 65: {
  u64 h;

  ((void) (0));
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  ((void) (0));
  h = filterHash(aMem, pOp);
# 104237 "c_tests/sqlite3.c"
  h %= (pIn1->n*8);
  if( (pIn1->z[h/8] & (1<<(h&7)))==0 ){
                         ;
    p->aCounter[8]++;
    goto jump_to_p2;
  }else{
    p->aCounter[7]++;
                         ;
  }
  break;
}
# 104274 "c_tests/sqlite3.c"
case 185:
case 8: {
  int i;

  char *zTrace;
# 104290 "c_tests/sqlite3.c"
  ((void) (0));


  ((void) (0));


  if( (db->mTrace & (0x01|0x40))!=0
   && p->minWriteFileFormat!=254
   && (zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql))!=0
  ){

    if( db->mTrace & 0x40 ){
      char *z = sqlite3VdbeExpandSql(p, zTrace);
      db->trace.xLegacy(db->pTraceArg, z);
      sqlite3_free(z);
    }else

    if( db->nVdbeExec>1 ){
      char *z = sqlite3MPrintf(db, "-- %s", zTrace);
      (void)db->trace.xV2(0x01, db->pTraceArg, p, z);
      sqlite3DbFree(db, z);
    }else{
      (void)db->trace.xV2(0x01, db->pTraceArg, p, zTrace);
    }
  }
# 104333 "c_tests/sqlite3.c"
  ((void) (0));
  if( pOp->p1>=sqlite3Config.iOnceResetThreshold ){
    if( pOp->opcode==185 ) break;
    for(i=1; i<p->nOp; i++){
      if( p->aOp[i].opcode==15 ) p->aOp[i].p1 = 0;
    }
    pOp->p1 = 0;
  }
  pOp->p1++;
  p->aCounter[6]++;
  goto jump_to_p2;
}
# 104460 "c_tests/sqlite3.c"
default: {
  ((void) (0));

  break;
}







    }
# 104511 "c_tests/sqlite3.c"
  }




abort_due_to_error:
  if( db->mallocFailed ){
    rc = 7;
  }else if( rc==(10 | (33<<8)) ){
    rc = sqlite3CorruptError(104520);
  }
  ((void) (0));
# 104535 "c_tests/sqlite3.c"
  if( p->zErrMsg==0 && rc!=(10 | (12<<8)) ){
    sqlite3VdbeError(p, "%s", sqlite3ErrStr(rc));
  }
  p->rc = rc;
  sqlite3SystemError(db, rc);
                                         ;
  sqlite3VdbeLogAbort(p, rc, pOp, aOp);
  if( p->eVdbeState==2 ) sqlite3VdbeHalt(p);
  if( rc==(10 | (12<<8)) ) sqlite3OomFault(db);
  if( rc==11 && db->autoCommit==0 ){
    db->flags |= ((u64)(0x00002)<<32);
  }
  rc = 1;
  if( resetSchemaOnFault>0 ){
    sqlite3ResetOneSchema(db, resetSchemaOnFault-1);
  }




vdbe_return:
# 104569 "c_tests/sqlite3.c"
  while( nVmStep>=nProgressLimit && db->xProgress!=0 ){
    nProgressLimit += db->nProgressOps;
    if( db->xProgress(db->pProgressArg) ){
      nProgressLimit = (0xffffffff|(((u64)0xffffffff)<<32));
      rc = 9;
      goto abort_due_to_error;
    }
  }

  p->aCounter[4] += (int)nVmStep;
  if( ((p->lockMask)!=0) ){
    sqlite3VdbeLeave(p);
  }
  ((void) (0));


  return rc;




too_big:
  sqlite3VdbeError(p, "string or blob too big");
  rc = 18;
  goto abort_due_to_error;



no_mem:
  sqlite3OomFault(db);
  sqlite3VdbeError(p, "out of memory");
  rc = 7;
  goto abort_due_to_error;




abort_due_to_interrupt:
  ((void) (0));
  rc = 9;
  goto abort_due_to_error;
}
# 104638 "c_tests/sqlite3.c"
typedef struct Incrblob Incrblob;
struct Incrblob {
  int nByte;
  int iOffset;
  u16 iCol;
  BtCursor *pCsr;
  sqlite3_stmt *pStmt;
  sqlite3 *db;
  char *zDb;
  Table *pTab;
};
# 104668 "c_tests/sqlite3.c"
static int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr){
  int rc;
  char *zErr = 0;
  Vdbe *v = (Vdbe *)p->pStmt;




  sqlite3VdbeMemSetInt64(&v->aMem[1], iRow);





  if( v->pc>4 ){
    v->pc = 4;
    ((void) (0));
    rc = sqlite3VdbeExec(v);
  }else{
    rc = sqlite3_step(p->pStmt);
  }
  if( rc==100 ){
    VdbeCursor *pC = v->apCsr[0];
    u32 type;
    ((void) (0));
    ((void) (0));
    type = pC->nHdrParsed>p->iCol ? pC->aType[p->iCol] : 0;
                                       ;
                                         ;
    if( type<12 ){
      zErr = sqlite3MPrintf(p->db, "cannot open value of type %s",
          type==0?"null": type==7?"real": "integer"
      );
      rc = 1;
      sqlite3_finalize(p->pStmt);
      p->pStmt = 0;
    }else{
      p->iOffset = pC->aType[p->iCol + pC->nField];
      p->nByte = sqlite3VdbeSerialTypeLen(type);
      p->pCsr = pC->uc.pCursor;
      sqlite3BtreeIncrblobCursor(p->pCsr);
    }
  }

  if( rc==100 ){
    rc = 0;
  }else if( p->pStmt ){
    rc = sqlite3_finalize(p->pStmt);
    p->pStmt = 0;
    if( rc==0 ){
      zErr = sqlite3MPrintf(p->db, "no such rowid: %lld", iRow);
      rc = 1;
    }else{
      zErr = sqlite3MPrintf(p->db, "%s", sqlite3_errmsg(p->db));
    }
  }

  ((void) (0));
  ((void) (0));

  *pzErr = zErr;
  return rc;
}




           int sqlite3_blob_open(
  sqlite3* db,
  const char *zDb,
  const char *zTable,
  const char *zColumn,
  sqlite_int64 iRow,
  int wrFlag,
  sqlite3_blob **ppBlob
){
  int nAttempt = 0;
  int iCol;
  int rc = 0;
  char *zErr = 0;
  Table *pTab;
  Incrblob *pBlob = 0;
  int iDb;
  Parse sParse;






  *ppBlob = 0;





  wrFlag = !!wrFlag;

  sqlite3_mutex_enter(db->mutex);

  pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));
  while(1){
    sqlite3ParseObjectInit(&sParse,db);
    if( !pBlob ) goto blob_open_out;
    sqlite3DbFree(db, zErr);
    zErr = 0;

    sqlite3BtreeEnterAll(db);
    pTab = sqlite3LocateTable(&sParse, 0, zTable, zDb);
    if( pTab && ((pTab)->eTabType==1) ){
      pTab = 0;
      sqlite3ErrorMsg(&sParse, "cannot open virtual table: %s", zTable);
    }
    if( pTab && !(((pTab)->tabFlags & 0x00000080)==0) ){
      pTab = 0;
      sqlite3ErrorMsg(&sParse, "cannot open table without rowid: %s", zTable);
    }
    if( pTab && (pTab->tabFlags&0x00000060)!=0 ){
      pTab = 0;
      sqlite3ErrorMsg(&sParse, "cannot open table with generated columns: %s",
                      zTable);
    }

    if( pTab && ((pTab)->eTabType==2) ){
      pTab = 0;
      sqlite3ErrorMsg(&sParse, "cannot open view: %s", zTable);
    }

    if( pTab==0
     || ((iDb = sqlite3SchemaToIndex(db, pTab->pSchema))==1 &&
         sqlite3OpenTempDatabase(&sParse))
    ){
      if( sParse.zErrMsg ){
        sqlite3DbFree(db, zErr);
        zErr = sParse.zErrMsg;
        sParse.zErrMsg = 0;
      }
      rc = 1;
      sqlite3BtreeLeaveAll(db);
      goto blob_open_out;
    }
    pBlob->pTab = pTab;
    pBlob->zDb = db->aDb[iDb].zDbSName;


    iCol = sqlite3ColumnIndex(pTab, zColumn);
    if( iCol<0 ){
      sqlite3DbFree(db, zErr);
      zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn);
      rc = 1;
      sqlite3BtreeLeaveAll(db);
      goto blob_open_out;
    }




    if( wrFlag ){
      const char *zFault = 0;
      Index *pIdx;

      if( db->flags&0x00004000 ){




        FKey *pFKey;
        ((void) (0));
        for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){
          int j;
          for(j=0; j<pFKey->nCol; j++){
            if( pFKey->aCol[j].iFrom==iCol ){
              zFault = "foreign key";
            }
          }
        }
      }

      for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
        int j;
        for(j=0; j<pIdx->nKeyCol; j++){

          if( pIdx->aiColumn[j]==iCol || pIdx->aiColumn[j]==(-2) ){
            zFault = "indexed";
          }
        }
      }
      if( zFault ){
        sqlite3DbFree(db, zErr);
        zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault);
        rc = 1;
        sqlite3BtreeLeaveAll(db);
        goto blob_open_out;
      }
    }

    pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(&sParse);
    ((void) (0));
    if( pBlob->pStmt ){
# 104883 "c_tests/sqlite3.c"
      static const int iLn = 0;
      static const VdbeOpList openBlob[] = {
        {170, 0, 0, 0},
        {113, 0, 0, 0},

        {31, 0, 5, 1},
        {95, 0, 0, 1},
        {85, 1, 0, 0},
        {71, 0, 0, 0},
      };
      Vdbe *v = (Vdbe *)pBlob->pStmt;
      VdbeOp *aOp;

      sqlite3VdbeAddOp4Int(v, 2, iDb, wrFlag,
                           pTab->pSchema->schema_cookie,
                           pTab->pSchema->iGeneration);
      sqlite3VdbeChangeP5(v, 1);
      ((void) (0));
      aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(openBlob)/sizeof(openBlob[0]))), openBlob, iLn);


      sqlite3VdbeUsesBtree(v, iDb);

      if( db->mallocFailed==0 ){
        ((void) (0));




        aOp[0].p1 = iDb;
        aOp[0].p2 = pTab->tnum;
        aOp[0].p3 = wrFlag;
        sqlite3VdbeChangeP4(v, 2, pTab->zName, 0);
      }
      if( db->mallocFailed==0 ){




        if( wrFlag ) aOp[1].opcode = 114;
        aOp[1].p2 = pTab->tnum;
        aOp[1].p3 = iDb;
# 104933 "c_tests/sqlite3.c"
        aOp[1].p4type = (-3);
        aOp[1].p4.i = pTab->nCol+1;
        aOp[3].p2 = pTab->nCol;

        sParse.nVar = 0;
        sParse.nMem = 1;
        sParse.nTab = 1;
        sqlite3VdbeMakeReady(v, &sParse);
      }
    }

    pBlob->iCol = iCol;
    pBlob->db = db;
    sqlite3BtreeLeaveAll(db);
    if( db->mallocFailed ){
      goto blob_open_out;
    }
    rc = blobSeekToRow(pBlob, iRow, &zErr);
    if( (++nAttempt)>=50 || rc!=17 ) break;
    sqlite3ParseObjectReset(&sParse);
  }

blob_open_out:
  if( rc==0 && db->mallocFailed==0 ){
    *ppBlob = (sqlite3_blob *)pBlob;
  }else{
    if( pBlob && pBlob->pStmt ) sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);
    sqlite3DbFree(db, pBlob);
  }
  sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : (char*)0), zErr);
  sqlite3DbFree(db, zErr);
  sqlite3ParseObjectReset(&sParse);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}





           int sqlite3_blob_close(sqlite3_blob *pBlob){
  Incrblob *p = (Incrblob *)pBlob;
  int rc;
  sqlite3 *db;

  if( p ){
    sqlite3_stmt *pStmt = p->pStmt;
    db = p->db;
    sqlite3_mutex_enter(db->mutex);
    sqlite3DbFree(db, p);
    sqlite3_mutex_leave(db->mutex);
    rc = sqlite3_finalize(pStmt);
  }else{
    rc = 0;
  }
  return rc;
}




static int blobReadWrite(
  sqlite3_blob *pBlob,
  void *z,
  int n,
  int iOffset,
  int (*xCall)(BtCursor*, u32, u32, void*)
){
  int rc = 0;
  Incrblob *p = (Incrblob *)pBlob;
  Vdbe *v;
  sqlite3 *db;

  if( p==0 ) return sqlite3MisuseError(105007);
  db = p->db;
  sqlite3_mutex_enter(db->mutex);
  v = (Vdbe*)p->pStmt;

  if( n<0 || iOffset<0 || ((sqlite3_int64)iOffset+n)>p->nByte ){

    rc = 1;
  }else if( v==0 ){



    rc = 4;
  }else{



    ((void) (0));
    sqlite3BtreeEnterCursor(p->pCsr);
# 105065 "c_tests/sqlite3.c"
    rc = xCall(p->pCsr, iOffset+p->iOffset, n, z);


    sqlite3BtreeLeaveCursor(p->pCsr);
    if( rc==4 ){
      sqlite3VdbeFinalize(v);
      p->pStmt = 0;
    }else{
      v->rc = rc;
    }
  }
  sqlite3Error(db, rc);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}




           int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){
  return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreePayloadChecked);
}




           int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){
  return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData);
}







           int sqlite3_blob_bytes(sqlite3_blob *pBlob){
  Incrblob *p = (Incrblob *)pBlob;
  return (p && p->pStmt) ? p->nByte : 0;
}
# 105117 "c_tests/sqlite3.c"
           int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){
  int rc;
  Incrblob *p = (Incrblob *)pBlob;
  sqlite3 *db;

  if( p==0 ) return sqlite3MisuseError(105122);
  db = p->db;
  sqlite3_mutex_enter(db->mutex);

  if( p->pStmt==0 ){



    rc = 4;
  }else{
    char *zErr;
    ((Vdbe*)p->pStmt)->rc = 0;
    rc = blobSeekToRow(p, iRow, &zErr);
    if( rc!=0 ){
      sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : (char*)0), zErr);
      sqlite3DbFree(db, zErr);
    }
    ((void) (0));
  }

  rc = sqlite3ApiExit(db, rc);
  ((void) (0));
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 105311 "c_tests/sqlite3.c"
typedef struct MergeEngine MergeEngine;
typedef struct PmaReader PmaReader;
typedef struct PmaWriter PmaWriter;
typedef struct SorterRecord SorterRecord;
typedef struct SortSubtask SortSubtask;
typedef struct SorterFile SorterFile;
typedef struct SorterList SorterList;
typedef struct IncrMerger IncrMerger;





struct SorterFile {
  sqlite3_file *pFd;
  i64 iEof;
};
# 105337 "c_tests/sqlite3.c"
struct SorterList {
  SorterRecord *pList;
  u8 *aMemory;
  i64 szPMA;
};
# 105407 "c_tests/sqlite3.c"
struct MergeEngine {
  int nTree;
  SortSubtask *pTask;
  int *aTree;
  PmaReader *aReadr;
};
# 105445 "c_tests/sqlite3.c"
typedef int (*SorterCompare)(SortSubtask*,int*,const void*,int,const void*,int);
struct SortSubtask {
  SQLiteThread *pThread;
  int bDone;
  int nPMA;
  VdbeSorter *pSorter;
  UnpackedRecord *pUnpacked;
  SorterList list;
  SorterCompare xCompare;
  SorterFile file;
  SorterFile file2;
  u64 nSpill;
};
# 105469 "c_tests/sqlite3.c"
struct VdbeSorter {
  int mnPmaSize;
  int mxPmaSize;
  int mxKeysize;
  int pgsz;
  PmaReader *pReader;
  MergeEngine *pMerger;
  sqlite3 *db;
  KeyInfo *pKeyInfo;
  UnpackedRecord *pUnpacked;
  SorterList list;
  int iMemory;
  int nMemory;
  u8 bUsePMA;
  u8 bUseThreads;
  u8 iPrev;
  u8 nTask;
  u8 typeMask;
  SortSubtask aTask[];
};
# 105505 "c_tests/sqlite3.c"
struct PmaReader {
  i64 iReadOff;
  i64 iEof;
  int nAlloc;
  int nKey;
  sqlite3_file *pFd;
  u8 *aAlloc;
  u8 *aKey;
  u8 *aBuffer;
  int nBuffer;
  u8 *aMap;
  IncrMerger *pIncr;
};
# 105551 "c_tests/sqlite3.c"
struct IncrMerger {
  SortSubtask *pTask;
  MergeEngine *pMerger;
  i64 iStartOff;
  int mxSz;
  int bEof;
  int bUseThread;
  SorterFile aFile[2];
};
# 105569 "c_tests/sqlite3.c"
struct PmaWriter {
  int eFWErr;
  u8 *aBuffer;
  int nBuffer;
  int iBufStart;
  int iBufEnd;
  i64 iWriteOff;
  sqlite3_file *pFd;
  u64 nPmaSpill;
};
# 105598 "c_tests/sqlite3.c"
struct SorterRecord {
  int nVal;
  union {
    SorterRecord *pNext;
    int iNext;
  } u;

};
# 105618 "c_tests/sqlite3.c"
static int vdbeIncrSwap(IncrMerger*);
static void vdbeIncrFree(IncrMerger *);





static void vdbePmaReaderClear(PmaReader *pReadr){
  sqlite3_free(pReadr->aAlloc);
  sqlite3_free(pReadr->aBuffer);
  if( pReadr->aMap ) sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);
  vdbeIncrFree(pReadr->pIncr);
  memset(pReadr, 0, sizeof(PmaReader));
}
# 105642 "c_tests/sqlite3.c"
static int vdbePmaReadBlob(
  PmaReader *p,
  int nByte,
  u8 **ppOut
){
  int iBuf;
  int nAvail;

  if( p->aMap ){
    *ppOut = &p->aMap[p->iReadOff];
    p->iReadOff += nByte;
    return 0;
  }

  ((void) (0));




  iBuf = p->iReadOff % p->nBuffer;
  if( iBuf==0 ){
    int nRead;
    int rc;


    if( (p->iEof - p->iReadOff) > (i64)p->nBuffer ){
      nRead = p->nBuffer;
    }else{
      nRead = (int)(p->iEof - p->iReadOff);
    }
    ((void) (0));


    rc = sqlite3OsRead(p->pFd, p->aBuffer, nRead, p->iReadOff);
    ((void) (0));
    if( rc!=0 ) return rc;
  }
  nAvail = p->nBuffer - iBuf;

  if( nByte<=nAvail ){



    *ppOut = &p->aBuffer[iBuf];
    p->iReadOff += nByte;
  }else{



    int nRem;


    if( p->nAlloc<nByte ){
      u8 *aNew;
      sqlite3_int64 nNew = ((128)>(2*(sqlite3_int64)p->nAlloc)?(128):(2*(sqlite3_int64)p->nAlloc));
      while( nByte>nNew ) nNew = nNew*2;
      aNew = sqlite3Realloc(p->aAlloc, nNew);
      if( !aNew ) return 7;
      p->nAlloc = nNew;
      p->aAlloc = aNew;
    }



    memcpy(p->aAlloc, &p->aBuffer[iBuf], nAvail);
    p->iReadOff += nAvail;
    nRem = nByte - nAvail;



    while( nRem>0 ){
      int rc;
      int nCopy;
      u8 *aNext = 0;

      nCopy = nRem;
      if( nRem>p->nBuffer ) nCopy = p->nBuffer;
      rc = vdbePmaReadBlob(p, nCopy, &aNext);
      if( rc!=0 ) return rc;
      ((void) (0));
      ((void) (0));
      memcpy(&p->aAlloc[nByte - nRem], aNext, nCopy);
      nRem -= nCopy;
    }

    *ppOut = p->aAlloc;
  }

  return 0;
}





static int vdbePmaReadVarint(PmaReader *p, u64 *pnOut){
  int iBuf;

  if( p->aMap ){
    p->iReadOff += sqlite3GetVarint(&p->aMap[p->iReadOff], pnOut);
  }else{
    iBuf = p->iReadOff % p->nBuffer;
    if( iBuf && (p->nBuffer-iBuf)>=9 ){
      p->iReadOff += sqlite3GetVarint(&p->aBuffer[iBuf], pnOut);
    }else{
      u8 aVarint[16], *a;
      int i = 0, rc;
      do{
        rc = vdbePmaReadBlob(p, 1, &a);
        if( rc ) return rc;
        aVarint[(i++)&0xf] = a[0];
      }while( (a[0]&0x80)!=0 );
      sqlite3GetVarint(aVarint, pnOut);
    }
  }

  return 0;
}
# 105770 "c_tests/sqlite3.c"
static int vdbeSorterMapFile(SortSubtask *pTask, SorterFile *pFile, u8 **pp){
  int rc = 0;
  if( pFile->iEof<=(i64)(pTask->pSorter->db->nMaxSorterMmap) ){
    sqlite3_file *pFd = pFile->pFd;
    if( pFd->pMethods->iVersion>=3 ){
      rc = sqlite3OsFetch(pFd, 0, (int)pFile->iEof, (void**)pp);
                               ;
    }
  }
  return rc;
}






static int vdbePmaReaderSeek(
  SortSubtask *pTask,
  PmaReader *pReadr,
  SorterFile *pFile,
  i64 iOff
){
  int rc = 0;

  ((void) (0));

  if( sqlite3FaultSim(201) ) return (10 | (1<<8));
  if( pReadr->aMap ){
    sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);
    pReadr->aMap = 0;
  }
  pReadr->iReadOff = iOff;
  pReadr->iEof = pFile->iEof;
  pReadr->pFd = pFile->pFd;

  rc = vdbeSorterMapFile(pTask, pFile, &pReadr->aMap);
  if( rc==0 && pReadr->aMap==0 ){
    int pgsz = pTask->pSorter->pgsz;
    int iBuf = pReadr->iReadOff % pgsz;
    if( pReadr->aBuffer==0 ){
      pReadr->aBuffer = (u8*)sqlite3Malloc(pgsz);
      if( pReadr->aBuffer==0 ) rc = 7;
      pReadr->nBuffer = pgsz;
    }
    if( rc==0 && iBuf ){
      int nRead = pgsz - iBuf;
      if( (pReadr->iReadOff + nRead) > pReadr->iEof ){
        nRead = (int)(pReadr->iEof - pReadr->iReadOff);
      }
      rc = sqlite3OsRead(
          pReadr->pFd, &pReadr->aBuffer[iBuf], nRead, pReadr->iReadOff
      );
                               ;
    }
  }

  return rc;
}





static int vdbePmaReaderNext(PmaReader *pReadr){
  int rc = 0;
  u64 nRec = 0;


  if( pReadr->iReadOff>=pReadr->iEof ){
    IncrMerger *pIncr = pReadr->pIncr;
    int bEof = 1;
    if( pIncr ){
      rc = vdbeIncrSwap(pIncr);
      if( rc==0 && pIncr->bEof==0 ){
        rc = vdbePmaReaderSeek(
            pIncr->pTask, pReadr, &pIncr->aFile[0], pIncr->iStartOff
        );
        bEof = 0;
      }
    }

    if( bEof ){

      vdbePmaReaderClear(pReadr);
                               ;
      return rc;
    }
  }

  if( rc==0 ){
    rc = vdbePmaReadVarint(pReadr, &nRec);
  }
  if( rc==0 ){
    pReadr->nKey = (int)nRec;
    rc = vdbePmaReadBlob(pReadr, (int)nRec, &pReadr->aKey);
                             ;
  }

  return rc;
}
# 105881 "c_tests/sqlite3.c"
static int vdbePmaReaderInit(
  SortSubtask *pTask,
  SorterFile *pFile,
  i64 iStart,
  PmaReader *pReadr,
  i64 *pnByte
){
  int rc;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  rc = vdbePmaReaderSeek(pTask, pReadr, pFile, iStart);
  if( rc==0 ){
    u64 nByte = 0;
    rc = vdbePmaReadVarint(pReadr, &nByte);
    pReadr->iEof = pReadr->iReadOff + nByte;
    *pnByte += nByte;
  }

  if( rc==0 ){
    rc = vdbePmaReaderNext(pReadr);
  }
  return rc;
}






static int vdbeSorterCompareTail(
  SortSubtask *pTask,
  int *pbKey2Cached,
  const void *pKey1, int nKey1,
  const void *pKey2, int nKey2
){
  UnpackedRecord *r2 = pTask->pUnpacked;
  if( *pbKey2Cached==0 ){
    sqlite3VdbeRecordUnpack(nKey2, pKey2, r2);
    *pbKey2Cached = 1;
  }
  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, r2, 1);
}
# 105941 "c_tests/sqlite3.c"
static int vdbeSorterCompare(
  SortSubtask *pTask,
  int *pbKey2Cached,
  const void *pKey1, int nKey1,
  const void *pKey2, int nKey2
){
  UnpackedRecord *r2 = pTask->pUnpacked;
  if( !*pbKey2Cached ){
    sqlite3VdbeRecordUnpack(nKey2, pKey2, r2);
    *pbKey2Cached = 1;
  }
  return sqlite3VdbeRecordCompare(nKey1, pKey1, r2);
}






static int vdbeSorterCompareText(
  SortSubtask *pTask,
  int *pbKey2Cached,
  const void *pKey1, int nKey1,
  const void *pKey2, int nKey2
){
  const u8 * const p1 = (const u8 * const)pKey1;
  const u8 * const p2 = (const u8 * const)pKey2;
  const u8 * const v1 = &p1[ p1[0] ];
  const u8 * const v2 = &p2[ p2[0] ];

  int n1;
  int n2;
  int res;

  n1=(u32)*(&p1[1]);if(n1>=0x80)sqlite3GetVarint32((&p1[1]),(u32*)&(n1));
  n2=(u32)*(&p2[1]);if(n2>=0x80)sqlite3GetVarint32((&p2[1]),(u32*)&(n2));
  res = memcmp(v1, v2, (((n1)<(n2)?(n1):(n2)) - 13)/2);
  if( res==0 ){
    res = n1 - n2;
  }

  if( res==0 ){
    if( pTask->pSorter->pKeyInfo->nKeyField>1 ){
      res = vdbeSorterCompareTail(
          pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
      );
    }
  }else{
    ((void) (0));
    ((void) (0));
    if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){
      res = res * -1;
    }
  }

  return res;
}





static int vdbeSorterCompareInt(
  SortSubtask *pTask,
  int *pbKey2Cached,
  const void *pKey1, int nKey1,
  const void *pKey2, int nKey2
){
  const u8 * const p1 = (const u8 * const)pKey1;
  const u8 * const p2 = (const u8 * const)pKey2;
  const int s1 = p1[1];
  const int s2 = p2[1];
  const u8 * const v1 = &p1[ p1[0] ];
  const u8 * const v2 = &p2[ p2[0] ];
  int res;

  ((void) (0));
  ((void) (0));

  if( s1==s2 ){

    static const u8 aLen[] = {0, 1, 2, 3, 4, 6, 8, 0, 0, 0 };
    const u8 n = aLen[s1];
    int i;
    res = 0;
    for(i=0; i<n; i++){
      if( (res = v1[i] - v2[i])!=0 ){
        if( ((v1[0] ^ v2[0]) & 0x80)!=0 ){
          res = v1[0] & 0x80 ? -1 : +1;
        }
        break;
      }
    }
  }else if( s1>7 && s2>7 ){
    res = s1 - s2;
  }else{
    if( s2>7 ){
      res = +1;
    }else if( s1>7 ){
      res = -1;
    }else{
      res = s1 - s2;
    }
    ((void) (0));

    if( res>0 ){
      if( *v1 & 0x80 ) res = -1;
    }else{
      if( *v2 & 0x80 ) res = +1;
    }
  }

  ((void) (0));
  if( res==0 ){
    if( pTask->pSorter->pKeyInfo->nKeyField>1 ){
      res = vdbeSorterCompareTail(
          pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
      );
    }
  }else if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){
    ((void) (0));
    res = res * -1;
  }

  return res;
}
# 106087 "c_tests/sqlite3.c"
static int sqlite3VdbeSorterInit(
  sqlite3 *db,
  int nField,
  VdbeCursor *pCsr
){
  int pgsz;
  int i;
  VdbeSorter *pSorter;
  KeyInfo *pKeyInfo;
  int szKeyInfo;
  i64 sz;
  int rc = 0;



  int nWorker;




  if( sqlite3TempInMemory(db) || sqlite3Config.bCoreMutex==0 ){
    nWorker = 0;
  }else{
    nWorker = db->aLimit[11];
  }
# 106122 "c_tests/sqlite3.c"
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  ((void) (0));
  szKeyInfo = (__builtin_offsetof(KeyInfo, aColl) + (pCsr->pKeyInfo->nAllField)*sizeof(CollSeq*));
  sz = (__builtin_offsetof(VdbeSorter, aTask)+(nWorker+1)*sizeof(SortSubtask));

  pSorter = (VdbeSorter*)sqlite3DbMallocZero(db, sz + szKeyInfo);
  pCsr->uc.pSorter = pSorter;
  if( pSorter==0 ){
    rc = 7;
  }else{
    Btree *pBt = db->aDb[0].pBt;
    pSorter->pKeyInfo = pKeyInfo = (KeyInfo*)((u8*)pSorter + sz);
    memcpy(pKeyInfo, pCsr->pKeyInfo, szKeyInfo);
    pKeyInfo->db = 0;
    if( nField && nWorker==0 ){
      pKeyInfo->nKeyField = nField;
      ((void) (0));
    }



    ((void) (0));
    sqlite3BtreeEnter(pBt);
    pSorter->pgsz = pgsz = sqlite3BtreeGetPageSize(pBt);
    sqlite3BtreeLeave(pBt);
    pSorter->nTask = nWorker + 1;
    pSorter->iPrev = (u8)(nWorker - 1);
    pSorter->bUseThreads = (pSorter->nTask>1);
    pSorter->db = db;
    for(i=0; i<pSorter->nTask; i++){
      SortSubtask *pTask = &pSorter->aTask[i];
      pTask->pSorter = pSorter;
    }

    if( !sqlite3TempInMemory(db) ){
      i64 mxCache;
      u32 szPma = sqlite3Config.szPma;
      pSorter->mnPmaSize = szPma * pgsz;

      mxCache = db->aDb[0].pSchema->cache_size;
      if( mxCache<0 ){


        mxCache = mxCache * -1024;
      }else{
        mxCache = mxCache * pgsz;
      }
      mxCache = ((mxCache)<((1<<29))?(mxCache):((1<<29)));
      pSorter->mxPmaSize = ((pSorter->mnPmaSize)>((int)mxCache)?(pSorter->mnPmaSize):((int)mxCache));



      if( sqlite3Config.bSmallMalloc==0 ){
        ((void) (0));
        pSorter->nMemory = pgsz;
        pSorter->list.aMemory = (u8*)sqlite3Malloc(pgsz);
        if( !pSorter->list.aMemory ) rc = 7;
      }
    }

    if( pKeyInfo->nAllField<13
     && (pKeyInfo->aColl[0]==0 || pKeyInfo->aColl[0]==db->pDfltColl)
     && (pKeyInfo->aSortFlags[0] & 0x02)==0
    ){
      pSorter->typeMask = 0x01 | 0x02;
    }
  }

  return rc;
}





static void vdbeSorterRecordFree(sqlite3 *db, SorterRecord *pRecord){
  SorterRecord *p;
  SorterRecord *pNext;
  for(p=pRecord; p; p=pNext){
    pNext = p->u.pNext;
    sqlite3DbFree(db, p);
  }
}





static void vdbeSortSubtaskCleanup(sqlite3 *db, SortSubtask *pTask){
  sqlite3DbFree(db, pTask->pUnpacked);



  if( pTask->list.aMemory ){
    sqlite3_free(pTask->list.aMemory);
  }else

  {
    ((void) (0));
    vdbeSorterRecordFree(0, pTask->list.pList);
  }
  if( pTask->file.pFd ){
    sqlite3OsCloseFree(pTask->file.pFd);
  }
  if( pTask->file2.pFd ){
    sqlite3OsCloseFree(pTask->file2.pFd);
  }
  memset(pTask, 0, sizeof(SortSubtask));
}
# 106280 "c_tests/sqlite3.c"
static int vdbeSorterJoinThread(SortSubtask *pTask){
  int rc = 0;
  if( pTask->pThread ){



    void *pRet = ((void*)(long int)(1));
                                                ;
    (void)sqlite3ThreadJoin(pTask->pThread, &pRet);
                                               ;
    rc = ((int)(long int)(pRet));
    ((void) (0));
    pTask->bDone = 0;
    pTask->pThread = 0;
  }
  return rc;
}




static int vdbeSorterCreateThread(
  SortSubtask *pTask,
  void *(*xTask)(void*),
  void *pIn
){
  ((void) (0));
  return sqlite3ThreadCreate(&pTask->pThread, xTask, pIn);
}





static int vdbeSorterJoinAll(VdbeSorter *pSorter, int rcin){
  int rc = rcin;
  int i;
# 106325 "c_tests/sqlite3.c"
  for(i=pSorter->nTask-1; i>=0; i--){
    SortSubtask *pTask = &pSorter->aTask[i];
    int rc2 = vdbeSorterJoinThread(pTask);
    if( rc==0 ) rc = rc2;
  }
  return rc;
}
# 106344 "c_tests/sqlite3.c"
static MergeEngine *vdbeMergeEngineNew(int nReader){
  int N = 2;
  i64 nByte;
  MergeEngine *pNew;

  ((void) (0));

  while( N<nReader ) N += N;
  nByte = sizeof(MergeEngine) + N * (sizeof(int) + sizeof(PmaReader));

  pNew = sqlite3FaultSim(100) ? 0 : (MergeEngine*)sqlite3MallocZero(nByte);
  if( pNew ){
    pNew->nTree = N;
    pNew->pTask = 0;
    pNew->aReadr = (PmaReader*)&pNew[1];
    pNew->aTree = (int*)&pNew->aReadr[N];
  }
  return pNew;
}




static void vdbeMergeEngineFree(MergeEngine *pMerger){
  int i;
  if( pMerger ){
    for(i=0; i<pMerger->nTree; i++){
      vdbePmaReaderClear(&pMerger->aReadr[i]);
    }
  }
  sqlite3_free(pMerger);
}





static void vdbeIncrFree(IncrMerger *pIncr){
  if( pIncr ){

    if( pIncr->bUseThread ){
      vdbeSorterJoinThread(pIncr->pTask);
      if( pIncr->aFile[0].pFd ) sqlite3OsCloseFree(pIncr->aFile[0].pFd);
      if( pIncr->aFile[1].pFd ) sqlite3OsCloseFree(pIncr->aFile[1].pFd);
    }

    vdbeMergeEngineFree(pIncr->pMerger);
    sqlite3_free(pIncr);
  }
}




static void sqlite3VdbeSorterReset(sqlite3 *db, VdbeSorter *pSorter){
  int i;
  (void)vdbeSorterJoinAll(pSorter, 0);
  ((void) (0));

  if( pSorter->pReader ){
    vdbePmaReaderClear(pSorter->pReader);
    sqlite3DbFree(db, pSorter->pReader);
    pSorter->pReader = 0;
  }

  vdbeMergeEngineFree(pSorter->pMerger);
  pSorter->pMerger = 0;
  for(i=0; i<pSorter->nTask; i++){
    SortSubtask *pTask = &pSorter->aTask[i];
    vdbeSortSubtaskCleanup(db, pTask);
    pTask->pSorter = pSorter;
  }
  if( pSorter->list.aMemory==0 ){
    vdbeSorterRecordFree(0, pSorter->list.pList);
  }
  pSorter->list.pList = 0;
  pSorter->list.szPMA = 0;
  pSorter->bUsePMA = 0;
  pSorter->iMemory = 0;
  pSorter->mxKeysize = 0;
  sqlite3DbFree(db, pSorter->pUnpacked);
  pSorter->pUnpacked = 0;
}




static void sqlite3VdbeSorterClose(sqlite3 *db, VdbeCursor *pCsr){
  VdbeSorter *pSorter;
  ((void) (0));
  pSorter = pCsr->uc.pSorter;
  if( pSorter ){


    int ii;
    for(ii=0; ii<pSorter->nTask; ii++){
      db->nSpill += pSorter->aTask[ii].nSpill;
    }
    sqlite3VdbeSorterReset(db, pSorter);
    sqlite3_free(pSorter->list.aMemory);
    sqlite3DbFree(db, pSorter);
    pCsr->uc.pSorter = 0;
  }
}
# 106459 "c_tests/sqlite3.c"
static void vdbeSorterExtendFile(sqlite3 *db, sqlite3_file *pFd, i64 nByte){
  if( nByte<=(i64)(db->nMaxSorterMmap) && pFd->pMethods->iVersion>=3 ){
    void *p = 0;
    int chunksize = 4*1024;
    sqlite3OsFileControlHint(pFd, 6, &chunksize);
    sqlite3OsFileControlHint(pFd, 5, &nByte);
    sqlite3OsFetch(pFd, 0, (int)nByte, &p);
    if( p ) sqlite3OsUnfetch(pFd, 0, p);
  }
}
# 106478 "c_tests/sqlite3.c"
static int vdbeSorterOpenTempFile(
  sqlite3 *db,
  i64 nExtend,
  sqlite3_file **ppFd
){
  int rc;
  if( sqlite3FaultSim(202) ) return (10 | (13<<8));
  rc = sqlite3OsOpenMalloc(db->pVfs, 0, ppFd,
      0x00001000 |
      0x00000002 | 0x00000004 |
      0x00000010 | 0x00000008, &rc
  );
  if( rc==0 ){
    i64 max = 0x7fff0000;
    sqlite3OsFileControlHint(*ppFd, 18, (void*)&max);
    if( nExtend>0 ){
      vdbeSorterExtendFile(db, *ppFd, nExtend);
    }
  }
  return rc;
}






static int vdbeSortAllocUnpacked(SortSubtask *pTask){
  if( pTask->pUnpacked==0 ){
    pTask->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pTask->pSorter->pKeyInfo);
    if( pTask->pUnpacked==0 ) return 7;
    pTask->pUnpacked->nField = pTask->pSorter->pKeyInfo->nKeyField;
    pTask->pUnpacked->errCode = 0;
  }
  return 0;
}





static SorterRecord *vdbeSorterMerge(
  SortSubtask *pTask,
  SorterRecord *p1,
  SorterRecord *p2
){
  SorterRecord *pFinal = 0;
  SorterRecord **pp = &pFinal;
  int bCached = 0;

  ((void) (0));
  for(;;){
    int res;
    res = pTask->xCompare(
        pTask, &bCached, ((void*)((SorterRecord*)(p1) + 1)), p1->nVal, ((void*)((SorterRecord*)(p2) + 1)), p2->nVal
    );

    if( res<=0 ){
      *pp = p1;
      pp = &p1->u.pNext;
      p1 = p1->u.pNext;
      if( p1==0 ){
        *pp = p2;
        break;
      }
    }else{
      *pp = p2;
      pp = &p2->u.pNext;
      p2 = p2->u.pNext;
      bCached = 0;
      if( p2==0 ){
        *pp = p1;
        break;
      }
    }
  }
  return pFinal;
}





static SorterCompare vdbeSorterGetCompare(VdbeSorter *p){
  if( p->typeMask==0x01 ){
    return vdbeSorterCompareInt;
  }else if( p->typeMask==0x02 ){
    return vdbeSorterCompareText;
  }
  return vdbeSorterCompare;
}






static int vdbeSorterSort(SortSubtask *pTask, SorterList *pList){
  int i;
  SorterRecord *p;
  int rc;
  SorterRecord *aSlot[64];

  rc = vdbeSortAllocUnpacked(pTask);
  if( rc!=0 ) return rc;

  p = pList->pList;
  pTask->xCompare = vdbeSorterGetCompare(pTask->pSorter);
  memset(aSlot, 0, sizeof(aSlot));

  while( p ){
    SorterRecord *pNext;
    if( pList->aMemory ){
      if( (u8*)p==pList->aMemory ){
        pNext = 0;
      }else{
        ((void) (0));
        pNext = (SorterRecord*)&pList->aMemory[p->u.iNext];
      }
    }else{
      pNext = p->u.pNext;
    }

    p->u.pNext = 0;
    for(i=0; aSlot[i]; i++){
      p = vdbeSorterMerge(pTask, p, aSlot[i]);



      ((void) (0));
      aSlot[i] = 0;
    }
    aSlot[i] = p;
    p = pNext;
  }

  p = 0;
  for(i=0; i<((int)(sizeof(aSlot)/sizeof(aSlot[0]))); i++){
    if( aSlot[i]==0 ) continue;
    p = p ? vdbeSorterMerge(pTask, p, aSlot[i]) : aSlot[i];
  }
  pList->pList = p;

  ((void) (0));


  return pTask->pUnpacked->errCode;
}




static void vdbePmaWriterInit(
  sqlite3_file *pFd,
  PmaWriter *p,
  int nBuf,
  i64 iStart
){
  memset(p, 0, sizeof(PmaWriter));
  p->aBuffer = (u8*)sqlite3Malloc(nBuf);
  if( !p->aBuffer ){
    p->eFWErr = 7;
  }else{
    p->iBufEnd = p->iBufStart = (iStart % nBuf);
    p->iWriteOff = iStart - p->iBufStart;
    p->nBuffer = nBuf;
    p->pFd = pFd;
  }
}





static void vdbePmaWriteBlob(PmaWriter *p, u8 *pData, int nData){
  int nRem = nData;
  while( nRem>0 && p->eFWErr==0 ){
    int nCopy = nRem;
    if( nCopy>(p->nBuffer - p->iBufEnd) ){
      nCopy = p->nBuffer - p->iBufEnd;
    }

    memcpy(&p->aBuffer[p->iBufEnd], &pData[nData-nRem], nCopy);
    p->iBufEnd += nCopy;
    if( p->iBufEnd==p->nBuffer ){
      p->eFWErr = sqlite3OsWrite(p->pFd,
          &p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,
          p->iWriteOff + p->iBufStart
      );
      p->nPmaSpill += (p->iBufEnd - p->iBufStart);
      p->iBufStart = p->iBufEnd = 0;
      p->iWriteOff += p->nBuffer;
    }
    ((void) (0));

    nRem -= nCopy;
  }
}
# 106687 "c_tests/sqlite3.c"
static int vdbePmaWriterFinish(PmaWriter *p, i64 *piEof, u64 *pnSpill){
  int rc;
  if( p->eFWErr==0 && (p->aBuffer) && p->iBufEnd>p->iBufStart ){
    p->eFWErr = sqlite3OsWrite(p->pFd,
        &p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,
        p->iWriteOff + p->iBufStart
    );
    p->nPmaSpill += (p->iBufEnd - p->iBufStart);
  }
  *piEof = (p->iWriteOff + p->iBufEnd);
  *pnSpill += p->nPmaSpill;
  sqlite3_free(p->aBuffer);
  rc = p->eFWErr;
  memset(p, 0, sizeof(PmaWriter));
  return rc;
}





static void vdbePmaWriteVarint(PmaWriter *p, u64 iVal){
  int nByte;
  u8 aByte[10];
  nByte = sqlite3PutVarint(aByte, iVal);
  vdbePmaWriteBlob(p, aByte, nByte);
}
# 106729 "c_tests/sqlite3.c"
static int vdbeSorterListToPMA(SortSubtask *pTask, SorterList *pList){
  sqlite3 *db = pTask->pSorter->db;
  int rc = 0;
  PmaWriter writer;







                                     ;
  memset(&writer, 0, sizeof(PmaWriter));
  ((void) (0));


  if( pTask->file.pFd==0 ){
    rc = vdbeSorterOpenTempFile(db, 0, &pTask->file.pFd);
    ((void) (0));
    ((void) (0));
    ((void) (0));
  }


  if( rc==0 ){
    vdbeSorterExtendFile(db, pTask->file.pFd, pTask->file.iEof+pList->szPMA+9);
  }


  if( rc==0 ){
    rc = vdbeSorterSort(pTask, pList);
  }

  if( rc==0 ){
    SorterRecord *p;
    SorterRecord *pNext = 0;

    vdbePmaWriterInit(pTask->file.pFd, &writer, pTask->pSorter->pgsz,
                      pTask->file.iEof);
    pTask->nPMA++;
    vdbePmaWriteVarint(&writer, pList->szPMA);
    for(p=pList->pList; p; p=pNext){
      pNext = p->u.pNext;
      vdbePmaWriteVarint(&writer, p->nVal);
      vdbePmaWriteBlob(&writer, ((void*)((SorterRecord*)(p) + 1)), p->nVal);
      if( pList->aMemory==0 ) sqlite3_free(p);
    }
    pList->pList = p;
    rc = vdbePmaWriterFinish(&writer, &pTask->file.iEof, &pTask->nSpill);
  }

                                    ;
  ((void) (0));
  ((void) (0));
  return rc;
}
# 106793 "c_tests/sqlite3.c"
static int vdbeMergeEngineStep(
  MergeEngine *pMerger,
  int *pbEof
){
  int rc;
  int iPrev = pMerger->aTree[1];
  SortSubtask *pTask = pMerger->pTask;


  rc = vdbePmaReaderNext(&pMerger->aReadr[iPrev]);


  if( rc==0 ){
    int i;
    PmaReader *pReadr1;
    PmaReader *pReadr2;
    int bCached = 0;



    pReadr1 = &pMerger->aReadr[(iPrev & 0xFFFE)];
    pReadr2 = &pMerger->aReadr[(iPrev | 0x0001)];

    for(i=(pMerger->nTree+iPrev)/2; i>0; i=i/2){

      int iRes;
      if( pReadr1->pFd==0 ){
        iRes = +1;
      }else if( pReadr2->pFd==0 ){
        iRes = -1;
      }else{
        iRes = pTask->xCompare(pTask, &bCached,
            pReadr1->aKey, pReadr1->nKey, pReadr2->aKey, pReadr2->nKey
        );
      }
# 106844 "c_tests/sqlite3.c"
      if( iRes<0 || (iRes==0 && pReadr1<pReadr2) ){
        pMerger->aTree[i] = (int)(pReadr1 - pMerger->aReadr);
        pReadr2 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];
        bCached = 0;
      }else{
        if( pReadr1->pFd ) bCached = 0;
        pMerger->aTree[i] = (int)(pReadr2 - pMerger->aReadr);
        pReadr1 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];
      }
    }
    *pbEof = (pMerger->aReadr[pMerger->aTree[1]].pFd==0);
  }

  return (rc==0 ? pTask->pUnpacked->errCode : rc);
}





static void *vdbeSorterFlushThread(void *pCtx){
  SortSubtask *pTask = (SortSubtask*)pCtx;
  int rc;
  ((void) (0));
  rc = vdbeSorterListToPMA(pTask, &pTask->list);
  pTask->bDone = 1;
  return ((void*)(long int)(rc));
}






static int vdbeSorterFlushPMA(VdbeSorter *pSorter){




  int rc = 0;
  int i;
  SortSubtask *pTask = 0;
  int nWorker = (pSorter->nTask-1);



  pSorter->bUsePMA = 1;
# 106900 "c_tests/sqlite3.c"
  for(i=0; i<nWorker; i++){
    int iTest = (pSorter->iPrev + i + 1) % nWorker;
    pTask = &pSorter->aTask[iTest];
    if( pTask->bDone ){
      rc = vdbeSorterJoinThread(pTask);
    }
    if( rc!=0 || pTask->pThread==0 ) break;
  }

  if( rc==0 ){
    if( i==nWorker ){

      rc = vdbeSorterListToPMA(&pSorter->aTask[nWorker], &pSorter->list);
    }else{

      u8 *aMem;
      void *pCtx;

      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));

      aMem = pTask->list.aMemory;
      pCtx = (void*)pTask;
      pSorter->iPrev = (u8)(pTask - pSorter->aTask);
      pTask->list = pSorter->list;
      pSorter->list.pList = 0;
      pSorter->list.szPMA = 0;
      if( aMem ){
        pSorter->list.aMemory = aMem;
        pSorter->nMemory = sqlite3MallocSize(aMem);
      }else if( pSorter->list.aMemory ){
        pSorter->list.aMemory = sqlite3Malloc(pSorter->nMemory);
        if( !pSorter->list.aMemory ) return 7;
      }

      rc = vdbeSorterCreateThread(pTask, vdbeSorterFlushThread, pCtx);
    }
  }

  return rc;

}




static int sqlite3VdbeSorterWrite(
  const VdbeCursor *pCsr,
  Mem *pVal
){
  VdbeSorter *pSorter;
  int rc = 0;
  SorterRecord *pNew;
  int bFlush;
  i64 nReq;
  i64 nPMA;
  int t;

  ((void) (0));
  pSorter = pCsr->uc.pSorter;
  t=(u32)*((const u8*)&pVal->z[1]);if(t>=0x80)sqlite3GetVarint32(((const u8*)&pVal->z[1]),(u32*)&(t));
  if( t>0 && t<10 && t!=7 ){
    pSorter->typeMask &= 0x01;
  }else if( t>10 && (t & 0x01) ){
    pSorter->typeMask &= 0x02;
  }else{
    pSorter->typeMask = 0;
  }

  ((void) (0));
# 106989 "c_tests/sqlite3.c"
  nReq = pVal->n + sizeof(SorterRecord);
  nPMA = pVal->n + sqlite3VarintLen(pVal->n);
  if( pSorter->mxPmaSize ){
    if( pSorter->list.aMemory ){
      bFlush = pSorter->iMemory && (pSorter->iMemory+nReq) > pSorter->mxPmaSize;
    }else{
      bFlush = (
          (pSorter->list.szPMA > pSorter->mxPmaSize)
       || (pSorter->list.szPMA > pSorter->mnPmaSize && sqlite3HeapNearlyFull())
      );
    }
    if( bFlush ){
      rc = vdbeSorterFlushPMA(pSorter);
      pSorter->list.szPMA = 0;
      pSorter->iMemory = 0;
      ((void) (0));
    }
  }

  pSorter->list.szPMA += nPMA;
  if( nPMA>pSorter->mxKeysize ){
    pSorter->mxKeysize = nPMA;
  }

  if( pSorter->list.aMemory ){
    int nMin = pSorter->iMemory + nReq;

    if( nMin>pSorter->nMemory ){
      u8 *aNew;
      sqlite3_int64 nNew = 2 * (sqlite3_int64)pSorter->nMemory;
      int iListOff = -1;
      if( pSorter->list.pList ){
        iListOff = (u8*)pSorter->list.pList - pSorter->list.aMemory;
      }
      while( nNew < nMin ) nNew = nNew*2;
      if( nNew > pSorter->mxPmaSize ) nNew = pSorter->mxPmaSize;
      if( nNew < nMin ) nNew = nMin;
      aNew = sqlite3Realloc(pSorter->list.aMemory, nNew);
      if( !aNew ) return 7;
      if( iListOff>=0 ){
        pSorter->list.pList = (SorterRecord*)&aNew[iListOff];
      }
      pSorter->list.aMemory = aNew;
      pSorter->nMemory = nNew;
    }

    pNew = (SorterRecord*)&pSorter->list.aMemory[pSorter->iMemory];
    pSorter->iMemory += (((nReq)+7)&~7);
    if( pSorter->list.pList ){
      pNew->u.iNext = (int)((u8*)(pSorter->list.pList) - pSorter->list.aMemory);
    }
  }else{
    pNew = (SorterRecord *)sqlite3Malloc(nReq);
    if( pNew==0 ){
      return 7;
    }
    pNew->u.pNext = pSorter->list.pList;
  }

  memcpy(((void*)((SorterRecord*)(pNew) + 1)), pVal->z, pVal->n);
  pNew->nVal = pVal->n;
  pSorter->list.pList = pNew;

  return rc;
}






static int vdbeIncrPopulate(IncrMerger *pIncr){
  int rc = 0;
  int rc2;
  i64 iStart = pIncr->iStartOff;
  SorterFile *pOut = &pIncr->aFile[1];
  SortSubtask *pTask = pIncr->pTask;
  MergeEngine *pMerger = pIncr->pMerger;
  PmaWriter writer;
  ((void) (0));

                                         ;

  vdbePmaWriterInit(pOut->pFd, &writer, pTask->pSorter->pgsz, iStart);
  while( rc==0 ){
    int dummy;
    PmaReader *pReader = &pMerger->aReadr[ pMerger->aTree[1] ];
    int nKey = pReader->nKey;
    i64 iEof = writer.iWriteOff + writer.iBufEnd;



    if( pReader->pFd==0 ) break;
    if( (iEof + nKey + sqlite3VarintLen(nKey))>(iStart + pIncr->mxSz) ) break;


    vdbePmaWriteVarint(&writer, nKey);
    vdbePmaWriteBlob(&writer, pReader->aKey, nKey);
    ((void) (0));
    rc = vdbeMergeEngineStep(pIncr->pMerger, &dummy);
  }

  rc2 = vdbePmaWriterFinish(&writer, &pOut->iEof, &pTask->nSpill);
  if( rc==0 ) rc = rc2;
                                        ;
  return rc;
}






static void *vdbeIncrPopulateThread(void *pCtx){
  IncrMerger *pIncr = (IncrMerger*)pCtx;
  void *pRet = ((void*)(long int)(vdbeIncrPopulate(pIncr)));
  pIncr->pTask->bDone = 1;
  return pRet;
}




static int vdbeIncrBgPopulate(IncrMerger *pIncr){
  void *p = (void*)pIncr;
  ((void) (0));
  return vdbeSorterCreateThread(pIncr->pTask, vdbeIncrPopulateThread, p);
}
# 107136 "c_tests/sqlite3.c"
static int vdbeIncrSwap(IncrMerger *pIncr){
  int rc = 0;


  if( pIncr->bUseThread ){
    rc = vdbeSorterJoinThread(pIncr->pTask);

    if( rc==0 ){
      SorterFile f0 = pIncr->aFile[0];
      pIncr->aFile[0] = pIncr->aFile[1];
      pIncr->aFile[1] = f0;
    }

    if( rc==0 ){
      if( pIncr->aFile[0].iEof==pIncr->iStartOff ){
        pIncr->bEof = 1;
      }else{
        rc = vdbeIncrBgPopulate(pIncr);
      }
    }
  }else

  {
    rc = vdbeIncrPopulate(pIncr);
    pIncr->aFile[0] = pIncr->aFile[1];
    if( pIncr->aFile[0].iEof==pIncr->iStartOff ){
      pIncr->bEof = 1;
    }
  }

  return rc;
}







static int vdbeIncrMergerNew(
  SortSubtask *pTask,
  MergeEngine *pMerger,
  IncrMerger **ppOut
){
  int rc = 0;
  IncrMerger *pIncr = *ppOut = (IncrMerger*)
       (sqlite3FaultSim(100) ? 0 : sqlite3MallocZero(sizeof(*pIncr)));
  if( pIncr ){
    pIncr->pMerger = pMerger;
    pIncr->pTask = pTask;
    pIncr->mxSz = ((pTask->pSorter->mxKeysize+9)>(pTask->pSorter->mxPmaSize/2)?(pTask->pSorter->mxKeysize+9):(pTask->pSorter->mxPmaSize/2));
    pTask->file2.iEof += pIncr->mxSz;
  }else{
    vdbeMergeEngineFree(pMerger);
    rc = 7;
  }
  ((void) (0));
  return rc;
}





static void vdbeIncrMergerSetThreads(IncrMerger *pIncr){
  pIncr->bUseThread = 1;
  pIncr->pTask->file2.iEof -= pIncr->mxSz;
}
# 107213 "c_tests/sqlite3.c"
static void vdbeMergeEngineCompare(
  MergeEngine *pMerger,
  int iOut
){
  int i1;
  int i2;
  int iRes;
  PmaReader *p1;
  PmaReader *p2;

  ((void) (0));

  if( iOut>=(pMerger->nTree/2) ){
    i1 = (iOut - pMerger->nTree/2) * 2;
    i2 = i1 + 1;
  }else{
    i1 = pMerger->aTree[iOut*2];
    i2 = pMerger->aTree[iOut*2+1];
  }

  p1 = &pMerger->aReadr[i1];
  p2 = &pMerger->aReadr[i2];

  if( p1->pFd==0 ){
    iRes = i2;
  }else if( p2->pFd==0 ){
    iRes = i1;
  }else{
    SortSubtask *pTask = pMerger->pTask;
    int bCached = 0;
    int res;
    ((void) (0));
    res = pTask->xCompare(
        pTask, &bCached, p1->aKey, p1->nKey, p2->aKey, p2->nKey
    );
    if( res<=0 ){
      iRes = i1;
    }else{
      iRes = i2;
    }
  }

  pMerger->aTree[iOut] = iRes;
}
# 107275 "c_tests/sqlite3.c"
static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode);
# 107295 "c_tests/sqlite3.c"
static int vdbeMergeEngineInit(
  SortSubtask *pTask,
  MergeEngine *pMerger,
  int eMode
){
  int rc = 0;
  int i;
  int nTree;



  ((void) (0));


  ((void) (0));


  ((void) (0));
  pMerger->pTask = pTask;

  nTree = pMerger->nTree;
  for(i=0; i<nTree; i++){
    if( 8>0 && eMode==2 ){







      rc = vdbePmaReaderNext(&pMerger->aReadr[nTree-i-1]);
    }else{
      rc = vdbePmaReaderIncrInit(&pMerger->aReadr[i], 0);
    }
    if( rc!=0 ) return rc;
  }

  for(i=pMerger->nTree-1; i>0; i--){
    vdbeMergeEngineCompare(pMerger, i);
  }
  return pTask->pUnpacked->errCode;
}
# 107371 "c_tests/sqlite3.c"
static int vdbePmaReaderIncrMergeInit(PmaReader *pReadr, int eMode){
  int rc = 0;
  IncrMerger *pIncr = pReadr->pIncr;
  SortSubtask *pTask = pIncr->pTask;
  sqlite3 *db = pTask->pSorter->db;


  ((void) (0));

  rc = vdbeMergeEngineInit(pTask, pIncr->pMerger, eMode);




  if( rc==0 ){
    int mxSz = pIncr->mxSz;

    if( pIncr->bUseThread ){
      rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[0].pFd);
      if( rc==0 ){
        rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[1].pFd);
      }
    }else

                                {
      if( pTask->file2.pFd==0 ){
        ((void) (0));
        rc = vdbeSorterOpenTempFile(db, pTask->file2.iEof, &pTask->file2.pFd);
        pTask->file2.iEof = 0;
      }
      if( rc==0 ){
        pIncr->aFile[1].pFd = pTask->file2.pFd;
        pIncr->iStartOff = pTask->file2.iEof;
        pTask->file2.iEof += mxSz;
      }
    }
  }


  if( rc==0 && pIncr->bUseThread ){
# 107421 "c_tests/sqlite3.c"
    ((void) (0));
    rc = vdbeIncrPopulate(pIncr);
  }


  if( rc==0 && (8==0 || eMode!=1) ){
    rc = vdbePmaReaderNext(pReadr);
  }

  return rc;
}






static void *vdbePmaReaderBgIncrInit(void *pCtx){
  PmaReader *pReader = (PmaReader*)pCtx;
  void *pRet = ((void*)(long int)(vdbePmaReaderIncrMergeInit(pReader,1)));


  pReader->pIncr->pTask->bDone = 1;
  return pRet;
}
# 107459 "c_tests/sqlite3.c"
static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode){
  IncrMerger *pIncr = pReadr->pIncr;
  int rc = 0;
  if( pIncr ){

    ((void) (0));
    if( pIncr->bUseThread ){
      void *pCtx = (void*)pReadr;
      rc = vdbeSorterCreateThread(pIncr->pTask, vdbePmaReaderBgIncrInit, pCtx);
    }else

    {
      rc = vdbePmaReaderIncrMergeInit(pReadr, eMode);
    }
  }
  return rc;
}
# 107489 "c_tests/sqlite3.c"
static int vdbeMergeEngineLevel0(
  SortSubtask *pTask,
  int nPMA,
  i64 *piOffset,
  MergeEngine **ppOut
){
  MergeEngine *pNew;
  i64 iOff = *piOffset;
  int i;
  int rc = 0;

  *ppOut = pNew = vdbeMergeEngineNew(nPMA);
  if( pNew==0 ) rc = 7;

  for(i=0; i<nPMA && rc==0; i++){
    i64 nDummy = 0;
    PmaReader *pReadr = &pNew->aReadr[i];
    rc = vdbePmaReaderInit(pTask, &pTask->file, iOff, pReadr, &nDummy);
    iOff = pReadr->iEof;
  }

  if( rc!=0 ){
    vdbeMergeEngineFree(pNew);
    *ppOut = 0;
  }
  *piOffset = iOff;
  return rc;
}
# 107528 "c_tests/sqlite3.c"
static int vdbeSorterTreeDepth(int nPMA){
  int nDepth = 0;
  i64 nDiv = 16;
  while( nDiv < (i64)nPMA ){
    nDiv = nDiv * 16;
    nDepth++;
  }
  return nDepth;
}
# 107546 "c_tests/sqlite3.c"
static int vdbeSorterAddToTree(
  SortSubtask *pTask,
  int nDepth,
  int iSeq,
  MergeEngine *pRoot,
  MergeEngine *pLeaf
){
  int rc = 0;
  int nDiv = 1;
  int i;
  MergeEngine *p = pRoot;
  IncrMerger *pIncr;

  rc = vdbeIncrMergerNew(pTask, pLeaf, &pIncr);

  for(i=1; i<nDepth; i++){
    nDiv = nDiv * 16;
  }

  for(i=1; i<nDepth && rc==0; i++){
    int iIter = (iSeq / nDiv) % 16;
    PmaReader *pReadr = &p->aReadr[iIter];

    if( pReadr->pIncr==0 ){
      MergeEngine *pNew = vdbeMergeEngineNew(16);
      if( pNew==0 ){
        rc = 7;
      }else{
        rc = vdbeIncrMergerNew(pTask, pNew, &pReadr->pIncr);
      }
    }
    if( rc==0 ){
      p = pReadr->pIncr->pMerger;
      nDiv = nDiv / 16;
    }
  }

  if( rc==0 ){
    p->aReadr[iSeq % 16].pIncr = pIncr;
  }else{
    vdbeIncrFree(pIncr);
  }
  return rc;
}
# 107602 "c_tests/sqlite3.c"
static int vdbeSorterMergeTreeBuild(
  VdbeSorter *pSorter,
  MergeEngine **ppOut
){
  MergeEngine *pMain = 0;
  int rc = 0;
  int iTask;





  ((void) (0));
  if( pSorter->nTask>1 ){
    pMain = vdbeMergeEngineNew(pSorter->nTask);
    if( pMain==0 ) rc = 7;
  }


  for(iTask=0; rc==0 && iTask<pSorter->nTask; iTask++){
    SortSubtask *pTask = &pSorter->aTask[iTask];
    ((void) (0));
    if( 8==0 || pTask->nPMA ){
      MergeEngine *pRoot = 0;
      int nDepth = vdbeSorterTreeDepth(pTask->nPMA);
      i64 iReadOff = 0;

      if( pTask->nPMA<=16 ){
        rc = vdbeMergeEngineLevel0(pTask, pTask->nPMA, &iReadOff, &pRoot);
      }else{
        int i;
        int iSeq = 0;
        pRoot = vdbeMergeEngineNew(16);
        if( pRoot==0 ) rc = 7;
        for(i=0; i<pTask->nPMA && rc==0; i += 16){
          MergeEngine *pMerger = 0;
          int nReader;

          nReader = ((pTask->nPMA - i)<(16)?(pTask->nPMA - i):(16));
          rc = vdbeMergeEngineLevel0(pTask, nReader, &iReadOff, &pMerger);
          if( rc==0 ){
            rc = vdbeSorterAddToTree(pTask, nDepth, iSeq++, pRoot, pMerger);
          }
        }
      }

      if( rc==0 ){

        if( pMain!=0 ){
          rc = vdbeIncrMergerNew(pTask, pRoot, &pMain->aReadr[iTask].pIncr);
        }else

        {
          ((void) (0));
          pMain = pRoot;
        }
      }else{
        vdbeMergeEngineFree(pRoot);
      }
    }
  }

  if( rc!=0 ){
    vdbeMergeEngineFree(pMain);
    pMain = 0;
  }
  *ppOut = pMain;
  return rc;
}
# 107681 "c_tests/sqlite3.c"
static int vdbeSorterSetupMerge(VdbeSorter *pSorter){
  int rc;
  SortSubtask *pTask0 = &pSorter->aTask[0];
  MergeEngine *pMain = 0;

  sqlite3 *db = pTask0->pSorter->db;
  int i;
  SorterCompare xCompare = vdbeSorterGetCompare(pSorter);
  for(i=0; i<pSorter->nTask; i++){
    pSorter->aTask[i].xCompare = xCompare;
  }


  rc = vdbeSorterMergeTreeBuild(pSorter, &pMain);
  if( rc==0 ){

    ((void) (0));
    if( pSorter->bUseThreads ){
      int iTask;
      PmaReader *pReadr = 0;
      SortSubtask *pLast = &pSorter->aTask[pSorter->nTask-1];
      rc = vdbeSortAllocUnpacked(pLast);
      if( rc==0 ){
        pReadr = (PmaReader*)sqlite3DbMallocZero(db, sizeof(PmaReader));
        pSorter->pReader = pReadr;
        if( pReadr==0 ) rc = 7;
      }
      if( rc==0 ){
        rc = vdbeIncrMergerNew(pLast, pMain, &pReadr->pIncr);
        if( rc==0 ){
          vdbeIncrMergerSetThreads(pReadr->pIncr);
          for(iTask=0; iTask<(pSorter->nTask-1); iTask++){
            IncrMerger *pIncr;
            if( (pIncr = pMain->aReadr[iTask].pIncr) ){
              vdbeIncrMergerSetThreads(pIncr);
              ((void) (0));
            }
          }
          for(iTask=0; rc==0 && iTask<pSorter->nTask; iTask++){
# 107729 "c_tests/sqlite3.c"
            PmaReader *p = &pMain->aReadr[iTask];
            ((void) (0));



            rc = vdbePmaReaderIncrInit(p, 1);
          }
        }
        pMain = 0;
      }
      if( rc==0 ){
        rc = vdbePmaReaderIncrMergeInit(pReadr, 2);
      }
    }else

    {
      rc = vdbeMergeEngineInit(pTask0, pMain, 0);
      pSorter->pMerger = pMain;
      pMain = 0;
    }
  }

  if( rc!=0 ){
    vdbeMergeEngineFree(pMain);
  }
  return rc;
}







static int sqlite3VdbeSorterRewind(const VdbeCursor *pCsr, int *pbEof){
  VdbeSorter *pSorter;
  int rc = 0;

  ((void) (0));
  pSorter = pCsr->uc.pSorter;
  ((void) (0));




  if( pSorter->bUsePMA==0 ){
    if( pSorter->list.pList ){
      *pbEof = 0;
      rc = vdbeSorterSort(&pSorter->aTask[0], &pSorter->list);
    }else{
      *pbEof = 1;
    }
    return rc;
  }





  ((void) (0));
  rc = vdbeSorterFlushPMA(pSorter);


  rc = vdbeSorterJoinAll(pSorter, rc);

                                 ;



  ((void) (0));
  if( rc==0 ){
    rc = vdbeSorterSetupMerge(pSorter);
    *pbEof = 0;
  }

                                     ;
  return rc;
}
# 107815 "c_tests/sqlite3.c"
static int sqlite3VdbeSorterNext(sqlite3 *db, const VdbeCursor *pCsr){
  VdbeSorter *pSorter;
  int rc;

  ((void) (0));
  pSorter = pCsr->uc.pSorter;
  ((void) (0));
  if( pSorter->bUsePMA ){
    ((void) (0));
    ((void) (0));
    ((void) (0));

    if( pSorter->bUseThreads ){
      rc = vdbePmaReaderNext(pSorter->pReader);
      if( rc==0 && pSorter->pReader->pFd==0 ) rc = 101;
    }else

                                    {
      int res = 0;
      ((void) (0));
      ((void) (0));
      rc = vdbeMergeEngineStep(pSorter->pMerger, &res);
      if( rc==0 && res ) rc = 101;
    }
  }else{
    SorterRecord *pFree = pSorter->list.pList;
    pSorter->list.pList = pFree->u.pNext;
    pFree->u.pNext = 0;
    if( pSorter->list.aMemory==0 ) vdbeSorterRecordFree(db, pFree);
    rc = pSorter->list.pList ? 0 : 101;
  }
  return rc;
}





static void *vdbeSorterRowkey(
  const VdbeSorter *pSorter,
  int *pnKey
){
  void *pKey;
  if( pSorter->bUsePMA ){
    PmaReader *pReader;

    if( pSorter->bUseThreads ){
      pReader = pSorter->pReader;
    }else

                                   {
      pReader = &pSorter->pMerger->aReadr[pSorter->pMerger->aTree[1]];
    }
    *pnKey = pReader->nKey;
    pKey = pReader->aKey;
  }else{
    *pnKey = pSorter->list.pList->nVal;
    pKey = ((void*)((SorterRecord*)(pSorter->list.pList) + 1));
  }
  return pKey;
}




static int sqlite3VdbeSorterRowkey(const VdbeCursor *pCsr, Mem *pOut){
  VdbeSorter *pSorter;
  void *pKey; int nKey;

  ((void) (0));
  pSorter = pCsr->uc.pSorter;
  pKey = vdbeSorterRowkey(pSorter, &nKey);
  if( sqlite3VdbeMemClearAndResize(pOut, nKey) ){
    return 7;
  }
  pOut->n = nKey;
  ((pOut)->flags = ((pOut)->flags&~(0x0dbf|0x0400))|0x0010);
  memcpy(pOut->z, pKey, nKey);

  return 0;
}
# 107913 "c_tests/sqlite3.c"
static int sqlite3VdbeSorterCompare(
  const VdbeCursor *pCsr,
  Mem *pVal,
  int nKeyCol,
  int *pRes
){
  VdbeSorter *pSorter;
  UnpackedRecord *r2;
  KeyInfo *pKeyInfo;
  int i;
  void *pKey; int nKey;

  ((void) (0));
  pSorter = pCsr->uc.pSorter;
  r2 = pSorter->pUnpacked;
  pKeyInfo = pCsr->pKeyInfo;
  if( r2==0 ){
    r2 = pSorter->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
    if( r2==0 ) return 7;
    r2->nField = nKeyCol;
  }
  ((void) (0));

  pKey = vdbeSorterRowkey(pSorter, &nKey);
  sqlite3VdbeRecordUnpack(nKey, pKey, r2);
  for(i=0; i<nKeyCol; i++){
    if( r2->aMem[i].flags & 0x0001 ){
      *pRes = -1;
      return 0;
    }
  }

  *pRes = sqlite3VdbeRecordCompare(pVal->n, pVal->z, r2);
  return 0;
}
# 108428 "c_tests/sqlite3.c"
typedef struct MemJournal MemJournal;
typedef struct FilePoint FilePoint;
typedef struct FileChunk FileChunk;







struct FileChunk {
  FileChunk *pNext;
  u8 zChunk[8];
};
# 108458 "c_tests/sqlite3.c"
struct FilePoint {
  sqlite3_int64 iOffset;
  FileChunk *pChunk;
};





struct MemJournal {
  const sqlite3_io_methods *pMethod;
  int nChunkSize;

  int nSpill;
  FileChunk *pFirst;
  FilePoint endpoint;
  FilePoint readpoint;

  int flags;
  sqlite3_vfs *pVfs;
  const char *zJournal;
};





static int memjrnlRead(
  sqlite3_file *pJfd,
  void *zBuf,
  int iAmt,
  sqlite_int64 iOfst
){
  MemJournal *p = (MemJournal *)pJfd;
  u8 *zOut = zBuf;
  int nRead = iAmt;
  int iChunkOffset;
  FileChunk *pChunk;

  if( (iAmt+iOfst)>p->endpoint.iOffset ){
    return (10 | (2<<8));
  }
  ((void) (0));
  if( p->readpoint.iOffset!=iOfst || iOfst==0 ){
    sqlite3_int64 iOff = 0;
    for(pChunk=p->pFirst;
        (pChunk) && (iOff+p->nChunkSize)<=iOfst;
        pChunk=pChunk->pNext
    ){
      iOff += p->nChunkSize;
    }
  }else{
    pChunk = p->readpoint.pChunk;
    ((void) (0));
  }

  iChunkOffset = (int)(iOfst%p->nChunkSize);
  do {
    int iSpace = p->nChunkSize - iChunkOffset;
    int nCopy = ((nRead)<((p->nChunkSize - iChunkOffset))?(nRead):((p->nChunkSize - iChunkOffset)));
    memcpy(zOut, (u8*)pChunk->zChunk + iChunkOffset, nCopy);
    zOut += nCopy;
    nRead -= iSpace;
    iChunkOffset = 0;
  } while( nRead>=0 && (pChunk=pChunk->pNext)!=0 && nRead>0 );
  p->readpoint.iOffset = pChunk ? iOfst+iAmt : 0;
  p->readpoint.pChunk = pChunk;

  return 0;
}




static void memjrnlFreeChunks(FileChunk *pFirst){
  FileChunk *pIter;
  FileChunk *pNext;
  for(pIter=pFirst; pIter; pIter=pNext){
    pNext = pIter->pNext;
    sqlite3_free(pIter);
  }
}




static int memjrnlCreateFile(MemJournal *p){
  int rc;
  sqlite3_file *pReal = (sqlite3_file*)p;
  MemJournal copy = *p;

  memset(p, 0, sizeof(MemJournal));
  rc = sqlite3OsOpen(copy.pVfs, copy.zJournal, pReal, copy.flags, 0);
  if( rc==0 ){
    int nChunk = copy.nChunkSize;
    i64 iOff = 0;
    FileChunk *pIter;
    for(pIter=copy.pFirst; pIter; pIter=pIter->pNext){
      if( iOff + nChunk > copy.endpoint.iOffset ){
        nChunk = copy.endpoint.iOffset - iOff;
      }
      rc = sqlite3OsWrite(pReal, (u8*)pIter->zChunk, nChunk, iOff);
      if( rc ) break;
      iOff += nChunk;
    }
    if( rc==0 ){

      memjrnlFreeChunks(copy.pFirst);
    }
  }
  if( rc!=0 ){




    sqlite3OsClose(pReal);
    *p = copy;
  }
  return rc;
}



static int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size);




static int memjrnlWrite(
  sqlite3_file *pJfd,
  const void *zBuf,
  int iAmt,
  sqlite_int64 iOfst
){
  MemJournal *p = (MemJournal *)pJfd;
  int nWrite = iAmt;
  u8 *zWrite = (u8 *)zBuf;



  if( p->nSpill>0 && (iAmt+iOfst)>p->nSpill ){
    int rc = memjrnlCreateFile(p);
    if( rc==0 ){
      rc = sqlite3OsWrite(pJfd, zBuf, iAmt, iOfst);
    }
    return rc;
  }


  else{





    ((void) (0));
    if( iOfst>0 && iOfst!=p->endpoint.iOffset ){
      memjrnlTruncate(pJfd, iOfst);
    }
    if( iOfst==0 && p->pFirst ){
      ((void) (0));
      memcpy((u8*)p->pFirst->zChunk, zBuf, iAmt);
    }else{
      while( nWrite>0 ){
        FileChunk *pChunk = p->endpoint.pChunk;
        int iChunkOffset = (int)(p->endpoint.iOffset%p->nChunkSize);
        int iSpace = ((nWrite)<(p->nChunkSize - iChunkOffset)?(nWrite):(p->nChunkSize - iChunkOffset));

        ((void) (0));
        if( iChunkOffset==0 ){

          FileChunk *pNew = sqlite3_malloc((sizeof(FileChunk) + ((p->nChunkSize)-8)));
          if( !pNew ){
            return (10 | (12<<8));
          }
          pNew->pNext = 0;
          if( pChunk ){
            ((void) (0));
            pChunk->pNext = pNew;
          }else{
            ((void) (0));
            p->pFirst = pNew;
          }
          pChunk = p->endpoint.pChunk = pNew;
        }

        ((void) (0));
        memcpy((u8*)pChunk->zChunk + iChunkOffset, zWrite, iSpace);
        zWrite += iSpace;
        nWrite -= iSpace;
        p->endpoint.iOffset += iSpace;
      }
    }
  }

  return 0;
}




static int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){
  MemJournal *p = (MemJournal *)pJfd;
  ((void) (0));
  if( size<p->endpoint.iOffset ){
    FileChunk *pIter = 0;
    if( size==0 ){
      memjrnlFreeChunks(p->pFirst);
      p->pFirst = 0;
    }else{
      i64 iOff = p->nChunkSize;
      for(pIter=p->pFirst; (pIter) && iOff<size; pIter=pIter->pNext){
        iOff += p->nChunkSize;
      }
      if( (pIter) ){
        memjrnlFreeChunks(pIter->pNext);
        pIter->pNext = 0;
      }
    }

    p->endpoint.pChunk = pIter;
    p->endpoint.iOffset = size;
    p->readpoint.pChunk = 0;
    p->readpoint.iOffset = 0;
  }
  return 0;
}




static int memjrnlClose(sqlite3_file *pJfd){
  MemJournal *p = (MemJournal *)pJfd;
  memjrnlFreeChunks(p->pFirst);
  return 0;
}







static int memjrnlSync(sqlite3_file *pJfd, int flags){
  (void)(pJfd),(void)(flags);
  return 0;
}




static int memjrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){
  MemJournal *p = (MemJournal *)pJfd;
  *pSize = (sqlite_int64) p->endpoint.iOffset;
  return 0;
}




static const struct sqlite3_io_methods MemJournalMethods = {
  1,
  memjrnlClose,
  memjrnlRead,
  memjrnlWrite,
  memjrnlTruncate,
  memjrnlSync,
  memjrnlFileSize,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
};
# 108752 "c_tests/sqlite3.c"
static int sqlite3JournalOpen(
  sqlite3_vfs *pVfs,
  const char *zName,
  sqlite3_file *pJfd,
  int flags,
  int nSpill
){
  MemJournal *p = (MemJournal*)pJfd;

  ((void) (0));





  memset(p, 0, sizeof(MemJournal));
  if( nSpill==0 ){
    return sqlite3OsOpen(pVfs, zName, pJfd, flags, 0);
  }

  if( nSpill>0 ){
    p->nChunkSize = nSpill;
  }else{
    p->nChunkSize = 8 + 1024 - sizeof(FileChunk);
    ((void) (0));
  }

  pJfd->pMethods = (const sqlite3_io_methods*)&MemJournalMethods;
  p->nSpill = nSpill;
  p->flags = flags;
  p->zJournal = zName;
  p->pVfs = pVfs;
  return 0;
}




static void sqlite3MemJournalOpen(sqlite3_file *pJfd){
  sqlite3JournalOpen(0, 0, pJfd, 0, -1);
}
# 108829 "c_tests/sqlite3.c"
static int sqlite3JournalIsInMemory(sqlite3_file *p){
  return p->pMethods==&MemJournalMethods;
}





static int sqlite3JournalSize(sqlite3_vfs *pVfs){
  return ((pVfs->szOsFile)>((int)sizeof(MemJournal))?(pVfs->szOsFile):((int)sizeof(MemJournal)));
}
# 108867 "c_tests/sqlite3.c"
static int walkWindowList(Walker *pWalker, Window *pList, int bOneOnly){
  Window *pWin;
  for(pWin=pList; pWin; pWin=pWin->pNextWin){
    int rc;
    rc = sqlite3WalkExprList(pWalker, pWin->pOrderBy);
    if( rc ) return 2;
    rc = sqlite3WalkExprList(pWalker, pWin->pPartition);
    if( rc ) return 2;
    rc = sqlite3WalkExpr(pWalker, pWin->pFilter);
    if( rc ) return 2;
    rc = sqlite3WalkExpr(pWalker, pWin->pStart);
    if( rc ) return 2;
    rc = sqlite3WalkExpr(pWalker, pWin->pEnd);
    if( rc ) return 2;
    if( bOneOnly ) break;
  }
  return 0;
}
# 108906 "c_tests/sqlite3.c"
static __attribute__((noinline)) int sqlite3WalkExprNN(Walker *pWalker, Expr *pExpr){
  int rc;
                                                  ;
                                                ;
  while(1){
    rc = pWalker->xExprCallback(pWalker, pExpr);
    if( rc ) return rc & 2;
    if( !(((pExpr)->flags&(u32)((0x010000|0x800000)))!=0) ){
      ((void) (0));
      if( pExpr->pLeft && sqlite3WalkExprNN(pWalker, pExpr->pLeft) ){
        return 2;
      }
      if( pExpr->pRight ){
        ((void) (0));
        pExpr = pExpr->pRight;
        continue;
      }else if( (((pExpr)->flags&0x001000)!=0) ){
        ((void) (0));
        if( sqlite3WalkSelect(pWalker, pExpr->x.pSelect) ) return 2;
      }else{
        if( pExpr->x.pList ){
          if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return 2;
        }

        if( (((pExpr)->flags&(u32)(0x1000000))!=0) ){
          if( walkWindowList(pWalker, pExpr->y.pWin, 1) ) return 2;
        }

      }
    }
    break;
  }
  return 0;
}
static int sqlite3WalkExpr(Walker *pWalker, Expr *pExpr){
  return pExpr ? sqlite3WalkExprNN(pWalker,pExpr) : 0;
}





static int sqlite3WalkExprList(Walker *pWalker, ExprList *p){
  int i;
  struct ExprList_item *pItem;
  if( p ){
    for(i=p->nExpr, pItem=p->a; i>0; i--, pItem++){
      if( sqlite3WalkExpr(pWalker, pItem->pExpr) ) return 2;
    }
  }
  return 0;
}





static void sqlite3WalkWinDefnDummyCallback(Walker *pWalker, Select *p){
  (void)(pWalker);
  (void)(p);

}







static int sqlite3WalkSelectExpr(Walker *pWalker, Select *p){
  if( sqlite3WalkExprList(pWalker, p->pEList) ) return 2;
  if( sqlite3WalkExpr(pWalker, p->pWhere) ) return 2;
  if( sqlite3WalkExprList(pWalker, p->pGroupBy) ) return 2;
  if( sqlite3WalkExpr(pWalker, p->pHaving) ) return 2;
  if( sqlite3WalkExprList(pWalker, p->pOrderBy) ) return 2;
  if( sqlite3WalkExpr(pWalker, p->pLimit) ) return 2;

  if( p->pWinDefn ){
    Parse *pParse;
    if( pWalker->xSelectCallback2==sqlite3WalkWinDefnDummyCallback
     || ((pParse = pWalker->pParse)!=0 && (pParse->eParseMode>=2))

     || pWalker->xSelectCallback2==sqlite3SelectPopWith

    ){


      int rc = walkWindowList(pWalker, p->pWinDefn, 0);
      return rc;
    }
  }

  return 0;
}
# 109008 "c_tests/sqlite3.c"
static int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){
  SrcList *pSrc;
  int i;
  SrcItem *pItem;

  pSrc = p->pSrc;
  if( (pSrc) ){
    for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){
      if( pItem->fg.isSubquery
       && sqlite3WalkSelect(pWalker, pItem->u4.pSubq->pSelect)
      ){
        return 2;
      }
      if( pItem->fg.isTabFunc
       && sqlite3WalkExprList(pWalker, pItem->u1.pFuncArg)
      ){
        return 2;
      }
    }
  }
  return 0;
}
# 109048 "c_tests/sqlite3.c"
static int sqlite3WalkSelect(Walker *pWalker, Select *p){
  int rc;
  if( p==0 ) return 0;
  if( pWalker->xSelectCallback==0 ) return 0;
  do{
    rc = pWalker->xSelectCallback(pWalker, p);
    if( rc ) return rc & 2;
    if( sqlite3WalkSelectExpr(pWalker, p)
     || sqlite3WalkSelectFrom(pWalker, p)
    ){
      return 2;
    }
    if( pWalker->xSelectCallback2 ){
      pWalker->xSelectCallback2(pWalker, p);
    }
    p = p->pPrior;
  }while( p!=0 );
  return 0;
}




static int sqlite3WalkerDepthIncrease(Walker *pWalker, Select *pSelect){
  (void)(pSelect);
  pWalker->walkerDepth++;
  return 0;
}
static void sqlite3WalkerDepthDecrease(Walker *pWalker, Select *pSelect){
  (void)(pSelect);
  pWalker->walkerDepth--;
}
# 109091 "c_tests/sqlite3.c"
static int sqlite3ExprWalkNoop(Walker *NotUsed, Expr *NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}





static int sqlite3SelectWalkNoop(Walker *NotUsed, Select *NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}
# 109141 "c_tests/sqlite3.c"
static int incrAggDepth(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==169 ) pExpr->op2 += pWalker->u.n;
  return 0;
}
static void incrAggFunctionDepth(Expr *pExpr, int N){
  if( N>0 ){
    Walker w;
    memset(&w, 0, sizeof(w));
    w.xExprCallback = incrAggDepth;
    w.u.n = N;
    sqlite3WalkExpr(&w, pExpr);
  }
}
# 109174 "c_tests/sqlite3.c"
static void resolveAlias(
  Parse *pParse,
  ExprList *pEList,
  int iCol,
  Expr *pExpr,
  int nSubquery
){
  Expr *pOrig;
  Expr *pDup;
  sqlite3 *db;

  ((void) (0));
  pOrig = pEList->a[iCol].pExpr;
  ((void) (0));
  ((void) (0));
  if( pExpr->pAggInfo ) return;
  db = pParse->db;
  pDup = sqlite3ExprDup(db, pOrig, 0);
  if( db->mallocFailed ){
    sqlite3ExprDelete(db, pDup);
    pDup = 0;
  }else{
    Expr temp;
    incrAggFunctionDepth(pDup, nSubquery);
    if( pExpr->op==114 ){
      ((void) (0));
      pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr->u.zToken);
    }
    memcpy(&temp, pDup, sizeof(Expr));
    memcpy(pDup, pExpr, sizeof(Expr));
    memcpy(pExpr, &temp, sizeof(Expr));
    if( (((pExpr)->flags&(u32)(0x1000000))!=0) ){
      if( (pExpr->y.pWin!=0) ){
        pExpr->y.pWin->pOwner = pExpr;
      }
    }
    sqlite3ExprDeferredDelete(pParse, pDup);
  }
}
# 109231 "c_tests/sqlite3.c"
static int sqlite3MatchEName(
  const struct ExprList_item *pItem,
  const char *zCol,
  const char *zTab,
  const char *zDb,
  int *pbRowid
){
  int n;
  const char *zSpan;
  int eEName = pItem->fg.eEName;
  if( eEName!=2 && (eEName!=3 || (pbRowid==0)) ){
    return 0;
  }
  ((void) (0));
  zSpan = pItem->zEName;
  for(n=0; (zSpan[n]) && zSpan[n]!='.'; n++){}
  if( zDb && (sqlite3_strnicmp(zSpan, zDb, n)!=0 || zDb[n]!=0) ){
    return 0;
  }
  zSpan += n+1;
  for(n=0; (zSpan[n]) && zSpan[n]!='.'; n++){}
  if( zTab && (sqlite3_strnicmp(zSpan, zTab, n)!=0 || zTab[n]!=0) ){
    return 0;
  }
  zSpan += n+1;
  if( zCol ){
    if( eEName==2 && sqlite3StrICmp(zSpan, zCol)!=0 ) return 0;
    if( eEName==3 && sqlite3IsRowid(zCol)==0 ) return 0;
  }
  if( eEName==3 ) *pbRowid = 1;
  return 1;
}




static int areDoubleQuotedStringsEnabled(sqlite3 *db, NameContext *pTopNC){
  if( db->init.busy ) return 1;
  if( pTopNC->ncFlags & 0x010000 ){

    if( sqlite3WritableSchema(db) && (db->flags & 0x40000000)!=0 ){
      return 1;
    }
    return (db->flags & 0x20000000)!=0;
  }else{

    return (db->flags & 0x40000000)!=0;
  }
}





static Bitmask sqlite3ExprColUsed(Expr *pExpr){
  int n;
  Table *pExTab;

  n = pExpr->iColumn;
  ((void) (0));
  pExTab = pExpr->y.pTab;
  ((void) (0));
  ((void) (0));
  if( (pExTab->tabFlags & 0x00000060)!=0
   && (pExTab->aCol[n].colFlags & 0x0060)!=0
  ){
                                   ;
                                 ;
    return pExTab->nCol>=((int)(sizeof(Bitmask)*8)) ? ((Bitmask)-1) : (((Bitmask)1)<<(pExTab->nCol))-1;
  }else{
                        ;
                      ;
    if( n>=((int)(sizeof(Bitmask)*8)) ) n = ((int)(sizeof(Bitmask)*8))-1;
    return ((Bitmask)1)<<n;
  }
}







static void extendFJMatch(
  Parse *pParse,
  ExprList **ppList,
  SrcItem *pMatch,
  i16 iColumn
){
  Expr *pNew = sqlite3ExprAlloc(pParse->db, 168, 0, 0);
  if( pNew ){
    pNew->iTable = pMatch->iCursor;
    pNew->iColumn = iColumn;
    pNew->y.pTab = pMatch->pSTab;
    ((void) (0));
    (pNew)->flags|=(u32)(0x200000);
    *ppList = sqlite3ExprListAppend(pParse, *ppList, pNew);
  }
}




static __attribute__((noinline)) int isValidSchemaTableName(
  const char *zTab,
  Table *pTab,
  const char *zDb
){
  const char *zLegacy;
  ((void) (0));
  ((void) (0));
  if( sqlite3_strnicmp(zTab, "sqlite_", 7)!=0 ) return 0;
  zLegacy = pTab->zName;
  if( strcmp(zLegacy+7, &"sqlite_temp_master"[7])==0 ){
    if( sqlite3StrICmp(zTab+7, &"sqlite_temp_schema"[7])==0 ){
      return 1;
    }
    if( zDb==0 ) return 0;
    if( sqlite3StrICmp(zTab+7, &"sqlite_master"[7])==0 ) return 1;
    if( sqlite3StrICmp(zTab+7, &"sqlite_schema"[7])==0 ) return 1;
  }else{
    if( sqlite3StrICmp(zTab+7, &"sqlite_schema"[7])==0 ) return 1;
  }
  return 0;
}
# 109384 "c_tests/sqlite3.c"
static int lookupName(
  Parse *pParse,
  const char *zDb,
  const char *zTab,
  const Expr *pRight,
  NameContext *pNC,
  Expr *pExpr
){
  int i, j;
  int cnt = 0;
  int cntTab = 0;
  int nSubquery = 0;
  sqlite3 *db = pParse->db;
  SrcItem *pItem;
  SrcItem *pMatch = 0;
  NameContext *pTopNC = pNC;
  Schema *pSchema = 0;
  int eNewExprOp = 168;
  Table *pTab = 0;
  ExprList *pFJMatch = 0;
  const char *zCol = pRight->u.zToken;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  pExpr->iTable = -1;
                                        ;





  if( zDb ){
                                         ;
                                         ;
    if( (pNC->ncFlags & (0x000002|0x000004))!=0 ){




      zDb = 0;
    }else{
      for(i=0; i<db->nDb; i++){
        ((void) (0));
        if( sqlite3StrICmp(db->aDb[i].zDbSName,zDb)==0 ){
          pSchema = db->aDb[i].pSchema;
          break;
        }
      }
      if( i==db->nDb && sqlite3StrICmp("main", zDb)==0 ){


        pSchema = db->aDb[0].pSchema;
        zDb = db->aDb[0].zDbSName;
      }
    }
  }


  ((void) (0));
  do{
    ExprList *pEList;
    SrcList *pSrcList = pNC->pSrcList;

    if( pSrcList ){
      for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){
        pTab = pItem->pSTab;
        ((void) (0));
        ((void) (0));
        ((void) (0));
        if( pItem->fg.isNestedFrom ){






          int hit = 0;
          Select *pSel;
          ((void) (0));
          ((void) (0));
          pSel = pItem->u4.pSubq->pSelect;
          ((void) (0));
          pEList = pSel->pEList;
          ((void) (0));
          ((void) (0));
          for(j=0; j<pEList->nExpr; j++){
            int bRowid = 0;
            if( !sqlite3MatchEName(&pEList->a[j], zCol, zTab, zDb, &bRowid) ){
              continue;
            }
            if( bRowid==0 ){
              if( cnt>0 ){
                if( pItem->fg.isUsing==0
                 || sqlite3IdListIndex(pItem->u3.pUsing, zCol)<0
                 || pMatch==pItem
                ){





                  sqlite3ExprListDelete(db, pFJMatch);
                  pFJMatch = 0;
                }else
                if( (pItem->fg.jointype & 0x10)==0 ){

                  continue;
                }else
                if( (pItem->fg.jointype & 0x08)==0 ){

                  cnt = 0;
                  sqlite3ExprListDelete(db, pFJMatch);
                  pFJMatch = 0;
                }else{

                  extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);
                }
              }
              cnt++;
              hit = 1;
            }else if( cnt>0 ){


              continue;
            }
            cntTab++;
            pMatch = pItem;
            pExpr->iColumn = j;
            pEList->a[j].fg.bUsed = 1;


            ((void) (0));
            if( pEList->a[j].fg.bUsingTerm ) break;
          }
          if( hit || zTab==0 ) continue;
        }
        ((void) (0));
        if( zTab ){
          if( zDb ){
            if( pTab->pSchema!=pSchema ) continue;
            if( pSchema==0 && strcmp(zDb,"*")!=0 ) continue;
          }
          if( pItem->zAlias!=0 ){
            if( sqlite3StrICmp(zTab, pItem->zAlias)!=0 ){
              continue;
            }
          }else if( sqlite3StrICmp(zTab, pTab->zName)!=0 ){
            if( pTab->tnum!=1 ) continue;
            if( !isValidSchemaTableName(zTab, pTab, zDb) ) continue;
          }
          ((void) (0));
          if( (pParse->eParseMode>=2) && pItem->zAlias ){
            sqlite3RenameTokenRemap(pParse, 0, (void*)&pExpr->y.pTab);
          }
        }
        j = sqlite3ColumnIndex(pTab, zCol);
        if( j>=0 ){
          if( cnt>0 ){
            if( pItem->fg.isUsing==0
             || sqlite3IdListIndex(pItem->u3.pUsing, zCol)<0
            ){



              sqlite3ExprListDelete(db, pFJMatch);
              pFJMatch = 0;
            }else
            if( (pItem->fg.jointype & 0x10)==0 ){

              continue;
            }else
            if( (pItem->fg.jointype & 0x08)==0 ){

              cnt = 0;
              sqlite3ExprListDelete(db, pFJMatch);
              pFJMatch = 0;
            }else{

              extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);
            }
          }
          cnt++;
          pMatch = pItem;

          pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;
          if( pItem->fg.isNestedFrom ){
            sqlite3SrcItemColumnUsed(pItem, j);
          }
        }
        if( 0==cnt && (((pTab)->tabFlags & 0x00000200)==0) ){
# 109606 "c_tests/sqlite3.c"
          cntTab++;
          pMatch = pItem;

        }
      }
      if( pMatch ){
        pExpr->iTable = pMatch->iCursor;
        ((void) (0));
        pExpr->y.pTab = pMatch->pSTab;
        if( (pMatch->fg.jointype & (0x08|0x40))!=0 ){
          (pExpr)->flags|=(u32)(0x200000);
        }
        pSchema = pExpr->y.pTab->pSchema;
      }
    }







    if( cnt==0 && zDb==0 ){
      pTab = 0;

      if( pParse->pTriggerTab!=0 ){
        int op = pParse->eTriggerOp;
        ((void) (0));
        if( pParse->bReturning ){
          if( (pNC->ncFlags & 0x000400)!=0
           && (zTab==0 || sqlite3StrICmp(zTab,pParse->pTriggerTab->zName)==0 || isValidSchemaTableName(zTab, pParse->pTriggerTab, 0))


          ){
            pExpr->iTable = op!=129;
            pTab = pParse->pTriggerTab;
          }
        }else if( op!=129 && zTab && sqlite3StrICmp("new",zTab) == 0 ){
          pExpr->iTable = 1;
          pTab = pParse->pTriggerTab;
        }else if( op!=128 && zTab && sqlite3StrICmp("old",zTab)==0 ){
          pExpr->iTable = 0;
          pTab = pParse->pTriggerTab;
        }
      }


      if( (pNC->ncFlags & 0x000200)!=0 && zTab!=0 ){
        Upsert *pUpsert = pNC->uNC.pUpsert;
        if( pUpsert && sqlite3StrICmp("excluded",zTab)==0 ){
          pTab = pUpsert->pUpsertSrc->a[0].pSTab;
          pExpr->iTable = 2;
        }
      }


      if( pTab ){
        int iCol;
        pSchema = pTab->pSchema;
        cntTab++;
        iCol = sqlite3ColumnIndex(pTab, zCol);
        if( iCol>=0 ){
          if( pTab->iPKey==iCol ) iCol = -1;
        }else{
          if( sqlite3IsRowid(zCol) && (((pTab)->tabFlags & 0x00000200)==0) ){
            iCol = -1;
          }else{
            iCol = pTab->nCol;
          }
        }
        if( iCol<pTab->nCol ){
          cnt++;
          pMatch = 0;

          if( pExpr->iTable==2 ){
                                  ;
            ((void) (0));
            if( (pParse->eParseMode>=2) ){
              pExpr->iColumn = iCol;
              pExpr->y.pTab = pTab;
              eNewExprOp = 168;
            }else{
              pExpr->iTable = pNC->uNC.pUpsert->regData +
                 sqlite3TableColumnToStorage(pTab, iCol);
              eNewExprOp = 176;
            }
          }else

          {
            ((void) (0));
            pExpr->y.pTab = pTab;
            if( pParse->bReturning ){
              eNewExprOp = 176;
              pExpr->op2 = 168;
              pExpr->iColumn = iCol;
              pExpr->iTable = pNC->uNC.iBaseReg + (pTab->nCol+1)*pExpr->iTable +
                 sqlite3TableColumnToStorage(pTab, iCol) + 1;
            }else{
              pExpr->iColumn = (i16)iCol;
              eNewExprOp = 78;

              if( iCol<0 ){
                pExpr->affExpr = 0x44;
              }else if( pExpr->iTable==0 ){
                                    ;
                                    ;
                pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
              }else{
                                    ;
                                    ;
                pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
              }

            }
          }
        }
      }
    }





    if( cnt==0
     && cntTab>=1
     && pMatch
     && (pNC->ncFlags & (0x000020|0x000008))==0
     && sqlite3IsRowid(zCol)
     && ((((pMatch->pSTab)->tabFlags & 0x00000200)==0) || pMatch->fg.isNestedFrom)
    ){
      cnt = cntTab;





      if( pMatch->fg.isNestedFrom==0 ) pExpr->iColumn = -1;
      pExpr->affExpr = 0x44;
    }
# 109764 "c_tests/sqlite3.c"
    if( cnt==0
     && (pNC->ncFlags & 0x000080)!=0
     && zTab==0
    ){
      pEList = pNC->uNC.pEList;
      ((void) (0));
      for(j=0; j<pEList->nExpr; j++){
        char *zAs = pEList->a[j].zEName;
        if( pEList->a[j].fg.eEName==0
         && sqlite3_stricmp(zAs, zCol)==0
        ){
          Expr *pOrig;
          ((void) (0));
          ((void) (0));
          ((void) (0));
          pOrig = pEList->a[j].pExpr;
          if( (pNC->ncFlags&0x000001)==0 && (((pOrig)->flags&(u32)(0x000010))!=0) ){
            sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);
            return 2;
          }
          if( (((pOrig)->flags&(u32)(0x008000))!=0)
           && ((pNC->ncFlags&0x004000)==0 || pNC!=pTopNC )
          ){
            sqlite3ErrorMsg(pParse, "misuse of aliased window function %s",zAs);
            return 2;
          }
          if( sqlite3ExprVectorSize(pOrig)!=1 ){
            sqlite3ErrorMsg(pParse, "row value misused");
            return 2;
          }
          resolveAlias(pParse, pEList, j, pExpr, nSubquery);
          cnt = 1;
          pMatch = 0;
          ((void) (0));
          if( (pParse->eParseMode>=2) ){
            sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);
          }
          goto lookupname_end;
        }
      }
    }




    if( cnt ) break;
    pNC = pNC->pNext;
    nSubquery++;
  }while( pNC );
# 109825 "c_tests/sqlite3.c"
  if( cnt==0 && zTab==0 ){
    ((void) (0));
    if( (((pExpr)->flags&(u32)(0x000080))!=0)
     && areDoubleQuotedStringsEnabled(db, pTopNC)
    ){
# 109844 "c_tests/sqlite3.c"
      sqlite3_log(28,
        "double-quoted string literal: \"%w\"", zCol);



      pExpr->op = 118;
      memset(&pExpr->y, 0, sizeof(pExpr->y));
      return 1;
    }
    if( sqlite3ExprIdToTrueFalse(pExpr) ){
      return 1;
    }
  }
# 109865 "c_tests/sqlite3.c"
  ((void) (0));
  ((void) (0));
  if( cnt!=1 ){
    const char *zErr;
    if( pFJMatch ){
      if( pFJMatch->nExpr==cnt-1 ){
        if( (((pExpr)->flags&(u32)(0x800000))!=0) ){
          (pExpr)->flags&=~(u32)(0x800000);
        }else{
          sqlite3ExprDelete(db, pExpr->pLeft);
          pExpr->pLeft = 0;
          sqlite3ExprDelete(db, pExpr->pRight);
          pExpr->pRight = 0;
        }
        extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);
        pExpr->op = 172;
        pExpr->u.zToken = "coalesce";
        pExpr->x.pList = pFJMatch;
        cnt = 1;
        goto lookupname_end;
      }else{
        sqlite3ExprListDelete(db, pFJMatch);
        pFJMatch = 0;
      }
    }
    zErr = cnt==0 ? "no such column" : "ambiguous column name";
    if( zDb ){
      sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);
    }else if( zTab ){
      sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);
    }else if( cnt==0 && (((pRight)->flags&(u32)(0x000080))!=0) ){
      sqlite3ErrorMsg(pParse, "%s: \"%s\" - should this be a"
                              " string literal in single-quotes?",
                              zErr, zCol);
    }else{
      sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);
    }
    sqlite3RecordErrorOffsetOfExpr(pParse->db, pExpr);
    pParse->checkSchema = 1;
    pTopNC->nNcErr++;
    eNewExprOp = 122;
  }
  ((void) (0));


  if( !(((pExpr)->flags&(u32)((0x010000|0x800000)))!=0) ){
    sqlite3ExprDelete(db, pExpr->pLeft);
    pExpr->pLeft = 0;
    sqlite3ExprDelete(db, pExpr->pRight);
    pExpr->pRight = 0;
    (pExpr)->flags|=(u32)(0x800000);
  }
# 109932 "c_tests/sqlite3.c"
  if( pMatch ){
    if( pExpr->iColumn>=0 ){
      pMatch->colUsed |= sqlite3ExprColUsed(pExpr);
    }else{
      pMatch->fg.rowidUsed = 1;
    }
  }

  pExpr->op = eNewExprOp;
lookupname_end:
  if( cnt==1 ){
    ((void) (0));

    if( pParse->db->xAuth
     && (pExpr->op==168 || pExpr->op==78)
    ){
      sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);
    }



    for(;;){
      ((void) (0));
      pTopNC->nRef++;
      if( pTopNC==pNC ) break;
      pTopNC = pTopNC->pNext;
    }
    return 1;
  } else {
    return 2;
  }
}





static Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){
  Expr *p = sqlite3ExprAlloc(db, 168, 0, 0);
  if( p ){
    SrcItem *pItem = &pSrc->a[iSrc];
    Table *pTab;
    ((void) (0));
    pTab = p->y.pTab = pItem->pSTab;
    p->iTable = pItem->iCursor;
    if( p->y.pTab->iPKey==iCol ){
      p->iColumn = -1;
    }else{
      p->iColumn = (ynVar)iCol;
      if( (pTab->tabFlags & 0x00000060)!=0
       && (pTab->aCol[iCol].colFlags & 0x0060)!=0
      ){
                                  ;
                                  ;
        pItem->colUsed = pTab->nCol>=64 ? ((Bitmask)-1) : (((Bitmask)1)<<(pTab->nCol))-1;
      }else{
                             ;
                               ;
        pItem->colUsed |= ((Bitmask)1)<<(iCol>=((int)(sizeof(Bitmask)*8)) ? ((int)(sizeof(Bitmask)*8))-1 : iCol);
      }
    }
  }
  return p;
}
# 110013 "c_tests/sqlite3.c"
static void notValidImpl(
   Parse *pParse,
   NameContext *pNC,
   const char *zMsg,
   Expr *pExpr,
   Expr *pError
){
  const char *zIn = "partial index WHERE clauses";
  if( pNC->ncFlags & 0x000020 ) zIn = "index expressions";

  else if( pNC->ncFlags & 0x000004 ) zIn = "CHECK constraints";


  else if( pNC->ncFlags & 0x000008 ) zIn = "generated columns";

  sqlite3ErrorMsg(pParse, "%s prohibited in %s", zMsg, zIn);
  if( pExpr ) pExpr->op = 122;
  sqlite3RecordErrorOffsetOfExpr(pParse->db, pError);
}
# 110041 "c_tests/sqlite3.c"
static int exprProbability(Expr *p){
  double r = -1.0;
  if( p->op!=154 ) return -1;
  ((void) (0));
  sqlite3AtoF(p->u.zToken, &r, sqlite3Strlen30(p->u.zToken), 1);
  ((void) (0));
  if( r>1.0 ) return -1;
  return (int)(r*134217728.0);
}
# 110062 "c_tests/sqlite3.c"
static int resolveExprStep(Walker *pWalker, Expr *pExpr){
  NameContext *pNC;
  Parse *pParse;

  pNC = pWalker->u.pNC;
  ((void) (0));
  pParse = pNC->pParse;
  ((void) (0));
# 110080 "c_tests/sqlite3.c"
  switch( pExpr->op ){






    case 76: {
      SrcList *pSrcList = pNC->pSrcList;
      SrcItem *pItem;
      ((void) (0));
      pItem = pSrcList->a;
      pExpr->op = 168;
      ((void) (0));
      pExpr->y.pTab = pItem->pSTab;
      pExpr->iTable = pItem->iCursor;
      pExpr->iColumn--;
      pExpr->affExpr = 0x44;
      break;
    }
# 110128 "c_tests/sqlite3.c"
    case 52:
    case 51: {
      int anRef[8];
      NameContext *p;
      int i;
      for(i=0, p=pNC; p && i<((int)(sizeof(anRef)/sizeof(anRef[0]))); p=p->pNext, i++){
        anRef[i] = p->nRef;
      }
      sqlite3WalkExpr(pWalker, pExpr->pLeft);
      if( (pParse->eParseMode>=2) ) return 1;
      if( sqlite3ExprCanBeNull(pExpr->pLeft) ){

        return 1;
      }

      for(i=0, p=pNC; p; p=p->pNext, i++){
        if( (p->ncFlags & 0x100000)==0 ){
          return 1;
        }
      }
                                                    ;
      ((void) (0));
# 110159 "c_tests/sqlite3.c"
      pExpr->u.iValue = (pExpr->op==52);
      pExpr->flags |= 0x000800;
      pExpr->op = 156;
      for(i=0, p=pNC; p && i<((int)(sizeof(anRef)/sizeof(anRef[0]))); p=p->pNext, i++){
        p->nRef = anRef[i];
      }
      sqlite3ExprDelete(pParse->db, pExpr->pLeft);
      pExpr->pLeft = 0;
      return 1;
    }
# 110178 "c_tests/sqlite3.c"
    case 60:
    case 142: {
      const char *zTable;
      const char *zDb;
      Expr *pRight;

      if( pExpr->op==60 ){
        zDb = 0;
        zTable = 0;
        ((void) (0));
        pRight = pExpr;
      }else{
        Expr *pLeft = pExpr->pLeft;
                                             ;
                                            ;
        ((void) (0)); if( ((pNC)->ncFlags & (0x000020|0x000008))!=0 ) notValidImpl(pParse,pNC,"the \".\" operator",0,pExpr);;

        pRight = pExpr->pRight;
        if( pRight->op==60 ){
          zDb = 0;
        }else{
          ((void) (0));
          ((void) (0));
          zDb = pLeft->u.zToken;
          pLeft = pRight->pLeft;
          pRight = pRight->pRight;
        }
        ((void) (0));
        zTable = pLeft->u.zToken;
        ((void) (0));
        if( (pParse->eParseMode>=2) ){
          sqlite3RenameTokenRemap(pParse, (void*)pExpr, (void*)pRight);
          sqlite3RenameTokenRemap(pParse, (void*)&pExpr->y.pTab, (void*)pLeft);
        }
      }
      return lookupName(pParse, zDb, zTable, pRight, pNC, pExpr);
    }



    case 172: {
      ExprList *pList;
      int n;
      int no_such_func = 0;
      int wrong_num_args = 0;
      int is_agg = 0;
      const char *zId;
      FuncDef *pDef;
      u8 enc = ((pParse->db)->enc);
      int savedAllowFlags = (pNC->ncFlags & (0x000001 | 0x004000));

      Window *pWin = (( ((((pExpr))->flags&(u32)(0x1000000))!=0) && pExpr->y.pWin->eFrmType!=167 ) ? pExpr->y.pWin : 0);

      ((void) (0));
      ((void) (0));
      pList = pExpr->x.pList;
      n = pList ? pList->nExpr : 0;
      zId = pExpr->u.zToken;
      pDef = sqlite3FindFunction(pParse->db, zId, n, enc, 0);
      if( pDef==0 ){
        pDef = sqlite3FindFunction(pParse->db, zId, -2, enc, 0);
        if( pDef==0 ){
          no_such_func = 1;
        }else{
          wrong_num_args = 1;
        }
      }else{
        is_agg = pDef->xFinalize!=0;
        if( pDef->funcFlags & 0x0400 ){
          (pExpr)->flags|=(u32)(0x080000);
          if( n==2 ){
            pExpr->iTable = exprProbability(pList->a[1].pExpr);
            if( pExpr->iTable<0 ){
              sqlite3ErrorMsg(pParse,
                "second argument to %#T() must be a "
                "constant between 0.0 and 1.0", pExpr);
              pNC->nNcErr++;
            }
          }else{
# 110266 "c_tests/sqlite3.c"
            pExpr->iTable = pDef->zName[0]=='u' ? 8388608 : 125829120;
          }
        }

        {
          int auth = sqlite3AuthCheck(pParse, 31, 0,pDef->zName,0);
          if( auth!=0 ){
            if( auth==1 ){
              sqlite3ErrorMsg(pParse, "not authorized to use function: %#T",
                                      pExpr);
              pNC->nNcErr++;
            }
            pExpr->op = 122;
            return 1;
          }
        }
# 110292 "c_tests/sqlite3.c"
        if( (pDef->funcFlags & 0x000100000)
         || (((pExpr)->flags&(u32)(0x80000000))!=0)
        ){
          int ii;
          for(ii=0; ii<n; ii++){
            (pList->a[ii].pExpr)->flags|=(u32)(0x80000000);
          }
        }

        if( pDef->funcFlags & (0x0800|0x2000) ){




          (pExpr)->flags|=(u32)(0x100000);
        }
        if( (pDef->funcFlags & 0x0800)==0 ){






          ((void) (0)); if( ((pNC)->ncFlags & (0x000020|0x000002|0x000008))!=0 ) notValidImpl(pParse,pNC,"non-deterministic functions",0,pExpr);;

        }else{
          ((void) (0));
          pExpr->op2 = pNC->ncFlags & 0x00002e;
        }
        if( (pDef->funcFlags & 0x00040000)!=0
         && pParse->nested==0
         && (pParse->db->mDbFlags & 0x0020)==0
        ){




          no_such_func = 1;
          pDef = 0;
        }else
        if( (pDef->funcFlags & (0x00080000|0x00200000))!=0
         && !(pParse->eParseMode>=2)
        ){
          if( pNC->ncFlags & 0x040000 ) (pExpr)->flags|=(u32)(0x40000000);
          sqlite3ExprFunctionUsable(pParse, pExpr, pDef);
        }
      }

      if( 0==(pParse->eParseMode>=2) ){

        ((void) (0));



        if( pDef && pDef->xValue==0 && pWin ){
          sqlite3ErrorMsg(pParse,
              "%#T() may not be used as a window function", pExpr
          );
          pNC->nNcErr++;
        }else if(
              (is_agg && (pNC->ncFlags & 0x000001)==0)
           || (is_agg && (pDef->funcFlags&0x00010000) && !pWin)
           || (is_agg && pWin && (pNC->ncFlags & 0x004000)==0)
        ){
          const char *zType;
          if( (pDef->funcFlags & 0x00010000) || pWin ){
            zType = "window";
          }else{
            zType = "aggregate";
          }
          sqlite3ErrorMsg(pParse, "misuse of %s function %#T()",zType,pExpr);
          pNC->nNcErr++;
          is_agg = 0;
        }







        else if( no_such_func && pParse->db->init.busy==0



        ){
          sqlite3ErrorMsg(pParse, "no such function: %#T", pExpr);
          pNC->nNcErr++;
        }else if( wrong_num_args ){
          sqlite3ErrorMsg(pParse,"wrong number of arguments to function %#T()",
               pExpr);
          pNC->nNcErr++;
        }

        else if( is_agg==0 && (((pExpr)->flags&(u32)(0x1000000))!=0) ){
          sqlite3ErrorMsg(pParse,
              "FILTER may not be used with non-aggregate %#T()",
              pExpr
          );
          pNC->nNcErr++;
        }

        else if( is_agg==0 && pExpr->pLeft ){
          sqlite3ExprOrderByAggregateError(pParse, pExpr);
          pNC->nNcErr++;
        }
        if( is_agg ){




          pNC->ncFlags &= ~(0x004000 | (!pWin ? 0x000001 : 0));



        }
      }
      else if( (((pExpr)->flags&(u32)(0x1000000))!=0) || pExpr->pLeft ){
        is_agg = 1;
      }
      sqlite3WalkExprList(pWalker, pList);
      if( is_agg ){
        if( pExpr->pLeft ){
          ((void) (0));
          ((void) (0));
          sqlite3WalkExprList(pWalker, pExpr->pLeft->x.pList);
        }

        if( pWin && pParse->nErr==0 ){
          Select *pSel = pNC->pWinSelect;
          ((void) (0));
          if( (pParse->eParseMode>=2)==0 ){
            sqlite3WindowUpdate(pParse, pSel ? pSel->pWinDefn : 0, pWin, pDef);
            if( pParse->db->mallocFailed ) break;
          }
          sqlite3WalkExprList(pWalker, pWin->pPartition);
          sqlite3WalkExprList(pWalker, pWin->pOrderBy);
          sqlite3WalkExpr(pWalker, pWin->pFilter);
          sqlite3WindowLink(pSel, pWin);
          pNC->ncFlags |= 0x008000;
        }else

        {
          NameContext *pNC2;
          pExpr->op = 169;
          pExpr->op2 = 0;

          if( (((pExpr)->flags&(u32)(0x1000000))!=0) ){
            sqlite3WalkExpr(pWalker, pExpr->y.pWin->pFilter);
          }

          pNC2 = pNC;
          while( pNC2
              && sqlite3ReferencesSrcList(pParse, pExpr, pNC2->pSrcList)==0
          ){
            pExpr->op2 += (1 + pNC2->nNestedSelect);
            pNC2 = pNC2->pNext;
          }
          ((void) (0));
          if( pNC2 && pDef ){
            pExpr->op2 += pNC2->nNestedSelect;
            ((void) (0));
            ((void) (0));
                                                                 ;
                                                                   ;
            pNC2->ncFlags |= 0x000010
              | ((pDef->funcFlags^0x08000000)
                  & (0x1000|0x08000000));
          }
        }
        pNC->ncFlags |= savedAllowFlags;
      }



      return 1;
    }

    case 20:
    case 139:

    case 50: {
                                  ;
                                      ;
                                      ;
      if( (((pExpr)->flags&0x001000)!=0) ){
        int nRef = pNC->nRef;
                                             ;
                                             ;
                                             ;
                                            ;
        ((void) (0));
        if( pExpr->op==20 ) pParse->bHasExists = 1;
        if( pNC->ncFlags & 0x00002e ){
          notValidImpl(pParse, pNC, "subqueries", pExpr, pExpr);
        }else{
          sqlite3WalkSelect(pWalker, pExpr->x.pSelect);
        }
        ((void) (0));
        if( nRef!=pNC->nRef ){
          (pExpr)->flags|=(u32)(0x000040);
          pExpr->x.pSelect->selFlags |= 0x20000000;
        }
        pNC->ncFlags |= 0x000040;
      }
      break;
    }
    case 157: {
                                           ;
                                           ;
                                           ;
                                          ;
      ((void) (0)); if( ((pNC)->ncFlags & (0x000004|0x000002|0x000020|0x000008))!=0 ) notValidImpl(pParse,pNC,"parameters",pExpr,pExpr);;

      break;
    }
    case 45:
    case 46: {
      Expr *pRight = sqlite3ExprSkipCollateAndLikely(pExpr->pRight);
      ((void) (0));


      if( (pRight) && (pRight->op==60 || pRight->op==171) ){
        int rc = resolveExprStep(pWalker, pRight);
        if( rc==2 ) return 2;
        if( pRight->op==171 ){
          pExpr->op2 = pExpr->op;
          pExpr->op = 175;
          return 0;
        }
      }
                     __attribute__((fallthrough));
    }
    case 49:
    case 54:
    case 53:
    case 57:
    case 56:
    case 55:
    case 58: {
      int nLeft, nRight;
      if( pParse->db->mallocFailed ) break;
      ((void) (0));
      nLeft = sqlite3ExprVectorSize(pExpr->pLeft);
      if( pExpr->op==49 ){
        ((void) (0));
        nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[0].pExpr);
        if( nRight==nLeft ){
          nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[1].pExpr);
        }
      }else{
        ((void) (0));
        nRight = sqlite3ExprVectorSize(pExpr->pRight);
      }
      if( nLeft!=nRight ){
                                    ;
                                    ;
                                    ;
                                    ;
                                    ;
                                    ;
                                    ;
                                       ;
                                         ;
        sqlite3ErrorMsg(pParse, "row value misused");
        sqlite3RecordErrorOffsetOfExpr(pParse->db, pExpr);
      }
      break;
    }
  }
  ((void) (0));
  return pParse->nErr ? 2 : 0;
}
# 110578 "c_tests/sqlite3.c"
static int resolveAsName(
  Parse *pParse,
  ExprList *pEList,
  Expr *pE
){
  int i;

  (void)(pParse);

  if( pE->op==60 ){
    const char *zCol;
    ((void) (0));
    zCol = pE->u.zToken;
    for(i=0; i<pEList->nExpr; i++){
      if( pEList->a[i].fg.eEName==0
       && sqlite3_stricmp(pEList->a[i].zEName, zCol)==0
      ){
        return i+1;
      }
    }
  }
  return 0;
}
# 110620 "c_tests/sqlite3.c"
static int resolveOrderByTermToExprList(
  Parse *pParse,
  Select *pSelect,
  Expr *pE
){
  int i;
  ExprList *pEList;
  NameContext nc;
  sqlite3 *db;
  int rc;
  u8 savedSuppErr;

  ((void) (0));
  pEList = pSelect->pEList;



  memset(&nc, 0, sizeof(nc));
  nc.pParse = pParse;
  nc.pSrcList = pSelect->pSrc;
  nc.uNC.pEList = pEList;
  nc.ncFlags = 0x000001|0x000080|0x080000;
  nc.nNcErr = 0;
  db = pParse->db;
  savedSuppErr = db->suppressErr;
  db->suppressErr = 1;
  rc = sqlite3ResolveExprNames(&nc, pE);
  db->suppressErr = savedSuppErr;
  if( rc ) return 0;





  for(i=0; i<pEList->nExpr; i++){
    if( sqlite3ExprCompare(0, pEList->a[i].pExpr, pE, -1)<2 ){
      return i+1;
    }
  }


  return 0;
}




static void resolveOutOfRangeError(
  Parse *pParse,
  const char *zType,
  int i,
  int mx,
  Expr *pError
){
  sqlite3ErrorMsg(pParse,
    "%r %s BY term out of range - should be "
    "between 1 and %d", i, zType, mx);
  sqlite3RecordErrorOffsetOfExpr(pParse->db, pError);
}
# 110695 "c_tests/sqlite3.c"
static int resolveCompoundOrderBy(
  Parse *pParse,
  Select *pSelect
){
  int i;
  ExprList *pOrderBy;
  ExprList *pEList;
  sqlite3 *db;
  int moreToDo = 1;

  pOrderBy = pSelect->pOrderBy;
  if( pOrderBy==0 ) return 0;
  db = pParse->db;
  if( pOrderBy->nExpr>db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
    return 1;
  }
  for(i=0; i<pOrderBy->nExpr; i++){
    pOrderBy->a[i].fg.done = 0;
  }
  pSelect->pNext = 0;
  while( pSelect->pPrior ){
    pSelect->pPrior->pNext = pSelect;
    pSelect = pSelect->pPrior;
  }
  while( pSelect && moreToDo ){
    struct ExprList_item *pItem;
    moreToDo = 0;
    pEList = pSelect->pEList;
    ((void) (0));
    for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
      int iCol = -1;
      Expr *pE, *pDup;
      if( pItem->fg.done ) continue;
      pE = sqlite3ExprSkipCollateAndLikely(pItem->pExpr);
      if( (pE==0) ) continue;
      if( sqlite3ExprIsInteger(pE, &iCol, 0) ){
        if( iCol<=0 || iCol>pEList->nExpr ){
          resolveOutOfRangeError(pParse, "ORDER", i+1, pEList->nExpr, pE);
          return 1;
        }
      }else{
        iCol = resolveAsName(pParse, pEList, pE);
        if( iCol==0 ){
# 110750 "c_tests/sqlite3.c"
          pDup = sqlite3ExprDup(db, pE, 0);
          if( !db->mallocFailed ){
            ((void) (0));
            iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup);
            if( (pParse->eParseMode>=2) && iCol>0 ){
              resolveOrderByTermToExprList(pParse, pSelect, pE);
            }
          }
          sqlite3ExprDelete(db, pDup);
        }
      }
      if( iCol>0 ){


        if( !(pParse->eParseMode>=2) ){
          Expr *pNew = sqlite3Expr(db, 156, 0);
          if( pNew==0 ) return 1;
          pNew->flags |= 0x000800;
          pNew->u.iValue = iCol;
          if( pItem->pExpr==pE ){
            pItem->pExpr = pNew;
          }else{
            Expr *pParent = pItem->pExpr;
            ((void) (0));
            while( pParent->pLeft->op==114 ) pParent = pParent->pLeft;
            ((void) (0));
            pParent->pLeft = pNew;
          }
          sqlite3ExprDelete(db, pE);
          pItem->u.x.iOrderByCol = (u16)iCol;
        }
        pItem->fg.done = 1;
      }else{
        moreToDo = 1;
      }
    }
    pSelect = pSelect->pNext;
  }
  for(i=0; i<pOrderBy->nExpr; i++){
    if( pOrderBy->a[i].fg.done==0 ){
      sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any "
            "column in the result set", i+1);
      return 1;
    }
  }
  return 0;
}
# 110808 "c_tests/sqlite3.c"
static int sqlite3ResolveOrderGroupBy(
  Parse *pParse,
  Select *pSelect,
  ExprList *pOrderBy,
  const char *zType
){
  int i;
  sqlite3 *db = pParse->db;
  ExprList *pEList;
  struct ExprList_item *pItem;

  if( pOrderBy==0 || pParse->db->mallocFailed || (pParse->eParseMode>=2) ) return 0;
  if( pOrderBy->nExpr>db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);
    return 1;
  }
  pEList = pSelect->pEList;
  ((void) (0));
  for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
    if( pItem->u.x.iOrderByCol ){
      if( pItem->u.x.iOrderByCol>pEList->nExpr ){
        resolveOutOfRangeError(pParse, zType, i+1, pEList->nExpr, 0);
        return 1;
      }
      resolveAlias(pParse, pEList, pItem->u.x.iOrderByCol-1, pItem->pExpr,0);
    }
  }
  return 0;
}





static int resolveRemoveWindowsCb(Walker *pWalker, Expr *pExpr){
  (void)(pWalker);
  if( (((pExpr)->flags&(u32)(0x1000000))!=0) ){
    Window *pWin = pExpr->y.pWin;
    sqlite3WindowUnlinkFromSelect(pWin);
  }
  return 0;
}





static void windowRemoveExprFromSelect(Select *pSelect, Expr *pExpr){
  if( pSelect->pWin ){
    Walker sWalker;
    memset(&sWalker, 0, sizeof(Walker));
    sWalker.xExprCallback = resolveRemoveWindowsCb;
    sWalker.u.pSelect = pSelect;
    sqlite3WalkExpr(&sWalker, pExpr);
  }
}
# 110886 "c_tests/sqlite3.c"
static int resolveOrderGroupBy(
  NameContext *pNC,
  Select *pSelect,
  ExprList *pOrderBy,
  const char *zType
){
  int i, j;
  int iCol;
  struct ExprList_item *pItem;
  Parse *pParse;
  int nResult;

  ((void) (0));
  nResult = pSelect->pEList->nExpr;
  pParse = pNC->pParse;
  for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
    Expr *pE = pItem->pExpr;
    Expr *pE2 = sqlite3ExprSkipCollateAndLikely(pE);
    if( (pE2==0) ) continue;
    if( zType[0]!='G' ){
      iCol = resolveAsName(pParse, pSelect->pEList, pE2);
      if( iCol>0 ){




        pItem->u.x.iOrderByCol = (u16)iCol;
        continue;
      }
    }
    if( sqlite3ExprIsInteger(pE2, &iCol, 0) ){



      if( iCol<1 || iCol>0xffff ){
        resolveOutOfRangeError(pParse, zType, i+1, nResult, pE2);
        return 1;
      }
      pItem->u.x.iOrderByCol = (u16)iCol;
      continue;
    }


    pItem->u.x.iOrderByCol = 0;
    if( sqlite3ResolveExprNames(pNC, pE) ){
      return 1;
    }
    for(j=0; j<pSelect->pEList->nExpr; j++){
      if( sqlite3ExprCompare(0, pE, pSelect->pEList->a[j].pExpr, -1)==0 ){



        windowRemoveExprFromSelect(pSelect, pE);
        pItem->u.x.iOrderByCol = j+1;
      }
    }
  }
  return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType);
}




static int resolveSelectStep(Walker *pWalker, Select *p){
  NameContext *pOuterNC;
  NameContext sNC;
  int isCompound;
  int nCompound;
  Parse *pParse;
  int i;
  ExprList *pGroupBy;
  Select *pLeftmost;
  sqlite3 *db;


  ((void) (0));
  if( p->selFlags & 0x0000004 ){
    return 1;
  }
  pOuterNC = pWalker->u.pNC;
  pParse = pWalker->pParse;
  db = pParse->db;
# 110977 "c_tests/sqlite3.c"
  if( (p->selFlags & 0x0000040)==0 ){
    sqlite3SelectPrep(pParse, p, pOuterNC);
    return pParse->nErr ? 2 : 1;
  }

  isCompound = p->pPrior!=0;
  nCompound = 0;
  pLeftmost = p;
  while( p ){
    ((void) (0));
    ((void) (0));
    p->selFlags |= 0x0000004;




    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    sNC.pWinSelect = p;
    if( sqlite3ResolveExprNames(&sNC, p->pLimit) ){
      return 2;
    }







    if( p->selFlags & 0x0010000 ){
      Select *pSub;
      ((void) (0));
      ((void) (0));
      pSub = p->pSrc->a[0].u4.pSubq->pSelect;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      pSub->pOrderBy = p->pOrderBy;
      p->pOrderBy = 0;
    }



    if( pOuterNC ) pOuterNC->nNestedSelect++;
    for(i=0; i<p->pSrc->nSrc; i++){
      SrcItem *pItem = &p->pSrc->a[i];
      ((void) (0));

      if( pItem->fg.isSubquery
       && (pItem->u4.pSubq->pSelect->selFlags & 0x0000004)==0
      ){
        int nRef = pOuterNC ? pOuterNC->nRef : 0;
        const char *zSavedContext = pParse->zAuthContext;

        if( pItem->zName ) pParse->zAuthContext = pItem->zName;
        sqlite3ResolveSelectNames(pParse, pItem->u4.pSubq->pSelect, pOuterNC);
        pParse->zAuthContext = zSavedContext;
        if( pParse->nErr ) return 2;
        ((void) (0));







        if( pOuterNC ){
          ((void) (0));
          pItem->fg.isCorrelated = (pOuterNC->nRef>nRef);
        }
      }
    }
    if( pOuterNC && (pOuterNC->nNestedSelect>0) ){
      pOuterNC->nNestedSelect--;
    }




    sNC.ncFlags = 0x000001|0x004000;
    sNC.pSrcList = p->pSrc;
    sNC.pNext = pOuterNC;


    if( sqlite3ResolveExprListNames(&sNC, p->pEList) ) return 2;
    sNC.ncFlags &= ~0x004000;




    ((void) (0));
    pGroupBy = p->pGroupBy;
    if( pGroupBy || (sNC.ncFlags & 0x000010)!=0 ){
      ((void) (0));
      ((void) (0));
      p->selFlags |= 0x0000008 | (sNC.ncFlags&(0x001000|0x8000000));
    }else{
      sNC.ncFlags &= ~0x000001;
    }
# 111085 "c_tests/sqlite3.c"
    ((void) (0));
    sNC.uNC.pEList = p->pEList;
    sNC.ncFlags |= 0x000080;
    if( p->pHaving ){
      if( (p->selFlags & 0x0000008)==0 ){
        sqlite3ErrorMsg(pParse, "HAVING clause on a non-aggregate query");
        return 2;
      }
      if( sqlite3ResolveExprNames(&sNC, p->pHaving) ) return 2;
    }
    sNC.ncFlags |= 0x100000;
    if( sqlite3ResolveExprNames(&sNC, p->pWhere) ) return 2;
    sNC.ncFlags &= ~0x100000;


    for(i=0; i<p->pSrc->nSrc; i++){
      SrcItem *pItem = &p->pSrc->a[i];
      if( pItem->fg.isTabFunc
       && sqlite3ResolveExprListNames(&sNC, pItem->u1.pFuncArg)
      ){
        return 2;
      }
    }


    if( (pParse->eParseMode>=2) ){
      Window *pWin;
      for(pWin=p->pWinDefn; pWin; pWin=pWin->pNextWin){
        if( sqlite3ResolveExprListNames(&sNC, pWin->pOrderBy)
         || sqlite3ResolveExprListNames(&sNC, pWin->pPartition)
        ){
          return 2;
        }
      }
    }





    sNC.pNext = 0;
    sNC.ncFlags |= 0x000001|0x004000;






    if( p->selFlags & 0x0010000 ){
      Select *pSub;
      ((void) (0));
      pSub = p->pSrc->a[0].u4.pSubq->pSelect;
      ((void) (0));
      p->pOrderBy = pSub->pOrderBy;
      pSub->pOrderBy = 0;
    }
# 111152 "c_tests/sqlite3.c"
    if( p->pOrderBy!=0
     && isCompound<=nCompound
     && resolveOrderGroupBy(&sNC, p, p->pOrderBy, "ORDER")
    ){
      return 2;
    }
    if( db->mallocFailed ){
      return 2;
    }
    sNC.ncFlags &= ~0x004000;




    if( pGroupBy ){
      struct ExprList_item *pItem;

      if( resolveOrderGroupBy(&sNC, p, pGroupBy, "GROUP") || db->mallocFailed ){
        return 2;
      }
      for(i=0, pItem=pGroupBy->a; i<pGroupBy->nExpr; i++, pItem++){
        if( (((pItem->pExpr)->flags&(u32)(0x000010))!=0) ){
          sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in "
              "the GROUP BY clause");
          return 2;
        }
      }
    }



    if( p->pNext && p->pEList->nExpr!=p->pNext->pEList->nExpr ){
      sqlite3SelectWrongNumTermsError(pParse, p->pNext);
      return 2;
    }



    p = p->pPrior;
    nCompound++;
  }




  if( isCompound && resolveCompoundOrderBy(pParse, pLeftmost) ){
    return 2;
  }

  return 1;
}
# 111252 "c_tests/sqlite3.c"
static int sqlite3ResolveExprNames(
  NameContext *pNC,
  Expr *pExpr
){
  int savedHasAgg;
  Walker w;

  if( pExpr==0 ) return 0;
  savedHasAgg = pNC->ncFlags & (0x000010|0x001000|0x008000|0x8000000);
  pNC->ncFlags &= ~(0x000010|0x001000|0x008000|0x8000000);
  w.pParse = pNC->pParse;
  w.xExprCallback = resolveExprStep;
  w.xSelectCallback = (pNC->ncFlags & 0x080000) ? 0 : resolveSelectStep;
  w.xSelectCallback2 = 0;
  w.u.pNC = pNC;

  w.pParse->nHeight += pExpr->nHeight;
  if( sqlite3ExprCheckHeight(w.pParse, w.pParse->nHeight) ){
    return 1;
  }

  ((void) (0));
  sqlite3WalkExprNN(&w, pExpr);

  w.pParse->nHeight -= pExpr->nHeight;

  ((void) (0));
  ((void) (0));
                                      ;
                                      ;
  (pExpr)->flags|=(u32)(pNC->ncFlags & (0x000010|0x008000));
  pNC->ncFlags |= savedHasAgg;
  return pNC->nNcErr>0 || w.pParse->nErr>0;
}
# 111295 "c_tests/sqlite3.c"
static int sqlite3ResolveExprListNames(
  NameContext *pNC,
  ExprList *pList
){
  int i;
  int savedHasAgg = 0;
  Walker w;
  if( pList==0 ) return 0;
  w.pParse = pNC->pParse;
  w.xExprCallback = resolveExprStep;
  w.xSelectCallback = resolveSelectStep;
  w.xSelectCallback2 = 0;
  w.u.pNC = pNC;
  savedHasAgg = pNC->ncFlags & (0x000010|0x001000|0x008000|0x8000000);
  pNC->ncFlags &= ~(0x000010|0x001000|0x008000|0x8000000);
  for(i=0; i<pList->nExpr; i++){
    Expr *pExpr = pList->a[i].pExpr;
    if( pExpr==0 ) continue;

    w.pParse->nHeight += pExpr->nHeight;
    if( sqlite3ExprCheckHeight(w.pParse, w.pParse->nHeight) ){
      return 1;
    }

    sqlite3WalkExprNN(&w, pExpr);

    w.pParse->nHeight -= pExpr->nHeight;

    ((void) (0));
    ((void) (0));
                                        ;
                                        ;
    if( pNC->ncFlags & (0x000010|0x001000|0x008000|0x8000000) ){
      (pExpr)->flags|=(u32)(pNC->ncFlags & (0x000010|0x008000));
      savedHasAgg |= pNC->ncFlags &
                          (0x000010|0x001000|0x008000|0x8000000);
      pNC->ncFlags &= ~(0x000010|0x001000|0x008000|0x8000000);
    }
    if( w.pParse->nErr>0 ) return 1;
  }
  pNC->ncFlags |= savedHasAgg;
  return 0;
}
# 111351 "c_tests/sqlite3.c"
static void sqlite3ResolveSelectNames(
  Parse *pParse,
  Select *p,
  NameContext *pOuterNC
){
  Walker w;

  ((void) (0));
  w.xExprCallback = resolveExprStep;
  w.xSelectCallback = resolveSelectStep;
  w.xSelectCallback2 = 0;
  w.pParse = pParse;
  w.u.pNC = pOuterNC;
  sqlite3WalkSelect(&w, p);
}
# 111385 "c_tests/sqlite3.c"
static int sqlite3ResolveSelfReference(
  Parse *pParse,
  Table *pTab,
  int type,
  Expr *pExpr,
  ExprList *pList
){
  SrcList *pSrc;
  NameContext sNC;
  int rc;
  union {
    SrcList sSrc;
    u8 srcSpace[(__builtin_offsetof(SrcList, a)+sizeof(SrcItem))];
  } uSrc;

  ((void) (0));
  ((void) (0));

  memset(&sNC, 0, sizeof(sNC));
  memset(&uSrc, 0, sizeof(uSrc));
  pSrc = &uSrc.sSrc;
  if( pTab ){
    pSrc->nSrc = 1;
    pSrc->a[0].zName = pTab->zName;
    pSrc->a[0].pSTab = pTab;
    pSrc->a[0].iCursor = -1;
    if( pTab->pSchema!=pParse->db->aDb[1].pSchema ){


      type |= 0x040000;
    }
  }
  sNC.pParse = pParse;
  sNC.pSrcList = pSrc;
  sNC.ncFlags = type | 0x010000;
  if( (rc = sqlite3ResolveExprNames(&sNC, pExpr))!=0 ) return rc;
  if( pList ) rc = sqlite3ResolveExprListNames(&sNC, pList);
  return rc;
}
# 111444 "c_tests/sqlite3.c"
static void exprCodeBetween(Parse*,Expr*,int,void(*)(Parse*,Expr*,int,int),int);
static int exprCodeVector(Parse *pParse, Expr *p, int *piToFree);




static char sqlite3TableColumnAffinity(const Table *pTab, int iCol){
  if( iCol<0 || (iCol>=pTab->nCol) ) return 0x44;
  return pTab->aCol[iCol].affinity;
}
# 111471 "c_tests/sqlite3.c"
static char sqlite3ExprAffinity(const Expr *pExpr){
  int op;
  op = pExpr->op;
  while( 1 ){
    if( op==168 || (op==170 && pExpr->y.pTab!=0) ){
      ((void) (0));
      ((void) (0));
      return sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);
    }
    if( op==139 ){
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);
    }

    if( op==36 ){
      ((void) (0));
      return sqlite3AffinityType(pExpr->u.zToken, 0);
    }

    if( op==178 ){
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      return sqlite3ExprAffinity(
          pExpr->pLeft->x.pSelect->pEList->a[pExpr->iColumn].pExpr
      );
    }
    if( op==177
     || (op==172 && pExpr->affExpr==0x58)
    ){
      ((void) (0));
      return sqlite3ExprAffinity(pExpr->x.pList->a[0].pExpr);
    }
    if( (((pExpr)->flags&(u32)(0x002000|0x040000))!=0) ){
      ((void) (0));


      pExpr = pExpr->pLeft;
      op = pExpr->op;
      continue;
    }
    if( op!=176 ) break;
    op = pExpr->op2;
    if( (op==176) ) break;
  }
  return pExpr->affExpr;
}
# 111533 "c_tests/sqlite3.c"
static int sqlite3ExprDataType(const Expr *pExpr){
  while( pExpr ){
    switch( pExpr->op ){
      case 114:
      case 179:
      case 173: {
        pExpr = pExpr->pLeft;
        break;
      }
      case 122: {
        pExpr = 0;
        break;
      }
      case 118: {
        return 0x02;
      }
      case 155: {
        return 0x04;
      }
      case 112: {
        return 0x06;
      }
      case 157:
      case 169:
      case 172: {
        return 0x07;
      }
      case 168:
      case 170:
      case 139:
      case 36:
      case 178:
      case 177: {
        int aff = sqlite3ExprAffinity(pExpr);
        if( aff>=0x43 ) return 0x05;
        if( aff==0x42 ) return 0x06;
        return 0x07;
      }
      case 158: {
        int res = 0;
        int ii;
        ExprList *pList = pExpr->x.pList;
        ((void) (0));
        ((void) (0));
        for(ii=1; ii<pList->nExpr; ii+=2){
          res |= sqlite3ExprDataType(pList->a[ii].pExpr);
        }
        if( pList->nExpr % 2 ){
          res |= sqlite3ExprDataType(pList->a[pList->nExpr-1].pExpr);
        }
        return res;
      }
      default: {
        return 0x01;
      }
    }
  }
  return 0x00;
}
# 111601 "c_tests/sqlite3.c"
static Expr *sqlite3ExprAddCollateToken(
  const Parse *pParse,
  Expr *pExpr,
  const Token *pCollName,
  int dequote
){
  if( pCollName->n>0 ){
    Expr *pNew = sqlite3ExprAlloc(pParse->db, 114, pCollName, dequote);
    if( pNew ){
      pNew->pLeft = pExpr;
      pNew->flags |= 0x000200|0x002000;
      pExpr = pNew;
    }
  }
  return pExpr;
}
static Expr *sqlite3ExprAddCollateString(
  const Parse *pParse,
  Expr *pExpr,
  const char *zC
){
  Token s;
  ((void) (0));
  sqlite3TokenInit(&s, (char*)zC);
  return sqlite3ExprAddCollateToken(pParse, pExpr, &s, 0);
}




static Expr *sqlite3ExprSkipCollate(Expr *pExpr){
  while( pExpr && (((pExpr)->flags&(u32)(0x002000))!=0) ){
    ((void) (0));
    pExpr = pExpr->pLeft;
  }
  return pExpr;
}






static Expr *sqlite3ExprSkipCollateAndLikely(Expr *pExpr){
  while( pExpr && (((pExpr)->flags&(u32)(0x002000|0x080000))!=0) ){
    if( (((pExpr)->flags&(u32)(0x080000))!=0) ){
      ((void) (0));
      ((void) (0));
      ((void) (0));
      pExpr = pExpr->x.pList->a[0].pExpr;
    }else if( pExpr->op==114 ){
      pExpr = pExpr->pLeft;
    }else{
      break;
    }
  }
  return pExpr;
}
# 111674 "c_tests/sqlite3.c"
static CollSeq *sqlite3ExprCollSeq(Parse *pParse, const Expr *pExpr){
  sqlite3 *db = pParse->db;
  CollSeq *pColl = 0;
  const Expr *p = pExpr;
  while( p ){
    int op = p->op;
    if( op==176 ) op = p->op2;
    if( (op==170 && p->y.pTab!=0)
     || op==168 || op==78
    ){
      int j;
      ((void) (0));
      ((void) (0));
      if( (j = p->iColumn)>=0 ){
        const char *zColl = sqlite3ColumnColl(&p->y.pTab->aCol[j]);
        pColl = sqlite3FindCollSeq(db, ((db)->enc), zColl, 0);
      }
      break;
    }
    if( op==36 || op==173 ){
      p = p->pLeft;
      continue;
    }
    if( op==177
     || (op==172 && p->affExpr==0x58)
    ){
      ((void) (0));
      p = p->x.pList->a[0].pExpr;
      continue;
    }
    if( op==114 ){
      ((void) (0));
      pColl = sqlite3GetCollSeq(pParse, ((db)->enc), 0, p->u.zToken);
      break;
    }
    if( p->flags & 0x000200 ){
      if( p->pLeft && (p->pLeft->flags & 0x000200)!=0 ){
        p = p->pLeft;
      }else{
        Expr *pNext = p->pRight;

        ((void) (0));
        if( (((p)->flags&0x001000)==0) && p->x.pList!=0 && !db->mallocFailed ){
          int i;
          for(i=0; i<p->x.pList->nExpr; i++){
            if( (((p->x.pList->a[i].pExpr)->flags&(u32)(0x000200))!=0) ){
              pNext = p->x.pList->a[i].pExpr;
              break;
            }
          }
        }
        p = pNext;
      }
    }else{
      break;
    }
  }
  if( sqlite3CheckCollSeq(pParse, pColl) ){
    pColl = 0;
  }
  return pColl;
}
# 111747 "c_tests/sqlite3.c"
static CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, const Expr *pExpr){
  CollSeq *p = sqlite3ExprCollSeq(pParse, pExpr);
  if( p==0 ) p = pParse->db->pDfltColl;
  ((void) (0));
  return p;
}




static int sqlite3ExprCollSeqMatch(Parse *pParse, const Expr *pE1, const Expr *pE2){
  CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pE1);
  CollSeq *pColl2 = sqlite3ExprNNCollSeq(pParse, pE2);
  return sqlite3StrICmp(pColl1->zName, pColl2->zName)==0;
}






static char sqlite3CompareAffinity(const Expr *pExpr, char aff2){
  char aff1 = sqlite3ExprAffinity(pExpr);
  if( aff1>0x40 && aff2>0x40 ){



    if( ((aff1)>=0x43) || ((aff2)>=0x43) ){
      return 0x43;
    }else{
      return 0x41;
    }
  }else{

    ((void) (0));
    return (aff1<=0x40 ? aff2 : aff1) | 0x40;
  }
}





static char comparisonAffinity(const Expr *pExpr){
  char aff;
  ((void) (0));


  ((void) (0));
  aff = sqlite3ExprAffinity(pExpr->pLeft);
  if( pExpr->pRight ){
    aff = sqlite3CompareAffinity(pExpr->pRight, aff);
  }else if( (((pExpr)->flags&0x001000)!=0) ){
    aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);
  }else if( aff==0 ){
    aff = 0x41;
  }
  return aff;
}







static int sqlite3IndexAffinityOk(const Expr *pExpr, char idx_affinity){
  char aff = comparisonAffinity(pExpr);
  if( aff<0x42 ){
    return 1;
  }
  if( aff==0x42 ){
    return idx_affinity==0x42;
  }
  return ((idx_affinity)>=0x43);
}





static u8 binaryCompareP5(
  const Expr *pExpr1,
  const Expr *pExpr2,
  int jumpIfNull
){
  u8 aff = (char)sqlite3ExprAffinity(pExpr2);
  aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;
  return aff;
}
# 111850 "c_tests/sqlite3.c"
static CollSeq *sqlite3BinaryCompareCollSeq(
  Parse *pParse,
  const Expr *pLeft,
  const Expr *pRight
){
  CollSeq *pColl;
  ((void) (0));
  if( pLeft->flags & 0x000200 ){
    pColl = sqlite3ExprCollSeq(pParse, pLeft);
  }else if( pRight && (pRight->flags & 0x000200)!=0 ){
    pColl = sqlite3ExprCollSeq(pParse, pRight);
  }else{
    pColl = sqlite3ExprCollSeq(pParse, pLeft);
    if( !pColl ){
      pColl = sqlite3ExprCollSeq(pParse, pRight);
    }
  }
  return pColl;
}
# 111878 "c_tests/sqlite3.c"
static CollSeq *sqlite3ExprCompareCollSeq(Parse *pParse, const Expr *p){
  if( (((p)->flags&(u32)(0x000400))!=0) ){
    return sqlite3BinaryCompareCollSeq(pParse, p->pRight, p->pLeft);
  }else{
    return sqlite3BinaryCompareCollSeq(pParse, p->pLeft, p->pRight);
  }
}




static int codeCompare(
  Parse *pParse,
  Expr *pLeft,
  Expr *pRight,
  int opcode,
  int in1, int in2,
  int dest,
  int jumpIfNull,
  int isCommuted
){
  int p5;
  int addr;
  CollSeq *p4;

  if( pParse->nErr ) return 0;
  if( isCommuted ){
    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);
  }else{
    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
  }
  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);
  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
                           (void*)p4, (-2));
  sqlite3VdbeChangeP5(pParse->pVdbe, (u16)p5);
  return addr;
}
# 111925 "c_tests/sqlite3.c"
static int sqlite3ExprIsVector(const Expr *pExpr){
  return sqlite3ExprVectorSize(pExpr)>1;
}







static int sqlite3ExprVectorSize(const Expr *pExpr){
  u8 op = pExpr->op;
  if( op==176 ) op = pExpr->op2;
  if( op==177 ){
    ((void) (0));
    return pExpr->x.pList->nExpr;
  }else if( op==139 ){
    ((void) (0));
    return pExpr->x.pSelect->pEList->nExpr;
  }else{
    return 1;
  }
}
# 111964 "c_tests/sqlite3.c"
static Expr *sqlite3VectorFieldSubexpr(Expr *pVector, int i){
  ((void) (0));
  if( sqlite3ExprIsVector(pVector) ){
    ((void) (0));
    if( pVector->op==139 || pVector->op2==139 ){
      ((void) (0));
      return pVector->x.pSelect->pEList->a[i].pExpr;
    }else{
      ((void) (0));
      return pVector->x.pList->a[i].pExpr;
    }
  }
  return pVector;
}
# 112000 "c_tests/sqlite3.c"
static Expr *sqlite3ExprForVectorField(
  Parse *pParse,
  Expr *pVector,
  int iField,
  int nField
){
  Expr *pRet;
  if( pVector->op==139 ){
    ((void) (0));
# 112025 "c_tests/sqlite3.c"
    pRet = sqlite3PExpr(pParse, 178, 0, 0);
    if( pRet ){
      (pRet)->flags|=(u32)(0x020000);
      pRet->iTable = nField;
      pRet->iColumn = iField;
      pRet->pLeft = pVector;
    }
  }else{
    if( pVector->op==177 ){
      Expr **ppVector;
      ((void) (0));
      ppVector = &pVector->x.pList->a[iField].pExpr;
      pVector = *ppVector;
      if( (pParse->eParseMode>=2) ){

        *ppVector = 0;
        return pVector;
      }
    }
    pRet = sqlite3ExprDup(pParse->db, pVector, 0);
  }
  return pRet;
}
# 112057 "c_tests/sqlite3.c"
static int exprCodeSubselect(Parse *pParse, Expr *pExpr){
  int reg = 0;

  if( pExpr->op==139 ){
    reg = sqlite3CodeSubselect(pParse, pExpr);
  }

  return reg;
}
# 112085 "c_tests/sqlite3.c"
static int exprVectorRegister(
  Parse *pParse,
  Expr *pVector,
  int iField,
  int regSelect,
  Expr **ppExpr,
  int *pRegFree
){
  u8 op = pVector->op;
  ((void) (0));
  if( op==176 ){
    *ppExpr = sqlite3VectorFieldSubexpr(pVector, iField);
    return pVector->iTable+iField;
  }
  if( op==139 ){
    ((void) (0));
    *ppExpr = pVector->x.pSelect->pEList->a[iField].pExpr;
     return regSelect+iField;
  }
  if( op==177 ){
    ((void) (0));
    *ppExpr = pVector->x.pList->a[iField].pExpr;
    return sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree);
  }
  return 0;
}
# 112123 "c_tests/sqlite3.c"
static void codeVectorCompare(
  Parse *pParse,
  Expr *pExpr,
  int dest,
  u8 op,
  u8 p5
){
  Vdbe *v = pParse->pVdbe;
  Expr *pLeft = pExpr->pLeft;
  Expr *pRight = pExpr->pRight;
  int nLeft = sqlite3ExprVectorSize(pLeft);
  int i;
  int regLeft = 0;
  int regRight = 0;
  u8 opx = op;
  int addrCmp = 0;
  int addrDone = sqlite3VdbeMakeLabel(pParse);
  int isCommuted = (((pExpr)->flags&(u32)(0x000400))!=0);

  ((void) (0));
  if( pParse->nErr ) return;
  if( nLeft!=sqlite3ExprVectorSize(pRight) ){
    sqlite3ErrorMsg(pParse, "row value misused");
    return;
  }
  ((void) (0));




  ((void) (0));

  ((void) (0));
  ((void) (0));

  if( op==56 ) opx = 57;
  if( op==58 ) opx = 55;
  if( op==53 ) opx = 54;

  regLeft = exprCodeSubselect(pParse, pLeft);
  regRight = exprCodeSubselect(pParse, pRight);

  sqlite3VdbeAddOp2(v, 72, 1, dest);
  for(i=0; 1 ; i++){
    int regFree1 = 0, regFree2 = 0;
    Expr *pL = 0, *pR = 0;
    int r1, r2;
    ((void) (0));
    if( addrCmp ) sqlite3VdbeJumpHere(v, addrCmp);
    r1 = exprVectorRegister(pParse, pLeft, i, regLeft, &pL, &regFree1);
    r2 = exprVectorRegister(pParse, pRight, i, regRight, &pR, &regFree2);
    addrCmp = sqlite3VdbeCurrentAddr(v);
    codeCompare(pParse, pL, pR, opx, r1, r2, addrDone, p5, isCommuted);
                       ; ;
                       ; ;
                       ; ;
                       ; ;
                       ; ;
                       ; ;
    sqlite3ReleaseTempReg(pParse, regFree1);
    sqlite3ReleaseTempReg(pParse, regFree2);
    if( (opx==57 || opx==55) && i<nLeft-1 ){
      addrCmp = sqlite3VdbeAddOp0(v, 59);
                          ; ;
                          ; ;
    }
    if( p5==0x80 ){
      sqlite3VdbeAddOp2(v, 72, 0, dest);
    }else{
      sqlite3VdbeAddOp3(v, 93, r1, dest, r2);
    }
    if( i==nLeft-1 ){
      break;
    }
    if( opx==54 ){
      sqlite3VdbeAddOp2(v, 52, dest, addrDone); ;
    }else{
      ((void) (0));
      sqlite3VdbeAddOp2(v, 9, 0, addrDone);
      if( i==nLeft-2 ) opx = op;
    }
  }
  sqlite3VdbeJumpHere(v, addrCmp);
  sqlite3VdbeResolveLabel(v, addrDone);
  if( op==53 ){
    sqlite3VdbeAddOp2(v, 19, dest, dest);
  }
}







static int sqlite3ExprCheckHeight(Parse *pParse, int nHeight){
  int rc = 0;
  int mxHeight = pParse->db->aLimit[3];
  if( nHeight>mxHeight ){
    sqlite3ErrorMsg(pParse,
       "Expression tree is too large (maximum depth %d)", mxHeight
    );
    rc = 1;
  }
  return rc;
}
# 112239 "c_tests/sqlite3.c"
static void heightOfExpr(const Expr *p, int *pnHeight){
  if( p ){
    if( p->nHeight>*pnHeight ){
      *pnHeight = p->nHeight;
    }
  }
}
static void heightOfExprList(const ExprList *p, int *pnHeight){
  if( p ){
    int i;
    for(i=0; i<p->nExpr; i++){
      heightOfExpr(p->a[i].pExpr, pnHeight);
    }
  }
}
static void heightOfSelect(const Select *pSelect, int *pnHeight){
  const Select *p;
  for(p=pSelect; p; p=p->pPrior){
    heightOfExpr(p->pWhere, pnHeight);
    heightOfExpr(p->pHaving, pnHeight);
    heightOfExpr(p->pLimit, pnHeight);
    heightOfExprList(p->pEList, pnHeight);
    heightOfExprList(p->pGroupBy, pnHeight);
    heightOfExprList(p->pOrderBy, pnHeight);
  }
}
# 112276 "c_tests/sqlite3.c"
static void exprSetHeight(Expr *p){
  int nHeight = p->pLeft ? p->pLeft->nHeight : 0;
  if( (p->pRight) && p->pRight->nHeight>nHeight ){
    nHeight = p->pRight->nHeight;
  }
  if( (((p)->flags&0x001000)!=0) ){
    heightOfSelect(p->x.pSelect, &nHeight);
  }else if( p->x.pList ){
    heightOfExprList(p->x.pList, &nHeight);
    p->flags |= (0x000200|0x400000|0x000008) & sqlite3ExprListFlags(p->x.pList);
  }
  p->nHeight = nHeight + 1;
}
# 112298 "c_tests/sqlite3.c"
static void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){
  if( pParse->nErr ) return;
  exprSetHeight(p);
  sqlite3ExprCheckHeight(pParse, p->nHeight);
}





static int sqlite3SelectExprHeight(const Select *p){
  int nHeight = 0;
  heightOfSelect(p, &nHeight);
  return nHeight;
}
# 112330 "c_tests/sqlite3.c"
static void sqlite3ExprSetErrorOffset(Expr *pExpr, int iOfst){
  if( pExpr==0 ) return;
  if( ((((pExpr)->flags&(0x000002|0x000001))!=0)) ) return;
  pExpr->w.iOfst = iOfst;
}
# 112357 "c_tests/sqlite3.c"
static Expr *sqlite3ExprAlloc(
  sqlite3 *db,
  int op,
  const Token *pToken,
  int dequote
){
  Expr *pNew;
  int nExtra = 0;
  int iValue = 0;

  ((void) (0));
  if( pToken ){
    if( op!=156 || pToken->z==0
          || sqlite3GetInt32(pToken->z, &iValue)==0 ){
      nExtra = pToken->n+1;
      ((void) (0));
    }
  }
  pNew = sqlite3DbMallocRawNN(db, sizeof(Expr)+nExtra);
  if( pNew ){
    memset(pNew, 0, sizeof(Expr));
    pNew->op = (u8)op;
    pNew->iAgg = -1;
    if( pToken ){
      if( nExtra==0 ){
        pNew->flags |= 0x000800|0x800000|(iValue?0x10000000:0x20000000);
        pNew->u.iValue = iValue;
      }else{
        pNew->u.zToken = (char*)&pNew[1];
        ((void) (0));
        if( pToken->n ) memcpy(pNew->u.zToken, pToken->z, pToken->n);
        pNew->u.zToken[pToken->n] = 0;
        if( dequote && (sqlite3CtypeMap[(unsigned char)(pNew->u.zToken[0])]&0x80) ){
          sqlite3DequoteExpr(pNew);
        }
      }
    }

    pNew->nHeight = 1;

  }
  return pNew;
}





static Expr *sqlite3Expr(
  sqlite3 *db,
  int op,
  const char *zToken
){
  Token x;
  x.z = zToken;
  x.n = sqlite3Strlen30(zToken);
  return sqlite3ExprAlloc(db, op, &x, 0);
}







static void sqlite3ExprAttachSubtrees(
  sqlite3 *db,
  Expr *pRoot,
  Expr *pLeft,
  Expr *pRight
){
  if( pRoot==0 ){
    ((void) (0));
    sqlite3ExprDelete(db, pLeft);
    sqlite3ExprDelete(db, pRight);
  }else{
    ((void) (0));
    ((void) (0));
    if( pRight ){
      pRoot->pRight = pRight;
      pRoot->flags |= (0x000200|0x400000|0x000008) & pRight->flags;

      pRoot->nHeight = pRight->nHeight+1;
    }else{
      pRoot->nHeight = 1;

    }
    if( pLeft ){
      pRoot->pLeft = pLeft;
      pRoot->flags |= (0x000200|0x400000|0x000008) & pLeft->flags;

      if( pLeft->nHeight>=pRoot->nHeight ){
        pRoot->nHeight = pLeft->nHeight+1;
      }

    }
  }
}
# 112463 "c_tests/sqlite3.c"
static Expr *sqlite3PExpr(
  Parse *pParse,
  int op,
  Expr *pLeft,
  Expr *pRight
){
  Expr *p;
  p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr));
  if( p ){
    memset(p, 0, sizeof(Expr));
    p->op = op & 0xff;
    p->iAgg = -1;
    sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);
    sqlite3ExprCheckHeight(pParse, p->nHeight);
  }else{
    sqlite3ExprDelete(pParse->db, pLeft);
    sqlite3ExprDelete(pParse->db, pRight);
  }
  return p;
}





static void sqlite3PExprAddSelect(Parse *pParse, Expr *pExpr, Select *pSelect){
  if( pExpr ){
    pExpr->x.pSelect = pSelect;
    (pExpr)->flags|=(u32)(0x001000|0x400000);
    sqlite3ExprSetHeightAndFlags(pParse, pExpr);
  }else{
    ((void) (0));
    sqlite3SelectDelete(pParse->db, pSelect);
  }
}
# 112518 "c_tests/sqlite3.c"
static Select *sqlite3ExprListToValues(Parse *pParse, int nElem, ExprList *pEList){
  int ii;
  Select *pRet = 0;
  ((void) (0));
  for(ii=0; ii<pEList->nExpr; ii++){
    Select *pSel;
    Expr *pExpr = pEList->a[ii].pExpr;
    int nExprElem;
    if( pExpr->op==177 ){
      ((void) (0));
      nExprElem = pExpr->x.pList->nExpr;
    }else{
      nExprElem = 1;
    }
    if( nExprElem!=nElem ){
      sqlite3ErrorMsg(pParse, "IN(...) element has %d term%s - expected %d",
          nExprElem, nExprElem>1?"s":"", nElem
      );
      break;
    }
    ((void) (0));
    pSel = sqlite3SelectNew(pParse, pExpr->x.pList, 0, 0, 0, 0, 0, 0x0000200,0);
    pExpr->x.pList = 0;
    if( pSel ){
      if( pRet ){
        pSel->op = 136;
        pSel->pPrior = pRet;
      }
      pRet = pSel;
    }
  }

  if( pRet && pRet->pPrior ){
    pRet->selFlags |= 0x0000400;
  }
  sqlite3ExprListDelete(pParse->db, pEList);
  return pRet;
}
# 112565 "c_tests/sqlite3.c"
static Expr *sqlite3ExprAnd(Parse *pParse, Expr *pLeft, Expr *pRight){
  sqlite3 *db = pParse->db;
  if( pLeft==0 ){
    return pRight;
  }else if( pRight==0 ){
    return pLeft;
  }else{
    u32 f = pLeft->flags | pRight->flags;
    if( (f&(0x000001|0x000002|0x20000000|0x000008))==0x20000000
     && !(pParse->eParseMode>=2)
    ){
      sqlite3ExprDeferredDelete(pParse, pLeft);
      sqlite3ExprDeferredDelete(pParse, pRight);
      return sqlite3Expr(db, 156, "0");
    }else{
      return sqlite3PExpr(pParse, 44, pLeft, pRight);
    }
  }
}





static Expr *sqlite3ExprFunction(
  Parse *pParse,
  ExprList *pList,
  const Token *pToken,
  int eDistinct
){
  Expr *pNew;
  sqlite3 *db = pParse->db;
  ((void) (0));
  pNew = sqlite3ExprAlloc(db, 172, pToken, 1);
  if( pNew==0 ){
    sqlite3ExprListDelete(db, pList);
    return 0;
  }
  ((void) (0));
  pNew->w.iOfst = (int)(pToken->z - pParse->zTail);
  if( pList
   && pList->nExpr > pParse->db->aLimit[6]
   && !pParse->nested
  ){
    sqlite3ErrorMsg(pParse, "too many arguments on function %T", pToken);
  }
  pNew->x.pList = pList;
  (pNew)->flags|=(u32)(0x000008);
  ((void) (0));
  sqlite3ExprSetHeightAndFlags(pParse, pNew);
  if( eDistinct==0x0000001 ) (pNew)->flags|=(u32)(0x000004);
  return pNew;
}





static void sqlite3ExprOrderByAggregateError(Parse *pParse, Expr *p){
  sqlite3ErrorMsg(pParse,
     "ORDER BY may not be used with non-aggregate %#T()", p
  );
}
# 112639 "c_tests/sqlite3.c"
static void sqlite3ExprAddFunctionOrderBy(
  Parse *pParse,
  Expr *pExpr,
  ExprList *pOrderBy
){
  Expr *pOB;
  sqlite3 *db = pParse->db;
  if( (pOrderBy==0) ){
    ((void) (0));
    return;
  }
  if( pExpr==0 ){
    ((void) (0));
    sqlite3ExprListDelete(db, pOrderBy);
    return;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pExpr->x.pList==0 || (pExpr->x.pList->nExpr==0) ){

    sqlite3ParserAddCleanup(pParse, sqlite3ExprListDeleteGeneric, pOrderBy);
    return;
  }
  if( ( ((((pExpr))->flags&(u32)(0x1000000))!=0) && pExpr->y.pWin->eFrmType!=167 ) ){
    sqlite3ExprOrderByAggregateError(pParse, pExpr);
    sqlite3ExprListDelete(db, pOrderBy);
    return;
  }
  if( pOrderBy->nExpr>db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
    sqlite3ExprListDelete(db, pOrderBy);
    return;
  }

  pOB = sqlite3ExprAlloc(db, 146, 0, 0);
  if( pOB==0 ){
    sqlite3ExprListDelete(db, pOrderBy);
    return;
  }
  pOB->x.pList = pOrderBy;
  ((void) (0));
  pExpr->pLeft = pOB;
  (pOB)->flags|=(u32)(0x020000);
}
# 112696 "c_tests/sqlite3.c"
static void sqlite3ExprFunctionUsable(
  Parse *pParse,
  const Expr *pExpr,
  const FuncDef *pDef
){
  ((void) (0));
  ((void) (0));
  if( (((pExpr)->flags&(u32)(0x40000000))!=0) ){
    if( (pDef->funcFlags & 0x00080000)!=0
     || (pParse->db->flags & 0x00000080)==0
    ){







      sqlite3ErrorMsg(pParse, "unsafe use of %#T()", pExpr);
    }
  }
}
# 112735 "c_tests/sqlite3.c"
static void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr, u32 n){
  sqlite3 *db = pParse->db;
  const char *z;
  ynVar x;

  if( pExpr==0 ) return;
  ((void) (0));
  z = pExpr->u.zToken;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( z[1]==0 ){

    ((void) (0));
    x = (ynVar)(++pParse->nVar);
  }else{
    int doAdd = 0;
    if( z[0]=='?' ){


      i64 i;
      int bOk;
      if( n==2 ){
        i = z[1]-'0';
        bOk = 1;
      }else{
        bOk = 0==sqlite3Atoi64(&z[1], &i, n-1, 1);
      }
                      ;
                      ;
                                                               ;
                                                             ;
      if( bOk==0 || i<1 || i>db->aLimit[9] ){
        sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d",
            db->aLimit[9]);
        sqlite3RecordErrorOffsetOfExpr(pParse->db, pExpr);
        return;
      }
      x = (ynVar)i;
      if( x>pParse->nVar ){
        pParse->nVar = (int)x;
        doAdd = 1;
      }else if( sqlite3VListNumToName(pParse->pVList, x)==0 ){
        doAdd = 1;
      }
    }else{




      x = (ynVar)sqlite3VListNameToNum(pParse->pVList, z, n);
      if( x==0 ){
        x = (ynVar)(++pParse->nVar);
        doAdd = 1;
      }
    }
    if( doAdd ){
      pParse->pVList = sqlite3VListAdd(db, pParse->pVList, z, n, x);
    }
  }
  pExpr->iColumn = x;
  if( x>db->aLimit[9] ){
    sqlite3ErrorMsg(pParse, "too many SQL variables");
    sqlite3RecordErrorOffsetOfExpr(pParse->db, pExpr);
  }
}




static __attribute__((noinline)) void sqlite3ExprDeleteNN(sqlite3 *db, Expr *p){
  ((void) (0));
  ((void) (0));
exprDeleteRestart:
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
# 112821 "c_tests/sqlite3.c"
  if( !(((p)->flags&(u32)((0x010000|0x800000)))!=0) ){

    ((void) (0));
    if( p->pRight ){
      ((void) (0));
      sqlite3ExprDeleteNN(db, p->pRight);
    }else if( (((p)->flags&0x001000)!=0) ){
      ((void) (0));
      sqlite3SelectDelete(db, p->x.pSelect);
    }else{
      sqlite3ExprListDelete(db, p->x.pList);

      if( (((p)->flags&(u32)(0x1000000))!=0) ){
        sqlite3WindowDelete(db, p->y.pWin);
      }

    }
    if( p->pLeft && p->op!=178 ){
      Expr *pLeft = p->pLeft;
      if( !(((p)->flags&(u32)(0x8000000))!=0)
       && !(((pLeft)->flags&(u32)(0x8000000))!=0)
      ){

        sqlite3DbNNFreeNN(db, p);
        p = pLeft;
        goto exprDeleteRestart;
      }else{
        sqlite3ExprDeleteNN(db, pLeft);
      }
    }
  }
  if( !(((p)->flags&(u32)(0x8000000))!=0) ){
    sqlite3DbNNFreeNN(db, p);
  }
}
static void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  if( p ) sqlite3ExprDeleteNN(db, p);
}
static void sqlite3ExprDeleteGeneric(sqlite3 *db, void *p){
  if( (p) ) sqlite3ExprDeleteNN(db, (Expr*)p);
}




static void sqlite3ClearOnOrUsing(sqlite3 *db, OnOrUsing *p){
  if( p==0 ){

  }else if( p->pOn ){
    sqlite3ExprDeleteNN(db, p->pOn);
  }else if( p->pUsing ){
    sqlite3IdListDelete(db, p->pUsing);
  }
}
# 112886 "c_tests/sqlite3.c"
static int sqlite3ExprDeferredDelete(Parse *pParse, Expr *pExpr){
  return 0==sqlite3ParserAddCleanup(pParse, sqlite3ExprDeleteGeneric, pExpr);
}




static void sqlite3ExprUnmapAndDelete(Parse *pParse, Expr *p){
  if( p ){
    if( (pParse->eParseMode>=2) ){
      sqlite3RenameExprUnmap(pParse, p);
    }
    sqlite3ExprDeleteNN(pParse->db, p);
  }
}






static int exprStructSize(const Expr *p){
  if( (((p)->flags&(u32)(0x010000))!=0) ) return __builtin_offsetof(Expr, pLeft);
  if( (((p)->flags&(u32)(0x004000))!=0) ) return __builtin_offsetof(Expr, iTable);
  return sizeof(Expr);
}
# 112947 "c_tests/sqlite3.c"
static int dupedExprStructSize(const Expr *p, int flags){
  int nSize;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( 0==flags || (((p)->flags&(u32)(0x020000))!=0) ){
    nSize = sizeof(Expr);
  }else{
    ((void) (0));
    ((void) (0));
    ((void) (0));
    if( p->pLeft || p->x.pList ){
      nSize = __builtin_offsetof(Expr, iTable) | 0x004000;
    }else{
      ((void) (0));
      nSize = __builtin_offsetof(Expr, pLeft) | 0x010000;
    }
  }
  return nSize;
}






static int dupedExprNodeSize(const Expr *p, int flags){
  int nByte = dupedExprStructSize(p, flags) & 0xfff;
  if( !(((p)->flags&(u32)(0x000800))!=0) && p->u.zToken ){
    nByte += (strlen(p->u.zToken)&0x3fffffff)+1;
  }
  return (((nByte)+7)&~7);
}
# 112992 "c_tests/sqlite3.c"
static int dupedExprSize(const Expr *p){
  int nByte;
  ((void) (0));
  nByte = dupedExprNodeSize(p, 0x0001);
  if( p->pLeft ) nByte += dupedExprSize(p->pLeft);
  if( p->pRight ) nByte += dupedExprSize(p->pRight);
  ((void) (0));
  return nByte;
}
# 113010 "c_tests/sqlite3.c"
typedef struct EdupBuf EdupBuf;
struct EdupBuf {
  u8 *zAlloc;



};







static Expr *exprDup(
  sqlite3 *db,
  const Expr *p,
  int dupFlags,
  EdupBuf *pEdupBuf
){
  Expr *pNew;
  EdupBuf sEdupBuf;
  u32 staticFlag;
  int nToken = -1;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  if( pEdupBuf ){
    sEdupBuf.zAlloc = pEdupBuf->zAlloc;



    staticFlag = 0x8000000;
    ((void) (0));
    ((void) (0));
  }else{
    int nAlloc;
    if( dupFlags ){
      nAlloc = dupedExprSize(p);
    }else if( !(((p)->flags&(u32)(0x000800))!=0) && p->u.zToken ){
      nToken = (strlen(p->u.zToken)&0x3fffffff)+1;
      nAlloc = (((sizeof(Expr) + nToken)+7)&~7);
    }else{
      nToken = 0;
      nAlloc = (((sizeof(Expr))+7)&~7);
    }
    ((void) (0));
    sEdupBuf.zAlloc = sqlite3DbMallocRawNN(db, nAlloc);




    staticFlag = 0;
  }
  pNew = (Expr *)sEdupBuf.zAlloc;
  ((void) (0));

  if( pNew ){





    const unsigned nStructSize = dupedExprStructSize(p, dupFlags);
    int nNewSize = nStructSize & 0xfff;
    if( nToken<0 ){
      if( !(((p)->flags&(u32)(0x000800))!=0) && p->u.zToken ){
        nToken = sqlite3Strlen30(p->u.zToken) + 1;
      }else{
        nToken = 0;
      }
    }
    if( dupFlags ){
      ((void) (0));
      ((void) (0));
      memcpy(sEdupBuf.zAlloc, p, nNewSize);
    }else{
      u32 nSize = (u32)exprStructSize(p);
      ((void) (0));

      memcpy(sEdupBuf.zAlloc, p, nSize);
      if( nSize<sizeof(Expr) ){
        memset(&sEdupBuf.zAlloc[nSize], 0, sizeof(Expr)-nSize);
      }
      nNewSize = sizeof(Expr);
    }


    pNew->flags &= ~(0x004000|0x010000|0x8000000);
    pNew->flags |= nStructSize & (0x004000|0x010000);
    pNew->flags |= staticFlag;
                                ;
    if( dupFlags ){
                                            ;
    }


    ((void) (0));
    if( nToken>0 ){
      char *zToken = pNew->u.zToken = (char*)&sEdupBuf.zAlloc[nNewSize];
      memcpy(zToken, p->u.zToken, nToken);
      nNewSize += nToken;
    }
    sEdupBuf.zAlloc += (((nNewSize)+7)&~7);

    if( ((p->flags|pNew->flags)&(0x010000|0x800000))==0 ){


      if( (((p)->flags&0x001000)!=0) ){
        pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, dupFlags);
      }else{
        pNew->x.pList = sqlite3ExprListDup(db, p->x.pList,
                           p->op!=146 ? dupFlags : 0);
      }


      if( (((p)->flags&(u32)(0x1000000))!=0) ){
        pNew->y.pWin = sqlite3WindowDup(db, pNew, p->y.pWin);
        ((void) (0));
      }



      if( dupFlags ){
        if( p->op==178 ){
          pNew->pLeft = p->pLeft;
          ((void) (0));


        }else{
          pNew->pLeft = p->pLeft ?
                      exprDup(db, p->pLeft, 0x0001, &sEdupBuf) : 0;
        }
        pNew->pRight = p->pRight ?
                       exprDup(db, p->pRight, 0x0001, &sEdupBuf) : 0;
      }else{
        if( p->op==178 ){
          pNew->pLeft = p->pLeft;
          ((void) (0));


        }else{
          pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0);
        }
        pNew->pRight = sqlite3ExprDup(db, p->pRight, 0);
      }
    }
  }
  if( pEdupBuf ) memcpy(pEdupBuf, &sEdupBuf, sizeof(sEdupBuf));
  ((void) (0));
  return pNew;
}







static With *sqlite3WithDup(sqlite3 *db, With *p){
  With *pRet = 0;
  if( p ){
    sqlite3_int64 nByte = (__builtin_offsetof(With, a) + (p->nCte)*sizeof(Cte));
    pRet = sqlite3DbMallocZero(db, nByte);
    if( pRet ){
      int i;
      pRet->nCte = p->nCte;
      for(i=0; i<p->nCte; i++){
        pRet->a[i].pSelect = sqlite3SelectDup(db, p->a[i].pSelect, 0);
        pRet->a[i].pCols = sqlite3ExprListDup(db, p->a[i].pCols, 0);
        pRet->a[i].zName = sqlite3DbStrDup(db, p->a[i].zName);
        pRet->a[i].eM10d = p->a[i].eM10d;
      }
    }
  }
  return pRet;
}
# 113202 "c_tests/sqlite3.c"
static int gatherSelectWindowsCallback(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==172 && (((pExpr)->flags&(u32)(0x1000000))!=0) ){
    Select *pSelect = pWalker->u.pSelect;
    Window *pWin = pExpr->y.pWin;
    ((void) (0));
    ((void) (0));
    ((void) (0));
    sqlite3WindowLink(pSelect, pWin);
  }
  return 0;
}
static int gatherSelectWindowsSelectCallback(Walker *pWalker, Select *p){
  return p==pWalker->u.pSelect ? 0 : 1;
}
static void gatherSelectWindows(Select *p){
  Walker w;
  w.xExprCallback = gatherSelectWindowsCallback;
  w.xSelectCallback = gatherSelectWindowsSelectCallback;
  w.xSelectCallback2 = 0;
  w.pParse = 0;
  w.u.pSelect = p;
  sqlite3WalkSelect(&w, p);
}
# 113245 "c_tests/sqlite3.c"
static Expr *sqlite3ExprDup(sqlite3 *db, const Expr *p, int flags){
  ((void) (0));
  return p ? exprDup(db, p, flags, 0) : 0;
}
static ExprList *sqlite3ExprListDup(sqlite3 *db, const ExprList *p, int flags){
  ExprList *pNew;
  struct ExprList_item *pItem;
  const struct ExprList_item *pOldItem;
  int i;
  Expr *pPriorSelectColOld = 0;
  Expr *pPriorSelectColNew = 0;
  ((void) (0));
  if( p==0 ) return 0;
  pNew = sqlite3DbMallocRawNN(db, sqlite3DbMallocSize(db, p));
  if( pNew==0 ) return 0;
  pNew->nExpr = p->nExpr;
  pNew->nAlloc = p->nAlloc;
  pItem = pNew->a;
  pOldItem = p->a;
  for(i=0; i<p->nExpr; i++, pItem++, pOldItem++){
    Expr *pOldExpr = pOldItem->pExpr;
    Expr *pNewExpr;
    pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags);
    if( pOldExpr
     && pOldExpr->op==178
     && (pNewExpr = pItem->pExpr)!=0
    ){
      if( pNewExpr->pRight ){
        pPriorSelectColOld = pOldExpr->pRight;
        pPriorSelectColNew = pNewExpr->pRight;
        pNewExpr->pLeft = pNewExpr->pRight;
      }else{
        if( pOldExpr->pLeft!=pPriorSelectColOld ){
          pPriorSelectColOld = pOldExpr->pLeft;
          pPriorSelectColNew = sqlite3ExprDup(db, pPriorSelectColOld, flags);
          pNewExpr->pRight = pPriorSelectColNew;
        }
        pNewExpr->pLeft = pPriorSelectColNew;
      }
    }
    pItem->zEName = sqlite3DbStrDup(db, pOldItem->zEName);
    pItem->fg = pOldItem->fg;
    pItem->u = pOldItem->u;
  }
  return pNew;
}
# 113300 "c_tests/sqlite3.c"
static SrcList *sqlite3SrcListDup(sqlite3 *db, const SrcList *p, int flags){
  SrcList *pNew;
  int i;
  ((void) (0));
  if( p==0 ) return 0;
  pNew = sqlite3DbMallocRawNN(db, (__builtin_offsetof(SrcList, a)+(p->nSrc)*sizeof(SrcItem)) );
  if( pNew==0 ) return 0;
  pNew->nSrc = pNew->nAlloc = p->nSrc;
  for(i=0; i<p->nSrc; i++){
    SrcItem *pNewItem = &pNew->a[i];
    const SrcItem *pOldItem = &p->a[i];
    Table *pTab;
    pNewItem->fg = pOldItem->fg;
    if( pOldItem->fg.isSubquery ){
      Subquery *pNewSubq = sqlite3DbMallocRaw(db, sizeof(Subquery));
      if( pNewSubq==0 ){
        ((void) (0));
        pNewItem->fg.isSubquery = 0;
      }else{
        memcpy(pNewSubq, pOldItem->u4.pSubq, sizeof(*pNewSubq));
        pNewSubq->pSelect = sqlite3SelectDup(db, pNewSubq->pSelect, flags);
        if( pNewSubq->pSelect==0 ){
          sqlite3DbFree(db, pNewSubq);
          pNewSubq = 0;
          pNewItem->fg.isSubquery = 0;
        }
      }
      pNewItem->u4.pSubq = pNewSubq;
    }else if( pOldItem->fg.fixedSchema ){
      pNewItem->u4.pSchema = pOldItem->u4.pSchema;
    }else{
      pNewItem->u4.zDatabase = sqlite3DbStrDup(db, pOldItem->u4.zDatabase);
    }
    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
    pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias);
    pNewItem->iCursor = pOldItem->iCursor;
    if( pNewItem->fg.isIndexedBy ){
      pNewItem->u1.zIndexedBy = sqlite3DbStrDup(db, pOldItem->u1.zIndexedBy);
    }else if( pNewItem->fg.isTabFunc ){
      pNewItem->u1.pFuncArg =
          sqlite3ExprListDup(db, pOldItem->u1.pFuncArg, flags);
    }else{
      pNewItem->u1.nRow = pOldItem->u1.nRow;
    }
    pNewItem->u2 = pOldItem->u2;
    if( pNewItem->fg.isCte ){
      pNewItem->u2.pCteUse->nUse++;
    }
    pTab = pNewItem->pSTab = pOldItem->pSTab;
    if( pTab ){
      pTab->nTabRef++;
    }
    if( pOldItem->fg.isUsing ){
      ((void) (0));
      pNewItem->u3.pUsing = sqlite3IdListDup(db, pOldItem->u3.pUsing);
    }else{
      pNewItem->u3.pOn = sqlite3ExprDup(db, pOldItem->u3.pOn, flags);
    }
    pNewItem->colUsed = pOldItem->colUsed;
  }
  return pNew;
}
static IdList *sqlite3IdListDup(sqlite3 *db, const IdList *p){
  IdList *pNew;
  int i;
  ((void) (0));
  if( p==0 ) return 0;
  pNew = sqlite3DbMallocRawNN(db, (__builtin_offsetof(IdList, a)+(p->nId)*sizeof(struct IdList_item)));
  if( pNew==0 ) return 0;
  pNew->nId = p->nId;
  for(i=0; i<p->nId; i++){
    struct IdList_item *pNewItem = &pNew->a[i];
    const struct IdList_item *pOldItem = &p->a[i];
    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
  }
  return pNew;
}
static Select *sqlite3SelectDup(sqlite3 *db, const Select *pDup, int flags){
  Select *pRet = 0;
  Select *pNext = 0;
  Select **pp = &pRet;
  const Select *p;

  ((void) (0));
  for(p=pDup; p; p=p->pPrior){
    Select *pNew = sqlite3DbMallocRawNN(db, sizeof(*p) );
    if( pNew==0 ) break;
    pNew->pEList = sqlite3ExprListDup(db, p->pEList, flags);
    pNew->pSrc = sqlite3SrcListDup(db, p->pSrc, flags);
    pNew->pWhere = sqlite3ExprDup(db, p->pWhere, flags);
    pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy, flags);
    pNew->pHaving = sqlite3ExprDup(db, p->pHaving, flags);
    pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, flags);
    pNew->op = p->op;
    pNew->pNext = pNext;
    pNew->pPrior = 0;
    pNew->pLimit = sqlite3ExprDup(db, p->pLimit, flags);
    pNew->iLimit = 0;
    pNew->iOffset = 0;
    pNew->selFlags = p->selFlags & ~(u32)0x0000020;
    pNew->addrOpenEphm[0] = -1;
    pNew->addrOpenEphm[1] = -1;
    pNew->nSelectRow = p->nSelectRow;
    pNew->pWith = sqlite3WithDup(db, p->pWith);

    pNew->pWin = 0;
    pNew->pWinDefn = sqlite3WindowListDup(db, p->pWinDefn);
    if( p->pWin && db->mallocFailed==0 ) gatherSelectWindows(pNew);

    pNew->selId = p->selId;
    if( db->mallocFailed ){



      pNew->pNext = 0;
      sqlite3SelectDelete(db, pNew);
      break;
    }
    *pp = pNew;
    pp = &pNew->pPrior;
    pNext = pNew;
  }
  return pRet;
}
# 113443 "c_tests/sqlite3.c"
static const struct ExprList_item zeroItem = {0};
static __attribute__((noinline)) ExprList *sqlite3ExprListAppendNew(
  sqlite3 *db,
  Expr *pExpr
){
  struct ExprList_item *pItem;
  ExprList *pList;

  pList = sqlite3DbMallocRawNN(db, (__builtin_offsetof(ExprList, a) + (4)*sizeof(struct ExprList_item)));
  if( pList==0 ){
    sqlite3ExprDelete(db, pExpr);
    return 0;
  }
  pList->nAlloc = 4;
  pList->nExpr = 1;
  pItem = &pList->a[0];
  *pItem = zeroItem;
  pItem->pExpr = pExpr;
  return pList;
}
static __attribute__((noinline)) ExprList *sqlite3ExprListAppendGrow(
  sqlite3 *db,
  ExprList *pList,
  Expr *pExpr
){
  struct ExprList_item *pItem;
  ExprList *pNew;
  pList->nAlloc *= 2;
  pNew = sqlite3DbRealloc(db, pList, (__builtin_offsetof(ExprList, a) + (pList->nAlloc)*sizeof(struct ExprList_item)));
  if( pNew==0 ){
    sqlite3ExprListDelete(db, pList);
    sqlite3ExprDelete(db, pExpr);
    return 0;
  }else{
    pList = pNew;
  }
  pItem = &pList->a[pList->nExpr++];
  *pItem = zeroItem;
  pItem->pExpr = pExpr;
  return pList;
}
static ExprList *sqlite3ExprListAppend(
  Parse *pParse,
  ExprList *pList,
  Expr *pExpr
){
  struct ExprList_item *pItem;
  if( pList==0 ){
    return sqlite3ExprListAppendNew(pParse->db,pExpr);
  }
  if( pList->nAlloc<pList->nExpr+1 ){
    return sqlite3ExprListAppendGrow(pParse->db,pList,pExpr);
  }
  pItem = &pList->a[pList->nExpr++];
  *pItem = zeroItem;
  pItem->pExpr = pExpr;
  return pList;
}
# 113513 "c_tests/sqlite3.c"
static ExprList *sqlite3ExprListAppendVector(
  Parse *pParse,
  ExprList *pList,
  IdList *pColumns,
  Expr *pExpr
){
  sqlite3 *db = pParse->db;
  int n;
  int i;
  int iFirst = pList ? pList->nExpr : 0;


  if( (pColumns==0) ) goto vector_append_error;
  if( pExpr==0 ) goto vector_append_error;






  if( pExpr->op!=139 && pColumns->nId!=(n=sqlite3ExprVectorSize(pExpr)) ){
    sqlite3ErrorMsg(pParse, "%d columns assigned %d values",
                    pColumns->nId, n);
    goto vector_append_error;
  }

  for(i=0; i<pColumns->nId; i++){
    Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i, pColumns->nId);
    ((void) (0));
    if( pSubExpr==0 ) continue;
    pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);
    if( pList ){
      ((void) (0));
      pList->a[pList->nExpr-1].zEName = pColumns->a[i].zName;
      pColumns->a[i].zName = 0;
    }
  }

  if( !db->mallocFailed && pExpr->op==139 && (pList!=0) ){
    Expr *pFirst = pList->a[iFirst].pExpr;
    ((void) (0));
    ((void) (0));



    pFirst->pRight = pExpr;
    pExpr = 0;



    pFirst->iTable = pColumns->nId;
  }

vector_append_error:
  sqlite3ExprUnmapAndDelete(pParse, pExpr);
  sqlite3IdListDelete(db, pColumns);
  return pList;
}




static void sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder, int eNulls){
  struct ExprList_item *pItem;
  if( p==0 ) return;
  ((void) (0));

  ((void) (0));
  ((void) (0));



  ((void) (0));




  pItem = &p->a[p->nExpr-1];
  ((void) (0));
  if( iSortOrder==-1 ){
    iSortOrder = 0;
  }
  pItem->fg.sortFlags = (u8)iSortOrder;

  if( eNulls!=-1 ){
    pItem->fg.bNulls = 1;
    if( iSortOrder!=eNulls ){
      pItem->fg.sortFlags |= 0x02;
    }
  }
}
# 113613 "c_tests/sqlite3.c"
static void sqlite3ExprListSetName(
  Parse *pParse,
  ExprList *pList,
  const Token *pName,
  int dequote
){
  ((void) (0));
  ((void) (0));
  if( pList ){
    struct ExprList_item *pItem;
    ((void) (0));
    pItem = &pList->a[pList->nExpr-1];
    ((void) (0));
    ((void) (0));
    pItem->zEName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n);
    if( dequote ){



      sqlite3Dequote(pItem->zEName);
      if( (pParse->eParseMode>=2) ){
        sqlite3RenameTokenMap(pParse, (const void*)pItem->zEName, pName);
      }
    }
  }
}
# 113648 "c_tests/sqlite3.c"
static void sqlite3ExprListSetSpan(
  Parse *pParse,
  ExprList *pList,
  const char *zStart,
  const char *zEnd
){
  sqlite3 *db = pParse->db;
  ((void) (0));
  if( pList ){
    struct ExprList_item *pItem = &pList->a[pList->nExpr-1];
    ((void) (0));
    if( pItem->zEName==0 ){
      pItem->zEName = sqlite3DbSpanDup(db, zStart, zEnd);
      pItem->fg.eEName = 1;
    }
  }
}





static void sqlite3ExprListCheckLength(
  Parse *pParse,
  ExprList *pEList,
  const char *zObject
){
  int mx = pParse->db->aLimit[2];
                                         ;
                                           ;
  if( pEList && pEList->nExpr>mx ){
    sqlite3ErrorMsg(pParse, "too many columns in %s", zObject);
  }
}




static __attribute__((noinline)) void exprListDeleteNN(sqlite3 *db, ExprList *pList){
  int i = pList->nExpr;
  struct ExprList_item *pItem = pList->a;
  ((void) (0));
  ((void) (0));
  do{
    sqlite3ExprDelete(db, pItem->pExpr);
    if( pItem->zEName ) sqlite3DbNNFreeNN(db, pItem->zEName);
    pItem++;
  }while( --i>0 );
  sqlite3DbNNFreeNN(db, pList);
}
static void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){
  if( pList ) exprListDeleteNN(db, pList);
}
static void sqlite3ExprListDeleteGeneric(sqlite3 *db, void *pList){
  if( (pList) ) exprListDeleteNN(db, (ExprList*)pList);
}





static u32 sqlite3ExprListFlags(const ExprList *pList){
  int i;
  u32 m = 0;
  ((void) (0));
  for(i=0; i<pList->nExpr; i++){
     Expr *pExpr = pList->a[i].pExpr;
     ((void) (0));
     m |= pExpr->flags;
  }
  return m;
}
# 113728 "c_tests/sqlite3.c"
static int sqlite3SelectWalkFail(Walker *pWalker, Select *NotUsed){
  (void)(NotUsed);
  pWalker->eCode = 0;
  return 2;
}
# 113742 "c_tests/sqlite3.c"
static u32 sqlite3IsTrueOrFalse(const char *zIn){
  if( sqlite3StrICmp(zIn, "true")==0 ) return 0x10000000;
  if( sqlite3StrICmp(zIn, "false")==0 ) return 0x20000000;
  return 0;
}







static int sqlite3ExprIdToTrueFalse(Expr *pExpr){
  u32 v;
  ((void) (0));
  if( !(((pExpr)->flags&(u32)(0x4000000|0x000800))!=0)
   && (v = sqlite3IsTrueOrFalse(pExpr->u.zToken))!=0
  ){
    pExpr->op = 171;
    (pExpr)->flags|=(u32)(v);
    return 1;
  }
  return 0;
}





static int sqlite3ExprTruthValue(const Expr *pExpr){
  pExpr = sqlite3ExprSkipCollateAndLikely((Expr*)pExpr);
  ((void) (0));
  ((void) (0));
  ((void) (0));

  return pExpr->u.zToken[4]==0;
}
# 113793 "c_tests/sqlite3.c"
static Expr *sqlite3ExprSimplifiedAndOr(Expr *pExpr){
  ((void) (0));
  if( pExpr->op==44 || pExpr->op==43 ){
    Expr *pRight = sqlite3ExprSimplifiedAndOr(pExpr->pRight);
    Expr *pLeft = sqlite3ExprSimplifiedAndOr(pExpr->pLeft);
    if( (((pLeft)->flags&(0x000001|0x10000000))==0x10000000) || (((pRight)->flags&(0x000001|0x20000000))==0x20000000) ){
      pExpr = pExpr->op==44 ? pRight : pLeft;
    }else if( (((pRight)->flags&(0x000001|0x10000000))==0x10000000) || (((pLeft)->flags&(0x000001|0x20000000))==0x20000000) ){
      pExpr = pExpr->op==44 ? pLeft : pRight;
    }
  }
  return pExpr;
}
# 113815 "c_tests/sqlite3.c"
static int exprEvalRhsFirst(Expr *pExpr){
  if( (((pExpr->pLeft)->flags&(u32)(0x400000))!=0)
   && !(((pExpr->pRight)->flags&(u32)(0x400000))!=0)
  ){
    return 1;
  }else{
    return 0;
  }
}
# 113837 "c_tests/sqlite3.c"
static int exprComputeOperands(
  Parse *pParse,
  Expr *pExpr,
  int *pR1,
  int *pR2,
  int *pFree1,
  int *pFree2
){
  int addrIsNull;
  int r1, r2;
  Vdbe *v = pParse->pVdbe;

  ((void) (0));






  if( exprEvalRhsFirst(pExpr) && sqlite3ExprCanBeNull(pExpr->pRight) ){
    r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, pFree2);
    addrIsNull = sqlite3VdbeAddOp1(v, 51, r2);
                                         ;
                   ;
  }else{
    r2 = 0;
    addrIsNull = 0;
  }
  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, pFree1);
  if( addrIsNull==0 ){





    if( (((pExpr->pRight)->flags&(u32)(0x400000))!=0)
     && sqlite3ExprCanBeNull(pExpr->pLeft)
    ){
      addrIsNull = sqlite3VdbeAddOp1(v, 51, r1);
                                            ;
                     ;
    }
    r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, pFree2);
  }
  *pR1 = r1;
  *pR2 = r2;
  return addrIsNull;
}
# 113902 "c_tests/sqlite3.c"
static __attribute__((noinline)) int exprNodeIsConstantFunction(
  Walker *pWalker,
  Expr *pExpr
){
  int n;
  ExprList *pList;
  FuncDef *pDef;
  sqlite3 *db;

  ((void) (0));
  if( (((pExpr)->flags&(u32)(0x010000))!=0)
   || (pList = pExpr->x.pList)==0
  ){;
    n = 0;
  }else{
    n = pList->nExpr;
    sqlite3WalkExprList(pWalker, pList);
    if( pWalker->eCode==0 ) return 2;
  }
  db = pWalker->pParse->db;
  pDef = sqlite3FindFunction(db, pExpr->u.zToken, n, ((db)->enc), 0);
  if( pDef==0
   || pDef->xFinalize!=0
   || (pDef->funcFlags & (0x0800|0x2000))==0
   || (((pExpr)->flags&(u32)(0x1000000))!=0)
  ){
    pWalker->eCode = 0;
    return 2;
  }
  return 1;
}
# 113961 "c_tests/sqlite3.c"
static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){
  ((void) (0));




  if( pWalker->eCode==2 && (((pExpr)->flags&(u32)(0x000001))!=0) ){
    pWalker->eCode = 0;
    return 2;
  }

  switch( pExpr->op ){



    case 172:
      if( (pWalker->eCode>=4 || (((pExpr)->flags&(u32)(0x100000))!=0))
       && !(((pExpr)->flags&(u32)(0x1000000))!=0)
      ){
        if( pWalker->eCode==5 ) (pExpr)->flags|=(u32)(0x40000000);
        return 0;
      }else if( pWalker->pParse ){
        return exprNodeIsConstantFunction(pWalker, pExpr);
      }else{
        pWalker->eCode = 0;
        return 2;
      }
    case 60:


      if( sqlite3ExprIdToTrueFalse(pExpr) ){
        return 1;
      }
                     __attribute__((fallthrough));
    case 168:
    case 169:
    case 170:
                                  ;
                                      ;
                                            ;
                                          ;
      if( (((pExpr)->flags&(u32)(0x000020))!=0) && pWalker->eCode!=2 ){
        return 0;
      }
      if( pWalker->eCode==3 && pExpr->iTable==pWalker->u.iCur ){
        return 0;
      }
                     __attribute__((fallthrough));
    case 179:
    case 176:
    case 142:
    case 72:
                                        ;
                                           ;
                                   ;
                                     ;
      pWalker->eCode = 0;
      return 2;
    case 157:
      if( pWalker->eCode==5 ){



        pExpr->op = 122;
      }else if( pWalker->eCode==4 ){


        pWalker->eCode = 0;
        return 2;
      }
                     __attribute__((fallthrough));
    default:
                                      ;
                                      ;
      return 0;
  }
}
static int exprIsConst(Parse *pParse, Expr *p, int initFlag){
  Walker w;
  w.eCode = initFlag;
  w.pParse = pParse;
  w.xExprCallback = exprNodeIsConstant;
  w.xSelectCallback = sqlite3SelectWalkFail;



  sqlite3WalkExpr(&w, p);
  return w.eCode;
}
# 114065 "c_tests/sqlite3.c"
static int sqlite3ExprIsConstant(Parse *pParse, Expr *p){
  return exprIsConst(pParse, p, 1);
}
# 114082 "c_tests/sqlite3.c"
static int sqlite3ExprIsConstantNotJoin(Parse *pParse, Expr *p){
  return exprIsConst(pParse, p, 2);
}







static int exprSelectWalkTableConstant(Walker *pWalker, Select *pSelect){
  ((void) (0));
  ((void) (0));
  if( (pSelect->selFlags & 0x20000000)!=0 ){
    pWalker->eCode = 0;
    return 2;
  }
  return 1;
}
# 114111 "c_tests/sqlite3.c"
static int sqlite3ExprIsTableConstant(Expr *p, int iCur, int bAllowSubq){
  Walker w;
  w.eCode = 3;
  w.pParse = 0;
  w.xExprCallback = exprNodeIsConstant;
  if( bAllowSubq ){
    w.xSelectCallback = exprSelectWalkTableConstant;
  }else{
    w.xSelectCallback = sqlite3SelectWalkFail;



  }
  w.u.iCur = iCur;
  sqlite3WalkExpr(&w, p);
  return w.eCode;
}
# 114173 "c_tests/sqlite3.c"
static int sqlite3ExprIsSingleTableConstraint(
  Expr *pExpr,
  const SrcList *pSrcList,
  int iSrc,
  int bAllowSubq
){
  const SrcItem *pSrc = &pSrcList->a[iSrc];
  if( pSrc->fg.jointype & 0x40 ){
    return 0;
  }
  if( pSrc->fg.jointype & 0x08 ){
    if( !(((pExpr)->flags&(u32)(0x000001))!=0) ) return 0;
    if( pExpr->w.iJoin!=pSrc->iCursor ) return 0;
  }else{
    if( (((pExpr)->flags&(u32)(0x000001))!=0) ) return 0;
  }
  if( (((pExpr)->flags&(u32)(0x000001|0x000002))!=0)
   && (pSrcList->a[0].fg.jointype & 0x40)!=0
  ){
    int jj;
    for(jj=0; jj<iSrc; jj++){
      if( pExpr->w.iJoin==pSrcList->a[jj].iCursor ){
        if( (pSrcList->a[jj].fg.jointype & 0x40)!=0 ){
          return 0;
        }
        break;
      }
    }
  }

  return sqlite3ExprIsTableConstant(pExpr, pSrc->iCursor, bAllowSubq);
}





static int exprNodeIsConstantOrGroupBy(Walker *pWalker, Expr *pExpr){
  ExprList *pGroupBy = pWalker->u.pGroupBy;
  int i;



  for(i=0; i<pGroupBy->nExpr; i++){
    Expr *p = pGroupBy->a[i].pExpr;
    if( sqlite3ExprCompare(0, pExpr, p, -1)<2 ){
      CollSeq *pColl = sqlite3ExprNNCollSeq(pWalker->pParse, p);
      if( sqlite3IsBinary(pColl) ){
        return 1;
      }
    }
  }


  if( (((pExpr)->flags&0x001000)!=0) ){
    pWalker->eCode = 0;
    return 2;
  }

  return exprNodeIsConstant(pWalker, pExpr);
}
# 114254 "c_tests/sqlite3.c"
static int sqlite3ExprIsConstantOrGroupBy(Parse *pParse, Expr *p, ExprList *pGroupBy){
  Walker w;
  w.eCode = 1;
  w.xExprCallback = exprNodeIsConstantOrGroupBy;
  w.xSelectCallback = 0;
  w.u.pGroupBy = pGroupBy;
  w.pParse = pParse;
  sqlite3WalkExpr(&w, p);
  return w.eCode;
}
# 114286 "c_tests/sqlite3.c"
static int sqlite3ExprIsConstantOrFunction(Expr *p, u8 isInit){
  ((void) (0));
  return exprIsConst(0, p, 4+isInit);
}
# 114319 "c_tests/sqlite3.c"
static int sqlite3ExprIsInteger(const Expr *p, int *pValue, Parse *pParse){
  int rc = 0;
  if( (p==0) ) return 0;



  ((void) (0));


  if( p->flags & 0x000800 ){
    *pValue = p->u.iValue;
    return 1;
  }
  switch( p->op ){
    case 173: {
      rc = sqlite3ExprIsInteger(p->pLeft, pValue, 0);
      break;
    }
    case 174: {
      int v = 0;
      if( sqlite3ExprIsInteger(p->pLeft, &v, 0) ){
        ((void) (0));
        *pValue = -v;
        rc = 1;
      }
      break;
    }
    case 157: {
      sqlite3_value *pVal;
      if( pParse==0 ) break;
      if( (pParse->pVdbe==0) ) break;
      if( (pParse->db->flags & 0x00800000)!=0 ) break;
      sqlite3VdbeSetVarmask(pParse->pVdbe, p->iColumn);
      pVal = sqlite3VdbeGetBoundValue(pParse->pReprepare, p->iColumn,
                                      0x41);
      if( pVal ){
        if( sqlite3_value_type(pVal)==1 ){
          sqlite3_int64 vv = sqlite3_value_int64(pVal);
          if( vv == (vv & 0x7fffffff) ){
            *pValue = (int)vv;
            rc = 1;
          }
        }
        sqlite3ValueFree(pVal);
      }
      break;
    }
    default: break;
  }
  return rc;
}
# 114385 "c_tests/sqlite3.c"
static int sqlite3ExprCanBeNull(const Expr *p){
  u8 op;
  ((void) (0));
  while( p->op==173 || p->op==174 ){
    p = p->pLeft;
    ((void) (0));
  }
  op = p->op;
  if( op==176 ) op = p->op2;
  switch( op ){
    case 156:
    case 118:
    case 154:
    case 155:
      return 0;
    case 168:
      ((void) (0));
      return (((p)->flags&(u32)(0x200000))!=0)
          || (p->y.pTab==0)



          || (p->iColumn>=0
              && p->y.pTab->aCol!=0
              && (p->iColumn<p->y.pTab->nCol)
              && p->y.pTab->aCol[p->iColumn].notNull==0);
    default:
      return 1;
  }
}
# 114426 "c_tests/sqlite3.c"
static int sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff){
  u8 op;
  int unaryMinus = 0;
  if( aff==0x41 ) return 1;
  while( p->op==173 || p->op==174 ){
    if( p->op==174 ) unaryMinus = 1;
    p = p->pLeft;
  }
  op = p->op;
  if( op==176 ) op = p->op2;
  switch( op ){
    case 156: {
      return aff>=0x43;
    }
    case 154: {
      return aff>=0x43;
    }
    case 118: {
      return !unaryMinus && aff==0x42;
    }
    case 155: {
      return !unaryMinus;
    }
    case 168: {
      ((void) (0));
      return aff>=0x43 && p->iColumn<0;
    }
    default: {
      return 0;
    }
  }
}




static int sqlite3IsRowid(const char *z){
  if( sqlite3StrICmp(z, "_ROWID_")==0 ) return 1;
  if( sqlite3StrICmp(z, "ROWID")==0 ) return 1;
  if( sqlite3StrICmp(z, "OID")==0 ) return 1;
  return 0;
}






static const char *sqlite3RowidAlias(Table *pTab){
  const char *azOpt[] = {"_ROWID_", "ROWID", "OID"};
  int ii;
  ((void) (0));
  for(ii=0; ii<((int)(sizeof(azOpt)/sizeof(azOpt[0]))); ii++){
    if( sqlite3ColumnIndex(pTab, azOpt[ii])<0 ) return azOpt[ii];
  }
  return 0;
}
# 114492 "c_tests/sqlite3.c"
static Select *isCandidateForInOpt(const Expr *pX){
  Select *p;
  SrcList *pSrc;
  ExprList *pEList;
  Table *pTab;
  int i;
  if( !(((pX)->flags&0x001000)!=0) ) return 0;
  if( (((pX)->flags&(u32)(0x000040))!=0) ) return 0;
  p = pX->x.pSelect;
  if( p->pPrior ) return 0;
  if( p->selFlags & (0x0000001|0x0000008) ){
                                                                       ;
                                                                        ;
    return 0;
  }
  ((void) (0));
  if( p->pLimit ) return 0;
  if( p->pWhere ) return 0;
  pSrc = p->pSrc;
  ((void) (0));
  if( pSrc->nSrc!=1 ) return 0;
  if( pSrc->a[0].fg.isSubquery) return 0;
  pTab = pSrc->a[0].pSTab;
  ((void) (0));
  ((void) (0));
  if( ((pTab)->eTabType==1) ) return 0;
  pEList = p->pEList;
  ((void) (0));

  for(i=0; i<pEList->nExpr; i++){
    Expr *pRes = pEList->a[i].pExpr;
    if( pRes->op!=168 ) return 0;
    ((void) (0));
  }
  return p;
}
# 114537 "c_tests/sqlite3.c"
static void sqlite3SetHasNullFlag(Vdbe *v, int iCur, int regHasNull){
  int addr1;
  sqlite3VdbeAddOp2(v, 72, 0, regHasNull);
  addr1 = sqlite3VdbeAddOp1(v, 36, iCur); ;
  sqlite3VdbeAddOp3(v, 95, iCur, 0, regHasNull);
  sqlite3VdbeChangeP5(v, 0x80);
                                              ;
  sqlite3VdbeJumpHere(v, addr1);
}
# 114554 "c_tests/sqlite3.c"
static int sqlite3InRhsIsConstant(Parse *pParse, Expr *pIn){
  Expr *pLHS;
  int res;
  ((void) (0));
  pLHS = pIn->pLeft;
  pIn->pLeft = 0;
  res = sqlite3ExprIsConstant(pParse, pIn);
  pIn->pLeft = pLHS;
  return res;
}
# 114650 "c_tests/sqlite3.c"
static int sqlite3FindInIndex(
  Parse *pParse,
  Expr *pX,
  u32 inFlags,
  int *prRhsHasNull,
  int *aiMap,
  int *piTab
){
  Select *p;
  int eType = 0;
  int iTab;
  int mustBeUnique;
  Vdbe *v = sqlite3GetVdbe(pParse);

  ((void) (0));
  mustBeUnique = (inFlags & 0x0004)!=0;
  iTab = pParse->nTab++;






  if( prRhsHasNull && (((pX)->flags&0x001000)!=0) ){
    int i;
    ExprList *pEList = pX->x.pSelect->pEList;
    for(i=0; i<pEList->nExpr; i++){
      if( sqlite3ExprCanBeNull(pEList->a[i].pExpr) ) break;
    }
    if( i==pEList->nExpr ){
      prRhsHasNull = 0;
    }
  }




  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){
    sqlite3 *db = pParse->db;
    Table *pTab;
    int iDb;
    ExprList *pEList = p->pEList;
    int nExpr = pEList->nExpr;

    ((void) (0));
    ((void) (0));
    ((void) (0));
    pTab = p->pSrc->a[0].pSTab;


    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    ((void) (0));
    sqlite3CodeVerifySchema(pParse, iDb);
    sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);

    ((void) (0));
    if( nExpr==1 && pEList->a[0].pExpr->iColumn<0 ){

      int iAddr = sqlite3VdbeAddOp0(v, 15);
                     ;

      sqlite3OpenTable(pParse, iTab, iDb, pTab, 113);
      eType = 1;
      sqlite3VdbeExplain (pParse, 0, "USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR",pTab->zName);

      sqlite3VdbeJumpHere(v, iAddr);
    }else{
      Index *pIdx;
      int affinity_ok = 1;
      int i;





      for(i=0; i<nExpr && affinity_ok; i++){
        Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);
        int iCol = pEList->a[i].pExpr->iColumn;
        char idxaff = sqlite3TableColumnAffinity(pTab,iCol);
        char cmpaff = sqlite3CompareAffinity(pLhs, idxaff);
                                           ;
                                           ;
        switch( cmpaff ){
          case 0x41:
            break;
          case 0x42:




            ((void) (0));
            break;
          default:
            affinity_ok = ((idxaff)>=0x43);
        }
      }

      if( affinity_ok ){

        for(pIdx=pTab->pIndex; pIdx && eType==0; pIdx=pIdx->pNext){
          Bitmask colUsed;
          Bitmask mCol;
          if( pIdx->nColumn<nExpr ) continue;
          if( pIdx->pPartIdxWhere!=0 ) continue;


                                          ;
                                          ;
          if( pIdx->nColumn>=((int)(sizeof(Bitmask)*8))-1 ) continue;
          if( mustBeUnique ){
            if( pIdx->nKeyCol>nExpr
             ||(pIdx->nColumn>nExpr && !((pIdx)->onError!=0))
            ){
              continue;
            }
          }

          colUsed = 0;
          for(i=0; i<nExpr; i++){
            Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);
            Expr *pRhs = pEList->a[i].pExpr;
            CollSeq *pReq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
            int j;

            for(j=0; j<nExpr; j++){
              if( pIdx->aiColumn[j]!=pRhs->iColumn ) continue;
              ((void) (0));
              if( pReq!=0 && sqlite3StrICmp(pReq->zName, pIdx->azColl[j])!=0 ){
                continue;
              }
              break;
            }
            if( j==nExpr ) break;
            mCol = (((Bitmask)1)<<(j));
            if( mCol & colUsed ) break;
            colUsed |= mCol;
            if( aiMap ) aiMap[i] = j;
          }

          ((void) (0));
          ((void) (0));
          if( colUsed==((((Bitmask)1)<<(nExpr))-1) ){

            int iAddr = sqlite3VdbeAddOp0(v, 15); ;
            sqlite3VdbeExplain (pParse, 0, "USING INDEX %s FOR IN-OPERATOR",pIdx->zName);

            sqlite3VdbeAddOp3(v, 113, iTab, pIdx->tnum, iDb);
            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
                                               ;
            ((void) (0));
            eType = 3 + pIdx->aSortOrder[0];

            if( prRhsHasNull ){





              *prRhsHasNull = ++pParse->nMem;
              if( nExpr==1 ){
                sqlite3SetHasNullFlag(v, iTab, *prRhsHasNull);
              }
            }
            sqlite3VdbeJumpHere(v, iAddr);
          }
        }
      }
    }
  }
# 114827 "c_tests/sqlite3.c"
  if( eType==0
   && (inFlags & 0x0001)
   && (((pX)->flags&0x001000)==0)
   && (!sqlite3InRhsIsConstant(pParse,pX) || pX->x.pList->nExpr<=2)
  ){
    pParse->nTab--;
    iTab = -1;
    eType = 5;
  }

  if( eType==0 ){



    u32 savedNQueryLoop = pParse->nQueryLoop;
    int rMayHaveNull = 0;
    eType = 2;
    if( inFlags & 0x0004 ){
      pParse->nQueryLoop = 0;
    }else if( prRhsHasNull ){
      *prRhsHasNull = rMayHaveNull = ++pParse->nMem;
    }
    ((void) (0));
    sqlite3CodeRhsOfIN(pParse, pX, iTab);
    if( rMayHaveNull ){
      sqlite3SetHasNullFlag(v, iTab, rMayHaveNull);
    }
    pParse->nQueryLoop = savedNQueryLoop;
  }

  if( aiMap && eType!=3 && eType!=4 ){
    int i, n;
    n = sqlite3ExprVectorSize(pX->pLeft);
    for(i=0; i<n; i++) aiMap[i] = i;
  }
  *piTab = iTab;
  return eType;
}
# 114876 "c_tests/sqlite3.c"
static char *exprINAffinity(Parse *pParse, const Expr *pExpr){
  Expr *pLeft = pExpr->pLeft;
  int nVal = sqlite3ExprVectorSize(pLeft);
  Select *pSelect = (((pExpr)->flags&0x001000)!=0) ? pExpr->x.pSelect : 0;
  char *zRet;

  ((void) (0));
  zRet = sqlite3DbMallocRaw(pParse->db, 1+(i64)nVal);
  if( zRet ){
    int i;
    for(i=0; i<nVal; i++){
      Expr *pA = sqlite3VectorFieldSubexpr(pLeft, i);
      char a = sqlite3ExprAffinity(pA);
      if( pSelect ){
        zRet[i] = sqlite3CompareAffinity(pSelect->pEList->a[i].pExpr, a);
      }else{
        zRet[i] = a;
      }
    }
    zRet[nVal] = '\0';
  }
  return zRet;
}
# 114908 "c_tests/sqlite3.c"
static void sqlite3SubselectError(Parse *pParse, int nActual, int nExpect){
  if( pParse->nErr==0 ){
    const char *zFmt = "sub-select returns %d columns - expected %d";
    sqlite3ErrorMsg(pParse, zFmt, nActual, nExpect);
  }
}
# 114927 "c_tests/sqlite3.c"
static void sqlite3VectorErrorMsg(Parse *pParse, Expr *pExpr){

  if( (((pExpr)->flags&0x001000)!=0) ){
    sqlite3SubselectError(pParse, pExpr->x.pSelect->pEList->nExpr, 1);
  }else

  {
    sqlite3ErrorMsg(pParse, "row value misused");
  }
}







static int findCompatibleInRhsSubrtn(
  Parse *pParse,
  Expr *pExpr,
  SubrtnSig *pNewSig
){
  VdbeOp *pOp, *pEnd;
  SubrtnSig *pSig;
  Vdbe *v;

  if( pNewSig==0 ) return 0;
  if( (pParse->mSubrtnSig & (1<<(pNewSig->selId&7)))==0 ) return 0;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  v = pParse->pVdbe;
  ((void) (0));
  pOp = sqlite3VdbeGetOp(v, 1);
  pEnd = sqlite3VdbeGetLastOp(v);
  for(; pOp<pEnd; pOp++){
    if( pOp->p4type!=(-17) ) continue;
    ((void) (0));
    pSig = pOp->p4.pSubrtnSig;
    ((void) (0));
    if( !pSig->bComplete ) continue;
    if( pNewSig->selId!=pSig->selId ) continue;
    if( strcmp(pNewSig->zAff,pSig->zAff)!=0 ) continue;
    pExpr->y.sub.iAddr = pSig->iAddr;
    pExpr->y.sub.regReturn = pSig->regReturn;
    pExpr->iTable = pSig->iTable;
    (pExpr)->flags|=(u32)(0x2000000);
    return 1;
  }
  return 0;
}
# 115005 "c_tests/sqlite3.c"
static void sqlite3CodeRhsOfIN(
  Parse *pParse,
  Expr *pExpr,
  int iTab
){
  int addrOnce = 0;
  int addr;
  Expr *pLeft;
  KeyInfo *pKeyInfo = 0;
  int nVal;
  Vdbe *v;
  SubrtnSig *pSig = 0;

  v = pParse->pVdbe;
  ((void) (0));
# 115031 "c_tests/sqlite3.c"
  if( !(((pExpr)->flags&(u32)(0x000040))!=0) && pParse->iSelfTab==0 ){





    ((void) (0));
    if( (((pExpr)->flags&0x001000)!=0) && (pExpr->x.pSelect->selFlags & 0x0000002)==0 ){
      pSig = sqlite3DbMallocRawNN(pParse->db, sizeof(pSig[0]));
      if( pSig ){
        pSig->selId = pExpr->x.pSelect->selId;
        pSig->zAff = exprINAffinity(pParse, pExpr);
      }
    }





    if( (((pExpr)->flags&(u32)(0x2000000))!=0)
     || findCompatibleInRhsSubrtn(pParse, pExpr, pSig)
    ){
      addrOnce = sqlite3VdbeAddOp0(v, 15); ;
      if( (((pExpr)->flags&0x001000)!=0) ){
        sqlite3VdbeExplain (pParse, 0, "REUSE LIST SUBQUERY %d", pExpr->x.pSelect->selId);

      }
      ((void) (0));
      sqlite3VdbeAddOp2(v, 10, pExpr->y.sub.regReturn,
                        pExpr->y.sub.iAddr);
      ((void) (0));
      sqlite3VdbeAddOp2(v, 116, iTab, pExpr->iTable);
      sqlite3VdbeJumpHere(v, addrOnce);
      if( pSig ){
        sqlite3DbFree(pParse->db, pSig->zAff);
        sqlite3DbFree(pParse->db, pSig);
      }
      return;
    }


    ((void) (0));
    (pExpr)->flags|=(u32)(0x2000000);
    ((void) (0));
    pExpr->y.sub.regReturn = ++pParse->nMem;
    pExpr->y.sub.iAddr =
      sqlite3VdbeAddOp2(v, 75, 0, pExpr->y.sub.regReturn) + 1;
    if( pSig ){
      pSig->bComplete = 0;
      pSig->iAddr = pExpr->y.sub.iAddr;
      pSig->regReturn = pExpr->y.sub.regReturn;
      pSig->iTable = iTab;
      pParse->mSubrtnSig = 1 << (pSig->selId&7);
      sqlite3VdbeChangeP4(v, -1, (const char*)pSig, (-17));
    }
    addrOnce = sqlite3VdbeAddOp0(v, 15); ;
  }


  pLeft = pExpr->pLeft;
  nVal = sqlite3ExprVectorSize(pLeft);




  pExpr->iTable = iTab;
  addr = sqlite3VdbeAddOp2(v, 119, pExpr->iTable, nVal);







  pKeyInfo = sqlite3KeyInfoAlloc(pParse->db, nVal, 1);

  if( (((pExpr)->flags&0x001000)!=0) ){





    Select *pSelect = pExpr->x.pSelect;
    ExprList *pEList = pSelect->pEList;

    sqlite3VdbeExplain (pParse, 1, "%sLIST SUBQUERY %d", addrOnce?"":"CORRELATED ", pSelect->selId );




    if( (pEList->nExpr==nVal) ){
      Select *pCopy;
      SelectDest dest;
      int i;
      int rc;
      int addrBloom = 0;
      sqlite3SelectDestInit(&dest, 11, iTab);
      dest.zAffSdst = exprINAffinity(pParse, pExpr);
      pSelect->iLimit = 0;
      if( addrOnce && (((pParse->db)->dbOptFlags&(0x00080000))==0) ){
        int regBloom = ++pParse->nMem;
        addrBloom = sqlite3VdbeAddOp2(v, 78, 10000, regBloom);
                                        ;
        dest.iSDParm2 = regBloom;
      }
                                                 ;
                             ;
      pCopy = sqlite3SelectDup(pParse->db, pSelect, 0);
      rc = pParse->db->mallocFailed ? 1 :sqlite3Select(pParse, pCopy, &dest);
      sqlite3SelectDelete(pParse->db, pCopy);
      sqlite3DbFree(pParse->db, dest.zAffSdst);
      if( addrBloom ){


        sqlite3VdbeGetOp(v, addrOnce)->p3 = dest.iSDParm2;
        if( dest.iSDParm2==0 ){

          sqlite3VdbeGetOp(v, addrBloom)->p1 = 10;
        }
      }
      if( rc ){
        sqlite3KeyInfoUnref(pKeyInfo);
        return;
      }
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      for(i=0; i<nVal; i++){
        Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);
        pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(
            pParse, p, pEList->a[i].pExpr
        );
      }
    }
  }else if( (pExpr->x.pList!=0) ){







    char affinity;
    int i;
    ExprList *pList = pExpr->x.pList;
    struct ExprList_item *pItem;
    int r1, r2;
    affinity = sqlite3ExprAffinity(pLeft);
    if( affinity<=0x40 ){
      affinity = 0x41;
    }else if( affinity==0x45 ){
      affinity = 0x43;
    }
    if( pKeyInfo ){
      ((void) (0));
      pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
    }


    r1 = sqlite3GetTempReg(pParse);
    r2 = sqlite3GetTempReg(pParse);
    for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){
      Expr *pE2 = pItem->pExpr;






      if( addrOnce && !sqlite3ExprIsConstant(pParse, pE2) ){
        sqlite3VdbeChangeToNoop(v, addrOnce-1);
        sqlite3VdbeChangeToNoop(v, addrOnce);
        (pExpr)->flags&=~(u32)(0x2000000);
        addrOnce = 0;
      }


      sqlite3ExprCode(pParse, pE2, r1);
      sqlite3VdbeAddOp4(v, 98, r1, 1, r2, &affinity, 1);
      sqlite3VdbeAddOp4Int(v, 139, iTab, r2, r1, 1);
    }
    sqlite3ReleaseTempReg(pParse, r1);
    sqlite3ReleaseTempReg(pParse, r2);
  }
  if( pSig ) pSig->bComplete = 1;
  if( pKeyInfo ){
    sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, (-8));
  }
  if( addrOnce ){
    sqlite3VdbeAddOp1(v, 137, iTab);
    sqlite3VdbeJumpHere(v, addrOnce);

    ((void) (0));
    ((void) (0));

    sqlite3VdbeAddOp3(v, 68, pExpr->y.sub.regReturn,
                      pExpr->y.sub.iAddr, 1);
                   ;
    sqlite3ClearTempRegCache(pParse);
  }
}
# 115250 "c_tests/sqlite3.c"
static int sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){
  int addrOnce = 0;
  int rReg = 0;
  Select *pSel;
  SelectDest dest;
  int nReg;
  Expr *pLimit;




  Vdbe *v = pParse->pVdbe;
  ((void) (0));
  if( pParse->nErr ) return 0;
                                  ;
                                  ;
  ((void) (0));
  ((void) (0));
  pSel = pExpr->x.pSelect;



  if( (((pExpr)->flags&(u32)(0x2000000))!=0) ){
    sqlite3VdbeExplain (pParse, 0, "REUSE SUBQUERY %d", pSel->selId);
    ((void) (0));
    sqlite3VdbeAddOp2(v, 10, pExpr->y.sub.regReturn,
                      pExpr->y.sub.iAddr);
    return pExpr->iTable;
  }


  ((void) (0));
  ((void) (0));
  (pExpr)->flags|=(u32)(0x2000000);
  pExpr->y.sub.regReturn = ++pParse->nMem;
  pExpr->y.sub.iAddr =
    sqlite3VdbeAddOp2(v, 75, 0, pExpr->y.sub.regReturn) + 1;
# 115298 "c_tests/sqlite3.c"
  if( !(((pExpr)->flags&(u32)(0x000040))!=0) ){
    addrOnce = sqlite3VdbeAddOp0(v, 15); ;
  }
# 115312 "c_tests/sqlite3.c"
  sqlite3VdbeExplain (pParse, 1, "%sSCALAR SUBQUERY %d", addrOnce?"":"CORRELATED ", pSel->selId);

                                                                ;
  nReg = pExpr->op==139 ? pSel->pEList->nExpr : 1;
  sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);
  pParse->nMem += nReg;
  if( pExpr->op==139 ){
    dest.eDest = 10;
    if( (pSel->selFlags&0x0000001) && pSel->pLimit && pSel->pLimit->pRight ){
# 115329 "c_tests/sqlite3.c"
      dest.iSdst = pParse->nMem+1;
      pParse->nMem += nReg;
    }else{
      dest.iSdst = dest.iSDParm;
    }
    dest.nSdst = nReg;
    sqlite3VdbeAddOp3(v, 76, 0, dest.iSDParm, pParse->nMem);
                                            ;
  }else{
    dest.eDest = 3;
    sqlite3VdbeAddOp2(v, 72, 0, dest.iSDParm);
                                          ;
  }
  if( pSel->pLimit ){



    Expr *pLeft = pSel->pLimit->pLeft;
    if( (((pLeft)->flags&(u32)(0x000800))!=0)==0
     || (pLeft->u.iValue!=1 && pLeft->u.iValue!=0)
    ){
      sqlite3 *db = pParse->db;
      pLimit = sqlite3Expr(db, 156, "0");
      if( pLimit ){
        pLimit->affExpr = 0x43;
        pLimit = sqlite3PExpr(pParse, 53,
            sqlite3ExprDup(db, pLeft, 0), pLimit);
      }
      sqlite3ExprDeferredDelete(pParse, pLeft);
      pSel->pLimit->pLeft = pLimit;
    }
  }else{

    pLimit = sqlite3Expr(pParse->db, 156, "1");
    pSel->pLimit = sqlite3PExpr(pParse, 149, pLimit, 0);
  }
  pSel->iLimit = 0;
  if( sqlite3Select(pParse, pSel, &dest) ){
    pExpr->op2 = pExpr->op;
    pExpr->op = 182;
    return 0;
  }
  pExpr->iTable = rReg = dest.iSDParm;
                                        ;
  if( addrOnce ){
    sqlite3VdbeJumpHere(v, addrOnce);
  }
                                                             ;


  ((void) (0));
  ((void) (0));

  sqlite3VdbeAddOp3(v, 68, pExpr->y.sub.regReturn,
                    pExpr->y.sub.iAddr, 1);
                 ;
  sqlite3ClearTempRegCache(pParse);
  return rReg;
}
# 115397 "c_tests/sqlite3.c"
static int sqlite3ExprCheckIN(Parse *pParse, Expr *pIn){
  int nVector = sqlite3ExprVectorSize(pIn->pLeft);
  if( (((pIn)->flags&0x001000)!=0) && !pParse->db->mallocFailed ){
    if( nVector!=pIn->x.pSelect->pEList->nExpr ){
      sqlite3SubselectError(pParse, pIn->x.pSelect->pEList->nExpr, nVector);
      return 1;
    }
  }else if( nVector!=1 ){
    sqlite3VectorErrorMsg(pParse, pIn->pLeft);
    return 1;
  }
  return 0;
}
# 115438 "c_tests/sqlite3.c"
static void sqlite3ExprCodeIN(
  Parse *pParse,
  Expr *pExpr,
  int destIfFalse,
  int destIfNull
){
  int rRhsHasNull = 0;
  int eType;
  int rLhs;
  Vdbe *v;
  int *aiMap = 0;
  char *zAff = 0;
  int nVector;
  int iDummy;
  Expr *pLeft;
  int i;
  int destStep2;
  int destStep6 = 0;
  int addrTruthOp;
  int destNotNull;
  int addrTop;
  int iTab = 0;
  u8 okConstFactor = pParse->okConstFactor;

  ((void) (0));
  pLeft = pExpr->pLeft;
  if( sqlite3ExprCheckIN(pParse, pExpr) ) return;
  zAff = exprINAffinity(pParse, pExpr);
  nVector = sqlite3ExprVectorSize(pExpr->pLeft);
  aiMap = (int*)sqlite3DbMallocZero(pParse->db, nVector*sizeof(int));
  if( pParse->db->mallocFailed ) goto sqlite3ExprCodeIN_oom_error;





  v = pParse->pVdbe;
  ((void) (0));
                                       ;
  eType = sqlite3FindInIndex(pParse, pExpr,
                             0x0002 | 0x0001,
                             destIfFalse==destIfNull ? 0 : &rRhsHasNull,
                             aiMap, &iTab);

  ((void) (0));
# 115507 "c_tests/sqlite3.c"
  ((void) (0));
  pParse->okConstFactor = 0;
  rLhs = exprCodeVector(pParse, pLeft, &iDummy);
  pParse->okConstFactor = okConstFactor;







  if( eType==5 ){
    ExprList *pList;
    CollSeq *pColl;
    int labelOk = sqlite3VdbeMakeLabel(pParse);
    int r2, regToFree;
    int regCkNull = 0;
    int ii;
    ((void) (0));
    ((void) (0));
    pList = pExpr->x.pList;
    pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
    if( destIfNull!=destIfFalse ){
      regCkNull = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp3(v, 103, rLhs, rLhs, regCkNull);
    }
    for(ii=0; ii<pList->nExpr; ii++){
      r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);
      if( regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr) ){
        sqlite3VdbeAddOp3(v, 103, regCkNull, r2, regCkNull);
      }
      sqlite3ReleaseTempReg(pParse, regToFree);
      if( ii<pList->nExpr-1 || destIfNull!=destIfFalse ){
        int op = rLhs!=r2 ? 54 : 52;
        sqlite3VdbeAddOp4(v, op, rLhs, labelOk, r2,
                          (void*)pColl, (-2));
                                                         ;
                                                          ;
                                                              ;
                                                               ;
        sqlite3VdbeChangeP5(v, zAff[0]);
      }else{
        int op = rLhs!=r2 ? 53 : 51;
        ((void) (0));
        sqlite3VdbeAddOp4(v, op, rLhs, destIfFalse, r2,
                          (void*)pColl, (-2));
                                    ;
                                        ;
        sqlite3VdbeChangeP5(v, zAff[0] | 0x10);
      }
    }
    if( regCkNull ){
      sqlite3VdbeAddOp2(v, 51, regCkNull, destIfNull); ;
      sqlite3VdbeGoto(v, destIfFalse);
    }
    sqlite3VdbeResolveLabel(v, labelOk);
    sqlite3ReleaseTempReg(pParse, regCkNull);
    goto sqlite3ExprCodeIN_finished;
  }

  if( eType!=1 ){





    sqlite3VdbeAddOp4(v, 97, rLhs, nVector, 0, zAff, nVector);
    for(i=0; i<nVector && aiMap[i]==i; i++){}
    if( i!=nVector ){

      int rLhsOrig = rLhs;
      rLhs = sqlite3GetTempRange(pParse, nVector);
      for(i=0; i<nVector; i++){
        sqlite3VdbeAddOp3(v, 81, rLhsOrig+i, rLhs+aiMap[i], 0);
      }
      sqlite3ReleaseTempReg(pParse, rLhsOrig);
    }
  }






  if( destIfNull==destIfFalse ){
    destStep2 = destIfFalse;
  }else{
    destStep2 = destStep6 = sqlite3VdbeMakeLabel(pParse);
  }
  for(i=0; i<nVector; i++){
    Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);
    if( pParse->nErr ) goto sqlite3ExprCodeIN_oom_error;
    if( sqlite3ExprCanBeNull(p) ){
      sqlite3VdbeAddOp2(v, 51, rLhs+i, destStep2);
                     ;
    }
  }





  if( eType==1 ){



    ((void) (0));
    sqlite3VdbeAddOp3(v, 30, iTab, destIfFalse, rLhs);
                   ;
    addrTruthOp = sqlite3VdbeAddOp0(v, 9);
  }else{
    if( destIfFalse==destIfNull ){

      if( (((pExpr)->flags&(u32)(0x2000000))!=0) ){
        const VdbeOp *pOp = sqlite3VdbeGetOp(v, pExpr->y.sub.iAddr);
        ((void) (0));
        if( pOp->opcode==15 && pOp->p3>0 ){
          ((void) (0));
          sqlite3VdbeAddOp4Int(v, 65, pOp->p3, destIfFalse,
                               rLhs, nVector); ;
        }
      }
      sqlite3VdbeAddOp4Int(v, 28, iTab, destIfFalse,
                           rLhs, nVector); ;
      goto sqlite3ExprCodeIN_finished;
    }

    addrTruthOp = sqlite3VdbeAddOp4Int(v, 29, iTab, 0,
                                      rLhs, nVector); ;
  }




  if( rRhsHasNull && nVector==1 ){
    sqlite3VdbeAddOp2(v, 52, rRhsHasNull, destIfFalse);
                   ;
  }




  if( destIfFalse==destIfNull ) sqlite3VdbeGoto(v, destIfFalse);
# 115658 "c_tests/sqlite3.c"
  if( destStep6 ) sqlite3VdbeResolveLabel(v, destStep6);
  addrTop = sqlite3VdbeAddOp2(v, 36, iTab, destIfFalse);
                 ;
  if( nVector>1 ){
    destNotNull = sqlite3VdbeMakeLabel(pParse);
  }else{


    destNotNull = destIfFalse;
  }
  for(i=0; i<nVector; i++){
    Expr *p;
    CollSeq *pColl;
    int r3 = sqlite3GetTempReg(pParse);
    p = sqlite3VectorFieldSubexpr(pLeft, i);
    pColl = sqlite3ExprCollSeq(pParse, p);
    sqlite3VdbeAddOp3(v, 95, iTab, i, r3);
    sqlite3VdbeAddOp4(v, 53, rLhs+i, destNotNull, r3,
                      (void*)pColl, (-2));
                   ;
    sqlite3ReleaseTempReg(pParse, r3);
  }
  sqlite3VdbeAddOp2(v, 9, 0, destIfNull);
  if( nVector>1 ){
    sqlite3VdbeResolveLabel(v, destNotNull);
    sqlite3VdbeAddOp2(v, 40, iTab, addrTop+1);
                   ;



    sqlite3VdbeAddOp2(v, 9, 0, destIfFalse);
  }


  sqlite3VdbeJumpHere(v, addrTruthOp);

sqlite3ExprCodeIN_finished:
                                 ;
sqlite3ExprCodeIN_oom_error:
  sqlite3DbFree(pParse->db, aiMap);
  sqlite3DbFree(pParse->db, zAff);
}
# 115711 "c_tests/sqlite3.c"
static void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem){
  if( (z!=0) ){
    double value;
    sqlite3AtoF(z, &value, sqlite3Strlen30(z), 1);
    ((void) (0));
    if( negateFlag ) value = -value;
    sqlite3VdbeAddOp4Dup8(v, 154, 0, iMem, 0, (u8*)&value, (-12));
  }
}
# 115729 "c_tests/sqlite3.c"
static void codeInteger(Parse *pParse, Expr *pExpr, int negFlag, int iMem){
  Vdbe *v = pParse->pVdbe;
  if( pExpr->flags & 0x000800 ){
    int i = pExpr->u.iValue;
    ((void) (0));
    if( negFlag ) i = -i;
    sqlite3VdbeAddOp2(v, 72, i, iMem);
  }else{
    int c;
    i64 value;
    const char *z = pExpr->u.zToken;
    ((void) (0));
    c = sqlite3DecOrHexToI64(z, &value);
    if( (c==3 && !negFlag) || (c==2) || (negFlag && value==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))))){




      if( sqlite3_strnicmp(z,"0x",2)==0 ){
        sqlite3ErrorMsg(pParse, "hex literal too big: %s%#T",
                        negFlag?"-":"",pExpr);
      }else

      {
        codeReal(v, z, negFlag, iMem);
      }

    }else{
      if( negFlag ){ value = c==3 ? (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) : -value; }
      sqlite3VdbeAddOp4Dup8(v, 73, 0, iMem, 0, (u8*)&value, (-13));
    }
  }
}





static void sqlite3ExprCodeLoadIndexColumn(
  Parse *pParse,
  Index *pIdx,
  int iTabCur,
  int iIdxCol,
  int regOut
){
  i16 iTabCol = pIdx->aiColumn[iIdxCol];
  if( iTabCol==(-2) ){
    ((void) (0));
    ((void) (0));
    pParse->iSelfTab = iTabCur + 1;
    sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[iIdxCol].pExpr, regOut);
    pParse->iSelfTab = 0;
  }else{
    sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pIdx->pTable, iTabCur,
                                    iTabCol, regOut);
  }
}






static void sqlite3ExprCodeGeneratedColumn(
  Parse *pParse,
  Table *pTab,
  Column *pCol,
  int regOut
){
  int iAddr;
  Vdbe *v = pParse->pVdbe;
  int nErr = pParse->nErr;
  ((void) (0));
  ((void) (0));
  if( pParse->iSelfTab>0 ){
    iAddr = sqlite3VdbeAddOp3(v, 20, pParse->iSelfTab-1, 0, regOut);
  }else{
    iAddr = 0;
  }
  sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab,pCol), regOut);
  if( (pCol->colFlags & 0x0020)!=0
   && (pTab->tabFlags & 0x00010000)!=0
  ){
    int p3 = 2+(int)(pCol - pTab->aCol);
    sqlite3VdbeAddOp4(v, 96, regOut, 1, p3, (char*)pTab, (-5));
  }else if( pCol->affinity>=0x42 ){
    sqlite3VdbeAddOp4(v, 97, regOut, 1, 0, &pCol->affinity, 1);
  }
  if( iAddr ) sqlite3VdbeJumpHere(v, iAddr);
  if( pParse->nErr>nErr ) pParse->db->errByteOffset = -1;
}





static void sqlite3ExprCodeGetColumnOfTable(
  Vdbe *v,
  Table *pTab,
  int iTabCur,
  int iCol,
  int regOut
){
  Column *pCol;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( iCol<0 || iCol==pTab->iPKey ){
    sqlite3VdbeAddOp2(v, 136, iTabCur, regOut);
                                             ;
  }else{
    int op;
    int x;
    if( ((pTab)->eTabType==1) ){
      op = 177;
      x = iCol;

    }else if( (pCol = &pTab->aCol[iCol])->colFlags & 0x0020 ){
      Parse *pParse = sqlite3VdbeParser(v);
      if( pCol->colFlags & 0x0100 ){
        sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"",
                        pCol->zCnName);
      }else{
        int savedSelfTab = pParse->iSelfTab;
        pCol->colFlags |= 0x0100;
        pParse->iSelfTab = iTabCur+1;
        sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, regOut);
        pParse->iSelfTab = savedSelfTab;
        pCol->colFlags &= ~0x0100;
      }
      return;

    }else if( !(((pTab)->tabFlags & 0x00000080)==0) ){
                                                               ;
      x = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), iCol);
      op = 95;
    }else{
      x = sqlite3TableColumnToStorage(pTab,iCol);
                         ;
      op = 95;
    }
    sqlite3VdbeAddOp3(v, op, iTabCur, x, regOut);
    sqlite3ColumnDefault(v, pTab, iCol, regOut);
  }
}
# 115882 "c_tests/sqlite3.c"
static int sqlite3ExprCodeGetColumn(
  Parse *pParse,
  Table *pTab,
  int iColumn,
  int iTable,
  int iReg,
  u8 p5
){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pTab, iTable, iColumn, iReg);
  if( p5 ){
    VdbeOp *pOp = sqlite3VdbeGetLastOp(pParse->pVdbe);
    if( pOp->opcode==95 ) pOp->p5 = p5;
    if( pOp->opcode==177 ) pOp->p5 = (p5 & 0x01);
  }
  return iReg;
}





static void sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg){
  sqlite3VdbeAddOp3(pParse->pVdbe, 80, iFrom, iTo, nReg);
}






static void sqlite3ExprToRegister(Expr *pExpr, int iReg){
  Expr *p = sqlite3ExprSkipCollateAndLikely(pExpr);
  if( (p==0) ) return;
  if( p->op==176 ){
    ((void) (0));
  }else{
    p->op2 = p->op;
    p->op = 176;
    p->iTable = iReg;
    (p)->flags&=~(u32)(0x002000);
  }
}
# 115938 "c_tests/sqlite3.c"
static int exprCodeVector(Parse *pParse, Expr *p, int *piFreeable){
  int iResult;
  int nResult = sqlite3ExprVectorSize(p);
  if( nResult==1 ){
    iResult = sqlite3ExprCodeTemp(pParse, p, piFreeable);
  }else{
    *piFreeable = 0;
    if( p->op==139 ){



      iResult = sqlite3CodeSubselect(pParse, p);

    }else{
      int i;
      iResult = pParse->nMem+1;
      pParse->nMem += nResult;
      ((void) (0));
      for(i=0; i<nResult; i++){
        sqlite3ExprCodeFactorable(pParse, p->x.pList->a[i].pExpr, i+iResult);
      }
    }
  }
  return iResult;
}





static void setDoNotMergeFlagOnCopy(Vdbe *v){
  if( sqlite3VdbeGetLastOp(v)->opcode==81 ){
    sqlite3VdbeChangeP5(v, 1);
  }
}





static int exprCodeInlineFunction(
  Parse *pParse,
  ExprList *pFarg,
  int iFuncId,
  int target
){
  int nFarg;
  Vdbe *v = pParse->pVdbe;
  ((void) (0));
  ((void) (0));
  nFarg = pFarg->nExpr;
  ((void) (0));
  switch( iFuncId ){
    case 0: {




      int endCoalesce = sqlite3VdbeMakeLabel(pParse);
      int i;
      ((void) (0));
      sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);
      for(i=1; i<nFarg; i++){
        sqlite3VdbeAddOp2(v, 52, target, endCoalesce);
                       ;
        sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);
      }
      setDoNotMergeFlagOnCopy(v);
      sqlite3VdbeResolveLabel(v, endCoalesce);
      break;
    }
    case 5: {
      Expr caseExpr;
      memset(&caseExpr, 0, sizeof(caseExpr));
      caseExpr.op = 158;
      caseExpr.x.pList = pFarg;
      return sqlite3ExprCodeTarget(pParse, &caseExpr, target);
    }
# 116027 "c_tests/sqlite3.c"
    default: {



      ((void) (0));
      target = sqlite3ExprCodeTarget(pParse, pFarg->a[0].pExpr, target);
      break;
    }






    case 3: {

      ((void) (0));
      sqlite3VdbeAddOp2(v, 72,
         sqlite3ExprCompare(0,pFarg->a[0].pExpr, pFarg->a[1].pExpr,-1),
         target);
      break;
    }

    case 2: {

      ((void) (0));
      sqlite3VdbeAddOp2(v, 72,
         sqlite3ExprImpliesExpr(pParse,pFarg->a[0].pExpr, pFarg->a[1].pExpr,-1),
         target);
      break;
    }

    case 1: {

      Expr *pA1;
      ((void) (0));
      pA1 = pFarg->a[1].pExpr;
      if( pA1->op==168 ){
        sqlite3VdbeAddOp2(v, 72,
           sqlite3ExprImpliesNonNullRow(pFarg->a[0].pExpr,pA1->iTable,1),
           target);
      }else{
        sqlite3VdbeAddOp2(v, 76, 0, target);
      }
      break;
    }

    case 4: {




      const char *azAff[] = { "blob", "text", "numeric", "integer",
                              "real", "flexnum" };
      char aff;
      ((void) (0));
      aff = sqlite3ExprAffinity(pFarg->a[0].pExpr);
      ((void) (0));

      sqlite3VdbeLoadString(v, target,
              (aff<=0x40) ? "none" : azAff[aff-0x41]);
      break;
    }

  }
  return target;
}
# 116112 "c_tests/sqlite3.c"
static int exprNodeCanReturnSubtype(Walker *pWalker, Expr *pExpr){
  int n;
  FuncDef *pDef;
  sqlite3 *db;
  if( pExpr->op!=172 ){
    return 1;
  }
  ((void) (0));
  db = pWalker->pParse->db;
  n = (pExpr->x.pList) ? pExpr->x.pList->nExpr : 0;
  pDef = sqlite3FindFunction(db, pExpr->u.zToken, n, ((db)->enc), 0);
  if( (pDef==0) || (pDef->funcFlags & 0x001000000)!=0 ){
    pWalker->eCode = 1;
    return 1;
  }
  return 0;
}
# 116138 "c_tests/sqlite3.c"
static int sqlite3ExprCanReturnSubtype(Parse *pParse, Expr *pExpr){
  Walker w;
  memset(&w, 0, sizeof(w));
  w.pParse = pParse;
  w.xExprCallback = exprNodeCanReturnSubtype;
  sqlite3WalkExpr(&w, pExpr);
  return w.eCode;
}
# 116154 "c_tests/sqlite3.c"
static __attribute__((noinline)) int sqlite3IndexedExprLookup(
  Parse *pParse,
  Expr *pExpr,
  int target
){
  IndexedExpr *p;
  Vdbe *v;
  for(p=pParse->pIdxEpr; p; p=p->pIENext){
    u8 exprAff;
    int iDataCur = p->iDataCur;
    if( iDataCur<0 ) continue;
    if( pParse->iSelfTab ){
      if( p->iDataCur!=pParse->iSelfTab-1 ) continue;
      iDataCur = -1;
    }
    if( sqlite3ExprCompare(0, pExpr, p->pExpr, iDataCur)!=0 ) continue;
    ((void) (0));
    exprAff = sqlite3ExprAffinity(pExpr);
    if( (exprAff<=0x41 && p->aff!=0x41)
     || (exprAff==0x42 && p->aff!=0x42)
     || (exprAff>=0x43 && p->aff!=0x43)
    ){

      continue;
    }






    if( (((pExpr)->flags&(u32)(0x80000000))!=0)
     && sqlite3ExprCanReturnSubtype(pParse, pExpr)
    ){
      continue;
    }

    v = pParse->pVdbe;
    ((void) (0));
    if( p->bMaybeNullRow ){



      int addr = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp3(v, 20, p->iIdxCur, addr+3, target);
                     ;
      sqlite3VdbeAddOp3(v, 95, p->iIdxCur, p->iIdxCol, target);
                                                                    ;
      sqlite3VdbeGoto(v, 0);
      p = pParse->pIdxEpr;
      pParse->pIdxEpr = 0;
      sqlite3ExprCode(pParse, pExpr, target);
      pParse->pIdxEpr = p;
      sqlite3VdbeJumpHere(v, addr+2);
    }else{
      sqlite3VdbeAddOp3(v, 95, p->iIdxCur, p->iIdxCol, target);
                                                                    ;
    }
    return target;
  }
  return -1;
}
# 116228 "c_tests/sqlite3.c"
static int exprPartidxExprLookup(Parse *pParse, Expr *pExpr, int iTarget){
  IndexedExpr *p;
  for(p=pParse->pIdxPartExpr; p; p=p->pIENext){
    if( pExpr->iColumn==p->iIdxCol && pExpr->iTable==p->iDataCur ){
      Vdbe *v = pParse->pVdbe;
      int addr = 0;
      int ret;

      if( p->bMaybeNullRow ){
        addr = sqlite3VdbeAddOp1(v, 20, p->iIdxCur);
      }
      ret = sqlite3ExprCodeTarget(pParse, p->pExpr, iTarget);
      sqlite3VdbeAddOp4(pParse->pVdbe, 97, ret, 1, 0,
                        (const char*)&p->aff, 1);
      if( addr ){
        sqlite3VdbeJumpHere(v, addr);
        sqlite3VdbeChangeP3(v, addr, ret);
      }
      return ret;
    }
  }
  return 0;
}
# 116262 "c_tests/sqlite3.c"
static __attribute__((noinline)) int exprCodeTargetAndOr(
  Parse *pParse,
  Expr *pExpr,
  int target,
  int *pTmpReg
){
  int op;
  int skipOp;
  int addrSkip;
  int regSS = 0;
  int r1, r2;
  Expr *pAlt;
  Vdbe *v;

  ((void) (0));
  op = pExpr->op;
  ((void) (0));
  ((void) (0)); ;
  ((void) (0)); ;
  ((void) (0));
  v = pParse->pVdbe;
  pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
  if( pAlt!=pExpr ){
    r1 = sqlite3ExprCodeTarget(pParse, pAlt, target);
    sqlite3VdbeAddOp3(v, 44, r1, r1, target);
    return target;
  }
  skipOp = op==44 ? 17 : 16;
  if( exprEvalRhsFirst(pExpr) ){


    r2 = regSS = sqlite3ExprCodeTarget(pParse, pExpr->pRight, target);
    addrSkip = sqlite3VdbeAddOp1(v, skipOp, r2);
                                         ;
                   ;
    r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, pTmpReg);
  }else{

    r1 = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
    if( (((pExpr->pRight)->flags&(u32)(0x400000))!=0) ){



      regSS = r1;
      addrSkip = sqlite3VdbeAddOp1(v, skipOp, r1);
                                            ;
                     ;
    }else{
      addrSkip = regSS = 0;
    }
    r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, pTmpReg);
  }
  sqlite3VdbeAddOp3(v, op, r2, r1, target);
                           ;
  if( addrSkip ){
    sqlite3VdbeAddOp2(v, 9, 0, sqlite3VdbeCurrentAddr(v)+2);
    sqlite3VdbeJumpHere(v, addrSkip);
    sqlite3VdbeAddOp3(v, 43, regSS, regSS, target);
                                          ;
  }
  return target;
}
# 116338 "c_tests/sqlite3.c"
static int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){
  Vdbe *v = pParse->pVdbe;
  int op;
  int inReg = target;
  int regFree1 = 0;
  int regFree2 = 0;
  int r1, r2;
  Expr tempX;
  int p5 = 0;

  ((void) (0));
  ((void) (0));

expr_code_doover:
  if( pExpr==0 ){
    op = 122;
  }else if( pParse->pIdxEpr!=0
   && !(((pExpr)->flags&(u32)(0x800000))!=0)
   && (r1 = sqlite3IndexedExprLookup(pParse, pExpr, target))>=0
  ){
    return r1;
  }else{
    ((void) (0));
    op = pExpr->op;
  }
  ((void) (0));
  switch( op ){
    case 170: {
      AggInfo *pAggInfo = pExpr->pAggInfo;
      struct AggInfo_col *pCol;
      ((void) (0));
      ((void) (0));
      if( pExpr->iAgg>=pAggInfo->nColumn ){


        sqlite3VdbeAddOp2(v, 76, 0, target);






        break;
      }
      pCol = &pAggInfo->aCol[pExpr->iAgg];
      if( !pAggInfo->directMode ){
        return ((pAggInfo)->iFirstReg+(pExpr->iAgg));
      }else if( pAggInfo->useSortingIdx ){
        Table *pTab = pCol->pTab;
        sqlite3VdbeAddOp3(v, 95, pAggInfo->sortingIdxPTab,
                              pCol->iSorterColumn, target);
        if( pTab==0 ){

        }else if( pCol->iColumn<0 ){
                                                 ;
        }else{

                                                              ;
          if( pTab->aCol[pCol->iColumn].affinity==0x45 ){
            sqlite3VdbeAddOp1(v, 88, target);
          }
        }
        return target;
      }else if( pExpr->y.pTab==0 ){


        sqlite3VdbeAddOp3(v, 95, pExpr->iTable, pExpr->iColumn, target);
        return target;
      }

                     __attribute__((fallthrough));
    }
    case 168: {
      int iTab = pExpr->iTable;
      int iReg;
      if( (((pExpr)->flags&(u32)(0x000020))!=0) ){






        int aff;
        iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);
        ((void) (0));
        ((void) (0));
        aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);
        if( aff>0x41 ){
          static const char zAff[] = "B\000C\000D\000E\000F";
          ((void) (0));
          ((void) (0));
          sqlite3VdbeAddOp4(v, 97, iReg, 1, 0,
                            &zAff[(aff-'B')*2], (-1));
        }
        return iReg;
      }
      if( iTab<0 ){
        if( pParse->iSelfTab<0 ){






          Column *pCol;
          Table *pTab;
          int iSrc;
          int iCol = pExpr->iColumn;
          ((void) (0));
          pTab = pExpr->y.pTab;
          ((void) (0));
          ((void) (0));
          ((void) (0));
          if( iCol<0 ){
            return -1-pParse->iSelfTab;
          }
          pCol = pTab->aCol + iCol;
                                                                  ;
          iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;

          if( pCol->colFlags & 0x0060 ){
            if( pCol->colFlags & 0x0100 ){
              sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"",
                              pCol->zCnName);
              return 0;
            }
            pCol->colFlags |= 0x0100;
            if( pCol->colFlags & 0x0080 ){
              sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, iSrc);
            }
            pCol->colFlags &= ~(0x0100|0x0080);
            return iSrc;
          }else

          if( pCol->affinity==0x45 ){
            sqlite3VdbeAddOp2(v, 82, iSrc, target);
            sqlite3VdbeAddOp1(v, 88, target);
            return target;
          }else{
            return iSrc;
          }
        }else{


          iTab = pParse->iSelfTab - 1;
        }
      }
      else if( pParse->pIdxPartExpr
       && 0!=(r1 = exprPartidxExprLookup(pParse, pExpr, target))
      ){
        return r1;
      }
      ((void) (0));
      ((void) (0));
      iReg = sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab,
                               pExpr->iColumn, iTab, target,
                               pExpr->op2);
      return iReg;
    }
    case 156: {
      codeInteger(pParse, pExpr, 0, target);
      return target;
    }
    case 171: {
      sqlite3VdbeAddOp2(v, 72, sqlite3ExprTruthValue(pExpr), target);
      return target;
    }

    case 154: {
      ((void) (0));
      codeReal(v, pExpr->u.zToken, 0, target);
      return target;
    }

    case 118: {
      ((void) (0));
      sqlite3VdbeLoadString(v, target, pExpr->u.zToken);
      return target;
    }
    case 83: {


      sqlite3VdbeAddOp3(v, 76, 0, target, target + pExpr->y.nReg - 1);
      return target;
    }
    default: {




      ((void) (0));
      sqlite3VdbeAddOp2(v, 76, 0, target);
      return target;
    }

    case 155: {
      int n;
      const char *z;
      char *zBlob;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      z = &pExpr->u.zToken[2];
      n = sqlite3Strlen30(z) - 1;
      ((void) (0));
      zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);
      sqlite3VdbeAddOp4(v, 78, n/2, target, 0, zBlob, (-6));
      return target;
    }

    case 157: {
      ((void) (0));
      ((void) (0));
      ((void) (0));
      sqlite3VdbeAddOp2(v, 79, pExpr->iColumn, target);
      return target;
    }
    case 176: {
      return pExpr->iTable;
    }

    case 36: {

      sqlite3ExprCode(pParse, pExpr->pLeft, target);
      ((void) (0));
      ((void) (0));
      sqlite3VdbeAddOp2(v, 89, target,
                        sqlite3AffinityType(pExpr->u.zToken, 0));
      return inReg;
    }

    case 45:
    case 46:
      op = (op==45) ? 54 : 53;
      p5 = 0x80;

    case 57:
    case 56:
    case 55:
    case 58:
    case 53:
    case 54: {
      Expr *pLeft = pExpr->pLeft;
      int addrIsNull = 0;
      if( sqlite3ExprIsVector(pLeft) ){
        codeVectorCompare(pParse, pExpr, target, op, p5);
      }else{
        if( (((pExpr)->flags&(u32)(0x400000))!=0) && p5!=0x80 ){
          addrIsNull = exprComputeOperands(pParse, pExpr,
                                     &r1, &r2, &regFree1, &regFree2);
        }else{
          r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
          r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
        }
        sqlite3VdbeAddOp2(v, 72, 1, inReg);
        codeCompare(pParse, pLeft, pExpr->pRight, op, r1, r2,
            sqlite3VdbeCurrentAddr(v)+2, p5,
            (((pExpr)->flags&(u32)(0x000400))!=0));
        ((void) (0)); ; ;
        ((void) (0)); ; ;
        ((void) (0)); ; ;
        ((void) (0)); ; ;
        ((void) (0)); ; ;
        ((void) (0)); ; ;
        if( p5==0x80 ){
          sqlite3VdbeAddOp2(v, 72, 0, inReg);
        }else{
          sqlite3VdbeAddOp3(v, 93, r1, inReg, r2);
          if( addrIsNull ){
            sqlite3VdbeAddOp2(v, 9, 0, sqlite3VdbeCurrentAddr(v)+2);
            sqlite3VdbeJumpHere(v, addrIsNull);
            sqlite3VdbeAddOp2(v, 76, 0, inReg);
          }
        }
                               ;
                               ;
      }
      break;
    }
    case 44:
    case 43: {
      inReg = exprCodeTargetAndOr(pParse, pExpr, target, &regFree1);
      break;
    }
    case 107:
    case 109:
    case 108:
    case 111:
    case 103:
    case 104:
    case 110:
    case 105:
    case 106:
    case 112: {
      int addrIsNull;
      ((void) (0)); ;
      ((void) (0)); ;
      ((void) (0)); ;
      ((void) (0)); ;
      ((void) (0)); ;
      ((void) (0)); ;
      ((void) (0)); ;
      ((void) (0)); ;
      ((void) (0)); ;
      if( (((pExpr)->flags&(u32)(0x400000))!=0) ){
        addrIsNull = exprComputeOperands(pParse, pExpr,
                                   &r1, &r2, &regFree1, &regFree2);
      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
        addrIsNull = 0;
      }
      sqlite3VdbeAddOp3(v, op, r2, r1, target);
                             ;
                             ;
      if( addrIsNull ){
        sqlite3VdbeAddOp2(v, 9, 0, sqlite3VdbeCurrentAddr(v)+2);
        sqlite3VdbeJumpHere(v, addrIsNull);
        sqlite3VdbeAddOp2(v, 76, 0, target);
                                              ;
      }
      break;
    }
    case 174: {
      Expr *pLeft = pExpr->pLeft;
      ((void) (0));
      if( pLeft->op==156 ){
        codeInteger(pParse, pLeft, 1, target);
        return target;

      }else if( pLeft->op==154 ){
        ((void) (0));
        codeReal(v, pLeft->u.zToken, 1, target);
        return target;

      }else{
        tempX.op = 156;
        tempX.flags = 0x000800|0x010000;
        tempX.u.iValue = 0;
                                      ;
        r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);
        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);
        sqlite3VdbeAddOp3(v, 108, r2, r1, target);
                               ;
      }
      break;
    }
    case 115:
    case 19: {
      ((void) (0)); ;
      ((void) (0)); ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
                             ;
      sqlite3VdbeAddOp2(v, op, r1, inReg);
      break;
    }
    case 175: {
      int isTrue;
      int bNormal;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
                             ;
      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
      bNormal = pExpr->op2==45;
                                  ;
                                   ;
      sqlite3VdbeAddOp4Int(v, 92, r1, inReg, !isTrue, isTrue ^ bNormal);
      break;
    }
    case 51:
    case 52: {
      int addr;
      ((void) (0)); ;
      ((void) (0)); ;
      sqlite3VdbeAddOp2(v, 72, 1, target);
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
                             ;
      addr = sqlite3VdbeAddOp1(v, op, r1);
                                      ;
                                       ;
      sqlite3VdbeAddOp2(v, 72, 0, target);
      sqlite3VdbeJumpHere(v, addr);
      break;
    }
    case 169: {
      AggInfo *pInfo = pExpr->pAggInfo;
      if( pInfo==0
       || (pExpr->iAgg<0)
       || (pExpr->iAgg>=pInfo->nFunc)
      ){
        ((void) (0));
        sqlite3ErrorMsg(pParse, "misuse of aggregate: %#T()", pExpr);
      }else{
        return ((pInfo)->iFirstReg+(pInfo)->nColumn+(pExpr->iAgg));
      }
      break;
    }
    case 172: {
      ExprList *pFarg;
      int nFarg;
      FuncDef *pDef;
      const char *zId;
      u32 constMask = 0;
      int i;
      sqlite3 *db = pParse->db;
      u8 enc = ((db)->enc);
      CollSeq *pColl = 0;


      if( (((pExpr)->flags&(u32)(0x1000000))!=0) ){
        return pExpr->y.pWin->regResult;
      }


      if( ((pParse)->okConstFactor)
       && sqlite3ExprIsConstantNotJoin(pParse,pExpr)
      ){


        return sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);
      }
      ((void) (0));
      ((void) (0));
      pFarg = pExpr->x.pList;
      nFarg = pFarg ? pFarg->nExpr : 0;
      ((void) (0));
      zId = pExpr->u.zToken;
      pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);





      if( pDef==0 || pDef->xFinalize!=0 ){
        sqlite3ErrorMsg(pParse, "unknown function: %#T()", pExpr);
        break;
      }
      if( (pDef->funcFlags & 0x00400000)!=0 && (pFarg!=0) ){
        ((void) (0));
        ((void) (0));
        return exprCodeInlineFunction(pParse, pFarg,
             ((int)(long int)(pDef->pUserData)), target);
      }else if( pDef->funcFlags & (0x00080000|0x00200000) ){
        sqlite3ExprFunctionUsable(pParse, pExpr, pDef);
      }

      for(i=0; i<nFarg; i++){
        if( i<32 && sqlite3ExprIsConstant(pParse, pFarg->a[i].pExpr) ){
                           ;
          constMask |= (((unsigned int)1)<<(i));
        }
        if( (pDef->funcFlags & 0x0020)!=0 && !pColl ){
          pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);
        }
      }
      if( pFarg ){
        if( constMask ){
          r1 = pParse->nMem+1;
          pParse->nMem += nFarg;
        }else{
          r1 = sqlite3GetTempRange(pParse, nFarg);
        }






        if( (pDef->funcFlags & (0x0040|0x0080))!=0 ){
          u8 exprOp;
          ((void) (0));
          ((void) (0));
          exprOp = pFarg->a[0].pExpr->op;
          if( exprOp==168 || exprOp==170 ){
            ((void) (0));
            ((void) (0));
            ((void) (0));
            ((void) (0));
                                                                               ;
                                                                               ;
                                                                               ;
            pFarg->a[0].pExpr->op2 = pDef->funcFlags & 0xc0;
          }
        }

        sqlite3ExprCodeExprList(pParse, pFarg, r1, 0, 0x02);
      }else{
        r1 = 0;
      }
# 116839 "c_tests/sqlite3.c"
      if( nFarg>=2 && (((pExpr)->flags&(u32)(0x000100))!=0) ){
        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);
      }else if( nFarg>0 ){
        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);
      }

      if( pDef->funcFlags & 0x0020 ){
        if( !pColl ) pColl = db->pDfltColl;
        sqlite3VdbeAddOp4(v, 86, 0, 0, 0, (char *)pColl, (-2));
      }
      sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,
                                 pDef, pExpr->op2);
      if( nFarg ){
        if( constMask==0 ){
          sqlite3ReleaseTempRange(pParse, r1, nFarg);
        }else{
                                                                      ;
        }
      }
      return target;
    }

    case 20:
    case 139: {
      int nCol;
                               ;
                               ;
      if( pParse->db->mallocFailed ){
        return 0;
      }else if( op==139
             && ((((pExpr)->flags&0x001000)!=0))
             && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1
      ){
        sqlite3SubselectError(pParse, nCol, 1);
      }else{
        return sqlite3CodeSubselect(pParse, pExpr);
      }
      break;
    }
    case 178: {
      int n;
      Expr *pLeft = pExpr->pLeft;
      if( pLeft->iTable==0 || pParse->withinRJSubrtn > pLeft->op2 ){
        pLeft->iTable = sqlite3CodeSubselect(pParse, pLeft);
        pLeft->op2 = pParse->withinRJSubrtn;
      }
      ((void) (0));
      n = sqlite3ExprVectorSize(pLeft);
      if( pExpr->iTable!=n ){
        sqlite3ErrorMsg(pParse, "%d columns assigned %d values",
                                pExpr->iTable, n);
      }
      return pLeft->iTable + pExpr->iColumn;
    }
    case 50: {
      int destIfFalse = sqlite3VdbeMakeLabel(pParse);
      int destIfNull = sqlite3VdbeMakeLabel(pParse);
      sqlite3VdbeAddOp2(v, 76, 0, target);
      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
      sqlite3VdbeAddOp2(v, 72, 1, target);
      sqlite3VdbeResolveLabel(v, destIfFalse);
      sqlite3VdbeAddOp2(v, 87, target, 0);
      sqlite3VdbeResolveLabel(v, destIfNull);
      return target;
    }
# 116918 "c_tests/sqlite3.c"
    case 49: {
      exprCodeBetween(pParse, pExpr, target, 0, 0);
      return target;
    }
    case 114: {
      if( !(((pExpr)->flags&(u32)(0x000200))!=0) ){






        ((void) (0));
        sqlite3ExprCode(pParse, pExpr->pLeft, target);
        sqlite3VdbeAddOp1(v, 181, target);
        return target;
      }else{
        pExpr = pExpr->pLeft;
        goto expr_code_doover;
      }
    }
    case 181:
    case 173: {
      pExpr = pExpr->pLeft;
      goto expr_code_doover;
    }

    case 78: {
# 116971 "c_tests/sqlite3.c"
      Table *pTab;
      int iCol;
      int p1;

      ((void) (0));
      pTab = pExpr->y.pTab;
      iCol = pExpr->iColumn;
      p1 = pExpr->iTable * (pTab->nCol+1) + 1
                     + sqlite3TableColumnToStorage(pTab, iCol);

      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));

      sqlite3VdbeAddOp2(v, 158, p1, target);



        ;







      if( iCol>=0 && pTab->aCol[iCol].affinity==0x45 ){
        sqlite3VdbeAddOp1(v, 88, target);
      }

      break;
    }

    case 177: {
      sqlite3ErrorMsg(pParse, "row value misused");
      break;
    }







    case 179: {
      int addrINR;
      u8 okConstFactor = pParse->okConstFactor;
      AggInfo *pAggInfo = pExpr->pAggInfo;
      if( pAggInfo ){
        ((void) (0));
        if( !pAggInfo->directMode ){
          inReg = ((pAggInfo)->iFirstReg+(pExpr->iAgg));
          break;
        }
        if( pExpr->pAggInfo->useSortingIdx ){
          sqlite3VdbeAddOp3(v, 95, pAggInfo->sortingIdxPTab,
                            pAggInfo->aCol[pExpr->iAgg].iSorterColumn,
                            target);
          inReg = target;
          break;
        }
      }
      addrINR = sqlite3VdbeAddOp3(v, 20, pExpr->iTable, 0, target);







      pParse->okConstFactor = 0;
      sqlite3ExprCode(pParse, pExpr->pLeft, target);
      ((void) (0));
      pParse->okConstFactor = okConstFactor;
      sqlite3VdbeJumpHere(v, addrINR);
      break;
    }
# 117071 "c_tests/sqlite3.c"
    case 158: {
      int endLabel;
      int nextCase;
      int nExpr;
      int i;
      ExprList *pEList;
      struct ExprList_item *aListelem;
      Expr opCompare;
      Expr *pX;
      Expr *pTest = 0;
      Expr *pDel = 0;
      sqlite3 *db = pParse->db;

      ((void) (0));
      ((void) (0));
      pEList = pExpr->x.pList;
      aListelem = pEList->a;
      nExpr = pEList->nExpr;
      endLabel = sqlite3VdbeMakeLabel(pParse);
      if( (pX = pExpr->pLeft)!=0 ){
        pDel = sqlite3ExprDup(db, pX, 0);
        if( db->mallocFailed ){
          sqlite3ExprDelete(db, pDel);
          break;
        }
                                     ;
        sqlite3ExprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));
                               ;
        memset(&opCompare, 0, sizeof(opCompare));
        opCompare.op = 54;
        opCompare.pLeft = pDel;
        pTest = &opCompare;




        regFree1 = 0;
      }
      for(i=0; i<nExpr-1; i=i+2){
        if( pX ){
          ((void) (0));
          opCompare.pRight = aListelem[i].pExpr;
        }else{
          pTest = aListelem[i].pExpr;
        }
        nextCase = sqlite3VdbeMakeLabel(pParse);
                                        ;
        sqlite3ExprIfFalse(pParse, pTest, nextCase, 0x10);
                                                       ;
        sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);
        sqlite3VdbeGoto(v, endLabel);
        sqlite3VdbeResolveLabel(v, nextCase);
      }
      if( (nExpr&1)!=0 ){
        sqlite3ExprCode(pParse, pEList->a[nExpr-1].pExpr, target);
      }else{
        sqlite3VdbeAddOp2(v, 76, 0, target);
      }
      sqlite3ExprDelete(db, pDel);
      setDoNotMergeFlagOnCopy(v);
      sqlite3VdbeResolveLabel(v, endLabel);
      break;
    }

    case 72: {
      ((void) (0));




      if( !pParse->pTriggerTab && !pParse->nested ){
        sqlite3ErrorMsg(pParse,
                       "RAISE() may only be used within a trigger-program");
        return 0;
      }
      if( pExpr->affExpr==2 ){
        sqlite3MayAbort(pParse);
      }
      ((void) (0));
      if( pExpr->affExpr==4 ){
        sqlite3VdbeAddOp2(v, 71, 0, 4);
                       ;
      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
        sqlite3VdbeAddOp3(v, 71,
             pParse->pTriggerTab ? (19 | (7<<8)) : 1,
             pExpr->affExpr, r1);
      }
      break;
    }

  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
  return inReg;
}
# 117185 "c_tests/sqlite3.c"
static int sqlite3ExprCodeRunJustOnce(
  Parse *pParse,
  Expr *pExpr,
  int regDest
){
  ExprList *p;
  ((void) (0));
  ((void) (0));
  p = pParse->pConstExpr;
  if( regDest<0 && p ){
    struct ExprList_item *pItem;
    int i;
    for(pItem=p->a, i=p->nExpr; i>0; pItem++, i--){
      if( pItem->fg.reusable
       && sqlite3ExprCompare(0,pItem->pExpr,pExpr,-1)==0
      ){
        return pItem->u.iConstExprReg;
      }
    }
  }
  pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);
  if( pExpr!=0 && (((pExpr)->flags&(u32)(0x000008))!=0) ){
    Vdbe *v = pParse->pVdbe;
    int addr;
    ((void) (0));
    addr = sqlite3VdbeAddOp0(v, 15); ;
    pParse->okConstFactor = 0;
    if( !pParse->db->mallocFailed ){
      if( regDest<0 ) regDest = ++pParse->nMem;
      sqlite3ExprCode(pParse, pExpr, regDest);
    }
    pParse->okConstFactor = 1;
    sqlite3ExprDelete(pParse->db, pExpr);
    sqlite3VdbeJumpHere(v, addr);
  }else{
    p = sqlite3ExprListAppend(pParse, p, pExpr);
    if( p ){
       struct ExprList_item *pItem = &p->a[p->nExpr-1];
       pItem->fg.reusable = regDest<0;
       if( regDest<0 ) regDest = ++pParse->nMem;
       pItem->u.iConstExprReg = regDest;
    }
    pParse->pConstExpr = p;
  }
  return regDest;
}





static __attribute__((noinline)) void sqlite3ExprNullRegisterRange(
  Parse *pParse,
  int iReg,
  int nReg
){
  u8 okConstFactor = pParse->okConstFactor;
  Expr t;
  memset(&t, 0, sizeof(t));
  t.op = 83;
  t.y.nReg = nReg;
  pParse->okConstFactor = 1;
  sqlite3ExprCodeRunJustOnce(pParse, &t, iReg);
  pParse->okConstFactor = okConstFactor;
}
# 117264 "c_tests/sqlite3.c"
static int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){
  int r2;
  pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);
  if( ((pParse)->okConstFactor)
   && (pExpr!=0)
   && pExpr->op!=176
   && sqlite3ExprIsConstantNotJoin(pParse, pExpr)
  ){
    *pReg = 0;
    r2 = sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);
  }else{
    int r1 = sqlite3GetTempReg(pParse);
    r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);
    if( r2==r1 ){
      *pReg = r1;
    }else{
      sqlite3ReleaseTempReg(pParse, r1);
      *pReg = 0;
    }
  }
  return r2;
}






static void sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){
  int inReg;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pParse->pVdbe==0 ) return;
  inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);
  if( inReg!=target ){
    u8 op;
    Expr *pX = sqlite3ExprSkipCollateAndLikely(pExpr);
                         ;
    if( (pX)
     && ((((pX)->flags&(u32)(0x400000))!=0) || pX->op==176)
    ){
      op = 81;
    }else{
      op = 82;
    }
    sqlite3VdbeAddOp2(pParse->pVdbe, op, inReg, target);
  }
}






static void sqlite3ExprCodeCopy(Parse *pParse, Expr *pExpr, int target){
  sqlite3 *db = pParse->db;
  pExpr = sqlite3ExprDup(db, pExpr, 0);
  if( !db->mallocFailed ) sqlite3ExprCode(pParse, pExpr, target);
  sqlite3ExprDelete(db, pExpr);
}







static void sqlite3ExprCodeFactorable(Parse *pParse, Expr *pExpr, int target){
  if( pParse->okConstFactor && sqlite3ExprIsConstantNotJoin(pParse,pExpr) ){
    sqlite3ExprCodeRunJustOnce(pParse, pExpr, target);
  }else{
    sqlite3ExprCodeCopy(pParse, pExpr, target);
  }
}
# 117361 "c_tests/sqlite3.c"
static int sqlite3ExprCodeExprList(
  Parse *pParse,
  ExprList *pList,
  int target,
  int srcReg,
  u8 flags
){
  struct ExprList_item *pItem;
  int i, j, n;
  u8 copyOp = (flags & 0x01) ? 81 : 82;
  Vdbe *v = pParse->pVdbe;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  n = pList->nExpr;
  if( !((pParse)->okConstFactor) ) flags &= ~0x02;
  for(pItem=pList->a, i=0; i<n; i++, pItem++){
    Expr *pExpr = pItem->pExpr;






    if( (flags & 0x04)!=0 && (j = pItem->u.x.iOrderByCol)>0 ){
      if( flags & 0x08 ){
        i--;
        n--;
      }else{
        sqlite3VdbeAddOp2(v, copyOp, j+srcReg-1, target+i);
      }
    }else if( (flags & 0x02)!=0
           && sqlite3ExprIsConstantNotJoin(pParse,pExpr)
    ){
      sqlite3ExprCodeRunJustOnce(pParse, pExpr, target+i);
    }else{
      int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target+i);
      if( inReg!=target+i ){
        VdbeOp *pOp;
        if( copyOp==81
         && (pOp=sqlite3VdbeGetLastOp(v))->opcode==81
         && pOp->p1+pOp->p3+1==inReg
         && pOp->p2+pOp->p3+1==target+i
         && pOp->p5==0
        ){
          pOp->p3++;
        }else{
          sqlite3VdbeAddOp2(v, copyOp, inReg, target+i);
        }
      }
    }
  }
  return n;
}
# 117436 "c_tests/sqlite3.c"
static void exprCodeBetween(
  Parse *pParse,
  Expr *pExpr,
  int dest,
  void (*xJump)(Parse*,Expr*,int,int),
  int jumpIfNull
){
  Expr exprAnd;
  Expr compLeft;
  Expr compRight;
  int regFree1 = 0;
  Expr *pDel = 0;
  sqlite3 *db = pParse->db;

  memset(&compLeft, 0, sizeof(Expr));
  memset(&compRight, 0, sizeof(Expr));
  memset(&exprAnd, 0, sizeof(Expr));

  ((void) (0));
  pDel = sqlite3ExprDup(db, pExpr->pLeft, 0);
  if( db->mallocFailed==0 ){
    exprAnd.op = 44;
    exprAnd.pLeft = &compLeft;
    exprAnd.pRight = &compRight;
    compLeft.op = 58;
    compLeft.pLeft = pDel;
    compLeft.pRight = pExpr->x.pList->a[0].pExpr;
    compRight.op = 56;
    compRight.pLeft = pDel;
    compRight.pRight = pExpr->x.pList->a[1].pExpr;
    sqlite3ExprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));
    if( xJump ){
      xJump(pParse, &exprAnd, dest, jumpIfNull);
    }else{





      pDel->flags |= 0x000001;
      sqlite3ExprCodeTarget(pParse, &exprAnd, dest);
    }
    sqlite3ReleaseTempReg(pParse, regFree1);
  }
  sqlite3ExprDelete(db, pDel);


                                                                       ;
                                                                       ;
                                                                       ;
                                                                       ;
                                                                       ;
                                                                       ;
                                                                       ;
                                                                       ;
                      ;
}
# 117508 "c_tests/sqlite3.c"
static void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){
  Vdbe *v = pParse->pVdbe;
  int op = 0;
  int regFree1 = 0;
  int regFree2 = 0;
  int r1, r2;

  ((void) (0));
  if( (v==0) ) return;
  if( (pExpr==0) ) return;
  ((void) (0));
  op = pExpr->op;
  switch( op ){
    case 44:
    case 43: {
      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
      if( pAlt!=pExpr ){
        sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);
      }else{
        Expr *pFirst, *pSecond;
        if( exprEvalRhsFirst(pExpr) ){
          pFirst = pExpr->pRight;
          pSecond = pExpr->pLeft;
        }else{
          pFirst = pExpr->pLeft;
          pSecond = pExpr->pRight;
        }
        if( op==44 ){
          int d2 = sqlite3VdbeMakeLabel(pParse);
                                   ;
          sqlite3ExprIfFalse(pParse, pFirst, d2,
                             jumpIfNull^0x10);
          sqlite3ExprIfTrue(pParse, pSecond, dest, jumpIfNull);
          sqlite3VdbeResolveLabel(v, d2);
        }else{
                                   ;
          sqlite3ExprIfTrue(pParse, pFirst, dest, jumpIfNull);
          sqlite3ExprIfTrue(pParse, pSecond, dest, jumpIfNull);
        }
      }
      break;
    }
    case 19: {
                               ;
      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
      break;
    }
    case 175: {
      int isNot;
      int isTrue;
                               ;
      isNot = pExpr->op2==46;
      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
                                 ;
                                  ;
      if( isTrue ^ isNot ){
        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,
                          isNot ? 0x10 : 0);
      }else{
        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,
                           isNot ? 0x10 : 0);
      }
      break;
    }
    case 45:
    case 46:
                           ;
                              ;
      op = (op==45) ? 54 : 53;
      jumpIfNull = 0x80;
                     __attribute__((fallthrough));
    case 57:
    case 56:
    case 55:
    case 58:
    case 53:
    case 54: {
      int addrIsNull;
      if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;
      if( (((pExpr)->flags&(u32)(0x400000))!=0) && jumpIfNull!=0x80 ){
        addrIsNull = exprComputeOperands(pParse, pExpr,
                                   &r1, &r2, &regFree1, &regFree2);
      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
        addrIsNull = 0;
      }
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, dest, jumpIfNull, (((pExpr)->flags&(u32)(0x000400))!=0));
      ((void) (0)); ; ;
      ((void) (0)); ; ;
      ((void) (0)); ; ;
      ((void) (0)); ; ;
      ((void) (0)); ;
                                                               ;
                                                               ;
      ((void) (0)); ;
                                                               ;
                                                               ;
                             ;
                             ;
      if( addrIsNull ){
        if( jumpIfNull ){
          sqlite3VdbeChangeP2(v, addrIsNull, dest);
        }else{
          sqlite3VdbeJumpHere(v, addrIsNull);
        }
      }
      break;
    }
    case 51:
    case 52: {
      ((void) (0)); ;
      ((void) (0)); ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      ((void) (0));
      if( regFree1 ) sqlite3VdbeTypeofColumn(v, r1);
      sqlite3VdbeAddOp2(v, op, r1, dest);
                                      ;
                                       ;
      break;
    }
    case 49: {
                               ;
      exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);
      break;
    }

    case 50: {
      int destIfFalse = sqlite3VdbeMakeLabel(pParse);
      int destIfNull = jumpIfNull ? dest : destIfFalse;
      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
      sqlite3VdbeGoto(v, dest);
      sqlite3VdbeResolveLabel(v, destIfFalse);
      break;
    }

    default: {
    default_expr:
      if( (((pExpr)->flags&(0x000001|0x10000000))==0x10000000) ){
        sqlite3VdbeGoto(v, dest);
      }else if( (((pExpr)->flags&(0x000001|0x20000000))==0x20000000) ){

      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
        sqlite3VdbeAddOp3(v, 16, r1, dest, jumpIfNull!=0);
                       ;
                               ;
                                 ;
      }
      break;
    }
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
}
# 117674 "c_tests/sqlite3.c"
static void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){
  Vdbe *v = pParse->pVdbe;
  int op = 0;
  int regFree1 = 0;
  int regFree2 = 0;
  int r1, r2;

  ((void) (0));
  if( (v==0) ) return;
  if( pExpr==0 ) return;
  ((void) (0));
# 117704 "c_tests/sqlite3.c"
  op = ((pExpr->op+(51&1))^1)-(51&1);



  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  switch( pExpr->op ){
    case 44:
    case 43: {
      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
      if( pAlt!=pExpr ){
        sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);
      }else{
        Expr *pFirst, *pSecond;
        if( exprEvalRhsFirst(pExpr) ){
          pFirst = pExpr->pRight;
          pSecond = pExpr->pLeft;
        }else{
          pFirst = pExpr->pLeft;
          pSecond = pExpr->pRight;
        }
        if( pExpr->op==44 ){
                                   ;
          sqlite3ExprIfFalse(pParse, pFirst, dest, jumpIfNull);
          sqlite3ExprIfFalse(pParse, pSecond, dest, jumpIfNull);
        }else{
          int d2 = sqlite3VdbeMakeLabel(pParse);
                                   ;
          sqlite3ExprIfTrue(pParse, pFirst, d2,
                            jumpIfNull^0x10);
          sqlite3ExprIfFalse(pParse, pSecond, dest, jumpIfNull);
          sqlite3VdbeResolveLabel(v, d2);
        }
      }
      break;
    }
    case 19: {
                               ;
      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
      break;
    }
    case 175: {
      int isNot;
      int isTrue;
                               ;
      isNot = pExpr->op2==46;
      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
                                 ;
                                  ;
      if( isTrue ^ isNot ){

        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,
                           isNot ? 0 : 0x10);

      }else{

        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,
                          isNot ? 0 : 0x10);
      }
      break;
    }
    case 45:
    case 46:
                                  ;
                                     ;
      op = (pExpr->op==45) ? 53 : 54;
      jumpIfNull = 0x80;
                     __attribute__((fallthrough));
    case 57:
    case 56:
    case 55:
    case 58:
    case 53:
    case 54: {
      int addrIsNull;
      if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;
      if( (((pExpr)->flags&(u32)(0x400000))!=0) && jumpIfNull!=0x80 ){
        addrIsNull = exprComputeOperands(pParse, pExpr,
                                   &r1, &r2, &regFree1, &regFree2);
      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
        addrIsNull = 0;
      }
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, dest, jumpIfNull,(((pExpr)->flags&(u32)(0x000400))!=0));
      ((void) (0)); ; ;
      ((void) (0)); ; ;
      ((void) (0)); ; ;
      ((void) (0)); ; ;
      ((void) (0)); ;
                                                               ;
                                                               ;
      ((void) (0)); ;
                                                               ;
                                                               ;
                             ;
                             ;
      if( addrIsNull ){
        if( jumpIfNull ){
          sqlite3VdbeChangeP2(v, addrIsNull, dest);
        }else{
          sqlite3VdbeJumpHere(v, addrIsNull);
        }
      }
      break;
    }
    case 51:
    case 52: {
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      ((void) (0));
      if( regFree1 ) sqlite3VdbeTypeofColumn(v, r1);
      sqlite3VdbeAddOp2(v, op, r1, dest);
                               ; ;
                                ; ;
      break;
    }
    case 49: {
                               ;
      exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);
      break;
    }

    case 50: {
      if( jumpIfNull ){
        sqlite3ExprCodeIN(pParse, pExpr, dest, dest);
      }else{
        int destIfNull = sqlite3VdbeMakeLabel(pParse);
        sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);
        sqlite3VdbeResolveLabel(v, destIfNull);
      }
      break;
    }

    default: {
    default_expr:
      if( (((pExpr)->flags&(0x000001|0x20000000))==0x20000000) ){
        sqlite3VdbeGoto(v, dest);
      }else if( (((pExpr)->flags&(0x000001|0x10000000))==0x10000000) ){

      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
        sqlite3VdbeAddOp3(v, 17, r1, dest, jumpIfNull!=0);
                       ;
                               ;
                                 ;
      }
      break;
    }
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
}






static void sqlite3ExprIfFalseDup(Parse *pParse, Expr *pExpr, int dest,int jumpIfNull){
  sqlite3 *db = pParse->db;
  Expr *pCopy = sqlite3ExprDup(db, pExpr, 0);
  if( db->mallocFailed==0 ){
    sqlite3ExprIfFalse(pParse, pCopy, dest, jumpIfNull);
  }
  sqlite3ExprDelete(db, pCopy);
}
# 117895 "c_tests/sqlite3.c"
static __attribute__((noinline)) int exprCompareVariable(
  const Parse *pParse,
  const Expr *pVar,
  const Expr *pExpr
){
  int res = 2;
  int iVar;
  sqlite3_value *pL, *pR = 0;

  if( pExpr->op==157 && pVar->iColumn==pExpr->iColumn ){
    return 0;
  }
  if( (pParse->db->flags & 0x00800000)!=0 ) return 2;
  sqlite3ValueFromExpr(pParse->db, pExpr, 1, 0x41, &pR);
  if( pR ){
    iVar = pVar->iColumn;
    sqlite3VdbeSetVarmask(pParse->pVdbe, iVar);
    pL = sqlite3VdbeGetBoundValue(pParse->pReprepare, iVar, 0x41);
    if( pL ){
      if( sqlite3_value_type(pL)==3 ){
        sqlite3_value_text(pL);
      }
      res = sqlite3MemCompare(pL, pR, 0) ? 2 : 0;
    }
    sqlite3ValueFree(pR);
    sqlite3ValueFree(pL);
  }
  return res;
}
# 117952 "c_tests/sqlite3.c"
static int sqlite3ExprCompare(
  const Parse *pParse,
  const Expr *pA,
  const Expr *pB,
  int iTab
){
  u32 combinedFlags;
  if( pA==0 || pB==0 ){
    return pB==pA ? 0 : 2;
  }
  if( pParse && pA->op==157 ){
    return exprCompareVariable(pParse, pA, pB);
  }
  combinedFlags = pA->flags | pB->flags;
  if( combinedFlags & 0x000800 ){
    if( (pA->flags&pB->flags&0x000800)!=0 && pA->u.iValue==pB->u.iValue ){
      return 0;
    }
    return 2;
  }
  if( pA->op!=pB->op || pA->op==72 ){
    if( pA->op==114 && sqlite3ExprCompare(pParse, pA->pLeft,pB,iTab)<2 ){
      return 1;
    }
    if( pB->op==114 && sqlite3ExprCompare(pParse, pA,pB->pLeft,iTab)<2 ){
      return 1;
    }
    if( pA->op==170 && pB->op==168
     && pB->iTable<0 && pA->iTable==iTab
    ){

    }else{
      return 2;
    }
  }
  ((void) (0));
  ((void) (0));
  if( pA->u.zToken ){
    if( pA->op==172 || pA->op==169 ){
      if( sqlite3StrICmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;

      ((void) (0));
      if( (((pA)->flags&(u32)(0x1000000))!=0)!=(((pB)->flags&(u32)(0x1000000))!=0) ){
        return 2;
      }
      if( (((pA)->flags&(u32)(0x1000000))!=0) ){
        if( sqlite3WindowCompare(pParse, pA->y.pWin, pB->y.pWin, 1)!=0 ){
          return 2;
        }
      }

    }else if( pA->op==122 ){
      return 0;
    }else if( pA->op==114 ){
      if( sqlite3_stricmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;
    }else
    if( pB->u.zToken!=0
     && pA->op!=168
     && pA->op!=170
     && strcmp(pA->u.zToken,pB->u.zToken)!=0
    ){
      return 2;
    }
  }
  if( (pA->flags & (0x000004|0x000400))
     != (pB->flags & (0x000004|0x000400)) ) return 2;
  if( ((combinedFlags & 0x010000)==0) ){
    if( combinedFlags & 0x001000 ) return 2;
    if( (combinedFlags & 0x000020)==0
     && sqlite3ExprCompare(pParse, pA->pLeft, pB->pLeft, iTab) ) return 2;
    if( sqlite3ExprCompare(pParse, pA->pRight, pB->pRight, iTab) ) return 2;
    if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab) ) return 2;
    if( pA->op!=118
     && pA->op!=171
     && ((combinedFlags & 0x004000)==0)
    ){
      if( pA->iColumn!=pB->iColumn ) return 2;
      if( pA->op2!=pB->op2 && pA->op==175 ) return 2;
      if( pA->op!=50 && pA->iTable!=pB->iTable && pA->iTable!=iTab ){
        return 2;
      }
    }
  }
  return 0;
}
# 118054 "c_tests/sqlite3.c"
static int sqlite3ExprListCompare(const ExprList *pA, const ExprList *pB, int iTab){
  int i;
  if( pA==0 && pB==0 ) return 0;
  if( pA==0 || pB==0 ) return 1;
  if( pA->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<pA->nExpr; i++){
    int res;
    Expr *pExprA = pA->a[i].pExpr;
    Expr *pExprB = pB->a[i].pExpr;
    if( pA->a[i].fg.sortFlags!=pB->a[i].fg.sortFlags ) return 1;
    if( (res = sqlite3ExprCompare(0, pExprA, pExprB, iTab)) ) return res;
  }
  return 0;
}





static int sqlite3ExprCompareSkip(Expr *pA,Expr *pB, int iTab){
  return sqlite3ExprCompare(0,
             sqlite3ExprSkipCollate(pA),
             sqlite3ExprSkipCollate(pB),
             iTab);
}







static int exprImpliesNotNull(
  const Parse *pParse,
  const Expr *p,
  const Expr *pNN,
  int iTab,
  int seenNot
){
  ((void) (0));
  ((void) (0));
  if( sqlite3ExprCompare(pParse, p, pNN, iTab)==0 ){
    return pNN->op!=122;
  }
  switch( p->op ){
    case 50: {
      if( seenNot && (((p)->flags&(u32)(0x001000))!=0) ) return 0;
      ((void) (0));
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
    case 49: {
      ExprList *pList;
      ((void) (0));
      pList = p->x.pList;
      ((void) (0));
      ((void) (0));
      if( seenNot ) return 0;
      if( exprImpliesNotNull(pParse, pList->a[0].pExpr, pNN, iTab, 1)
       || exprImpliesNotNull(pParse, pList->a[1].pExpr, pNN, iTab, 1)
      ){
        return 1;
      }
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
    case 54:
    case 53:
    case 57:
    case 56:
    case 55:
    case 58:
    case 107:
    case 108:
    case 104:
    case 105:
    case 106:
    case 112:
      seenNot = 1;
                     __attribute__((fallthrough));
    case 109:
    case 111:
    case 103:
    case 110: {
      if( exprImpliesNotNull(pParse, p->pRight, pNN, iTab, seenNot) ) return 1;
                     __attribute__((fallthrough));
    }
    case 181:
    case 114:
    case 173:
    case 174: {
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, seenNot);
    }
    case 175: {
      if( seenNot ) return 0;
      if( p->op2!=45 ) return 0;
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
    case 115:
    case 19: {
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
  }
  return 0;
}





static int sqlite3ExprIsNotTrue(Expr *pExpr){
  int v;
  if( pExpr->op==122 ) return 1;
  if( pExpr->op==171 && sqlite3ExprTruthValue(pExpr)==0 ) return 1;
  v = 1;
  if( sqlite3ExprIsInteger(pExpr, &v, 0) && v==0 ) return 1;
  return 0;
}
# 118181 "c_tests/sqlite3.c"
static int sqlite3ExprIsIIF(sqlite3 *db, const Expr *pExpr){
  ExprList *pList;
  if( pExpr->op==172 ){
    const char *z = pExpr->u.zToken;
    FuncDef *pDef;
    if( (z[0]!='i' && z[0]!='I') ) return 0;
    if( pExpr->x.pList==0 ) return 0;
    pDef = sqlite3FindFunction(db, z, pExpr->x.pList->nExpr, ((db)->enc), 0);



    if( (pDef==0) ) return 0;

    if( (pDef->funcFlags & 0x00400000)==0 ) return 0;
    if( ((int)(long int)(pDef->pUserData))!=5 ) return 0;
  }else if( pExpr->op==158 ){
    if( pExpr->pLeft!=0 ) return 0;
  }else{
    return 0;
  }
  pList = pExpr->x.pList;
  ((void) (0));
  if( pList->nExpr==2 ) return 1;
  if( pList->nExpr==3 && sqlite3ExprIsNotTrue(pList->a[2].pExpr) ) return 1;
  return 0;
}
# 118235 "c_tests/sqlite3.c"
static int sqlite3ExprImpliesExpr(
  const Parse *pParse,
  const Expr *pE1,
  const Expr *pE2,
  int iTab
){
  if( sqlite3ExprCompare(pParse, pE1, pE2, iTab)==0 ){
    return 1;
  }
  if( pE2->op==43
   && (sqlite3ExprImpliesExpr(pParse, pE1, pE2->pLeft, iTab)
             || sqlite3ExprImpliesExpr(pParse, pE1, pE2->pRight, iTab) )
  ){
    return 1;
  }
  if( pE2->op==52
   && exprImpliesNotNull(pParse, pE1, pE2->pLeft, iTab, 0)
  ){
    return 1;
  }
  if( sqlite3ExprIsIIF(pParse->db, pE1) ){
    return sqlite3ExprImpliesExpr(pParse,pE1->x.pList->a[0].pExpr,pE2,iTab);
  }
  return 0;
}





static void bothImplyNotNullRow(Walker *pWalker, Expr *pE1, Expr *pE2){
  if( pWalker->eCode==0 ){
    sqlite3WalkExpr(pWalker, pE1);
    if( pWalker->eCode ){
      pWalker->eCode = 0;
      sqlite3WalkExpr(pWalker, pE2);
    }
  }
}
# 118288 "c_tests/sqlite3.c"
static int impliesNotNullRow(Walker *pWalker, Expr *pExpr){
                                      ;
                                        ;
  if( (((pExpr)->flags&(u32)(0x000001))!=0) ) return 1;
  if( (((pExpr)->flags&(u32)(0x000002))!=0) && pWalker->mWFlags ){





    return 1;
  }
  switch( pExpr->op ){
    case 46:
    case 51:
    case 52:
    case 45:
    case 177:
    case 172:
    case 175:
    case 158:
                                     ;
                                      ;
                                       ;
                                  ;
                                      ;
                                        ;
                                     ;
                                    ;
      return 1;

    case 168:
      if( pWalker->u.iCur==pExpr->iTable ){
        pWalker->eCode = 1;
        return 2;
      }
      return 1;

    case 43:
    case 44:







                                  ;
                                   ;
      bothImplyNotNullRow(pWalker, pExpr->pLeft, pExpr->pRight);
      return 1;

    case 50:




      if( (((pExpr)->flags&0x001000)==0) && (pExpr->x.pList->nExpr>0) ){
        sqlite3WalkExpr(pWalker, pExpr->pLeft);
      }
      return 1;

    case 49:


      ((void) (0));
      ((void) (0));
      sqlite3WalkExpr(pWalker, pExpr->pLeft);
      bothImplyNotNullRow(pWalker, pExpr->x.pList->a[0].pExpr,
                                   pExpr->x.pList->a[1].pExpr);
      return 1;




    case 54:
    case 53:
    case 57:
    case 56:
    case 55:
    case 58: {
      Expr *pLeft = pExpr->pLeft;
      Expr *pRight = pExpr->pRight;
                                  ;
                                  ;
                                  ;
                                  ;
                                  ;
                                  ;


      ((void) (0));
      ((void) (0));
      if( (pLeft->op==168
           && (pLeft->y.pTab!=0)
           && ((pLeft->y.pTab)->eTabType==1))
       || (pRight->op==168
           && (pRight->y.pTab!=0)
           && ((pRight->y.pTab)->eTabType==1))
      ){
        return 1;
      }
                     __attribute__((fallthrough));
    }
    default:
      return 0;
  }
}
# 118419 "c_tests/sqlite3.c"
static int sqlite3ExprImpliesNonNullRow(Expr *p, int iTab, int isRJ){
  Walker w;
  p = sqlite3ExprSkipCollateAndLikely(p);
  if( p==0 ) return 0;
  if( p->op==52 ){
    p = p->pLeft;
  }else{
    while( p->op==44 ){
      if( sqlite3ExprImpliesNonNullRow(p->pLeft, iTab, isRJ) ) return 1;
      p = p->pRight;
    }
  }
  w.xExprCallback = impliesNotNullRow;
  w.xSelectCallback = 0;
  w.xSelectCallback2 = 0;
  w.eCode = 0;
  w.mWFlags = isRJ!=0;
  w.u.iCur = iTab;
  sqlite3WalkExpr(&w, p);
  return w.eCode;
}
# 118448 "c_tests/sqlite3.c"
struct IdxCover {
  Index *pIdx;
  int iCur;
};






static int exprIdxCover(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==168
   && pExpr->iTable==pWalker->u.pIdxCover->iCur
   && sqlite3TableColumnToIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0
  ){
    pWalker->eCode = 1;
    return 2;
  }
  return 0;
}
# 118479 "c_tests/sqlite3.c"
static int sqlite3ExprCoveredByIndex(
  Expr *pExpr,
  int iCur,
  Index *pIdx
){
  Walker w;
  struct IdxCover xcov;
  memset(&w, 0, sizeof(w));
  xcov.iCur = iCur;
  xcov.pIdx = pIdx;
  w.xExprCallback = exprIdxCover;
  w.u.pIdxCover = &xcov;
  sqlite3WalkExpr(&w, pExpr);
  return !w.eCode;
}





struct RefSrcList {
  sqlite3 *db;
  SrcList *pRef;
  i64 nExclude;
  int *aiExclude;
};
# 118514 "c_tests/sqlite3.c"
static int selectRefEnter(Walker *pWalker, Select *pSelect){
  struct RefSrcList *p = pWalker->u.pRefSrcList;
  SrcList *pSrc = pSelect->pSrc;
  i64 i, j;
  int *piNew;
  if( pSrc->nSrc==0 ) return 0;
  j = p->nExclude;
  p->nExclude += pSrc->nSrc;
  piNew = sqlite3DbRealloc(p->db, p->aiExclude, p->nExclude*sizeof(int));
  if( piNew==0 ){
    p->nExclude = 0;
    return 2;
  }else{
    p->aiExclude = piNew;
  }
  for(i=0; i<pSrc->nSrc; i++, j++){
     p->aiExclude[j] = pSrc->a[i].iCursor;
  }
  return 0;
}
static void selectRefLeave(Walker *pWalker, Select *pSelect){
  struct RefSrcList *p = pWalker->u.pRefSrcList;
  SrcList *pSrc = pSelect->pSrc;
  if( p->nExclude ){
    ((void) (0));
    p->nExclude -= pSrc->nSrc;
  }
}
# 118551 "c_tests/sqlite3.c"
static int exprRefToSrcList(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==168
   || pExpr->op==170
  ){
    int i;
    struct RefSrcList *p = pWalker->u.pRefSrcList;
    SrcList *pSrc = p->pRef;
    int nSrc = pSrc ? pSrc->nSrc : 0;
    for(i=0; i<nSrc; i++){
      if( pExpr->iTable==pSrc->a[i].iCursor ){
        pWalker->eCode |= 1;
        return 0;
      }
    }
    for(i=0; i<p->nExclude && p->aiExclude[i]!=pExpr->iTable; i++){}
    if( i>=p->nExclude ){
      pWalker->eCode |= 2;
    }
  }
  return 0;
}
# 118588 "c_tests/sqlite3.c"
static int sqlite3ReferencesSrcList(Parse *pParse, Expr *pExpr, SrcList *pSrcList){
  Walker w;
  struct RefSrcList x;
  ((void) (0));
  memset(&w, 0, sizeof(w));
  memset(&x, 0, sizeof(x));
  w.xExprCallback = exprRefToSrcList;
  w.xSelectCallback = selectRefEnter;
  w.xSelectCallback2 = selectRefLeave;
  w.u.pRefSrcList = &x;
  x.db = pParse->db;
  x.pRef = pSrcList;
  ((void) (0));
  ((void) (0));
  sqlite3WalkExprList(&w, pExpr->x.pList);
  if( pExpr->pLeft ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    sqlite3WalkExprList(&w, pExpr->pLeft->x.pList);
  }

  if( (((pExpr)->flags&(u32)(0x1000000))!=0) ){
    sqlite3WalkExpr(&w, pExpr->y.pWin->pFilter);
  }

  if( x.aiExclude ) sqlite3DbNNFreeNN(pParse->db, x.aiExclude);
  if( w.eCode & 0x01 ){
    return 1;
  }else if( w.eCode ){
    return 0;
  }else{
    return -1;
  }
}
# 118635 "c_tests/sqlite3.c"
static int agginfoPersistExprCb(Walker *pWalker, Expr *pExpr){
  if( (!(((pExpr)->flags&(u32)(0x010000|0x004000))!=0))
   && pExpr->pAggInfo!=0
  ){
    AggInfo *pAggInfo = pExpr->pAggInfo;
    int iAgg = pExpr->iAgg;
    Parse *pParse = pWalker->pParse;
    sqlite3 *db = pParse->db;
    ((void) (0));
    if( pExpr->op!=169 ){
      if( iAgg<pAggInfo->nColumn
       && pAggInfo->aCol[iAgg].pCExpr==pExpr
      ){
        pExpr = sqlite3ExprDup(db, pExpr, 0);
        if( pExpr && !sqlite3ExprDeferredDelete(pParse, pExpr) ){
          pAggInfo->aCol[iAgg].pCExpr = pExpr;
        }
      }
    }else{
      ((void) (0));
      if( (iAgg<pAggInfo->nFunc)
       && pAggInfo->aFunc[iAgg].pFExpr==pExpr
      ){
        pExpr = sqlite3ExprDup(db, pExpr, 0);
        if( pExpr && !sqlite3ExprDeferredDelete(pParse, pExpr) ){
          pAggInfo->aFunc[iAgg].pFExpr = pExpr;
        }
      }
    }
  }
  return 0;
}





static void sqlite3AggInfoPersistWalkerInit(Walker *pWalker, Parse *pParse){
  memset(pWalker, 0, sizeof(*pWalker));
  pWalker->pParse = pParse;
  pWalker->xExprCallback = agginfoPersistExprCb;
  pWalker->xSelectCallback = sqlite3SelectWalkNoop;
}





static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){
  int i;
  pInfo->aCol = sqlite3ArrayAllocate(
       db,
       pInfo->aCol,
       sizeof(pInfo->aCol[0]),
       &pInfo->nColumn,
       &i
  );
  return i;
}





static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){
  int i;
  pInfo->aFunc = sqlite3ArrayAllocate(
       db,
       pInfo->aFunc,
       sizeof(pInfo->aFunc[0]),
       &pInfo->nFunc,
       &i
  );
  return i;
}
# 118718 "c_tests/sqlite3.c"
static void findOrCreateAggInfoColumn(
  Parse *pParse,
  AggInfo *pAggInfo,
  Expr *pExpr
){
  struct AggInfo_col *pCol;
  int k;
  int mxTerm = pParse->db->aLimit[2];

  ((void) (0));
  ((void) (0));
  pCol = pAggInfo->aCol;
  for(k=0; k<pAggInfo->nColumn; k++, pCol++){
    if( pCol->pCExpr==pExpr ) return;
    if( pCol->iTable==pExpr->iTable
     && pCol->iColumn==pExpr->iColumn
     && pExpr->op!=179
    ){
      goto fix_up_expr;
    }
  }
  k = addAggInfoColumn(pParse->db, pAggInfo);
  if( k<0 ){

    ((void) (0));
    return;
  }
  if( k>mxTerm ){
    sqlite3ErrorMsg(pParse, "more than %d aggregate terms", mxTerm);
    k = mxTerm;
  }
  pCol = &pAggInfo->aCol[k];
  ((void) (0));
  pCol->pTab = pExpr->y.pTab;
  pCol->iTable = pExpr->iTable;
  pCol->iColumn = pExpr->iColumn;
  pCol->iSorterColumn = -1;
  pCol->pCExpr = pExpr;
  if( pAggInfo->pGroupBy && pExpr->op!=179 ){
    int j, n;
    ExprList *pGB = pAggInfo->pGroupBy;
    struct ExprList_item *pTerm = pGB->a;
    n = pGB->nExpr;
    for(j=0; j<n; j++, pTerm++){
      Expr *pE = pTerm->pExpr;
      if( pE->op==168
       && pE->iTable==pExpr->iTable
       && pE->iColumn==pExpr->iColumn
      ){
        pCol->iSorterColumn = j;
        break;
      }
    }
  }
  if( pCol->iSorterColumn<0 ){
    pCol->iSorterColumn = pAggInfo->nSortingColumn++;
  }
fix_up_expr:
                                        ;
  ((void) (0));
  pExpr->pAggInfo = pAggInfo;
  if( pExpr->op==168 ){
    pExpr->op = 170;
  }
  ((void) (0));
  pExpr->iAgg = (i16)k;
}






static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
  int i;
  NameContext *pNC = pWalker->u.pNC;
  Parse *pParse = pNC->pParse;
  SrcList *pSrcList = pNC->pSrcList;
  AggInfo *pAggInfo = pNC->uNC.pAggInfo;

  ((void) (0));
  ((void) (0));
  switch( pExpr->op ){
    default: {
      IndexedExpr *pIEpr;
      Expr tmp;
      ((void) (0));
      if( (pNC->ncFlags & 0x020000)==0 ) break;
      if( pParse->pIdxEpr==0 ) break;
      for(pIEpr=pParse->pIdxEpr; pIEpr; pIEpr=pIEpr->pIENext){
        int iDataCur = pIEpr->iDataCur;
        if( iDataCur<0 ) continue;
        if( sqlite3ExprCompare(0, pExpr, pIEpr->pExpr, iDataCur)==0 ) break;
      }
      if( pIEpr==0 ) break;
      if( (!(((pExpr)->flags&(0x1000000|0x2000000))==0)) ) break;
      for(i=0; i<pSrcList->nSrc; i++){
         if( pSrcList->a[0].iCursor==pIEpr->iDataCur ) break;
      }
      if( i>=pSrcList->nSrc ) break;
      if( (pExpr->pAggInfo!=0) ) break;
      if( pParse->nErr ){ return 2; }





      memset(&tmp, 0, sizeof(tmp));
      tmp.op = 170;
      tmp.iTable = pIEpr->iIdxCur;
      tmp.iColumn = pIEpr->iIdxCol;
      findOrCreateAggInfoColumn(pParse, pAggInfo, &tmp);
      if( pParse->nErr ){ return 2; }
      ((void) (0));
      ((void) (0));
      pAggInfo->aCol[tmp.iAgg].pCExpr = pExpr;
      pExpr->pAggInfo = pAggInfo;
      pExpr->iAgg = tmp.iAgg;
      return 1;
    }
    case 179:
    case 170:
    case 168: {
                                          ;
                                      ;
                                           ;


      if( (pSrcList!=0) ){
        SrcItem *pItem = pSrcList->a;
        for(i=0; i<pSrcList->nSrc; i++, pItem++){
          ((void) (0));
          if( pExpr->iTable==pItem->iCursor ){
            findOrCreateAggInfoColumn(pParse, pAggInfo, pExpr);
            break;
          }
        }
      }
      return 0;
    }
    case 169: {
      if( (pNC->ncFlags & 0x020000)==0
       && pWalker->walkerDepth==pExpr->op2
       && pExpr->pAggInfo==0
      ){



        struct AggInfo_func *pItem = pAggInfo->aFunc;
        int mxTerm = pParse->db->aLimit[2];
        ((void) (0));
        for(i=0; i<pAggInfo->nFunc; i++, pItem++){
          if( (pItem->pFExpr==pExpr) ) break;
          if( sqlite3ExprCompare(0, pItem->pFExpr, pExpr, -1)==0 ){
            break;
          }
        }
        if( i>mxTerm ){
          sqlite3ErrorMsg(pParse, "more than %d aggregate terms", mxTerm);
          i = mxTerm;
          ((void) (0));
        }else if( i>=pAggInfo->nFunc ){


          u8 enc = ((pParse->db)->enc);
          i = addAggInfoFunc(pParse->db, pAggInfo);
          if( i>=0 ){
            int nArg;
            ((void) (0));
            pItem = &pAggInfo->aFunc[i];
            pItem->pFExpr = pExpr;
            ((void) (0));
            nArg = pExpr->x.pList ? pExpr->x.pList->nExpr : 0;
            pItem->pFunc = sqlite3FindFunction(pParse->db,
                                         pExpr->u.zToken, nArg, enc, 0);
            ((void) (0));
            if( pExpr->pLeft
             && (pItem->pFunc->funcFlags & 0x0020)==0
            ){


              ExprList *pOBList;
              ((void) (0));
              ((void) (0));
              ((void) (0));
              pItem->iOBTab = pParse->nTab++;
              pOBList = pExpr->pLeft->x.pList;
              ((void) (0));
              ((void) (0));
              if( pOBList->nExpr==1
               && nArg==1
               && sqlite3ExprCompare(0,pOBList->a[0].pExpr,
                               pExpr->x.pList->a[0].pExpr,0)==0
              ){
                pItem->bOBPayload = 0;
                pItem->bOBUnique = (((pExpr)->flags&(u32)(0x000004))!=0);
              }else{
                pItem->bOBPayload = 1;
              }
              pItem->bUseSubtype =
                    (pItem->pFunc->funcFlags & 0x000100000)!=0;
            }else{
              pItem->iOBTab = -1;
            }
            if( (((pExpr)->flags&(u32)(0x000004))!=0) && !pItem->bOBUnique ){
              pItem->iDistinct = pParse->nTab++;
            }else{
              pItem->iDistinct = -1;
            }
          }
        }


        ((void) (0));
                                              ;
        ((void) (0));
        pExpr->iAgg = (i16)i;
        pExpr->pAggInfo = pAggInfo;
        return 1;
      }else{
        return 0;
      }
    }
  }
  return 0;
}
# 118954 "c_tests/sqlite3.c"
static void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){
  Walker w;
  w.xExprCallback = analyzeAggregate;
  w.xSelectCallback = sqlite3WalkerDepthIncrease;
  w.xSelectCallback2 = sqlite3WalkerDepthDecrease;
  w.walkerDepth = 0;
  w.u.pNC = pNC;
  w.pParse = 0;
  ((void) (0));
  sqlite3WalkExpr(&w, pExpr);
}







static void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){
  struct ExprList_item *pItem;
  int i;
  if( pList ){
    for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){
      sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);
    }
  }
}




static int sqlite3GetTempReg(Parse *pParse){
  if( pParse->nTempReg==0 ){
    return ++pParse->nMem;
  }
  return pParse->aTempReg[--pParse->nTempReg];
}





static void sqlite3ReleaseTempReg(Parse *pParse, int iReg){
  if( iReg ){
                                                      ;
    if( pParse->nTempReg<((int)(sizeof(pParse->aTempReg)/sizeof(pParse->aTempReg[0]))) ){
      pParse->aTempReg[pParse->nTempReg++] = iReg;
    }
  }
}




static int sqlite3GetTempRange(Parse *pParse, int nReg){
  int i, n;
  if( nReg==1 ) return sqlite3GetTempReg(pParse);
  i = pParse->iRangeReg;
  n = pParse->nRangeReg;
  if( nReg<=n ){
    pParse->iRangeReg += nReg;
    pParse->nRangeReg -= nReg;
  }else{
    i = pParse->nMem+1;
    pParse->nMem += nReg;
  }
  return i;
}
static void sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){
  if( nReg==1 ){
    sqlite3ReleaseTempReg(pParse, iReg);
    return;
  }
                                                       ;
  if( nReg>pParse->nRangeReg ){
    pParse->nRangeReg = nReg;
    pParse->iRangeReg = iReg;
  }
}
# 119042 "c_tests/sqlite3.c"
static void sqlite3ClearTempRegCache(Parse *pParse){
  pParse->nTempReg = 0;
  pParse->nRangeReg = 0;
}





static void sqlite3TouchRegister(Parse *pParse, int iReg){
  if( pParse->nMem<iReg ) pParse->nMem = iReg;
}
# 119141 "c_tests/sqlite3.c"
static int isAlterableTable(Parse *pParse, Table *pTab){
  if( 0==sqlite3_strnicmp(pTab->zName, "sqlite_", 7)

   || (pTab->tabFlags & 0x00008000)!=0
   || ( (pTab->tabFlags & 0x00001000)!=0
        && sqlite3ReadOnlyShadowTables(pParse->db)
   )

  ){
    sqlite3ErrorMsg(pParse, "table %s may not be altered", pTab->zName);
    return 1;
  }
  return 0;
}
# 119163 "c_tests/sqlite3.c"
static void renameTestSchema(
  Parse *pParse,
  const char *zDb,
  int bTemp,
  const char *zWhen,
  int bNoDQS
){
  pParse->colNamesSet = 1;
  sqlite3NestedParse(pParse,
      "SELECT 1 "
      "FROM \"%w\"." "sqlite_master" " "
      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
      " AND sql NOT LIKE 'create virtual%%'"
      " AND sqlite_rename_test(%Q, sql, type, name, %d, %Q, %d)=NULL ",
      zDb,
      zDb, bTemp, zWhen, bNoDQS
  );

  if( bTemp==0 ){
    sqlite3NestedParse(pParse,
        "SELECT 1 "
        "FROM temp." "sqlite_master" " "
        "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
        " AND sql NOT LIKE 'create virtual%%'"
        " AND sqlite_rename_test(%Q, sql, type, name, 1, %Q, %d)=NULL ",
        zDb, zWhen, bNoDQS
    );
  }
}
# 119200 "c_tests/sqlite3.c"
static void renameFixQuotes(Parse *pParse, const char *zDb, int bTemp){
  sqlite3NestedParse(pParse,
      "UPDATE \"%w\"." "sqlite_master"
      " SET sql = sqlite_rename_quotefix(%Q, sql)"
      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
      " AND sql NOT LIKE 'create virtual%%'" , zDb, zDb
  );
  if( bTemp==0 ){
    sqlite3NestedParse(pParse,
      "UPDATE temp." "sqlite_master"
      " SET sql = sqlite_rename_quotefix('temp', sql)"
      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
      " AND sql NOT LIKE 'create virtual%%'"
    );
  }
}





static void renameReloadSchema(Parse *pParse, int iDb, u16 p5){
  Vdbe *v = pParse->pVdbe;
  if( v ){
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, iDb, 0, p5);
    if( iDb!=1 ) sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, 1, 0, p5);
  }
}





static void sqlite3AlterRenameTable(
  Parse *pParse,
  SrcList *pSrc,
  Token *pName
){
  int iDb;
  char *zDb;
  Table *pTab;
  char *zName = 0;
  sqlite3 *db = pParse->db;
  int nTabName;
  const char *zTabName;
  Vdbe *v;
  VTable *pVTab = 0;

  if( (db->mallocFailed) ) goto exit_rename_table;
  ((void) (0));
  ((void) (0));

  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
  if( !pTab ) goto exit_rename_table;
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  zDb = db->aDb[iDb].zDbSName;


  zName = sqlite3NameFromToken(db, pName);
  if( !zName ) goto exit_rename_table;




  if( sqlite3FindTable(db, zName, zDb)
   || sqlite3FindIndex(db, zName, zDb)
   || sqlite3IsShadowTableOf(db, pTab, zName)
  ){
    sqlite3ErrorMsg(pParse,
        "there is already another table or index with this name: %s", zName);
    goto exit_rename_table;
  }




  if( 0!=isAlterableTable(pParse, pTab) ){
    goto exit_rename_table;
  }
  if( 0!=sqlite3CheckObjectName(pParse,zName,"table",zName) ){
    goto exit_rename_table;
  }


  if( ((pTab)->eTabType==2) ){
    sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab->zName);
    goto exit_rename_table;
  }




  if( sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0) ){
    goto exit_rename_table;
  }



  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto exit_rename_table;
  }
  if( ((pTab)->eTabType==1) ){
    pVTab = sqlite3GetVTable(db, pTab);
    if( pVTab->pVtab->pModule->xRename==0 ){
      pVTab = 0;
    }
  }






  v = sqlite3GetVdbe(pParse);
  if( v==0 ){
    goto exit_rename_table;
  }
  sqlite3MayAbort(pParse);


  zTabName = pTab->zName;
  nTabName = sqlite3Utf8CharLen(zTabName, -1);



  sqlite3NestedParse(pParse,
      "UPDATE \"%w\"." "sqlite_master" " SET "
      "sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) "
      "WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)"
      "AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
      , zDb, zDb, zTabName, zName, (iDb==1), zTabName
  );



  sqlite3NestedParse(pParse,
      "UPDATE %Q." "sqlite_master" " SET "
          "tbl_name = %Q, "
          "name = CASE "
            "WHEN type='table' THEN %Q "
            "WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X' "
            "     AND type='index' THEN "
             "'sqlite_autoindex_' || %Q || substr(name,%d+18) "
            "ELSE name END "
      "WHERE tbl_name=%Q COLLATE nocase AND "
          "(type='table' OR type='index' OR type='trigger');",
      zDb,
      zName, zName, zName,
      nTabName, zTabName
  );





  if( sqlite3FindTable(db, "sqlite_sequence", zDb) ){
    sqlite3NestedParse(pParse,
        "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q",
        zDb, zName, pTab->zName);
  }





  if( iDb!=1 ){
    sqlite3NestedParse(pParse,
        "UPDATE sqlite_temp_schema SET "
            "sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), "
            "tbl_name = "
              "CASE WHEN tbl_name=%Q COLLATE nocase AND "
              "  sqlite_rename_test(%Q, sql, type, name, 1, 'after rename', 0) "
              "THEN %Q ELSE tbl_name END "
            "WHERE type IN ('view', 'trigger')"
        , zDb, zTabName, zName, zTabName, zDb, zName);
  }







  if( pVTab ){
    int i = ++pParse->nMem;
    sqlite3VdbeLoadString(v, i, zName);
    sqlite3VdbeAddOp4(v, 178, i, 0, 0,(const char*)pVTab, (-11));
  }


  renameReloadSchema(pParse, iDb, 0x0001);
  renameTestSchema(pParse, zDb, iDb==1, "after rename", 0);

exit_rename_table:
  sqlite3SrcListDelete(db, pSrc);
  sqlite3DbFree(db, zName);
}





static void sqlite3ErrorIfNotEmpty(
  Parse *pParse,
  const char *zDb,
  const char *zTab,
  const char *zErr
){
  sqlite3NestedParse(pParse,
     "SELECT raise(ABORT,%Q) FROM \"%w\".\"%w\"",
     zErr, zDb, zTab
  );
}
# 119423 "c_tests/sqlite3.c"
static void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){
  Table *pNew;
  Table *pTab;
  int iDb;
  const char *zDb;
  const char *zTab;
  char *zCol;
  Column *pCol;
  Expr *pDflt;
  sqlite3 *db;
  Vdbe *v;
  int r1;

  db = pParse->db;
  ((void) (0));
  if( pParse->nErr ) return;
  ((void) (0));
  pNew = pParse->pNewTable;
  ((void) (0));

  ((void) (0));
  iDb = sqlite3SchemaToIndex(db, pNew->pSchema);
  zDb = db->aDb[iDb].zDbSName;
  zTab = &pNew->zName[16];
  pCol = &pNew->aCol[pNew->nCol-1];
  pDflt = sqlite3ColumnExpr(pNew, pCol);
  pTab = sqlite3FindTable(db, zTab, zDb);
  ((void) (0));



  if( sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0) ){
    return;
  }







  if( pCol->colFlags & 0x0001 ){
    sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");
    return;
  }
  if( pNew->pIndex ){
    sqlite3ErrorMsg(pParse,
         "Cannot add a UNIQUE column");
    return;
  }
  if( (pCol->colFlags & 0x0060)==0 ){




    ((void) (0));
    if( pDflt && pDflt->pLeft->op==122 ){
      pDflt = 0;
    }
    ((void) (0));
    if( (db->flags&0x00004000) && pNew->u.tab.pFKey && pDflt ){
      sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,
          "Cannot add a REFERENCES column with non-NULL default value");
    }
    if( pCol->notNull && !pDflt ){
      sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,
          "Cannot add a NOT NULL column with default value NULL");
    }





    if( pDflt ){
      sqlite3_value *pVal = 0;
      int rc;
      rc = sqlite3ValueFromExpr(db, pDflt, 1, 0x41, &pVal);
      ((void) (0));
      if( rc!=0 ){
        ((void) (0));
        return;
      }
      if( !pVal ){
        sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,
           "Cannot add a column with non-constant default");
      }
      sqlite3ValueFree(pVal);
    }
  }else if( pCol->colFlags & 0x0040 ){
    sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "cannot add a STORED column");
  }



  zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n);
  if( zCol ){
    char *zEnd = &zCol[pColDef->n-1];
    while( zEnd>zCol && (*zEnd==';' || (sqlite3CtypeMap[(unsigned char)(*zEnd)]&0x01)) ){
      *zEnd-- = '\0';
    }


    ((void) (0));
    ((void) (0));
    sqlite3NestedParse(pParse,
        "UPDATE \"%w\"." "sqlite_master" " SET "
          "sql = printf('%%.%ds, ',sql) || %Q"
          " || substr(sql,1+length(printf('%%.%ds',sql))) "
        "WHERE type = 'table' AND name = %Q",
      zDb, pNew->u.tab.addColOffset, zCol, pNew->u.tab.addColOffset,
      zTab
    );
    sqlite3DbFree(db, zCol);
  }

  v = sqlite3GetVdbe(pParse);
  if( v ){




    r1 = sqlite3GetTempReg(pParse);
    sqlite3VdbeAddOp3(v, 100, iDb, r1, 2);
    sqlite3VdbeUsesBtree(v, iDb);
    sqlite3VdbeAddOp2(v, 87, r1, -2);
    sqlite3VdbeAddOp2(v, 60, r1, sqlite3VdbeCurrentAddr(v)+2);
                   ;
    sqlite3VdbeAddOp3(v, 101, iDb, 2, 3);
    sqlite3ReleaseTempReg(pParse, r1);


    renameReloadSchema(pParse, iDb, 0x0003);


    if( pNew->pCheck!=0
     || (pCol->notNull && (pCol->colFlags & 0x0060)!=0)
     || (pTab->tabFlags & 0x00010000)!=0
    ){
      sqlite3NestedParse(pParse,
        "SELECT CASE WHEN quick_check GLOB 'CHECK*'"
        " THEN raise(ABORT,'CHECK constraint failed')"
        " WHEN quick_check GLOB 'non-* value in*'"
        " THEN raise(ABORT,'type mismatch on DEFAULT')"
        " ELSE raise(ABORT,'NOT NULL constraint failed')"
        " END"
        "  FROM pragma_quick_check(%Q,%Q)"
        " WHERE quick_check GLOB 'CHECK*'"
        " OR quick_check GLOB 'NULL*'"
        " OR quick_check GLOB 'non-* value in*'",
        zTab, zDb
      );
    }
  }
}
# 119593 "c_tests/sqlite3.c"
static void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){
  Table *pNew;
  Table *pTab;
  int iDb;
  int i;
  int nAlloc;
  sqlite3 *db = pParse->db;


  ((void) (0));
  ((void) (0));
  if( db->mallocFailed ) goto exit_begin_add_column;
  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
  if( !pTab ) goto exit_begin_add_column;


  if( ((pTab)->eTabType==1) ){
    sqlite3ErrorMsg(pParse, "virtual tables may not be altered");
    goto exit_begin_add_column;
  }



  if( ((pTab)->eTabType==2) ){
    sqlite3ErrorMsg(pParse, "Cannot add a column to a view");
    goto exit_begin_add_column;
  }
  if( 0!=isAlterableTable(pParse, pTab) ){
    goto exit_begin_add_column;
  }

  sqlite3MayAbort(pParse);
  ((void) (0));
  ((void) (0));
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
# 119636 "c_tests/sqlite3.c"
  pNew = (Table*)sqlite3DbMallocZero(db, sizeof(Table));
  if( !pNew ) goto exit_begin_add_column;
  pParse->pNewTable = pNew;
  pNew->nTabRef = 1;
  pNew->nCol = pTab->nCol;
  ((void) (0));
  nAlloc = (((pNew->nCol-1)/8)*8)+8;
  ((void) (0));
  pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*(u32)nAlloc);
  pNew->zName = sqlite3MPrintf(db, "sqlite_altertab_%s", pTab->zName);
  if( !pNew->aCol || !pNew->zName ){
    ((void) (0));
    goto exit_begin_add_column;
  }
  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*(size_t)pNew->nCol);
  for(i=0; i<pNew->nCol; i++){
    Column *pCol = &pNew->aCol[i];
    pCol->zCnName = sqlite3DbStrDup(db, pCol->zCnName);
    pCol->hName = sqlite3StrIHash(pCol->zCnName);
  }
  ((void) (0));
  pNew->u.tab.pDfltList = sqlite3ExprListDup(db, pTab->u.tab.pDfltList, 0);
  pNew->pSchema = db->aDb[iDb].pSchema;
  pNew->u.tab.addColOffset = pTab->u.tab.addColOffset;
  ((void) (0));

exit_begin_add_column:
  sqlite3SrcListDelete(db, pSrc);
  return;
}
# 119676 "c_tests/sqlite3.c"
static int isRealTable(Parse *pParse, Table *pTab, int bDrop){
  const char *zType = 0;

  if( ((pTab)->eTabType==2) ){
    zType = "view";
  }


  if( ((pTab)->eTabType==1) ){
    zType = "virtual table";
  }

  if( zType ){
    sqlite3ErrorMsg(pParse, "cannot %s %s \"%s\"",
        (bDrop ? "drop column from" : "rename columns of"),
        zType, pTab->zName
    );
    return 1;
  }
  return 0;
}
# 119706 "c_tests/sqlite3.c"
static void sqlite3AlterRenameColumn(
  Parse *pParse,
  SrcList *pSrc,
  Token *pOld,
  Token *pNew
){
  sqlite3 *db = pParse->db;
  Table *pTab;
  int iCol;
  char *zOld = 0;
  char *zNew = 0;
  const char *zDb;
  int iSchema;
  int bQuote;


  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
  if( !pTab ) goto exit_rename_column;


  if( 0!=isAlterableTable(pParse, pTab) ) goto exit_rename_column;
  if( 0!=isRealTable(pParse, pTab, 0) ) goto exit_rename_column;


  iSchema = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void) (0));
  zDb = db->aDb[iSchema].zDbSName;



  if( sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0) ){
    goto exit_rename_column;
  }




  zOld = sqlite3NameFromToken(db, pOld);
  if( !zOld ) goto exit_rename_column;
  iCol = sqlite3ColumnIndex(pTab, zOld);
  if( iCol<0 ){
    sqlite3ErrorMsg(pParse, "no such column: \"%T\"", pOld);
    goto exit_rename_column;
  }


  renameTestSchema(pParse, zDb, iSchema==1, "", 0);
  renameFixQuotes(pParse, zDb, iSchema==1);





  sqlite3MayAbort(pParse);
  zNew = sqlite3NameFromToken(db, pNew);
  if( !zNew ) goto exit_rename_column;
  ((void) (0));
  bQuote = (sqlite3CtypeMap[(unsigned char)(pNew->z[0])]&0x80);
  sqlite3NestedParse(pParse,
      "UPDATE \"%w\"." "sqlite_master" " SET "
      "sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) "
      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' "
      " AND (type != 'index' OR tbl_name = %Q)",
      zDb,
      zDb, pTab->zName, iCol, zNew, bQuote, iSchema==1,
      pTab->zName
  );

  sqlite3NestedParse(pParse,
      "UPDATE temp." "sqlite_master" " SET "
      "sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) "
      "WHERE type IN ('trigger', 'view')",
      zDb, pTab->zName, iCol, zNew, bQuote
  );


  renameReloadSchema(pParse, iSchema, 0x0001);
  renameTestSchema(pParse, zDb, iSchema==1, "after rename", 1);

 exit_rename_column:
  sqlite3SrcListDelete(db, pSrc);
  sqlite3DbFree(db, zOld);
  sqlite3DbFree(db, zNew);
  return;
}
# 119809 "c_tests/sqlite3.c"
struct RenameToken {
  const void *p;
  Token t;
  RenameToken *pNext;
};





typedef struct RenameCtx RenameCtx;
struct RenameCtx {
  RenameToken *pList;
  int nList;
  int iCol;
  Table *pTab;
  const char *zOld;
};
# 119883 "c_tests/sqlite3.c"
static const void *sqlite3RenameTokenMap(
  Parse *pParse,
  const void *pPtr,
  const Token *pToken
){
  RenameToken *pNew;
  ((void) (0));
                                   ;
  if( (pParse->eParseMode!=3) ){
    pNew = sqlite3DbMallocZero(pParse->db, sizeof(RenameToken));
    if( pNew ){
      pNew->p = pPtr;
      pNew->t = *pToken;
      pNew->pNext = pParse->pRename;
      pParse->pRename = pNew;
    }
  }

  return pPtr;
}






static void sqlite3RenameTokenRemap(Parse *pParse, const void *pTo, const void *pFrom){
  RenameToken *p;
                                  ;
  for(p=pParse->pRename; p; p=p->pNext){
    if( p->p==pFrom ){
      p->p = pTo;
      break;
    }
  }
}




static int renameUnmapExprCb(Walker *pWalker, Expr *pExpr){
  Parse *pParse = pWalker->pParse;
  sqlite3RenameTokenRemap(pParse, 0, (const void*)pExpr);
  if( (((pExpr)->flags&(0x1000000|0x2000000))==0) ){
    sqlite3RenameTokenRemap(pParse, 0, (const void*)&pExpr->y.pTab);
  }
  return 0;
}





static void renameWalkWith(Walker *pWalker, Select *pSelect){
  With *pWith = pSelect->pWith;
  if( pWith ){
    Parse *pParse = pWalker->pParse;
    int i;
    With *pCopy = 0;
    ((void) (0));
    if( (pWith->a[0].pSelect->selFlags & 0x0000040)==0 ){





      pCopy = sqlite3WithDup(pParse->db, pWith);
      pCopy = sqlite3WithPush(pParse, pCopy, 1);
    }
    for(i=0; i<pWith->nCte; i++){
      Select *p = pWith->a[i].pSelect;
      NameContext sNC;
      memset(&sNC, 0, sizeof(sNC));
      sNC.pParse = pParse;
      if( pCopy ) sqlite3SelectPrep(sNC.pParse, p, &sNC);
      if( sNC.pParse->db->mallocFailed ) return;
      sqlite3WalkSelect(pWalker, p);
      sqlite3RenameExprlistUnmap(pParse, pWith->a[i].pCols);
    }
    if( pCopy && pParse->pWith==pCopy ){
      pParse->pWith = pCopy->pOuter;
    }
  }
}




static void unmapColumnIdlistNames(
  Parse *pParse,
  const IdList *pIdList
){
  int ii;
  ((void) (0));
  for(ii=0; ii<pIdList->nId; ii++){
    sqlite3RenameTokenRemap(pParse, 0, (const void*)pIdList->a[ii].zName);
  }
}




static int renameUnmapSelectCb(Walker *pWalker, Select *p){
  Parse *pParse = pWalker->pParse;
  int i;
  if( pParse->nErr ) return 2;
                                   ;
                                      ;
  if( p->selFlags & (0x0200000|0x4000000) ){
    return 1;
  }
  if( (p->pEList) ){
    ExprList *pList = p->pEList;
    for(i=0; i<pList->nExpr; i++){
      if( pList->a[i].zEName && pList->a[i].fg.eEName==0 ){
        sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zEName);
      }
    }
  }
  if( (p->pSrc) ){
    SrcList *pSrc = p->pSrc;
    for(i=0; i<pSrc->nSrc; i++){
      sqlite3RenameTokenRemap(pParse, 0, (void*)pSrc->a[i].zName);
      if( pSrc->a[i].fg.isUsing==0 ){
        sqlite3WalkExpr(pWalker, pSrc->a[i].u3.pOn);
      }else{
        unmapColumnIdlistNames(pParse, pSrc->a[i].u3.pUsing);
      }
    }
  }

  renameWalkWith(pWalker, p);
  return 0;
}




static void sqlite3RenameExprUnmap(Parse *pParse, Expr *pExpr){
  u8 eMode = pParse->eParseMode;
  Walker sWalker;
  memset(&sWalker, 0, sizeof(Walker));
  sWalker.pParse = pParse;
  sWalker.xExprCallback = renameUnmapExprCb;
  sWalker.xSelectCallback = renameUnmapSelectCb;
  pParse->eParseMode = 3;
  sqlite3WalkExpr(&sWalker, pExpr);
  pParse->eParseMode = eMode;
}





static void sqlite3RenameExprlistUnmap(Parse *pParse, ExprList *pEList){
  if( pEList ){
    int i;
    Walker sWalker;
    memset(&sWalker, 0, sizeof(Walker));
    sWalker.pParse = pParse;
    sWalker.xExprCallback = renameUnmapExprCb;
    sqlite3WalkExprList(&sWalker, pEList);
    for(i=0; i<pEList->nExpr; i++){
      if( (pEList->a[i].fg.eEName==0) ){
        sqlite3RenameTokenRemap(pParse, 0, (void*)pEList->a[i].zEName);
      }
    }
  }
}




static void renameTokenFree(sqlite3 *db, RenameToken *pToken){
  RenameToken *pNext;
  RenameToken *p;
  for(p=pToken; p; p=pNext){
    pNext = p->pNext;
    sqlite3DbFree(db, p);
  }
}
# 120074 "c_tests/sqlite3.c"
static RenameToken *renameTokenFind(
  Parse *pParse,
  struct RenameCtx *pCtx,
  const void *pPtr
){
  RenameToken **pp;
  if( (pPtr==0) ){
    return 0;
  }
  for(pp=&pParse->pRename; (*pp); pp=&(*pp)->pNext){
    if( (*pp)->p==pPtr ){
      RenameToken *pToken = *pp;
      if( pCtx ){
        *pp = pToken->pNext;
        pToken->pNext = pCtx->pList;
        pCtx->pList = pToken;
        pCtx->nList++;
      }
      return pToken;
    }
  }
  return 0;
}






static int renameColumnSelectCb(Walker *pWalker, Select *p){
  if( p->selFlags & (0x0200000|0x4000000) ){
                                     ;
                                        ;
    return 1;
  }
  renameWalkWith(pWalker, p);
  return 0;
}
# 120122 "c_tests/sqlite3.c"
static int renameColumnExprCb(Walker *pWalker, Expr *pExpr){
  RenameCtx *p = pWalker->u.pRename;
  if( pExpr->op==78
   && pExpr->iColumn==p->iCol
   && pWalker->pParse->pTriggerTab==p->pTab
  ){
    renameTokenFind(pWalker->pParse, p, (void*)pExpr);
  }else if( pExpr->op==168
   && pExpr->iColumn==p->iCol
   && ((((pExpr)->flags&(0x1000000|0x2000000))==0))
   && p->pTab==pExpr->y.pTab
  ){
    renameTokenFind(pWalker->pParse, p, (void*)pExpr);
  }
  return 0;
}
# 120148 "c_tests/sqlite3.c"
static RenameToken *renameColumnTokenNext(RenameCtx *pCtx){
  RenameToken *pBest = pCtx->pList;
  RenameToken *pToken;
  RenameToken **pp;

  for(pToken=pBest->pNext; pToken; pToken=pToken->pNext){
    if( pToken->t.z>pBest->t.z ) pBest = pToken;
  }
  for(pp=&pCtx->pList; *pp!=pBest; pp=&(*pp)->pNext);
  *pp = pBest->pNext;

  return pBest;
}
# 120169 "c_tests/sqlite3.c"
static void renameColumnParseError(
  sqlite3_context *pCtx,
  const char *zWhen,
  sqlite3_value *pType,
  sqlite3_value *pObject,
  Parse *pParse
){
  const char *zT = (const char*)sqlite3_value_text(pType);
  const char *zN = (const char*)sqlite3_value_text(pObject);
  char *zErr;

  zErr = sqlite3MPrintf(pParse->db, "error in %s %s%s%s: %s",
      zT, zN, (zWhen[0] ? " " : ""), zWhen,
      pParse->zErrMsg
  );
  sqlite3_result_error(pCtx, zErr, -1);
  sqlite3DbFree(pParse->db, zErr);
}







static void renameColumnElistNames(
  Parse *pParse,
  RenameCtx *pCtx,
  const ExprList *pEList,
  const char *zOld
){
  if( pEList ){
    int i;
    for(i=0; i<pEList->nExpr; i++){
      const char *zName = pEList->a[i].zEName;
      if( (pEList->a[i].fg.eEName==0)
       && (zName!=0)
       && 0==sqlite3_stricmp(zName, zOld)
      ){
        renameTokenFind(pParse, pCtx, (const void*)zName);
      }
    }
  }
}






static void renameColumnIdlistNames(
  Parse *pParse,
  RenameCtx *pCtx,
  const IdList *pIdList,
  const char *zOld
){
  if( pIdList ){
    int i;
    for(i=0; i<pIdList->nId; i++){
      const char *zName = pIdList->a[i].zName;
      if( 0==sqlite3_stricmp(zName, zOld) ){
        renameTokenFind(pParse, pCtx, (const void*)zName);
      }
    }
  }
}






static int renameParseSql(
  Parse *p,
  const char *zDb,
  sqlite3 *db,
  const char *zSql,
  int bTemp
){
  int rc;
  u64 flags;

  sqlite3ParseObjectInit(p, db);
  if( zSql==0 ){
    return 7;
  }
  if( sqlite3_strnicmp(zSql,"CREATE ",7)!=0 ){
    return sqlite3CorruptError(120256);
  }
  if( bTemp ){
    db->init.iDb = 1;
  }else{
    int iDb = sqlite3FindDbName(db, zDb);
    ((void) (0));
    db->init.iDb = (u8)iDb;
  }
  p->eParseMode = 2;
  p->db = db;
  p->nQueryLoop = 1;
  flags = db->flags;
                                                                        ;
  db->flags |= ((u64)(0x00040)<<32);
  rc = sqlite3RunParser(p, zSql);
  db->flags = flags;
  if( db->mallocFailed ) rc = 7;
  if( rc==0
   && (p->pNewTable==0 && p->pNewIndex==0 && p->pNewTrigger==0)
  ){
    rc = sqlite3CorruptError(120277);
  }
# 120292 "c_tests/sqlite3.c"
  db->init.iDb = 0;
  return rc;
}
# 120305 "c_tests/sqlite3.c"
static int renameEditSql(
  sqlite3_context *pCtx,
  RenameCtx *pRename,
  const char *zSql,
  const char *zNew,
  int bQuote
){
  i64 nNew = sqlite3Strlen30(zNew);
  i64 nSql = sqlite3Strlen30(zSql);
  sqlite3 *db = sqlite3_context_db_handle(pCtx);
  int rc = 0;
  char *zQuot = 0;
  char *zOut;
  i64 nQuot = 0;
  char *zBuf1 = 0;
  char *zBuf2 = 0;

  if( zNew ){





    zQuot = sqlite3MPrintf(db, "\"%w\" ", zNew);
    if( zQuot==0 ){
      return 7;
    }else{
      nQuot = sqlite3Strlen30(zQuot)-1;
    }

    ((void) (0));
    zOut = sqlite3DbMallocZero(db, (u64)nSql + pRename->nList*(u64)nQuot + 1);
  }else{
    ((void) (0));
    zOut = (char*)sqlite3DbMallocZero(db, (2*(u64)nSql + 1) * 3);
    if( zOut ){
      zBuf1 = &zOut[nSql*2+1];
      zBuf2 = &zOut[nSql*4+2];
    }
  }





  if( zOut ){
    i64 nOut = nSql;
    ((void) (0));
    memcpy(zOut, zSql, (size_t)nSql);
    while( pRename->pList ){
      int iOff;
      i64 nReplace;
      const char *zReplace;
      RenameToken *pBest = renameColumnTokenNext(pRename);

      if( zNew ){
        if( bQuote==0 && sqlite3IsIdChar(*(u8*)pBest->t.z) ){
          nReplace = nNew;
          zReplace = zNew;
        }else{
          nReplace = nQuot;
          zReplace = zQuot;
          if( pBest->t.z[pBest->t.n]=='"' ) nReplace++;
        }
      }else{






        memcpy(zBuf1, pBest->t.z, pBest->t.n);
        zBuf1[pBest->t.n] = 0;
        sqlite3Dequote(zBuf1);
        ((void) (0));
        sqlite3_snprintf((int)(nSql*2), zBuf2, "%Q%s", zBuf1,
            pBest->t.z[pBest->t.n]=='\'' ? " " : ""
        );
        zReplace = zBuf2;
        nReplace = sqlite3Strlen30(zReplace);
      }

      iOff = (int)(pBest->t.z - zSql);
      if( pBest->t.n!=nReplace ){
        memmove(&zOut[iOff + nReplace], &zOut[iOff + pBest->t.n],
            nOut - (iOff + pBest->t.n)
        );
        nOut += nReplace - pBest->t.n;
        zOut[nOut] = '\0';
      }
      memcpy(&zOut[iOff], zReplace, nReplace);
      sqlite3DbFree(db, pBest);
    }

    sqlite3_result_text(pCtx, zOut, -1, ((sqlite3_destructor_type)-1));
    sqlite3DbFree(db, zOut);
  }else{
    rc = 7;
  }

  sqlite3_free(zQuot);
  return rc;
}




static void renameSetENames(ExprList *pEList, int val){
  ((void) (0));
  if( pEList ){
    int i;
    for(i=0; i<pEList->nExpr; i++){
      ((void) (0));
      pEList->a[i].fg.eEName = val&0x3;
    }
  }
}







static int renameResolveTrigger(Parse *pParse){
  sqlite3 *db = pParse->db;
  Trigger *pNew = pParse->pNewTrigger;
  TriggerStep *pStep;
  NameContext sNC;
  int rc = 0;

  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  ((void) (0));
  pParse->pTriggerTab = sqlite3FindTable(db, pNew->table,
      db->aDb[sqlite3SchemaToIndex(db, pNew->pTabSchema)].zDbSName
  );
  pParse->eTriggerOp = pNew->op;


  if( (pParse->pTriggerTab) ){
    rc = sqlite3ViewGetColumnNames(pParse, pParse->pTriggerTab)!=0;
  }


  if( rc==0 && pNew->pWhen ){
    rc = sqlite3ResolveExprNames(&sNC, pNew->pWhen);
  }

  for(pStep=pNew->step_list; rc==0 && pStep; pStep=pStep->pNext){
    if( pStep->pSelect ){
      sqlite3SelectPrep(pParse, pStep->pSelect, &sNC);
      if( pParse->nErr ) rc = pParse->rc;
    }
    if( rc==0 && pStep->zTarget ){
      SrcList *pSrc = sqlite3TriggerStepSrc(pParse, pStep);
      if( pSrc ){
        Select *pSel = sqlite3SelectNew(
            pParse, pStep->pExprList, pSrc, 0, 0, 0, 0, 0, 0
        );
        if( pSel==0 ){
          pStep->pExprList = 0;
          pSrc = 0;
          rc = 7;
        }else{
# 120478 "c_tests/sqlite3.c"
          renameSetENames(pStep->pExprList, 1);
          sqlite3SelectPrep(pParse, pSel, 0);
          renameSetENames(pStep->pExprList, 0);
          rc = pParse->nErr ? 1 : 0;
          ((void) (0));
          ((void) (0));
          if( pStep->pExprList ) pSel->pEList = 0;
          pSel->pSrc = 0;
          sqlite3SelectDelete(db, pSel);
        }
        if( pStep->pFrom ){
          int i;
          for(i=0; i<pStep->pFrom->nSrc && rc==0; i++){
            SrcItem *p = &pStep->pFrom->a[i];
            if( p->fg.isSubquery ){
              ((void) (0));
              sqlite3SelectPrep(pParse, p->u4.pSubq->pSelect, 0);
            }
          }
        }

        if( db->mallocFailed ){
          rc = 7;
        }
        sNC.pSrcList = pSrc;
        if( rc==0 && pStep->pWhere ){
          rc = sqlite3ResolveExprNames(&sNC, pStep->pWhere);
        }
        if( rc==0 ){
          rc = sqlite3ResolveExprListNames(&sNC, pStep->pExprList);
        }
        ((void) (0));
        if( pStep->pUpsert && rc==0 ){
          Upsert *pUpsert = pStep->pUpsert;
          pUpsert->pUpsertSrc = pSrc;
          sNC.uNC.pUpsert = pUpsert;
          sNC.ncFlags = 0x000200;
          rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);
          if( rc==0 ){
            ExprList *pUpsertSet = pUpsert->pUpsertSet;
            rc = sqlite3ResolveExprListNames(&sNC, pUpsertSet);
          }
          if( rc==0 ){
            rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertWhere);
          }
          if( rc==0 ){
            rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);
          }
          sNC.ncFlags = 0;
        }
        sNC.pSrcList = 0;
        sqlite3SrcListDelete(db, pSrc);
      }else{
        rc = 7;
      }
    }
  }
  return rc;
}





static void renameWalkTrigger(Walker *pWalker, Trigger *pTrigger){
  TriggerStep *pStep;


  sqlite3WalkExpr(pWalker, pTrigger->pWhen);


  for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){
    sqlite3WalkSelect(pWalker, pStep->pSelect);
    sqlite3WalkExpr(pWalker, pStep->pWhere);
    sqlite3WalkExprList(pWalker, pStep->pExprList);
    if( pStep->pUpsert ){
      Upsert *pUpsert = pStep->pUpsert;
      sqlite3WalkExprList(pWalker, pUpsert->pUpsertTarget);
      sqlite3WalkExprList(pWalker, pUpsert->pUpsertSet);
      sqlite3WalkExpr(pWalker, pUpsert->pUpsertWhere);
      sqlite3WalkExpr(pWalker, pUpsert->pUpsertTargetWhere);
    }
    if( pStep->pFrom ){
      int i;
      SrcList *pFrom = pStep->pFrom;
      for(i=0; i<pFrom->nSrc; i++){
        if( pFrom->a[i].fg.isSubquery ){
          ((void) (0));
          sqlite3WalkSelect(pWalker, pFrom->a[i].u4.pSubq->pSelect);
        }
      }
    }
  }
}





static void renameParseCleanup(Parse *pParse){
  sqlite3 *db = pParse->db;
  Index *pIdx;
  if( pParse->pVdbe ){
    sqlite3VdbeFinalize(pParse->pVdbe);
  }
  sqlite3DeleteTable(db, pParse->pNewTable);
  while( (pIdx = pParse->pNewIndex)!=0 ){
    pParse->pNewIndex = pIdx->pNext;
    sqlite3FreeIndex(db, pIdx);
  }
  sqlite3DeleteTrigger(db, pParse->pNewTrigger);
  sqlite3DbFree(db, pParse->zErrMsg);
  renameTokenFree(db, pParse->pRename);
  sqlite3ParseObjectReset(pParse);
}
# 120618 "c_tests/sqlite3.c"
static void renameColumnFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  RenameCtx sCtx;
  const char *zSql = (const char*)sqlite3_value_text(argv[0]);
  const char *zDb = (const char*)sqlite3_value_text(argv[3]);
  const char *zTable = (const char*)sqlite3_value_text(argv[4]);
  int iCol = sqlite3_value_int(argv[5]);
  const char *zNew = (const char*)sqlite3_value_text(argv[6]);
  int bQuote = sqlite3_value_int(argv[7]);
  int bTemp = sqlite3_value_int(argv[8]);
  const char *zOld;
  int rc;
  Parse sParse;
  Walker sWalker;
  Index *pIdx;
  int i;
  Table *pTab;

  sqlite3_xauth xAuth = db->xAuth;


  (void)(NotUsed);
  if( zSql==0 ) return;
  if( zTable==0 ) return;
  if( zNew==0 ) return;
  if( iCol<0 ) return;
  sqlite3BtreeEnterAll(db);
  pTab = sqlite3FindTable(db, zTable, zDb);
  if( pTab==0 || iCol>=pTab->nCol ){
    sqlite3BtreeLeaveAll(db);
    return;
  }
  zOld = pTab->aCol[iCol].zCnName;
  memset(&sCtx, 0, sizeof(sCtx));
  sCtx.iCol = ((iCol==pTab->iPKey) ? -1 : iCol);


  db->xAuth = 0;

  rc = renameParseSql(&sParse, zDb, db, zSql, bTemp);


  memset(&sWalker, 0, sizeof(Walker));
  sWalker.pParse = &sParse;
  sWalker.xExprCallback = renameColumnExprCb;
  sWalker.xSelectCallback = renameColumnSelectCb;
  sWalker.u.pRename = &sCtx;

  sCtx.pTab = pTab;
  if( rc!=0 ) goto renameColumnFunc_done;
  if( sParse.pNewTable ){
    if( ((sParse.pNewTable)->eTabType==2) ){
      Select *pSelect = sParse.pNewTable->u.view.pSelect;
      pSelect->selFlags &= ~(u32)0x0200000;
      sParse.rc = 0;
      sqlite3SelectPrep(&sParse, pSelect, 0);
      rc = (db->mallocFailed ? 7 : sParse.rc);
      if( rc==0 ){
        sqlite3WalkSelect(&sWalker, pSelect);
      }
      if( rc!=0 ) goto renameColumnFunc_done;
    }else if( ((sParse.pNewTable)->eTabType==0) ){

      int bFKOnly = sqlite3_stricmp(zTable, sParse.pNewTable->zName);
      FKey *pFKey;
      sCtx.pTab = sParse.pNewTable;
      if( bFKOnly==0 ){
        if( iCol<sParse.pNewTable->nCol ){
          renameTokenFind(
              &sParse, &sCtx, (void*)sParse.pNewTable->aCol[iCol].zCnName
          );
        }
        if( sCtx.iCol<0 ){
          renameTokenFind(&sParse, &sCtx, (void*)&sParse.pNewTable->iPKey);
        }
        sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);
        for(pIdx=sParse.pNewTable->pIndex; pIdx; pIdx=pIdx->pNext){
          sqlite3WalkExprList(&sWalker, pIdx->aColExpr);
        }
        for(pIdx=sParse.pNewIndex; pIdx; pIdx=pIdx->pNext){
          sqlite3WalkExprList(&sWalker, pIdx->aColExpr);
        }

        for(i=0; i<sParse.pNewTable->nCol; i++){
          Expr *pExpr = sqlite3ColumnExpr(sParse.pNewTable,
                                                  &sParse.pNewTable->aCol[i]);
          sqlite3WalkExpr(&sWalker, pExpr);
        }

      }

      ((void) (0));
      for(pFKey=sParse.pNewTable->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){
        for(i=0; i<pFKey->nCol; i++){
          if( bFKOnly==0 && pFKey->aCol[i].iFrom==iCol ){
            renameTokenFind(&sParse, &sCtx, (void*)&pFKey->aCol[i]);
          }
          if( 0==sqlite3_stricmp(pFKey->zTo, zTable)
           && 0==sqlite3_stricmp(pFKey->aCol[i].zCol, zOld)
          ){
            renameTokenFind(&sParse, &sCtx, (void*)pFKey->aCol[i].zCol);
          }
        }
      }
    }
  }else if( sParse.pNewIndex ){
    sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);
    sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);
  }else{

    TriggerStep *pStep;
    rc = renameResolveTrigger(&sParse);
    if( rc!=0 ) goto renameColumnFunc_done;

    for(pStep=sParse.pNewTrigger->step_list; pStep; pStep=pStep->pNext){
      if( pStep->zTarget ){
        Table *pTarget = sqlite3LocateTable(&sParse, 0, pStep->zTarget, zDb);
        if( pTarget==pTab ){
          if( pStep->pUpsert ){
            ExprList *pUpsertSet = pStep->pUpsert->pUpsertSet;
            renameColumnElistNames(&sParse, &sCtx, pUpsertSet, zOld);
          }
          renameColumnIdlistNames(&sParse, &sCtx, pStep->pIdList, zOld);
          renameColumnElistNames(&sParse, &sCtx, pStep->pExprList, zOld);
        }
      }
    }



    if( sParse.pTriggerTab==pTab ){
      renameColumnIdlistNames(&sParse, &sCtx,sParse.pNewTrigger->pColumns,zOld);
    }


    renameWalkTrigger(&sWalker, sParse.pNewTrigger);
  }

  ((void) (0));
  rc = renameEditSql(context, &sCtx, zSql, zNew, bQuote);

renameColumnFunc_done:
  if( rc!=0 ){
    if( rc==1 && sqlite3WritableSchema(db) ){
      sqlite3_result_value(context, argv[0]);
    }else if( sParse.zErrMsg ){
      renameColumnParseError(context, "", argv[1], argv[2], &sParse);
    }else{
      sqlite3_result_error_code(context, rc);
    }
  }

  renameParseCleanup(&sParse);
  renameTokenFree(db, sCtx.pList);

  db->xAuth = xAuth;

  sqlite3BtreeLeaveAll(db);
}




static int renameTableExprCb(Walker *pWalker, Expr *pExpr){
  RenameCtx *p = pWalker->u.pRename;
  if( pExpr->op==168
   && ((((pExpr)->flags&(0x1000000|0x2000000))==0))
   && p->pTab==pExpr->y.pTab
  ){
    renameTokenFind(pWalker->pParse, p, (void*)&pExpr->y.pTab);
  }
  return 0;
}




static int renameTableSelectCb(Walker *pWalker, Select *pSelect){
  int i;
  RenameCtx *p = pWalker->u.pRename;
  SrcList *pSrc = pSelect->pSrc;
  if( pSelect->selFlags & (0x0200000|0x4000000) ){
                                           ;
                                              ;
    return 1;
  }
  if( (pSrc==0) ){
    ((void) (0));
    return 2;
  }
  for(i=0; i<pSrc->nSrc; i++){
    SrcItem *pItem = &pSrc->a[i];
    if( pItem->pSTab==p->pTab ){
      renameTokenFind(pWalker->pParse, p, pItem->zName);
    }
  }
  renameWalkWith(pWalker, pSelect);

  return 0;
}
# 120843 "c_tests/sqlite3.c"
static void renameTableFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  const char *zDb = (const char*)sqlite3_value_text(argv[0]);
  const char *zInput = (const char*)sqlite3_value_text(argv[3]);
  const char *zOld = (const char*)sqlite3_value_text(argv[4]);
  const char *zNew = (const char*)sqlite3_value_text(argv[5]);
  int bTemp = sqlite3_value_int(argv[6]);
  (void)(NotUsed);

  if( zInput && zOld && zNew ){
    Parse sParse;
    int rc;
    int bQuote = 1;
    RenameCtx sCtx;
    Walker sWalker;


    sqlite3_xauth xAuth = db->xAuth;
    db->xAuth = 0;


    sqlite3BtreeEnterAll(db);

    memset(&sCtx, 0, sizeof(RenameCtx));
    sCtx.pTab = sqlite3FindTable(db, zOld, zDb);
    memset(&sWalker, 0, sizeof(Walker));
    sWalker.pParse = &sParse;
    sWalker.xExprCallback = renameTableExprCb;
    sWalker.xSelectCallback = renameTableSelectCb;
    sWalker.u.pRename = &sCtx;

    rc = renameParseSql(&sParse, zDb, db, zInput, bTemp);

    if( rc==0 ){
      int isLegacy = (db->flags & 0x04000000);
      if( sParse.pNewTable ){
        Table *pTab = sParse.pNewTable;

        if( ((pTab)->eTabType==2) ){
          if( isLegacy==0 ){
            Select *pSelect = pTab->u.view.pSelect;
            NameContext sNC;
            memset(&sNC, 0, sizeof(sNC));
            sNC.pParse = &sParse;

            ((void) (0));
            pSelect->selFlags &= ~(u32)0x0200000;
            sqlite3SelectPrep(&sParse, pTab->u.view.pSelect, &sNC);
            if( sParse.nErr ){
              rc = sParse.rc;
            }else{
              sqlite3WalkSelect(&sWalker, pTab->u.view.pSelect);
            }
          }
        }else{


          if( (isLegacy==0 || (db->flags & 0x00004000))
           && !((pTab)->eTabType==1)
          ){
            FKey *pFKey;
            ((void) (0));
            for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){
              if( sqlite3_stricmp(pFKey->zTo, zOld)==0 ){
                renameTokenFind(&sParse, &sCtx, (void*)pFKey->zTo);
              }
            }
          }





          if( sqlite3_stricmp(zOld, pTab->zName)==0 ){
            sCtx.pTab = pTab;
            if( isLegacy==0 ){
              sqlite3WalkExprList(&sWalker, pTab->pCheck);
            }
            renameTokenFind(&sParse, &sCtx, pTab->zName);
          }
        }
      }

      else if( sParse.pNewIndex ){
        renameTokenFind(&sParse, &sCtx, sParse.pNewIndex->zName);
        if( isLegacy==0 ){
          sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);
        }
      }


      else{
        Trigger *pTrigger = sParse.pNewTrigger;
        TriggerStep *pStep;
        if( 0==sqlite3_stricmp(sParse.pNewTrigger->table, zOld)
            && sCtx.pTab->pSchema==pTrigger->pTabSchema
          ){
          renameTokenFind(&sParse, &sCtx, sParse.pNewTrigger->table);
        }

        if( isLegacy==0 ){
          rc = renameResolveTrigger(&sParse);
          if( rc==0 ){
            renameWalkTrigger(&sWalker, pTrigger);
            for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){
              if( pStep->zTarget && 0==sqlite3_stricmp(pStep->zTarget, zOld) ){
                renameTokenFind(&sParse, &sCtx, pStep->zTarget);
              }
              if( pStep->pFrom ){
                int i;
                for(i=0; i<pStep->pFrom->nSrc; i++){
                  SrcItem *pItem = &pStep->pFrom->a[i];
                  if( 0==sqlite3_stricmp(pItem->zName, zOld) ){
                    renameTokenFind(&sParse, &sCtx, pItem->zName);
                  }
                }
              }
            }
          }
        }
      }

    }

    if( rc==0 ){
      rc = renameEditSql(context, &sCtx, zInput, zNew, bQuote);
    }
    if( rc!=0 ){
      if( rc==1 && sqlite3WritableSchema(db) ){
        sqlite3_result_value(context, argv[3]);
      }else if( sParse.zErrMsg ){
        renameColumnParseError(context, "", argv[1], argv[2], &sParse);
      }else{
        sqlite3_result_error_code(context, rc);
      }
    }

    renameParseCleanup(&sParse);
    renameTokenFree(db, sCtx.pList);
    sqlite3BtreeLeaveAll(db);

    db->xAuth = xAuth;

  }

  return;
}

static int renameQuotefixExprCb(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==118 && (pExpr->flags & 0x000080) ){
    renameTokenFind(pWalker->pParse, pWalker->u.pRename, (const void*)pExpr);
  }
  return 0;
}
# 121029 "c_tests/sqlite3.c"
static void renameQuotefixFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  char const *zDb = (const char*)sqlite3_value_text(argv[0]);
  char const *zInput = (const char*)sqlite3_value_text(argv[1]);


  sqlite3_xauth xAuth = db->xAuth;
  db->xAuth = 0;


  sqlite3BtreeEnterAll(db);

  (void)(NotUsed);
  if( zDb && zInput ){
    int rc;
    Parse sParse;
    rc = renameParseSql(&sParse, zDb, db, zInput, 0);

    if( rc==0 ){
      RenameCtx sCtx;
      Walker sWalker;


      memset(&sCtx, 0, sizeof(RenameCtx));
      memset(&sWalker, 0, sizeof(Walker));
      sWalker.pParse = &sParse;
      sWalker.xExprCallback = renameQuotefixExprCb;
      sWalker.xSelectCallback = renameColumnSelectCb;
      sWalker.u.pRename = &sCtx;

      if( sParse.pNewTable ){
        if( ((sParse.pNewTable)->eTabType==2) ){
          Select *pSelect = sParse.pNewTable->u.view.pSelect;
          pSelect->selFlags &= ~(u32)0x0200000;
          sParse.rc = 0;
          sqlite3SelectPrep(&sParse, pSelect, 0);
          rc = (db->mallocFailed ? 7 : sParse.rc);
          if( rc==0 ){
            sqlite3WalkSelect(&sWalker, pSelect);
          }
        }else{
          int i;
          sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);

          for(i=0; i<sParse.pNewTable->nCol; i++){
            sqlite3WalkExpr(&sWalker,
               sqlite3ColumnExpr(sParse.pNewTable,
                                         &sParse.pNewTable->aCol[i]));
          }

        }
      }else if( sParse.pNewIndex ){
        sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);
        sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);
      }else{

        rc = renameResolveTrigger(&sParse);
        if( rc==0 ){
          renameWalkTrigger(&sWalker, sParse.pNewTrigger);
        }

      }

      if( rc==0 ){
        rc = renameEditSql(context, &sCtx, zInput, 0, 0);
      }
      renameTokenFree(db, sCtx.pList);
    }
    if( rc!=0 ){
      if( sqlite3WritableSchema(db) && rc==1 ){
        sqlite3_result_value(context, argv[1]);
      }else{
        sqlite3_result_error_code(context, rc);
      }
    }
    renameParseCleanup(&sParse);
  }


  db->xAuth = xAuth;


  sqlite3BtreeLeaveAll(db);
}
# 121142 "c_tests/sqlite3.c"
static void renameTableTest(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  char const *zDb = (const char*)sqlite3_value_text(argv[0]);
  char const *zInput = (const char*)sqlite3_value_text(argv[1]);
  int bTemp = sqlite3_value_int(argv[4]);
  int isLegacy = (db->flags & 0x04000000);
  char const *zWhen = (const char*)sqlite3_value_text(argv[5]);
  int bNoDQS = sqlite3_value_int(argv[6]);


  sqlite3_xauth xAuth = db->xAuth;
  db->xAuth = 0;


  (void)(NotUsed);

  if( zDb && zInput ){
    int rc;
    Parse sParse;
    u64 flags = db->flags;
    if( bNoDQS ) db->flags &= ~(0x40000000|0x20000000);
    rc = renameParseSql(&sParse, zDb, db, zInput, bTemp);
    db->flags = flags;
    if( rc==0 ){
      if( isLegacy==0 && sParse.pNewTable && ((sParse.pNewTable)->eTabType==2) ){
        NameContext sNC;
        memset(&sNC, 0, sizeof(sNC));
        sNC.pParse = &sParse;
        sqlite3SelectPrep(&sParse, sParse.pNewTable->u.view.pSelect, &sNC);
        if( sParse.nErr ) rc = sParse.rc;
      }

      else if( sParse.pNewTrigger ){
        if( isLegacy==0 ){
          rc = renameResolveTrigger(&sParse);
        }
        if( rc==0 ){
          int i1 = sqlite3SchemaToIndex(db, sParse.pNewTrigger->pTabSchema);
          int i2 = sqlite3FindDbName(db, zDb);
          if( i1==i2 ){

            sqlite3_result_int(context, 1);
          }
        }
      }
    }

    if( rc!=0 && zWhen && !sqlite3WritableSchema(db) ){

      renameColumnParseError(context, zWhen, argv[2], argv[3],&sParse);
    }
    renameParseCleanup(&sParse);
  }


  db->xAuth = xAuth;

}
# 121217 "c_tests/sqlite3.c"
static void dropColumnFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  int iSchema = sqlite3_value_int(argv[0]);
  const char *zSql = (const char*)sqlite3_value_text(argv[1]);
  int iCol = sqlite3_value_int(argv[2]);
  const char *zDb = db->aDb[iSchema].zDbSName;
  int rc;
  Parse sParse;
  RenameToken *pCol;
  Table *pTab;
  const char *zEnd;
  char *zNew = 0;


  sqlite3_xauth xAuth = db->xAuth;
  db->xAuth = 0;


  (void)(NotUsed);
  rc = renameParseSql(&sParse, zDb, db, zSql, iSchema==1);
  if( rc!=0 ) goto drop_column_done;
  pTab = sParse.pNewTable;
  if( pTab==0 || pTab->nCol==1 || iCol>=pTab->nCol ){

    rc = sqlite3CorruptError(121245);
    goto drop_column_done;
  }

  pCol = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol].zCnName);
  if( iCol<pTab->nCol-1 ){
    RenameToken *pEnd;
    pEnd = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol+1].zCnName);
    zEnd = (const char*)pEnd->t.z;
  }else{
    ((void) (0));
    zEnd = (const char*)&zSql[pTab->u.tab.addColOffset];
    while( (pCol->t.z[0]!=0) && pCol->t.z[0]!=',' ) pCol->t.z--;
  }

  zNew = sqlite3MPrintf(db, "%.*s%s", pCol->t.z-zSql, zSql, zEnd);
  sqlite3_result_text(context, zNew, -1, ((sqlite3_destructor_type)-1));
  sqlite3_free(zNew);

drop_column_done:
  renameParseCleanup(&sParse);

  db->xAuth = xAuth;

  if( rc!=0 ){
    sqlite3_result_error_code(context, rc);
  }
}
# 121282 "c_tests/sqlite3.c"
static void sqlite3AlterDropColumn(Parse *pParse, SrcList *pSrc, const Token *pName){
  sqlite3 *db = pParse->db;
  Table *pTab;
  int iDb;
  const char *zDb;
  char *zCol = 0;
  int iCol;


  ((void) (0));
  ((void) (0));
  if( (db->mallocFailed) ) goto exit_drop_column;
  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
  if( !pTab ) goto exit_drop_column;



  if( 0!=isAlterableTable(pParse, pTab) ) goto exit_drop_column;
  if( 0!=isRealTable(pParse, pTab, 1) ) goto exit_drop_column;


  zCol = sqlite3NameFromToken(db, pName);
  if( zCol==0 ){
    ((void) (0));
    goto exit_drop_column;
  }
  iCol = sqlite3ColumnIndex(pTab, zCol);
  if( iCol<0 ){
    sqlite3ErrorMsg(pParse, "no such column: \"%T\"", pName);
    goto exit_drop_column;
  }



  if( pTab->aCol[iCol].colFlags & (0x0001|0x0008) ){
    sqlite3ErrorMsg(pParse, "cannot drop %s column: \"%s\"",
        (pTab->aCol[iCol].colFlags&0x0001) ? "PRIMARY KEY" : "UNIQUE",
        zCol
    );
    goto exit_drop_column;
  }


  if( pTab->nCol<=1 ){
    sqlite3ErrorMsg(pParse, "cannot drop column \"%s\": no other columns exist",zCol);
    goto exit_drop_column;
  }


  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void) (0));
  zDb = db->aDb[iDb].zDbSName;


  if( sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, zCol) ){
    goto exit_drop_column;
  }

  renameTestSchema(pParse, zDb, iDb==1, "", 0);
  renameFixQuotes(pParse, zDb, iDb==1);
  sqlite3NestedParse(pParse,
      "UPDATE \"%w\"." "sqlite_master" " SET "
      "sql = sqlite_drop_column(%d, sql, %d) "
      "WHERE (type=='table' AND tbl_name=%Q COLLATE nocase)"
      , zDb, iDb, iCol, pTab->zName
  );


  renameReloadSchema(pParse, iDb, 0x0002);
  renameTestSchema(pParse, zDb, iDb==1, "after drop column", 1);


  if( pParse->nErr==0 && (pTab->aCol[iCol].colFlags & 0x0020)==0 ){
    int i;
    int addr;
    int reg;
    int regRec;
    Index *pPk = 0;
    int nField = 0;
    int iCur;
    Vdbe *v = sqlite3GetVdbe(pParse);
    iCur = pParse->nTab++;
    sqlite3OpenTable(pParse, iCur, iDb, pTab, 114);
    addr = sqlite3VdbeAddOp1(v, 36, iCur); ;
    reg = ++pParse->nMem;
    if( (((pTab)->tabFlags & 0x00000080)==0) ){
      sqlite3VdbeAddOp2(v, 136, iCur, reg);
      pParse->nMem += pTab->nCol;
    }else{
      pPk = sqlite3PrimaryKeyIndex(pTab);
      pParse->nMem += pPk->nColumn;
      for(i=0; i<pPk->nKeyCol; i++){
        sqlite3VdbeAddOp3(v, 95, iCur, i, reg+i+1);
      }
      nField = pPk->nKeyCol;
    }
    regRec = ++pParse->nMem;
    for(i=0; i<pTab->nCol; i++){
      if( i!=iCol && (pTab->aCol[i].colFlags & 0x0020)==0 ){
        int regOut;
        if( pPk ){
          int iPos = sqlite3TableColumnToIndex(pPk, i);
          int iColPos = sqlite3TableColumnToIndex(pPk, iCol);
          if( iPos<pPk->nKeyCol ) continue;
          regOut = reg+1+iPos-(iPos>iColPos);
        }else{
          regOut = reg+1+nField;
        }
        if( i==pTab->iPKey ){
          sqlite3VdbeAddOp2(v, 76, 0, regOut);
        }else{
          char aff = pTab->aCol[i].affinity;
          if( aff==0x45 ){
            pTab->aCol[i].affinity = 0x43;
          }
          sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, regOut);
          pTab->aCol[i].affinity = aff;
        }
        nField++;
      }
    }
    if( nField==0 ){

      pParse->nMem++;
      sqlite3VdbeAddOp2(v, 76, 0, reg+1);
      nField = 1;
    }
    sqlite3VdbeAddOp3(v, 98, reg+1, nField, regRec);
    if( pPk ){
      sqlite3VdbeAddOp4Int(v, 139, iCur, regRec, reg+1, pPk->nKeyCol);
    }else{
      sqlite3VdbeAddOp3(v, 129, iCur, regRec, reg);
    }
    sqlite3VdbeChangeP5(v, 0x02);

    sqlite3VdbeAddOp2(v, 40, iCur, addr+1); ;
    sqlite3VdbeJumpHere(v, addr);
  }

exit_drop_column:
  sqlite3DbFree(db, zCol);
  sqlite3SrcListDelete(db, pSrc);
}




static void sqlite3AlterFunctions(void){
  static FuncDef aAlterTableFuncs[] = {
    {9, 0x00800000| 0x00040000|1|0x0800, 0, 0, renameColumnFunc, 0, 0, 0, "sqlite_rename_column", {0} },
    {7, 0x00800000| 0x00040000|1|0x0800, 0, 0, renameTableFunc, 0, 0, 0, "sqlite_rename_table", {0} },
    {7, 0x00800000| 0x00040000|1|0x0800, 0, 0, renameTableTest, 0, 0, 0, "sqlite_rename_test", {0} },
    {3, 0x00800000| 0x00040000|1|0x0800, 0, 0, dropColumnFunc, 0, 0, 0, "sqlite_drop_column", {0} },
    {2, 0x00800000| 0x00040000|1|0x0800, 0, 0, renameQuotefixFunc, 0, 0, 0, "sqlite_rename_quotefix", {0} },
  };
  sqlite3InsertBuiltinFuncs(aAlterTableFuncs, ((int)(sizeof(aAlterTableFuncs)/sizeof(aAlterTableFuncs[0]))));
}
# 121608 "c_tests/sqlite3.c"
static void openStatTable(
  Parse *pParse,
  int iDb,
  int iStatCur,
  const char *zWhere,
  const char *zWhereType
){
  static const struct {
    const char *zName;
    const char *zCols;
  } aTable[] = {
    { "sqlite_stat1", "tbl,idx,stat" },



    { "sqlite_stat4", 0 },

    { "sqlite_stat3", 0 },
  };
  int i;
  sqlite3 *db = pParse->db;
  Db *pDb;
  Vdbe *v = sqlite3GetVdbe(pParse);
  u32 aRoot[((int)(sizeof(aTable)/sizeof(aTable[0])))];
  u8 aCreateTbl[((int)(sizeof(aTable)/sizeof(aTable[0])))];



  const int nToOpen = 1;


  if( v==0 ) return;
  ((void) (0));
  ((void) (0));
  pDb = &db->aDb[iDb];




  for(i=0; i<((int)(sizeof(aTable)/sizeof(aTable[0]))); i++){
    const char *zTab = aTable[i].zName;
    Table *pStat;
    aCreateTbl[i] = 0;
    if( (pStat = sqlite3FindTable(db, zTab, pDb->zDbSName))==0 ){
      if( i<nToOpen ){




        sqlite3NestedParse(pParse,
            "CREATE TABLE %Q.%s(%s)", pDb->zDbSName, zTab, aTable[i].zCols
        );
        ((void) (0));
        aRoot[i] = (u32)pParse->u1.cr.regRoot;
        aCreateTbl[i] = 0x10;
      }
    }else{



      aRoot[i] = pStat->tnum;
      sqlite3TableLock(pParse, iDb, aRoot[i], 1, zTab);
      if( zWhere ){
        sqlite3NestedParse(pParse,
           "DELETE FROM %Q.%s WHERE %s=%Q",
           pDb->zDbSName, zTab, zWhereType, zWhere
        );




      }else{

        sqlite3VdbeAddOp2(v, 146, (int)aRoot[i], iDb);
      }
    }
  }


  for(i=0; i<nToOpen; i++){
    ((void) (0));
    sqlite3VdbeAddOp4Int(v, 114, iStatCur+i, (int)aRoot[i], iDb, 3);
    sqlite3VdbeChangeP5(v, aCreateTbl[i]);
                                     ;
  }
}
# 121707 "c_tests/sqlite3.c"
typedef struct StatAccum StatAccum;
typedef struct StatSample StatSample;
struct StatSample {
  tRowcnt *anDLt;
# 121723 "c_tests/sqlite3.c"
};
struct StatAccum {
  sqlite3 *db;
  tRowcnt nEst;
  tRowcnt nRow;
  int nLimit;
  int nCol;
  int nKeyCol;
  u8 nSkipAhead;
  StatSample current;
# 121744 "c_tests/sqlite3.c"
};
# 121808 "c_tests/sqlite3.c"
static void statAccumDestructor(void *pOld){
  StatAccum *p = (StatAccum*)pOld;
# 121818 "c_tests/sqlite3.c"
  sqlite3DbFree(p->db, p);
}
# 121843 "c_tests/sqlite3.c"
static void statInit(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  StatAccum *p;
  int nCol;
  int nKeyCol;
  int nColUp;
  i64 n;
  sqlite3 *db = sqlite3_context_db_handle(context);






  (void)(argc);
  nCol = sqlite3_value_int(argv[0]);
  ((void) (0));
  nColUp = sizeof(tRowcnt)<8 ? (nCol+1)&~1 : nCol;
  nKeyCol = sqlite3_value_int(argv[1]);
  ((void) (0));
  ((void) (0));


  n = sizeof(*p)
    + sizeof(tRowcnt)*nColUp;
# 121879 "c_tests/sqlite3.c"
  p = sqlite3DbMallocZero(db, n);
  if( p==0 ){
    sqlite3_result_error_nomem(context);
    return;
  }

  p->db = db;
  p->nEst = sqlite3_value_int64(argv[2]);
  p->nRow = 0;
  p->nLimit = sqlite3_value_int(argv[3]);
  p->nCol = nCol;
  p->nKeyCol = nKeyCol;
  p->nSkipAhead = 0;
  p->current.anDLt = (tRowcnt*)&p[1];
# 121927 "c_tests/sqlite3.c"
  sqlite3_result_blob(context, p, sizeof(*p), statAccumDestructor);
}
static const FuncDef statInitFuncdef = {
  4,
  1,
  0,
  0,
  statInit,
  0,
  0, 0,
  "stat_init",
  {0}
};
# 122144 "c_tests/sqlite3.c"
static void statPush(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int i;


  StatAccum *p = (StatAccum*)sqlite3_value_blob(argv[0]);
  int iChng = sqlite3_value_int(argv[1]);

  (void)(argc);
  (void)(context);
  ((void) (0));
  ((void) (0));

  if( p->nRow==0 ){




  }else{
# 122178 "c_tests/sqlite3.c"
    for(i=iChng; i<p->nCol; i++){
      p->current.anDLt[i]++;




    }
  }

  p->nRow++;
# 122217 "c_tests/sqlite3.c"
  if( p->nLimit && p->nRow>(tRowcnt)p->nLimit*(p->nSkipAhead+1) ){
    p->nSkipAhead++;
    sqlite3_result_int(context, p->current.anDLt[0]>0);
  }
}

static const FuncDef statPushFuncdef = {
  2+0,
  1,
  0,
  0,
  statPush,
  0,
  0, 0,
  "stat_push",
  {0}
};
# 122260 "c_tests/sqlite3.c"
static void statGet(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  StatAccum *p = (StatAccum*)sqlite3_value_blob(argv[0]);
# 122277 "c_tests/sqlite3.c"
  ((void) (0));

  {
# 122306 "c_tests/sqlite3.c"
    sqlite3_str sStat;
    int i;

    sqlite3StrAccumInit(&sStat, 0, 0, 0, (p->nKeyCol+1)*100);
    sqlite3_str_appendf(&sStat, "%llu",
        p->nSkipAhead ? (u64)p->nEst : (u64)p->nRow);
    for(i=0; i<p->nKeyCol; i++){
      u64 nDistinct = p->current.anDLt[i] + 1;
      u64 iVal = (p->nRow + nDistinct - 1) / nDistinct;
      if( iVal==2 && p->nRow*10 <= nDistinct*11 ) iVal = 1;
      sqlite3_str_appendf(&sStat, " %llu", iVal);



    }
    sqlite3ResultStrAccum(context, &sStat);
  }
# 122362 "c_tests/sqlite3.c"
  (void)(argc);

}
static const FuncDef statGetFuncdef = {
  1+0,
  1,
  0,
  0,
  statGet,
  0,
  0, 0,
  "stat_get",
  {0}
};

static void callStatGet(Parse *pParse, int regStat, int iParam, int regOut){





  (void)(iParam);

  ((void) (0));
  sqlite3VdbeAddFunctionCall(pParse, 0, regStat, regOut, 1+0,
                             &statGetFuncdef, 0);
}
# 122419 "c_tests/sqlite3.c"
static void analyzeOneTable(
  Parse *pParse,
  Table *pTab,
  Index *pOnlyIdx,
  int iStatCur,
  int iMem,
  int iTab
){
  sqlite3 *db = pParse->db;
  Index *pIdx;
  int iIdxCur;
  int iTabCur;
  Vdbe *v;
  int i;
  int jZeroRows = -1;
  int iDb;
  u8 needTableCnt = 1;
  int regNewRowid = iMem++;
  int regStat = iMem++;
  int regChng = iMem++;
  int regRowid = iMem++;
  int regTemp = iMem++;
  int regTemp2 = iMem++;
  int regTabname = iMem++;
  int regIdxname = iMem++;
  int regStat1 = iMem++;
  int regPrev = iMem;







  sqlite3TouchRegister(pParse, iMem);
  ((void) (0));
  v = sqlite3GetVdbe(pParse);
  if( v==0 || (pTab==0) ){
    return;
  }
  if( !((pTab)->eTabType==0) ){

    return;
  }
  if( sqlite3_strlike("sqlite\\_%", pTab->zName, '\\')==0 ){

    return;
  }
  ((void) (0));
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void) (0));
  ((void) (0));

  if( sqlite3AuthCheck(pParse, 28, pTab->zName, 0,
      db->aDb[iDb].zDbSName ) ){
    return;
  }
# 122494 "c_tests/sqlite3.c"
  sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
  iTabCur = iTab++;
  iIdxCur = iTab++;
  pParse->nTab = ((pParse->nTab)>(iTab)?(pParse->nTab):(iTab));
  sqlite3OpenTable(pParse, iTabCur, iDb, pTab, 113);
  sqlite3VdbeLoadString(v, regTabname, pTab->zName);

  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    int nCol;
    int addrGotoEnd;
    int addrNextRow;
    const char *zIdxName;
    int nColTest;

    if( pOnlyIdx && pOnlyIdx!=pIdx ) continue;
    if( pIdx->pPartIdxWhere==0 ) needTableCnt = 0;
    if( !(((pTab)->tabFlags & 0x00000080)==0) && ((pIdx)->idxType==2) ){
      nCol = pIdx->nKeyCol;
      zIdxName = pTab->zName;
      nColTest = nCol - 1;
    }else{
      nCol = pIdx->nColumn;
      zIdxName = pIdx->zName;
      nColTest = pIdx->uniqNotNull ? pIdx->nKeyCol-1 : nCol-1;
    }


    sqlite3VdbeLoadString(v, regIdxname, zIdxName);
                                                                 ;
# 122565 "c_tests/sqlite3.c"
    sqlite3TouchRegister(pParse, regPrev+nColTest);


    ((void) (0));
    sqlite3VdbeAddOp3(v, 113, iIdxCur, pIdx->tnum, iDb);
    sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
                                       ;
# 122585 "c_tests/sqlite3.c"
    ((void) (0));
    sqlite3VdbeAddOp2(v, 72, db->nAnalysisLimit, regTemp2);






    sqlite3VdbeAddOp2(v, 72, nCol, regStat+1);
    ((void) (0));
    sqlite3VdbeAddOp2(v, 72, pIdx->nKeyCol, regRowid);
    sqlite3VdbeAddOp3(v, 99, iIdxCur, regTemp,
                      (((db)->dbOptFlags&(0x00000800))!=0));
    sqlite3VdbeAddFunctionCall(pParse, 0, regStat+1, regStat, 4,
                               &statInitFuncdef, 0);
    addrGotoEnd = sqlite3VdbeAddOp1(v, 36, iIdxCur);
                   ;

    sqlite3VdbeAddOp2(v, 72, 0, regChng);
    addrNextRow = sqlite3VdbeCurrentAddr(v);

    if( nColTest>0 ){
      int endDistinctTest = sqlite3VdbeMakeLabel(pParse);
      int *aGotoChng;
      aGotoChng = sqlite3DbMallocRawNN(db, sizeof(int)*nColTest);
      if( aGotoChng==0 ) continue;
# 122622 "c_tests/sqlite3.c"
      sqlite3VdbeAddOp0(v, 9);
      addrNextRow = sqlite3VdbeCurrentAddr(v);
      if( nColTest==1 && pIdx->nKeyCol==1 && ((pIdx)->onError!=0) ){



        sqlite3VdbeAddOp2(v, 52, regPrev, endDistinctTest);
                       ;
      }
      for(i=0; i<nColTest; i++){
        char *pColl = (char*)sqlite3LocateCollSeq(pParse, pIdx->azColl[i]);
        sqlite3VdbeAddOp2(v, 72, i, regChng);
        sqlite3VdbeAddOp3(v, 95, iIdxCur, i, regTemp);
                                                       ;
        aGotoChng[i] =
        sqlite3VdbeAddOp4(v, 53, regTemp, 0, regPrev+i, pColl, (-2));
        sqlite3VdbeChangeP5(v, 0x80);
                       ;
      }
      sqlite3VdbeAddOp2(v, 72, nColTest, regChng);
      sqlite3VdbeGoto(v, endDistinctTest);
# 122652 "c_tests/sqlite3.c"
      sqlite3VdbeJumpHere(v, addrNextRow-1);
      for(i=0; i<nColTest; i++){
        sqlite3VdbeJumpHere(v, aGotoChng[i]);
        sqlite3VdbeAddOp3(v, 95, iIdxCur, i, regPrev+i);
                                                       ;
      }
      sqlite3VdbeResolveLabel(v, endDistinctTest);
      sqlite3DbFree(db, aGotoChng);
    }
# 122689 "c_tests/sqlite3.c"
    ((void) (0));
    {
      sqlite3VdbeAddFunctionCall(pParse, 1, regStat, regTemp, 2+0,
                                 &statPushFuncdef, 0);
      if( db->nAnalysisLimit ){
        int j1, j2, j3;
        j1 = sqlite3VdbeAddOp1(v, 51, regTemp); ;
        j2 = sqlite3VdbeAddOp1(v, 16, regTemp); ;
        j3 = sqlite3VdbeAddOp4Int(v, 24, iIdxCur, 0, regPrev, 1);
                       ;
        sqlite3VdbeJumpHere(v, j1);
        sqlite3VdbeAddOp2(v, 40, iIdxCur, addrNextRow); ;
        sqlite3VdbeJumpHere(v, j2);
        sqlite3VdbeJumpHere(v, j3);
      }else{
        sqlite3VdbeAddOp2(v, 40, iIdxCur, addrNextRow); ;
      }
    }


    if( pIdx->pPartIdxWhere ){


      sqlite3VdbeJumpHere(v, addrGotoEnd);
      addrGotoEnd = 0;
    }
    callStatGet(pParse, regStat, 0, regStat1);
    ((void) (0));
    sqlite3VdbeAddOp4(v, 98, regTabname, 3, regTemp, "BBB", 0);
    sqlite3VdbeAddOp2(v, 128, iStatCur, regNewRowid);
    sqlite3VdbeAddOp3(v, 129, iStatCur, regTemp, regNewRowid);



    sqlite3VdbeChangeP5(v, 0x08);
# 122797 "c_tests/sqlite3.c"
    if( addrGotoEnd ) sqlite3VdbeJumpHere(v, addrGotoEnd);
  }





  if( pOnlyIdx==0 && needTableCnt ){
                                       ;
    sqlite3VdbeAddOp2(v, 99, iTabCur, regStat1);
    jZeroRows = sqlite3VdbeAddOp1(v, 17, regStat1); ;
    sqlite3VdbeAddOp2(v, 76, 0, regIdxname);
    ((void) (0));
    sqlite3VdbeAddOp4(v, 98, regTabname, 3, regTemp, "BBB", 0);
    sqlite3VdbeAddOp2(v, 128, iStatCur, regNewRowid);
    sqlite3VdbeAddOp3(v, 129, iStatCur, regTemp, regNewRowid);
    sqlite3VdbeChangeP5(v, 0x08);



    sqlite3VdbeJumpHere(v, jZeroRows);
  }
}






static void loadAnalysis(Parse *pParse, int iDb){
  Vdbe *v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3VdbeAddOp1(v, 151, iDb);
  }
}




static void analyzeDatabase(Parse *pParse, int iDb){
  sqlite3 *db = pParse->db;
  Schema *pSchema = db->aDb[iDb].pSchema;
  HashElem *k;
  int iStatCur;
  int iMem;
  int iTab;

  sqlite3BeginWriteOperation(pParse, 0, iDb);
  iStatCur = pParse->nTab;
  pParse->nTab += 3;
  openStatTable(pParse, iDb, iStatCur, 0, 0);
  iMem = pParse->nMem+1;
  iTab = pParse->nTab;
  ((void) (0));
  for(k=((&pSchema->tblHash)->first); k; k=((k)->next)){
    Table *pTab = (Table*)((k)->data);
    analyzeOneTable(pParse, pTab, 0, iStatCur, iMem, iTab);



    ((void) (0));

  }
  loadAnalysis(pParse, iDb);
}






static void analyzeTable(Parse *pParse, Table *pTab, Index *pOnlyIdx){
  int iDb;
  int iStatCur;

  ((void) (0));
  ((void) (0));
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  sqlite3BeginWriteOperation(pParse, 0, iDb);
  iStatCur = pParse->nTab;
  pParse->nTab += 3;
  if( pOnlyIdx ){
    openStatTable(pParse, iDb, iStatCur, pOnlyIdx->zName, "idx");
  }else{
    openStatTable(pParse, iDb, iStatCur, pTab->zName, "tbl");
  }
  analyzeOneTable(pParse, pTab, pOnlyIdx, iStatCur,pParse->nMem+1,pParse->nTab);
  loadAnalysis(pParse, iDb);
}
# 122899 "c_tests/sqlite3.c"
static void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2){
  sqlite3 *db = pParse->db;
  int iDb;
  int i;
  char *z, *zDb;
  Table *pTab;
  Index *pIdx;
  Token *pTableName;
  Vdbe *v;



  ((void) (0));
  if( 0!=sqlite3ReadSchema(pParse) ){
    return;
  }

  ((void) (0));
  if( pName1==0 ){

    for(i=0; i<db->nDb; i++){
      if( i==1 ) continue;
      analyzeDatabase(pParse, i);
    }
  }else if( pName2->n==0 && (iDb = sqlite3FindDb(db, pName1))>=0 ){

    analyzeDatabase(pParse, iDb);
  }else{

    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pTableName);
    if( iDb>=0 ){
      zDb = pName2->n ? db->aDb[iDb].zDbSName : 0;
      z = sqlite3NameFromToken(db, pTableName);
      if( z ){
        if( (pIdx = sqlite3FindIndex(db, z, zDb))!=0 ){
          analyzeTable(pParse, pIdx->pTable, pIdx);
        }else if( (pTab = sqlite3LocateTable(pParse, 0, z, zDb))!=0 ){
          analyzeTable(pParse, pTab, 0);
        }
        sqlite3DbFree(db, z);
      }
    }
  }
  if( db->nSqlExec==0 && (v = sqlite3GetVdbe(pParse))!=0 ){
    sqlite3VdbeAddOp0(v, 167);
  }
}





typedef struct analysisInfo analysisInfo;
struct analysisInfo {
  sqlite3 *db;
  const char *zDatabase;
};






static void decodeIntArray(
  char *zIntArray,
  int nOut,
  tRowcnt *aOut,
  LogEst *aLog,
  Index *pIndex
){
  char *z = zIntArray;
  int c;
  int i;
  tRowcnt v;




  ((void) (0));

  for(i=0; *z && i<nOut; i++){
    v = 0;
    while( (c=z[0])>='0' && c<='9' ){
      v = v*10 + c - '0';
      z++;
    }




    ((void) (0));
    (void)(aOut);
    ((void) (0));
    aLog[i] = sqlite3LogEst(v);

    if( *z==' ' ) z++;
  }

  ((void) (0)); {



    pIndex->bUnordered = 0;
    pIndex->noSkipScan = 0;
    while( z[0] ){
      if( sqlite3_strglob("unordered*", z)==0 ){
        pIndex->bUnordered = 1;
      }else if( sqlite3_strglob("sz=[0-9]*", z)==0 ){
        int sz = sqlite3Atoi(z+3);
        if( sz<2 ) sz = 2;
        pIndex->szIdxRow = sqlite3LogEst(sz);
      }else if( sqlite3_strglob("noskipscan*", z)==0 ){
        pIndex->noSkipScan = 1;
      }





      while( z[0]!=0 && z[0]!=' ' ) z++;
      while( z[0]==' ' ) z++;
    }
  }
}
# 123035 "c_tests/sqlite3.c"
static int analysisLoader(void *pData, int argc, char **argv, char **NotUsed){
  analysisInfo *pInfo = (analysisInfo*)pData;
  Index *pIndex;
  Table *pTable;
  const char *z;

  ((void) (0));
  (void)(NotUsed),(void)(argc);

  if( argv==0 || argv[0]==0 || argv[2]==0 ){
    return 0;
  }
  pTable = sqlite3FindTable(pInfo->db, argv[0], pInfo->zDatabase);
  if( pTable==0 ){
    return 0;
  }
  if( argv[1]==0 ){
    pIndex = 0;
  }else if( sqlite3_stricmp(argv[0],argv[1])==0 ){
    pIndex = sqlite3PrimaryKeyIndex(pTable);
  }else{
    pIndex = sqlite3FindIndex(pInfo->db, argv[1], pInfo->zDatabase);
  }
  z = argv[2];

  if( pIndex ){
    tRowcnt *aiRowEst = 0;
    int nCol = pIndex->nKeyCol+1;
# 123073 "c_tests/sqlite3.c"
    pIndex->bUnordered = 0;
    decodeIntArray((char*)z, nCol, aiRowEst, pIndex->aiRowLogEst, pIndex);
    pIndex->hasStat1 = 1;
    if( pIndex->pPartIdxWhere==0 ){
      pTable->nRowLogEst = pIndex->aiRowLogEst[0];
      pTable->tabFlags |= 0x00000010;
    }
  }else{
    Index fakeIdx;
    fakeIdx.szIdxRow = pTable->szTabRow;



    decodeIntArray((char*)z, 1, 0, &pTable->nRowLogEst, &fakeIdx);
    pTable->szTabRow = fakeIdx.szIdxRow;
    pTable->tabFlags |= 0x00000010;
  }

  return 0;
}





static void sqlite3DeleteIndexSamples(sqlite3 *db, Index *pIdx){
  ((void) (0));
  ((void) (0));
# 123115 "c_tests/sqlite3.c"
  (void)(db);
  (void)(pIdx);

}
# 123384 "c_tests/sqlite3.c"
static int sqlite3AnalysisLoad(sqlite3 *db, int iDb){
  analysisInfo sInfo;
  HashElem *i;
  char *zSql;
  int rc = 0;
  Schema *pSchema = db->aDb[iDb].pSchema;
  const Table *pStat1;

  ((void) (0));
  ((void) (0));


  ((void) (0));
  for(i=((&pSchema->tblHash)->first); i; i=((i)->next)){
    Table *pTab = ((i)->data);
    pTab->tabFlags &= ~0x00000010;
  }
  for(i=((&pSchema->idxHash)->first); i; i=((i)->next)){
    Index *pIdx = ((i)->data);
    pIdx->hasStat1 = 0;




  }


  sInfo.db = db;
  sInfo.zDatabase = db->aDb[iDb].zDbSName;
  if( (pStat1 = sqlite3FindTable(db, "sqlite_stat1", sInfo.zDatabase))
   && ((pStat1)->eTabType==0)
  ){
    zSql = sqlite3MPrintf(db,
        "SELECT tbl,idx,stat FROM %Q.sqlite_stat1", sInfo.zDatabase);
    if( zSql==0 ){
      rc = 7;
    }else{
      rc = sqlite3_exec(db, zSql, analysisLoader, &sInfo, 0);
      sqlite3DbFree(db, zSql);
    }
  }


  ((void) (0));
  for(i=((&pSchema->idxHash)->first); i; i=((i)->next)){
    Index *pIdx = ((i)->data);
    if( !pIdx->hasStat1 ) sqlite3DefaultRowEst(pIdx);
  }
# 123447 "c_tests/sqlite3.c"
  if( rc==7 ){
    sqlite3OomFault(db);
  }
  return rc;
}
# 123492 "c_tests/sqlite3.c"
static int resolveAttachExpr(NameContext *pName, Expr *pExpr)
{
  int rc = 0;
  if( pExpr ){
    if( pExpr->op!=60 ){
      rc = sqlite3ResolveExprNames(pName, pExpr);
    }else{
      pExpr->op = 118;
    }
  }
  return rc;
}





static int sqlite3DbIsNamed(sqlite3 *db, int iDb, const char *zName){
  return (
      sqlite3StrICmp(db->aDb[iDb].zDbSName, zName)==0
   || (iDb==0 && sqlite3StrICmp("main", zName)==0)
  );
}
# 123531 "c_tests/sqlite3.c"
static void attachFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  int i;
  int rc = 0;
  sqlite3 *db = sqlite3_context_db_handle(context);
  const char *zName;
  const char *zFile;
  char *zPath = 0;
  char *zErr = 0;
  unsigned int flags;
  Db *aNew;
  Db *pNew = 0;
  char *zErrDyn = 0;
  sqlite3_vfs *pVfs;

  (void)(NotUsed);
  zFile = (const char *)sqlite3_value_text(argv[0]);
  zName = (const char *)sqlite3_value_text(argv[1]);
  if( zFile==0 ) zFile = "";
  if( zName==0 ) zName = "";







  if( (db->init.reopenMemdb) ){



    Btree *pNewBt = 0;
    pVfs = sqlite3_vfs_find("memdb");
    if( pVfs==0 ) return;
    rc = sqlite3BtreeOpen(pVfs, "x\0", db, &pNewBt, 0, 0x00000100);
    if( rc==0 ){
      Schema *pNewSchema = sqlite3SchemaGet(db, pNewBt);
      if( pNewSchema ){



        pNew = &db->aDb[db->init.iDb];
        if( (pNew->pBt) ) sqlite3BtreeClose(pNew->pBt);
        pNew->pBt = pNewBt;
        pNew->pSchema = pNewSchema;
      }else{
        sqlite3BtreeClose(pNewBt);
        rc = 7;
      }
    }
    if( rc ) goto attach_error;
  }else{
# 123594 "c_tests/sqlite3.c"
    if( db->nDb>=db->aLimit[7]+2 ){
      zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d",
        db->aLimit[7]
      );
      goto attach_error;
    }
    for(i=0; i<db->nDb; i++){
      ((void) (0));
      if( sqlite3DbIsNamed(db, i, zName) ){
        zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);
        goto attach_error;
      }
    }




    if( db->aDb==db->aDbStatic ){
      aNew = sqlite3DbMallocRawNN(db, sizeof(db->aDb[0])*3 );
      if( aNew==0 ) return;
      memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);
    }else{
      aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(1+(i64)db->nDb));
      if( aNew==0 ) return;
    }
    db->aDb = aNew;
    pNew = &db->aDb[db->nDb];
    memset(pNew, 0, sizeof(*pNew));





    flags = db->openFlags;
    rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);
    if( rc!=0 ){
      if( rc==7 ) sqlite3OomFault(db);
      sqlite3_result_error(context, zErr, -1);
      sqlite3_free(zErr);
      return;
    }
    if( (db->flags & ((u64)(0x00020)<<32))==0 ){
      flags &= ~(0x00000004|0x00000002);
      flags |= 0x00000001;
    }else if( (db->flags & ((u64)(0x00010)<<32))==0 ){
      flags &= ~0x00000004;
    }
    ((void) (0));
    flags |= 0x00000100;
    rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);
    db->nDb++;
    pNew->zDbSName = sqlite3DbStrDup(db, zName);
  }
  db->noSharedCache = 0;
  if( rc==19 ){
    rc = 1;
    zErrDyn = sqlite3MPrintf(db, "database is already attached");
  }else if( rc==0 ){
    Pager *pPager;
    pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);
    if( !pNew->pSchema ){
      rc = 7;
    }else if( pNew->pSchema->file_format && pNew->pSchema->enc!=((db)->enc) ){
      zErrDyn = sqlite3MPrintf(db,
        "attached databases must use the same text encoding as main database");
      rc = 1;
    }
    sqlite3BtreeEnter(pNew->pBt);
    pPager = sqlite3BtreePager(pNew->pBt);
    sqlite3PagerLockingMode(pPager, db->dfltLockMode);
    sqlite3BtreeSecureDelete(pNew->pBt,
                             sqlite3BtreeSecureDelete(db->aDb[0].pBt,-1) );

    sqlite3BtreeSetPagerFlags(pNew->pBt,
                      0x03 | (db->flags & 0x38));

    sqlite3BtreeLeave(pNew->pBt);
  }
  pNew->safety_level = 2 +1;
  if( rc==0 && pNew->zDbSName==0 ){
    rc = 7;
  }
  sqlite3_free_filename( zPath );






  if( rc==0 ){
    sqlite3BtreeEnterAll(db);
    db->init.iDb = 0;
    db->mDbFlags &= ~(0x0010);







    if( !(db->init.reopenMemdb) ){
      rc = sqlite3Init(db, &zErrDyn);
    }
    sqlite3BtreeLeaveAll(db);
    ((void) (0));
  }
  if( rc ){
    if( (!(db->init.reopenMemdb)) ){
      int iDb = db->nDb - 1;
      ((void) (0));
      if( db->aDb[iDb].pBt ){
        sqlite3BtreeClose(db->aDb[iDb].pBt);
        db->aDb[iDb].pBt = 0;
        db->aDb[iDb].pSchema = 0;
      }
      sqlite3ResetAllSchemasOfConnection(db);
      db->nDb = iDb;
      if( rc==7 || rc==(10 | (12<<8)) ){
        sqlite3OomFault(db);
        sqlite3DbFree(db, zErrDyn);
        zErrDyn = sqlite3MPrintf(db, "out of memory");
      }else if( zErrDyn==0 ){
        zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);
      }
    }
    goto attach_error;
  }

  return;

attach_error:

  if( zErrDyn ){
    sqlite3_result_error(context, zErrDyn, -1);
    sqlite3DbFree(db, zErrDyn);
  }
  if( rc ) sqlite3_result_error_code(context, rc);
}
# 123741 "c_tests/sqlite3.c"
static void detachFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  const char *zName = (const char *)sqlite3_value_text(argv[0]);
  sqlite3 *db = sqlite3_context_db_handle(context);
  int i;
  Db *pDb = 0;
  HashElem *pEntry;
  char zErr[128];

  (void)(NotUsed);

  if( zName==0 ) zName = "";
  for(i=0; i<db->nDb; i++){
    pDb = &db->aDb[i];
    if( pDb->pBt==0 ) continue;
    if( sqlite3DbIsNamed(db, i, zName) ) break;
  }

  if( i>=db->nDb ){
    sqlite3_snprintf(sizeof(zErr),zErr, "no such database: %s", zName);
    goto detach_error;
  }
  if( i<2 ){
    sqlite3_snprintf(sizeof(zErr),zErr, "cannot detach database %s", zName);
    goto detach_error;
  }
  if( sqlite3BtreeTxnState(pDb->pBt)!=0
   || sqlite3BtreeIsInBackup(pDb->pBt)
  ){
    sqlite3_snprintf(sizeof(zErr),zErr, "database %s is locked", zName);
    goto detach_error;
  }



  ((void) (0));
  pEntry = ((&db->aDb[1].pSchema->trigHash)->first);
  while( pEntry ){
    Trigger *pTrig = (Trigger*)((pEntry)->data);
    if( pTrig->pTabSchema==pDb->pSchema ){
      pTrig->pTabSchema = pTrig->pSchema;
    }
    pEntry = ((pEntry)->next);
  }

  sqlite3BtreeClose(pDb->pBt);
  pDb->pBt = 0;
  pDb->pSchema = 0;
  sqlite3CollapseDatabaseArray(db);
  return;

detach_error:
  sqlite3_result_error(context, zErr, -1);
}





static void codeAttach(
  Parse *pParse,
  int type,
  FuncDef const *pFunc,
  Expr *pAuthArg,
  Expr *pFilename,
  Expr *pDbname,
  Expr *pKey
){
  int rc;
  NameContext sName;
  Vdbe *v;
  sqlite3* db = pParse->db;
  int regArgs;

  if( 0!=sqlite3ReadSchema(pParse) ) goto attach_end;

  if( pParse->nErr ) goto attach_end;
  memset(&sName, 0, sizeof(NameContext));
  sName.pParse = pParse;

  if(
      0!=resolveAttachExpr(&sName, pFilename) ||
      0!=resolveAttachExpr(&sName, pDbname) ||
      0!=resolveAttachExpr(&sName, pKey)
  ){
    goto attach_end;
  }


  if( (pAuthArg) ){
    char *zAuthArg;
    if( pAuthArg->op==118 ){
      ((void) (0));
      zAuthArg = pAuthArg->u.zToken;
    }else{
      zAuthArg = 0;
    }
    rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);
    if(rc!=0 ){
      goto attach_end;
    }
  }



  v = sqlite3GetVdbe(pParse);
  regArgs = sqlite3GetTempRange(pParse, 4);
  sqlite3ExprCode(pParse, pFilename, regArgs);
  sqlite3ExprCode(pParse, pDbname, regArgs+1);
  sqlite3ExprCode(pParse, pKey, regArgs+2);

  ((void) (0));
  if( v ){
    sqlite3VdbeAddFunctionCall(pParse, 0, regArgs+3-pFunc->nArg, regArgs+3,
                               pFunc->nArg, pFunc, 0);




    sqlite3VdbeAddOp1(v, 167, (type==24));
  }

attach_end:
  sqlite3ExprDelete(db, pFilename);
  sqlite3ExprDelete(db, pDbname);
  sqlite3ExprDelete(db, pKey);
}






static void sqlite3Detach(Parse *pParse, Expr *pDbname){
  static const FuncDef detach_func = {
    1,
    1,
    0,
    0,
    detachFunc,
    0,
    0, 0,
    "sqlite_detach",
    {0}
  };
  codeAttach(pParse, 25, &detach_func, pDbname, 0, 0, pDbname);
}






static void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){
  static const FuncDef attach_func = {
    3,
    1,
    0,
    0,
    attachFunc,
    0,
    0, 0,
    "sqlite_attach",
    {0}
  };
  codeAttach(pParse, 24, &attach_func, p, p, pDbname, pKey);
}





static int fixExprCb(Walker *p, Expr *pExpr){
  DbFixer *pFix = p->u.pFix;
  if( !pFix->bTemp ) (pExpr)->flags|=(u32)(0x40000000);
  if( pExpr->op==157 ){
    if( pFix->pParse->db->init.busy ){
      pExpr->op = 122;
    }else{
      sqlite3ErrorMsg(pFix->pParse, "%s cannot use variables", pFix->zType);
      return 2;
    }
  }
  return 0;
}




static int fixSelectCb(Walker *p, Select *pSelect){
  DbFixer *pFix = p->u.pFix;
  int i;
  SrcItem *pItem;
  sqlite3 *db = pFix->pParse->db;
  int iDb = sqlite3FindDbName(db, pFix->zDb);
  SrcList *pList = pSelect->pSrc;

  if( (pList==0) ) return 0;
  for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){
    if( pFix->bTemp==0 && pItem->fg.isSubquery==0 ){
      if( pItem->fg.fixedSchema==0 && pItem->u4.zDatabase!=0 ){
        if( iDb!=sqlite3FindDbName(db, pItem->u4.zDatabase) ){
          sqlite3ErrorMsg(pFix->pParse,
              "%s %T cannot reference objects in database %s",
              pFix->zType, pFix->pName, pItem->u4.zDatabase);
          return 2;
        }
        sqlite3DbFree(db, pItem->u4.zDatabase);
        pItem->fg.notCte = 1;
        pItem->fg.hadSchema = 1;
      }
      pItem->u4.pSchema = pFix->pSchema;
      pItem->fg.fromDDL = 1;
      pItem->fg.fixedSchema = 1;
    }

    if( pList->a[i].fg.isUsing==0
     && sqlite3WalkExpr(&pFix->w, pList->a[i].u3.pOn)
    ){
      return 2;
    }

  }
  if( pSelect->pWith ){
    for(i=0; i<pSelect->pWith->nCte; i++){
      if( sqlite3WalkSelect(p, pSelect->pWith->a[i].pSelect) ){
        return 2;
      }
    }
  }
  return 0;
}





static void sqlite3FixInit(
  DbFixer *pFix,
  Parse *pParse,
  int iDb,
  const char *zType,
  const Token *pName
){
  sqlite3 *db = pParse->db;
  ((void) (0));
  pFix->pParse = pParse;
  pFix->zDb = db->aDb[iDb].zDbSName;
  pFix->pSchema = db->aDb[iDb].pSchema;
  pFix->zType = zType;
  pFix->pName = pName;
  pFix->bTemp = (iDb==1);
  pFix->w.pParse = pParse;
  pFix->w.xExprCallback = fixExprCb;
  pFix->w.xSelectCallback = fixSelectCb;
  pFix->w.xSelectCallback2 = sqlite3WalkWinDefnDummyCallback;
  pFix->w.walkerDepth = 0;
  pFix->w.eCode = 0;
  pFix->w.u.pFix = pFix;
}
# 124019 "c_tests/sqlite3.c"
static int sqlite3FixSrcList(
  DbFixer *pFix,
  SrcList *pList
){
  int res = 0;
  if( pList ){
    Select s;
    memset(&s, 0, sizeof(s));
    s.pSrc = pList;
    res = sqlite3WalkSelect(&pFix->w, &s);
  }
  return res;
}

static int sqlite3FixSelect(
  DbFixer *pFix,
  Select *pSelect
){
  return sqlite3WalkSelect(&pFix->w, pSelect);
}
static int sqlite3FixExpr(
  DbFixer *pFix,
  Expr *pExpr
){
  return sqlite3WalkExpr(&pFix->w, pExpr);
}



static int sqlite3FixTriggerStep(
  DbFixer *pFix,
  TriggerStep *pStep
){
  while( pStep ){
    if( sqlite3WalkSelect(&pFix->w, pStep->pSelect)
     || sqlite3WalkExpr(&pFix->w, pStep->pWhere)
     || sqlite3WalkExprList(&pFix->w, pStep->pExprList)
     || sqlite3FixSrcList(pFix, pStep->pFrom)
    ){
      return 1;
    }

    {
      Upsert *pUp;
      for(pUp=pStep->pUpsert; pUp; pUp=pUp->pNextUpsert){
        if( sqlite3WalkExprList(&pFix->w, pUp->pUpsertTarget)
         || sqlite3WalkExpr(&pFix->w, pUp->pUpsertTargetWhere)
         || sqlite3WalkExprList(&pFix->w, pUp->pUpsertSet)
         || sqlite3WalkExpr(&pFix->w, pUp->pUpsertWhere)
        ){
          return 1;
        }
      }
    }

    pStep = pStep->pNext;
  }

  return 0;
}
# 124152 "c_tests/sqlite3.c"
           int sqlite3_set_authorizer(
  sqlite3 *db,
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pArg
){



  sqlite3_mutex_enter(db->mutex);
  db->xAuth = (sqlite3_xauth)xAuth;
  db->pAuthArg = pArg;
  if( db->xAuth ) sqlite3ExpirePreparedStatements(db, 1);
  sqlite3_mutex_leave(db->mutex);
  return 0;
}





static void sqliteAuthBadReturnCode(Parse *pParse){
  sqlite3ErrorMsg(pParse, "authorizer malfunction");
  pParse->rc = 1;
}
# 124186 "c_tests/sqlite3.c"
static int sqlite3AuthReadCol(
  Parse *pParse,
  const char *zTab,
  const char *zCol,
  int iDb
){
  sqlite3 *db = pParse->db;
  char *zDb = db->aDb[iDb].zDbSName;
  int rc;

  if( db->init.busy ) return 0;
  rc = db->xAuth(db->pAuthArg, 20, zTab,zCol,zDb,pParse->zAuthContext);
  if( rc==1 ){
    char *z = sqlite3_mprintf("%s.%s", zTab, zCol);
    if( db->nDb>2 || iDb!=0 ) z = sqlite3_mprintf("%s.%z", zDb, z);
    sqlite3ErrorMsg(pParse, "access to %z is prohibited", z);
    pParse->rc = 23;
  }else if( rc!=2 && rc!=0 ){
    sqliteAuthBadReturnCode(pParse);
  }
  return rc;
}
# 124218 "c_tests/sqlite3.c"
static void sqlite3AuthRead(
  Parse *pParse,
  Expr *pExpr,
  Schema *pSchema,
  SrcList *pTabList
){
  Table *pTab = 0;
  const char *zCol;
  int iSrc;
  int iDb;
  int iCol;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  iDb = sqlite3SchemaToIndex(pParse->db, pSchema);
  if( iDb<0 ){


    return;
  }

  if( pExpr->op==78 ){
    pTab = pParse->pTriggerTab;
  }else{
    ((void) (0));
    for(iSrc=0; iSrc<pTabList->nSrc; iSrc++){
      if( pExpr->iTable==pTabList->a[iSrc].iCursor ){
        pTab = pTabList->a[iSrc].pSTab;
        break;
      }
    }
  }
  iCol = pExpr->iColumn;
  if( pTab==0 ) return;

  if( iCol>=0 ){
    ((void) (0));
    zCol = pTab->aCol[iCol].zCnName;
  }else if( pTab->iPKey>=0 ){
    ((void) (0));
    zCol = pTab->aCol[pTab->iPKey].zCnName;
  }else{
    zCol = "ROWID";
  }
  ((void) (0));
  if( 2==sqlite3AuthReadCol(pParse, pTab->zName, zCol, iDb) ){
    pExpr->op = 122;
  }
}







static int sqlite3AuthCheck(
  Parse *pParse,
  int code,
  const char *zArg1,
  const char *zArg2,
  const char *zArg3
){
  sqlite3 *db = pParse->db;
  int rc;




  ((void) (0));
  if( db->xAuth==0 || db->init.busy || (pParse->eParseMode!=0) ){
    return 0;
  }







                      ;
                      ;
                      ;
                                     ;

  rc = db->xAuth(db->pAuthArg,code,zArg1,zArg2,zArg3,pParse->zAuthContext);
  if( rc==1 ){
    sqlite3ErrorMsg(pParse, "not authorized");
    pParse->rc = 23;
  }else if( rc!=0 && rc!=2 ){
    rc = 1;
    sqliteAuthBadReturnCode(pParse);
  }
  return rc;
}






static void sqlite3AuthContextPush(
  Parse *pParse,
  AuthContext *pContext,
  const char *zContext
){
  ((void) (0));
  pContext->pParse = pParse;
  pContext->zAuthContext = pParse->zAuthContext;
  pParse->zAuthContext = zContext;
}





static void sqlite3AuthContextPop(AuthContext *pContext){
  if( pContext->pParse ){
    pContext->pParse->zAuthContext = pContext->zAuthContext;
    pContext->pParse = 0;
  }
}
# 124377 "c_tests/sqlite3.c"
struct TableLock {
  int iDb;
  Pgno iTab;
  u8 isWriteLock;
  const char *zLockName;
};
# 124394 "c_tests/sqlite3.c"
static __attribute__((noinline)) void lockTable(
  Parse *pParse,
  int iDb,
  Pgno iTab,
  u8 isWriteLock,
  const char *zName
){
  Parse *pToplevel;
  int i;
  int nBytes;
  TableLock *p;
  ((void) (0));

  pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  for(i=0; i<pToplevel->nTableLock; i++){
    p = &pToplevel->aTableLock[i];
    if( p->iDb==iDb && p->iTab==iTab ){
      p->isWriteLock = (p->isWriteLock || isWriteLock);
      return;
    }
  }

  ((void) (0));
  nBytes = sizeof(TableLock) * (pToplevel->nTableLock+1);
  pToplevel->aTableLock =
      sqlite3DbReallocOrFree(pToplevel->db, pToplevel->aTableLock, nBytes);
  if( pToplevel->aTableLock ){
    p = &pToplevel->aTableLock[pToplevel->nTableLock++];
    p->iDb = iDb;
    p->iTab = iTab;
    p->isWriteLock = isWriteLock;
    p->zLockName = zName;
  }else{
    pToplevel->nTableLock = 0;
    sqlite3OomFault(pToplevel->db);
  }
}
static void sqlite3TableLock(
  Parse *pParse,
  int iDb,
  Pgno iTab,
  u8 isWriteLock,
  const char *zName
){
  if( iDb==1 ) return;
  if( !sqlite3BtreeSharable(pParse->db->aDb[iDb].pBt) ) return;
  lockTable(pParse, iDb, iTab, isWriteLock, zName);
}





static void codeTableLocks(Parse *pParse){
  int i;
  Vdbe *pVdbe = pParse->pVdbe;
  ((void) (0));

  for(i=0; i<pParse->nTableLock; i++){
    TableLock *p = &pParse->aTableLock[i];
    int p1 = p->iDb;
    sqlite3VdbeAddOp4(pVdbe, 170, p1, p->iTab, p->isWriteLock,
                      p->zLockName, (-1));
  }
}
# 124486 "c_tests/sqlite3.c"
static void sqlite3FinishCoding(Parse *pParse){
  sqlite3 *db;
  Vdbe *v;
  int iDb, i;

  ((void) (0));
  db = pParse->db;
  ((void) (0));
  if( pParse->nested ) return;
  if( pParse->nErr ){
    if( db->mallocFailed ) pParse->rc = 7;
    return;
  }
  ((void) (0));




  v = pParse->pVdbe;
  if( v==0 ){
    if( db->init.busy ){
      pParse->rc = 101;
      return;
    }
    v = sqlite3GetVdbe(pParse);
    if( v==0 ) pParse->rc = 1;
  }
  ((void) (0));

  if( v ){
    if( pParse->bReturning ){
      Returning *pReturning;
      int addrRewind;
      int reg;

      ((void) (0));
      pReturning = pParse->u1.d.pReturning;
      if( pReturning->nRetCol ){
        sqlite3VdbeAddOp0(v, 84);
        addrRewind =
           sqlite3VdbeAddOp1(v, 36, pReturning->iRetCur);
                       ;
        reg = pReturning->iRetReg;
        for(i=0; i<pReturning->nRetCol; i++){
          sqlite3VdbeAddOp3(v, 95, pReturning->iRetCur, i, reg+i);
        }
        sqlite3VdbeAddOp2(v, 85, reg, i);
        sqlite3VdbeAddOp2(v, 40, pReturning->iRetCur, addrRewind+1);
                       ;
        sqlite3VdbeJumpHere(v, addrRewind);
      }
    }
    sqlite3VdbeAddOp0(v, 71);







    ((void) (0));
    sqlite3VdbeJumpHere(v, 0);
    ((void) (0));
    iDb = 0;
    do{
      Schema *pSchema;
      if( (((pParse->cookieMask)&(((yDbMask)1)<<(iDb)))!=0)==0 ) continue;
      sqlite3VdbeUsesBtree(v, iDb);
      pSchema = db->aDb[iDb].pSchema;
      sqlite3VdbeAddOp4Int(v,
        2,
        iDb,
        (((pParse->writeMask)&(((yDbMask)1)<<(iDb)))!=0),
        pSchema->schema_cookie,
        pSchema->iGeneration
      );
      if( db->init.busy==0 ) sqlite3VdbeChangeP5(v, 1);

                                                                            ;
    }while( ++iDb<db->nDb );

    for(i=0; i<pParse->nVtabLock; i++){
      char *vtab = (char *)sqlite3GetVTable(db, pParse->apVtabLock[i]);
      sqlite3VdbeAddOp4(v, 171, 0, 0, 0, vtab, (-11));
    }
    pParse->nVtabLock = 0;







    if( pParse->nTableLock ) codeTableLocks(pParse);




    if( pParse->pAinc ) sqlite3AutoincrementBegin(pParse);



    if( pParse->pConstExpr ){
      ExprList *pEL = pParse->pConstExpr;
      pParse->okConstFactor = 0;
      for(i=0; i<pEL->nExpr; i++){
        ((void) (0));
        sqlite3ExprCode(pParse, pEL->a[i].pExpr, pEL->a[i].u.iConstExprReg);
      }
    }

    if( pParse->bReturning ){
      Returning *pRet;
      ((void) (0));
      pRet = pParse->u1.d.pReturning;
      if( pRet->nRetCol ){
        sqlite3VdbeAddOp2(v, 119, pRet->iRetCur, pRet->nRetCol);
      }
    }


    sqlite3VdbeGoto(v, 1);
  }



  ((void) (0));
  ((void) (0));
  if( pParse->nErr==0 ){


    ((void) (0));
    sqlite3VdbeMakeReady(v, pParse);
    pParse->rc = 101;
  }else{
    pParse->rc = 1;
  }
}
# 124638 "c_tests/sqlite3.c"
static void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){
  va_list ap;
  char *zSql;
  sqlite3 *db = pParse->db;
  u32 savedDbFlags = db->mDbFlags;
  char saveBuf[(sizeof(Parse)-__builtin_offsetof(Parse, sLastToken))];

  if( pParse->nErr ) return;
  if( pParse->eParseMode ) return;
  ((void) (0));
  __builtin_va_start(ap, zFormat);
  zSql = sqlite3VMPrintf(db, zFormat, ap);
  __builtin_va_end(ap);
  if( zSql==0 ){



    if( !db->mallocFailed ) pParse->rc = 18;
    pParse->nErr++;
    return;
  }
  pParse->nested++;
  memcpy(saveBuf, (((char*)(pParse))+__builtin_offsetof(Parse, sLastToken)), (sizeof(Parse)-__builtin_offsetof(Parse, sLastToken)));
  memset((((char*)(pParse))+__builtin_offsetof(Parse, sLastToken)), 0, (sizeof(Parse)-__builtin_offsetof(Parse, sLastToken)));
  db->mDbFlags |= 0x0002;
  sqlite3RunParser(pParse, zSql);
  db->mDbFlags = savedDbFlags;
  sqlite3DbFree(db, zSql);
  memcpy((((char*)(pParse))+__builtin_offsetof(Parse, sLastToken)), saveBuf, (sizeof(Parse)-__builtin_offsetof(Parse, sLastToken)));
  pParse->nested--;
}
# 124682 "c_tests/sqlite3.c"
static Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){
  Table *p = 0;
  int i;


  ((void) (0));
  if( zDatabase ){
    for(i=0; i<db->nDb; i++){
      if( sqlite3StrICmp(zDatabase, db->aDb[i].zDbSName)==0 ) break;
    }
    if( i>=db->nDb ){


      if( sqlite3StrICmp(zDatabase,"main")==0 ){
        i = 0;
      }else{
        return 0;
      }
    }
    p = sqlite3HashFind(&db->aDb[i].pSchema->tblHash, zName);
    if( p==0 && sqlite3_strnicmp(zName, "sqlite_", 7)==0 ){
      if( i==1 ){
        if( sqlite3StrICmp(zName+7, &"sqlite_temp_schema"[7])==0
         || sqlite3StrICmp(zName+7, &"sqlite_schema"[7])==0
         || sqlite3StrICmp(zName+7, &"sqlite_master"[7])==0
        ){
          p = sqlite3HashFind(&db->aDb[1].pSchema->tblHash,
                              "sqlite_temp_master");
        }
      }else{
        if( sqlite3StrICmp(zName+7, &"sqlite_schema"[7])==0 ){
          p = sqlite3HashFind(&db->aDb[i].pSchema->tblHash,
                              "sqlite_master");
        }
      }
    }
  }else{

    p = sqlite3HashFind(&db->aDb[1].pSchema->tblHash, zName);
    if( p ) return p;

    p = sqlite3HashFind(&db->aDb[0].pSchema->tblHash, zName);
    if( p ) return p;

    for(i=2; i<db->nDb; i++){
      ((void) (0));
      p = sqlite3HashFind(&db->aDb[i].pSchema->tblHash, zName);
      if( p ) break;
    }
    if( p==0 && sqlite3_strnicmp(zName, "sqlite_", 7)==0 ){
      if( sqlite3StrICmp(zName+7, &"sqlite_schema"[7])==0 ){
        p = sqlite3HashFind(&db->aDb[0].pSchema->tblHash, "sqlite_master");
      }else if( sqlite3StrICmp(zName+7, &"sqlite_temp_schema"[7])==0 ){
        p = sqlite3HashFind(&db->aDb[1].pSchema->tblHash,
                            "sqlite_temp_master");
      }
    }
  }
  return p;
}
# 124753 "c_tests/sqlite3.c"
static Table *sqlite3LocateTable(
  Parse *pParse,
  u32 flags,
  const char *zName,
  const char *zDbase
){
  Table *p;
  sqlite3 *db = pParse->db;



  if( (db->mDbFlags & 0x0010)==0
   && 0!=sqlite3ReadSchema(pParse)
  ){
    return 0;
  }

  p = sqlite3FindTable(db, zName, zDbase);
  if( p==0 ){




    if( (pParse->prepFlags & 0x04)==0 && db->init.busy==0 ){
      Module *pMod = (Module*)sqlite3HashFind(&db->aModule, zName);
      if( pMod==0 && sqlite3_strnicmp(zName, "pragma_", 7)==0 ){
        pMod = sqlite3PragmaVtabRegister(db, zName);
      }

      if( pMod==0 && sqlite3_strnicmp(zName, "json", 4)==0 ){
        pMod = sqlite3JsonVtabRegister(db, zName);
      }






      if( pMod && sqlite3VtabEponymousTableInit(pParse, pMod) ){
                                    ;
        return pMod->pEpoTab;
      }
    }

    if( flags & 0x02 ) return 0;
    pParse->checkSchema = 1;
  }else if( ((p)->eTabType==1) && (pParse->prepFlags & 0x04)!=0 ){
    p = 0;
  }

  if( p==0 ){
    const char *zMsg = flags & 0x01 ? "no such view" : "no such table";
    if( zDbase ){
      sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName);
    }else{
      sqlite3ErrorMsg(pParse, "%s: %s", zMsg, zName);
    }
  }else{
    ((void) (0));
  }

  return p;
}
# 124826 "c_tests/sqlite3.c"
static Table *sqlite3LocateTableItem(
  Parse *pParse,
  u32 flags,
  SrcItem *p
){
  const char *zDb;
  if( p->fg.fixedSchema ){
    int iDb = sqlite3SchemaToIndex(pParse->db, p->u4.pSchema);
    zDb = pParse->db->aDb[iDb].zDbSName;
  }else{
    ((void) (0));
    zDb = p->u4.zDatabase;
  }
  return sqlite3LocateTable(pParse, flags, p->zName, zDb);
}





static const char *sqlite3PreferredTableName(const char *zName){
  if( sqlite3_strnicmp(zName, "sqlite_", 7)==0 ){
    if( sqlite3StrICmp(zName+7, &"sqlite_master"[7])==0 ){
      return "sqlite_schema";
    }
    if( sqlite3StrICmp(zName+7, &"sqlite_temp_master"[7])==0 ){
      return "sqlite_temp_schema";
    }
  }
  return zName;
}
# 124870 "c_tests/sqlite3.c"
static Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){
  Index *p = 0;
  int i;

  ((void) (0));
  for(i=0; i<db->nDb; i++){
    int j = (i<2) ? i^1 : i;
    Schema *pSchema = db->aDb[j].pSchema;
    ((void) (0));
    if( zDb && sqlite3DbIsNamed(db, j, zDb)==0 ) continue;
    ((void) (0));
    p = sqlite3HashFind(&pSchema->idxHash, zName);
    if( p ) break;
  }
  return p;
}




static void sqlite3FreeIndex(sqlite3 *db, Index *p){

  sqlite3DeleteIndexSamples(db, p);

  sqlite3ExprDelete(db, p->pPartIdxWhere);
  sqlite3ExprListDelete(db, p->aColExpr);
  sqlite3DbFree(db, p->zColAff);
  if( p->isResized ) sqlite3DbFree(db, (void *)p->azColl);



  sqlite3DbFree(db, p);
}







static void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){
  Index *pIndex;
  Hash *pHash;

  ((void) (0));
  pHash = &db->aDb[iDb].pSchema->idxHash;
  pIndex = sqlite3HashInsert(pHash, zIdxName, 0);
  if( (pIndex) ){
    if( pIndex->pTable->pIndex==pIndex ){
      pIndex->pTable->pIndex = pIndex->pNext;
    }else{
      Index *p;


      p = pIndex->pTable->pIndex;
      while( (p) && p->pNext!=pIndex ){ p = p->pNext; }
      if( (p && p->pNext==pIndex) ){
        p->pNext = pIndex->pNext;
      }
    }
    sqlite3FreeIndex(db, pIndex);
  }
  db->mDbFlags |= 0x0001;
}
# 124943 "c_tests/sqlite3.c"
static void sqlite3CollapseDatabaseArray(sqlite3 *db){
  int i, j;
  for(i=j=2; i<db->nDb; i++){
    struct Db *pDb = &db->aDb[i];
    if( pDb->pBt==0 ){
      sqlite3DbFree(db, pDb->zDbSName);
      pDb->zDbSName = 0;
      continue;
    }
    if( j<i ){
      db->aDb[j] = db->aDb[i];
    }
    j++;
  }
  db->nDb = j;
  if( db->nDb<=2 && db->aDb!=db->aDbStatic ){
    memcpy(db->aDbStatic, db->aDb, 2*sizeof(db->aDb[0]));
    sqlite3DbFree(db, db->aDb);
    db->aDb = db->aDbStatic;
  }
}






static void sqlite3ResetOneSchema(sqlite3 *db, int iDb){
  int i;
  ((void) (0));

  if( iDb>=0 ){
    ((void) (0));
    (db)->aDb[iDb].pSchema->schemaFlags|=(0x0008);
    (db)->aDb[1].pSchema->schemaFlags|=(0x0008);
    db->mDbFlags &= ~0x0010;
  }

  if( db->nSchemaLock==0 ){
    for(i=0; i<db->nDb; i++){
      if( (((db)->aDb[i].pSchema->schemaFlags&(0x0008))==(0x0008)) ){
        sqlite3SchemaClear(db->aDb[i].pSchema);
      }
    }
  }
}





static void sqlite3ResetAllSchemasOfConnection(sqlite3 *db){
  int i;
  sqlite3BtreeEnterAll(db);
  for(i=0; i<db->nDb; i++){
    Db *pDb = &db->aDb[i];
    if( pDb->pSchema ){
      if( db->nSchemaLock==0 ){
        sqlite3SchemaClear(pDb->pSchema);
      }else{
        (db)->aDb[i].pSchema->schemaFlags|=(0x0008);
      }
    }
  }
  db->mDbFlags &= ~(0x0001|0x0010);
  sqlite3VtabUnlockList(db);
  sqlite3BtreeLeaveAll(db);
  if( db->nSchemaLock==0 ){
    sqlite3CollapseDatabaseArray(db);
  }
}




static void sqlite3CommitInternalChanges(sqlite3 *db){
  db->mDbFlags &= ~0x0001;
}






static void sqlite3ColumnSetExpr(
  Parse *pParse,
  Table *pTab,
  Column *pCol,
  Expr *pExpr
){
  ExprList *pList;
  ((void) (0));
  pList = pTab->u.tab.pDfltList;
  if( pCol->iDflt==0
   || (pList==0)
   || (pList->nExpr<pCol->iDflt)
  ){
    pCol->iDflt = pList==0 ? 1 : pList->nExpr+1;
    pTab->u.tab.pDfltList = sqlite3ExprListAppend(pParse, pList, pExpr);
  }else{
    sqlite3ExprDelete(pParse->db, pList->a[pCol->iDflt-1].pExpr);
    pList->a[pCol->iDflt-1].pExpr = pExpr;
  }
}






static Expr *sqlite3ColumnExpr(Table *pTab, Column *pCol){
  if( pCol->iDflt==0 ) return 0;
  if( !((pTab)->eTabType==0) ) return 0;
  if( (pTab->u.tab.pDfltList==0) ) return 0;
  if( (pTab->u.tab.pDfltList->nExpr<pCol->iDflt) ) return 0;
  return pTab->u.tab.pDfltList->a[pCol->iDflt-1].pExpr;
}




static void sqlite3ColumnSetColl(
  sqlite3 *db,
  Column *pCol,
  const char *zColl
){
  i64 nColl;
  i64 n;
  char *zNew;
  ((void) (0));
  n = sqlite3Strlen30(pCol->zCnName) + 1;
  if( pCol->colFlags & 0x0004 ){
    n += sqlite3Strlen30(pCol->zCnName+n) + 1;
  }
  nColl = sqlite3Strlen30(zColl) + 1;
  zNew = sqlite3DbRealloc(db, pCol->zCnName, nColl+n);
  if( zNew ){
    pCol->zCnName = zNew;
    memcpy(pCol->zCnName + n, zColl, nColl);
    pCol->colFlags |= 0x0200;
  }
}




static const char *sqlite3ColumnColl(Column *pCol){
  const char *z;
  if( (pCol->colFlags & 0x0200)==0 ) return 0;
  z = pCol->zCnName;
  while( *z ){ z++; }
  if( pCol->colFlags & 0x0004 ){
    do{ z++; }while( *z );
  }
  return z+1;
}





static void sqlite3DeleteColumnNames(sqlite3 *db, Table *pTable){
  int i;
  Column *pCol;
  ((void) (0));
  ((void) (0));
  if( (pCol = pTable->aCol)!=0 ){
    for(i=0; i<pTable->nCol; i++, pCol++){
      ((void) (0));
      sqlite3DbFree(db, pCol->zCnName);
    }
    sqlite3DbNNFreeNN(db, pTable->aCol);
    if( ((pTable)->eTabType==0) ){
      sqlite3ExprListDelete(db, pTable->u.tab.pDfltList);
    }
    if( db->pnBytesFreed==0 ){
      pTable->aCol = 0;
      pTable->nCol = 0;
      if( ((pTable)->eTabType==0) ){
        pTable->u.tab.pDfltList = 0;
      }
    }
  }
}
# 125143 "c_tests/sqlite3.c"
static void __attribute__((noinline)) deleteTable(sqlite3 *db, Table *pTable){
  Index *pIndex, *pNext;
# 125162 "c_tests/sqlite3.c"
  for(pIndex = pTable->pIndex; pIndex; pIndex=pNext){
    pNext = pIndex->pNext;
    ((void) (0));

    if( db->pnBytesFreed==0 && !((pTable)->eTabType==1) ){
      char *zName = pIndex->zName;
                                 sqlite3HashInsert(
         &pIndex->pSchema->idxHash, zName, 0
      );
      ((void) (0));
      ((void) (0));
    }
    sqlite3FreeIndex(db, pIndex);
  }

  if( ((pTable)->eTabType==0) ){
    sqlite3FkDelete(db, pTable);
  }

  else if( ((pTable)->eTabType==1) ){
    sqlite3VtabClear(db, pTable);
  }

  else{
    ((void) (0));
    sqlite3SelectDelete(db, pTable->u.view.pSelect);
  }



  sqlite3DeleteColumnNames(db, pTable);
  sqlite3DbFree(db, pTable->zName);
  sqlite3DbFree(db, pTable->zColAff);
  sqlite3ExprListDelete(db, pTable->pCheck);
  sqlite3DbFree(db, pTable);


  ((void) (0));
}
static void sqlite3DeleteTable(sqlite3 *db, Table *pTable){

  ((void) (0));
  if( !pTable ) return;
  if( db->pnBytesFreed==0 && (--pTable->nTabRef)>0 ) return;
  deleteTable(db, pTable);
}
static void sqlite3DeleteTableGeneric(sqlite3 *db, void *pTable){
  sqlite3DeleteTable(db, (Table*)pTable);
}






static void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){
  Table *p;
  Db *pDb;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
                            ;
  pDb = &db->aDb[iDb];
  p = sqlite3HashInsert(&pDb->pSchema->tblHash, zTabName, 0);
  sqlite3DeleteTable(db, p);
  db->mDbFlags |= 0x0001;
}
# 125245 "c_tests/sqlite3.c"
static char *sqlite3NameFromToken(sqlite3 *db, const Token *pName){
  char *zName;
  if( pName ){
    zName = sqlite3DbStrNDup(db, (const char*)pName->z, pName->n);
    sqlite3Dequote(zName);
  }else{
    zName = 0;
  }
  return zName;
}





static void sqlite3OpenSchemaTable(Parse *p, int iDb){
  Vdbe *v = sqlite3GetVdbe(p);
  sqlite3TableLock(p, iDb, 1, 1, "sqlite_master");
  sqlite3VdbeAddOp4Int(v, 114, 0, 1, iDb, 5);
  if( p->nTab==0 ){
    p->nTab = 1;
  }
}







static int sqlite3FindDbName(sqlite3 *db, const char *zName){
  int i = -1;
  if( zName ){
    Db *pDb;
    for(i=(db->nDb-1), pDb=&db->aDb[i]; i>=0; i--, pDb--){
      if( 0==sqlite3_stricmp(pDb->zDbSName, zName) ) break;


      if( i==0 && 0==sqlite3_stricmp("main", zName) ) break;
    }
  }
  return i;
}







static int sqlite3FindDb(sqlite3 *db, Token *pName){
  int i;
  char *zName;
  zName = sqlite3NameFromToken(db, pName);
  i = sqlite3FindDbName(db, zName);
  sqlite3DbFree(db, zName);
  return i;
}
# 125320 "c_tests/sqlite3.c"
static int sqlite3TwoPartName(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  Token **pUnqual
){
  int iDb;
  sqlite3 *db = pParse->db;

  ((void) (0));
  if( pName2->n>0 ){
    if( db->init.busy ) {
      sqlite3ErrorMsg(pParse, "corrupt database");
      return -1;
    }
    *pUnqual = pName2;
    iDb = sqlite3FindDb(db, pName1);
    if( iDb<0 ){
      sqlite3ErrorMsg(pParse, "unknown database %T", pName1);
      return -1;
    }
  }else{
    ((void) (0));

    iDb = db->init.iDb;
    *pUnqual = pName1;
  }
  return iDb;
}




static int sqlite3WritableSchema(sqlite3 *db){
                                                                  ;

                                   ;

                                 ;

                                                      ;
  return (db->flags&(0x00000001|0x10000000))==0x00000001;
}
# 125375 "c_tests/sqlite3.c"
static int sqlite3CheckObjectName(
  Parse *pParse,
  const char *zName,
  const char *zType,
  const char *zTblName
){
  sqlite3 *db = pParse->db;
  if( sqlite3WritableSchema(db)
   || db->init.imposterTable
   || !sqlite3Config.bExtraSchemaChecks
  ){

    return 0;
  }
  if( db->init.busy ){
    if( sqlite3_stricmp(zType, db->init.azInit[0])
     || sqlite3_stricmp(zName, db->init.azInit[1])
     || sqlite3_stricmp(zTblName, db->init.azInit[2])
    ){
      sqlite3ErrorMsg(pParse, "");
      return 1;
    }
  }else{
    if( (pParse->nested==0 && 0==sqlite3_strnicmp(zName, "sqlite_", 7))
     || (sqlite3ReadOnlyShadowTables(db) && sqlite3ShadowTableName(db, zName))
    ){
      sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s",
                      zName);
      return 1;
    }

  }
  return 0;
}




static Index *sqlite3PrimaryKeyIndex(Table *pTab){
  Index *p;
  for(p=pTab->pIndex; p && !((p)->idxType==2); p=p->pNext){}
  return p;
}







static int sqlite3TableColumnToIndex(Index *pIdx, int iCol){
  int i;
  i16 iCol16;
  ((void) (0));
  ((void) (0));
  iCol16 = iCol;
  for(i=0; i<pIdx->nColumn; i++){
    if( iCol16==pIdx->aiColumn[i] ){
      return i;
    }
  }
  return -1;
}
# 125451 "c_tests/sqlite3.c"
static i16 sqlite3StorageColumnToTable(Table *pTab, i16 iCol){
  if( pTab->tabFlags & 0x00000020 ){
    int i;
    for(i=0; i<=iCol; i++){
      if( pTab->aCol[i].colFlags & 0x0020 ) iCol++;
    }
  }
  return iCol;
}
# 125499 "c_tests/sqlite3.c"
static i16 sqlite3TableColumnToStorage(Table *pTab, i16 iCol){
  int i;
  i16 n;
  ((void) (0));
  if( (pTab->tabFlags & 0x00000020)==0 || iCol<0 ) return iCol;
  for(i=0, n=0; i<iCol; i++){
    if( (pTab->aCol[i].colFlags & 0x0020)==0 ) n++;
  }
  if( pTab->aCol[i].colFlags & 0x0020 ){

    return pTab->nNVCol + i - n;
  }else{

    return n;
  }
}
# 125525 "c_tests/sqlite3.c"
static void sqlite3ForceNotReadOnly(Parse *pParse){
  int iReg = ++pParse->nMem;
  Vdbe *v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3VdbeAddOp3(v, 4, 0, iReg, (-1));
    sqlite3VdbeUsesBtree(v, 0);
  }
}
# 125550 "c_tests/sqlite3.c"
static void sqlite3StartTable(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  int isTemp,
  int isView,
  int isVirtual,
  int noErr
){
  Table *pTable;
  char *zName = 0;
  sqlite3 *db = pParse->db;
  Vdbe *v;
  int iDb;
  Token *pName;

  if( db->init.busy && db->init.newTnum==1 ){

    iDb = db->init.iDb;
    zName = sqlite3DbStrDup(db, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"));
    pName = pName1;
  }else{

    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
    if( iDb<0 ) return;
    if( !0 && isTemp && pName2->n>0 && iDb!=1 ){


      sqlite3ErrorMsg(pParse, "temporary table name must be unqualified");
      return;
    }
    if( !0 && isTemp ) iDb = 1;
    zName = sqlite3NameFromToken(db, pName);
    if( (pParse->eParseMode>=2) ){
      sqlite3RenameTokenMap(pParse, (void*)zName, pName);
    }
  }
  pParse->sNameToken = *pName;
  if( zName==0 ) return;
  if( sqlite3CheckObjectName(pParse, zName, isView?"view":"table", zName) ){
    goto begin_table_error;
  }
  if( db->init.iDb==1 ) isTemp = 1;

  ((void) (0));
  ((void) (0));
  {
    static const u8 aCode[] = {
       2,
       4,
       8,
       6
    };
    char *zDb = db->aDb[iDb].zDbSName;
    if( sqlite3AuthCheck(pParse, 18, ((!0)&&(isTemp==1)?"sqlite_temp_master":"sqlite_master"), 0, zDb) ){
      goto begin_table_error;
    }
    if( !isVirtual && sqlite3AuthCheck(pParse, (int)aCode[isTemp+2*isView],
                                       zName, 0, zDb) ){
      goto begin_table_error;
    }
  }
# 125621 "c_tests/sqlite3.c"
  if( !(pParse->eParseMode!=0) ){
    char *zDb = db->aDb[iDb].zDbSName;
    if( 0!=sqlite3ReadSchema(pParse) ){
      goto begin_table_error;
    }
    pTable = sqlite3FindTable(db, zName, zDb);
    if( pTable ){
      if( !noErr ){
        sqlite3ErrorMsg(pParse, "%s %T already exists",
                        (((pTable)->eTabType==2)? "view" : "table"), pName);
      }else{
        ((void) (0));
        sqlite3CodeVerifySchema(pParse, iDb);
        sqlite3ForceNotReadOnly(pParse);
      }
      goto begin_table_error;
    }
    if( sqlite3FindIndex(db, zName, zDb)!=0 ){
      sqlite3ErrorMsg(pParse, "there is already an index named %s", zName);
      goto begin_table_error;
    }
  }

  pTable = sqlite3DbMallocZero(db, sizeof(Table));
  if( pTable==0 ){
    ((void) (0));
    pParse->rc = 7;
    pParse->nErr++;
    goto begin_table_error;
  }
  pTable->zName = zName;
  pTable->iPKey = -1;
  pTable->pSchema = db->aDb[iDb].pSchema;
  pTable->nTabRef = 1;



  pTable->nRowLogEst = 200; ((void) (0));

  ((void) (0));
  pParse->pNewTable = pTable;
# 125671 "c_tests/sqlite3.c"
  if( !db->init.busy && (v = sqlite3GetVdbe(pParse))!=0 ){
    int addr1;
    int fileFormat;
    int reg1, reg2, reg3;

    static const char nullRow[] = { 6, 0, 0, 0, 0, 0 };
    sqlite3BeginWriteOperation(pParse, 1, iDb);


    if( isVirtual ){
      sqlite3VdbeAddOp0(v, 171);
    }





    ((void) (0));
    reg1 = pParse->u1.cr.regRowid = ++pParse->nMem;
    reg2 = pParse->u1.cr.regRoot = ++pParse->nMem;
    reg3 = ++pParse->nMem;
    sqlite3VdbeAddOp3(v, 100, iDb, reg3, 2);
    sqlite3VdbeUsesBtree(v, iDb);
    addr1 = sqlite3VdbeAddOp1(v, 16, reg3); ;
    fileFormat = (db->flags & 0x00000002)!=0 ?
                  1 : 4;
    sqlite3VdbeAddOp3(v, 101, iDb, 2, fileFormat);
    sqlite3VdbeAddOp3(v, 101, iDb, 5, ((db)->enc));
    sqlite3VdbeJumpHere(v, addr1);
# 125711 "c_tests/sqlite3.c"
    if( isView || isVirtual ){
      sqlite3VdbeAddOp2(v, 72, 0, reg2);
    }else

    {
      ((void) (0));
      pParse->u1.cr.addrCrTab =
         sqlite3VdbeAddOp3(v, 148, iDb, reg2, 1);
    }
    sqlite3OpenSchemaTable(pParse, iDb);
    sqlite3VdbeAddOp2(v, 128, 0, reg1);
    sqlite3VdbeAddOp4(v, 78, 6, reg3, 0, nullRow, (-1));
    sqlite3VdbeAddOp3(v, 129, 0, reg3, reg1);
    sqlite3VdbeChangeP5(v, 0x08);
    sqlite3VdbeAddOp0(v, 123);
  }else if( db->init.imposterTable ){
    pTable->tabFlags |= 0x00020000;
    if( db->init.imposterTable>=2 ) pTable->tabFlags |= 0x00000001;
  }


  return;


begin_table_error:
  pParse->checkSchema = 1;
  sqlite3DbFree(db, zName);
  return;
}
# 125758 "c_tests/sqlite3.c"
static void sqlite3DeleteReturning(sqlite3 *db, void *pArg){
  Returning *pRet = (Returning*)pArg;
  Hash *pHash;
  pHash = &(db->aDb[1].pSchema->trigHash);
  sqlite3HashInsert(pHash, pRet->zName, 0);
  sqlite3ExprListDelete(db, pRet->pReturnEL);
  sqlite3DbFree(db, pRet);
}
# 125783 "c_tests/sqlite3.c"
static void sqlite3AddReturning(Parse *pParse, ExprList *pList){
  Returning *pRet;
  Hash *pHash;
  sqlite3 *db = pParse->db;
  if( pParse->pNewTrigger ){
    sqlite3ErrorMsg(pParse, "cannot use RETURNING in a trigger");
  }else{
    ((void) (0));
  }
  pParse->bReturning = 1;
  pRet = sqlite3DbMallocZero(db, sizeof(*pRet));
  if( pRet==0 ){
    sqlite3ExprListDelete(db, pList);
    return;
  }
  ((void) (0));
  pParse->u1.d.pReturning = pRet;
  pRet->pParse = pParse;
  pRet->pReturnEL = pList;
  sqlite3ParserAddCleanup(pParse, sqlite3DeleteReturning, pRet);
                                  ;
  if( db->mallocFailed ) return;
  sqlite3_snprintf(sizeof(pRet->zName), pRet->zName,
                   "sqlite_returning_%p", pParse);
  pRet->retTrig.zName = pRet->zName;
  pRet->retTrig.op = 151;
  pRet->retTrig.tr_tm = 2;
  pRet->retTrig.bReturning = 1;
  pRet->retTrig.pSchema = db->aDb[1].pSchema;
  pRet->retTrig.pTabSchema = db->aDb[1].pSchema;
  pRet->retTrig.step_list = &pRet->retTStep;
  pRet->retTStep.op = 151;
  pRet->retTStep.pTrig = &pRet->retTrig;
  pRet->retTStep.pExprList = pList;
  pHash = &(db->aDb[1].pSchema->trigHash);
  ((void) (0));

  if( sqlite3HashInsert(pHash, pRet->zName, &pRet->retTrig)
          ==&pRet->retTrig ){
    sqlite3OomFault(db);
  }
}
# 125834 "c_tests/sqlite3.c"
static void sqlite3AddColumn(Parse *pParse, Token sName, Token sType){
  Table *p;
  int i;
  char *z;
  char *zType;
  Column *pCol;
  sqlite3 *db = pParse->db;
  Column *aNew;
  u8 eType = 0;
  u8 szEst = 1;
  char affinity = 0x41;

  if( (p = pParse->pNewTable)==0 ) return;
  if( p->nCol+1>db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many columns on %s", p->zName);
    return;
  }
  if( !(pParse->eParseMode>=2) ) sqlite3DequoteToken(&sName);





  if( sType.n>=16
   && sqlite3_strnicmp(sType.z+(sType.n-6),"always",6)==0
  ){
    sType.n -= 6;
    while( (sType.n>0) && (sqlite3CtypeMap[(unsigned char)(sType.z[sType.n-1])]&0x01) ) sType.n--;
    if( sType.n>=9
     && sqlite3_strnicmp(sType.z+(sType.n-9),"generated",9)==0
    ){
      sType.n -= 9;
      while( sType.n>0 && (sqlite3CtypeMap[(unsigned char)(sType.z[sType.n-1])]&0x01) ) sType.n--;
    }
  }




  if( sType.n>=3 ){
    sqlite3DequoteToken(&sType);
    for(i=0; i<6; i++){
       if( sType.n==sqlite3StdTypeLen[i]
        && sqlite3_strnicmp(sType.z, sqlite3StdType[i], sType.n)==0
       ){
         sType.n = 0;
         eType = i+1;
         affinity = sqlite3StdTypeAffinity[i];
         if( affinity<=0x42 ) szEst = 5;
         break;
       }
    }
  }

  z = sqlite3DbMallocRaw(db, (i64)sName.n + 1 + (i64)sType.n + (sType.n>0) );
  if( z==0 ) return;
  if( (pParse->eParseMode>=2) ) sqlite3RenameTokenMap(pParse, (void*)z, &sName);
  memcpy(z, sName.z, sName.n);
  z[sName.n] = 0;
  sqlite3Dequote(z);
  if( p->nCol && sqlite3ColumnIndex(p, z)>=0 ){
    sqlite3ErrorMsg(pParse, "duplicate column name: %s", z);
    sqlite3DbFree(db, z);
    return;
  }
  aNew = sqlite3DbRealloc(db,p->aCol,((i64)p->nCol+1)*sizeof(p->aCol[0]));
  if( aNew==0 ){
    sqlite3DbFree(db, z);
    return;
  }
  p->aCol = aNew;
  pCol = &p->aCol[p->nCol];
  memset(pCol, 0, sizeof(p->aCol[0]));
  pCol->zCnName = z;
  pCol->hName = sqlite3StrIHash(z);
                                          ;

  if( sType.n==0 ){


    pCol->affinity = affinity;
    pCol->eCType = eType;
    pCol->szEst = szEst;







  }else{
    zType = z + sqlite3Strlen30(z) + 1;
    memcpy(zType, sType.z, sType.n);
    zType[sType.n] = 0;
    sqlite3Dequote(zType);
    pCol->affinity = sqlite3AffinityType(zType, pCol);
    pCol->colFlags |= 0x0004;
  }
  if( p->nCol<=0xff ){
    u8 h = pCol->hName % sizeof(p->aHx);
    p->aHx[h] = p->nCol;
  }
  p->nCol++;
  p->nNVCol++;
  ((void) (0));
  pParse->u1.cr.constraintName.n = 0;
}







static void sqlite3AddNotNull(Parse *pParse, int onError){
  Table *p;
  Column *pCol;
  p = pParse->pNewTable;
  if( p==0 || (p->nCol<1) ) return;
  pCol = &p->aCol[p->nCol-1];
  pCol->notNull = (u8)onError;
  p->tabFlags |= 0x00000800;



  if( pCol->colFlags & 0x0008 ){
    Index *pIdx;
    for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
      ((void) (0));
      if( pIdx->aiColumn[0]==p->nCol-1 ){
        pIdx->uniqNotNull = 1;
      }
    }
  }
}
# 125995 "c_tests/sqlite3.c"
static char sqlite3AffinityType(const char *zIn, Column *pCol){
  u32 h = 0;
  char aff = 0x43;
  const char *zChar = 0;

  ((void) (0));
  while( zIn[0] ){
    u8 x = *(u8*)zIn;
    h = (h<<8) + sqlite3UpperToLower[x];
    zIn++;
    if( h==(('c'<<24)+('h'<<16)+('a'<<8)+'r') ){
      aff = 0x42;
      zChar = zIn;
    }else if( h==(('c'<<24)+('l'<<16)+('o'<<8)+'b') ){
      aff = 0x42;
    }else if( h==(('t'<<24)+('e'<<16)+('x'<<8)+'t') ){
      aff = 0x42;
    }else if( h==(('b'<<24)+('l'<<16)+('o'<<8)+'b')
        && (aff==0x43 || aff==0x45) ){
      aff = 0x41;
      if( zIn[0]=='(' ) zChar = zIn;

    }else if( h==(('r'<<24)+('e'<<16)+('a'<<8)+'l')
        && aff==0x43 ){
      aff = 0x45;
    }else if( h==(('f'<<24)+('l'<<16)+('o'<<8)+'a')
        && aff==0x43 ){
      aff = 0x45;
    }else if( h==(('d'<<24)+('o'<<16)+('u'<<8)+'b')
        && aff==0x43 ){
      aff = 0x45;

    }else if( (h&0x00FFFFFF)==(('i'<<16)+('n'<<8)+'t') ){
      aff = 0x44;
      break;
    }
  }



  if( pCol ){
    int v = 0;
    if( aff<0x43 ){
      if( zChar ){
        while( zChar[0] ){
          if( (sqlite3CtypeMap[(unsigned char)(zChar[0])]&0x04) ){

            sqlite3GetInt32(zChar, &v);
            break;
          }
          zChar++;
        }
      }else{
        v = 16;
      }
    }





    v = v/4 + 1;
    if( v>255 ) v = 255;
    pCol->szEst = v;
  }
  return aff;
}
# 126073 "c_tests/sqlite3.c"
static void sqlite3AddDefaultValue(
  Parse *pParse,
  Expr *pExpr,
  const char *zStart,
  const char *zEnd
){
  Table *p;
  Column *pCol;
  sqlite3 *db = pParse->db;
  p = pParse->pNewTable;
  if( p!=0 ){
    int isInit = db->init.busy && db->init.iDb!=1;
    pCol = &(p->aCol[p->nCol-1]);
    if( !sqlite3ExprIsConstantOrFunction(pExpr, isInit) ){
      sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant",
          pCol->zCnName);

    }else if( pCol->colFlags & 0x0060 ){
                                                  ;
                                                 ;
      sqlite3ErrorMsg(pParse, "cannot use DEFAULT on a generated column");

    }else{



      Expr x, *pDfltExpr;
      memset(&x, 0, sizeof(x));
      x.op = 181;
      x.u.zToken = sqlite3DbSpanDup(db, zStart, zEnd);
      x.pLeft = pExpr;
      x.flags = 0x002000;
      pDfltExpr = sqlite3ExprDup(db, &x, 0x0001);
      sqlite3DbFree(db, x.u.zToken);
      sqlite3ColumnSetExpr(pParse, p, pCol, pDfltExpr);
    }
  }
  if( (pParse->eParseMode>=2) ){
    sqlite3RenameExprUnmap(pParse, pExpr);
  }
  sqlite3ExprDelete(db, pExpr);
}
# 126132 "c_tests/sqlite3.c"
static void sqlite3StringToId(Expr *p){
  if( p->op==118 ){
    p->op = 60;
  }else if( p->op==114 && p->pLeft->op==118 ){
    p->pLeft->op = 60;
  }
}




static void makeColumnPartOfPrimaryKey(Parse *pParse, Column *pCol){
  pCol->colFlags |= 0x0001;

  if( pCol->colFlags & 0x0060 ){
                                                ;
                                               ;
    sqlite3ErrorMsg(pParse,
      "generated columns cannot be part of the PRIMARY KEY");
  }

}
# 126173 "c_tests/sqlite3.c"
static void sqlite3AddPrimaryKey(
  Parse *pParse,
  ExprList *pList,
  int onError,
  int autoInc,
  int sortOrder
){
  Table *pTab = pParse->pNewTable;
  Column *pCol = 0;
  int iCol = -1, i;
  int nTerm;
  if( pTab==0 ) goto primary_key_exit;
  if( pTab->tabFlags & 0x00000004 ){
    sqlite3ErrorMsg(pParse,
      "table \"%s\" has more than one primary key", pTab->zName);
    goto primary_key_exit;
  }
  pTab->tabFlags |= 0x00000004;
  if( pList==0 ){
    iCol = pTab->nCol - 1;
    pCol = &pTab->aCol[iCol];
    makeColumnPartOfPrimaryKey(pParse, pCol);
    nTerm = 1;
  }else{
    nTerm = pList->nExpr;
    for(i=0; i<nTerm; i++){
      Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[i].pExpr);
      ((void) (0));
      sqlite3StringToId(pCExpr);
      if( pCExpr->op==60 ){
        ((void) (0));
        iCol = sqlite3ColumnIndex(pTab, pCExpr->u.zToken);
        if( iCol>=0 ){
          pCol = &pTab->aCol[iCol];
          makeColumnPartOfPrimaryKey(pParse, pCol);
        }
      }
    }
  }
  if( nTerm==1
   && pCol
   && pCol->eCType==4
   && sortOrder!=1
  ){
    if( (pParse->eParseMode>=2) && pList ){
      Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[0].pExpr);
      sqlite3RenameTokenRemap(pParse, &pTab->iPKey, pCExpr);
    }
    pTab->iPKey = iCol;
    pTab->keyConf = (u8)onError;
    ((void) (0));
    pTab->tabFlags |= autoInc*0x00000008;
    if( pList ) pParse->iPkSortOrder = pList->a[0].fg.sortFlags;
    (void)sqlite3HasExplicitNulls(pParse, pList);
  }else if( autoInc ){

    sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an "
       "INTEGER PRIMARY KEY");

  }else{
    sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0,
                           0, sortOrder, 0, 2);
    pList = 0;
  }

primary_key_exit:
  sqlite3ExprListDelete(pParse->db, pList);
  return;
}




static void sqlite3AddCheckConstraint(
  Parse *pParse,
  Expr *pCheckExpr,
  const char *zStart,
  const char *zEnd
){

  Table *pTab = pParse->pNewTable;
  sqlite3 *db = pParse->db;
  if( pTab && !(pParse->eParseMode==1)
   && !sqlite3BtreeIsReadonly(db->aDb[db->init.iDb].pBt)
  ){
    pTab->pCheck = sqlite3ExprListAppend(pParse, pTab->pCheck, pCheckExpr);
    ((void) (0));
    if( pParse->u1.cr.constraintName.n ){
      sqlite3ExprListSetName(pParse, pTab->pCheck,
                             &pParse->u1.cr.constraintName, 1);
    }else{
      Token t;
      for(zStart++; (sqlite3CtypeMap[(unsigned char)(zStart[0])]&0x01); zStart++){}
      while( (sqlite3CtypeMap[(unsigned char)(zEnd[-1])]&0x01) ){ zEnd--; }
      t.z = zStart;
      t.n = (int)(zEnd - t.z);
      sqlite3ExprListSetName(pParse, pTab->pCheck, &t, 1);
    }
  }else

  {
    sqlite3ExprDelete(pParse->db, pCheckExpr);
  }
}





static void sqlite3AddCollateType(Parse *pParse, Token *pToken){
  Table *p;
  int i;
  char *zColl;
  sqlite3 *db;

  if( (p = pParse->pNewTable)==0 || (pParse->eParseMode>=2) ) return;
  i = p->nCol-1;
  db = pParse->db;
  zColl = sqlite3NameFromToken(db, pToken);
  if( !zColl ) return;

  if( sqlite3LocateCollSeq(pParse, zColl) ){
    Index *pIdx;
    sqlite3ColumnSetColl(db, &p->aCol[i], zColl);





    for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
      ((void) (0));
      if( pIdx->aiColumn[0]==i ){
        pIdx->azColl[0] = sqlite3ColumnColl(&p->aCol[i]);
      }
    }
  }
  sqlite3DbFree(db, zColl);
}




static void sqlite3AddGenerated(Parse *pParse, Expr *pExpr, Token *pType){

  u8 eType = 0x0020;
  Table *pTab = pParse->pNewTable;
  Column *pCol;
  if( pTab==0 ){

    goto generated_done;
  }
  pCol = &(pTab->aCol[pTab->nCol-1]);
  if( (pParse->eParseMode==1) ){
    sqlite3ErrorMsg(pParse, "virtual tables cannot use computed columns");
    goto generated_done;
  }
  if( pCol->iDflt>0 ) goto generated_error;
  if( pType ){
    if( pType->n==7 && sqlite3_strnicmp("virtual",pType->z,7)==0 ){

    }else if( pType->n==6 && sqlite3_strnicmp("stored",pType->z,6)==0 ){
      eType = 0x0040;
    }else{
      goto generated_error;
    }
  }
  if( eType==0x0020 ) pTab->nNVCol--;
  pCol->colFlags |= eType;
  ((void) (0));
  ((void) (0));
  pTab->tabFlags |= eType;
  if( pCol->colFlags & 0x0001 ){
    makeColumnPartOfPrimaryKey(pParse, pCol);
  }
  if( (pExpr) && pExpr->op==60 ){




    pExpr = sqlite3PExpr(pParse, 173, pExpr, 0);
  }
  if( pExpr && pExpr->op!=72 ) pExpr->affExpr = pCol->affinity;
  sqlite3ColumnSetExpr(pParse, pTab, pCol, pExpr);
  pExpr = 0;
  goto generated_done;

generated_error:
  sqlite3ErrorMsg(pParse, "error in generated column \"%s\"",
                  pCol->zCnName);
generated_done:
  sqlite3ExprDelete(pParse->db, pExpr);






}
# 126391 "c_tests/sqlite3.c"
static void sqlite3ChangeCookie(Parse *pParse, int iDb){
  sqlite3 *db = pParse->db;
  Vdbe *v = pParse->pVdbe;
  ((void) (0));
  sqlite3VdbeAddOp3(v, 101, iDb, 1,
                   (int)(1+(unsigned)db->aDb[iDb].pSchema->schema_cookie));
}
# 126407 "c_tests/sqlite3.c"
static int identLength(const char *z){
  int n;
  for(n=0; *z; n++, z++){
    if( *z=='"' ){ n++; }
  }
  return n + 2;
}
# 126428 "c_tests/sqlite3.c"
static void identPut(char *z, int *pIdx, char *zSignedIdent){
  unsigned char *zIdent = (unsigned char*)zSignedIdent;
  int i, j, needQuote;
  i = *pIdx;

  for(j=0; zIdent[j]; j++){
    if( !(sqlite3CtypeMap[(unsigned char)(zIdent[j])]&0x06) && zIdent[j]!='_' ) break;
  }
  needQuote = (sqlite3CtypeMap[(unsigned char)(zIdent[0])]&0x04)
            || sqlite3KeywordCode(zIdent, j)!=60
            || zIdent[j]!=0
            || j==0;

  if( needQuote ) z[i++] = '"';
  for(j=0; zIdent[j]; j++){
    z[i++] = zIdent[j];
    if( zIdent[j]=='"' ) z[i++] = '"';
  }
  if( needQuote ) z[i++] = '"';
  z[i] = 0;
  *pIdx = i;
}






static char *createTableStmt(sqlite3 *db, Table *p){
  int i, k, len;
  i64 n;
  char *zStmt;
  char *zSep, *zSep2, *zEnd;
  Column *pCol;
  n = 0;
  for(pCol = p->aCol, i=0; i<p->nCol; i++, pCol++){
    n += identLength(pCol->zCnName) + 5;
  }
  n += identLength(p->zName);
  if( n<50 ){
    zSep = "";
    zSep2 = ",";
    zEnd = ")";
  }else{
    zSep = "\n  ";
    zSep2 = ",\n  ";
    zEnd = "\n)";
  }
  n += 35 + 6*p->nCol;
  zStmt = sqlite3DbMallocRaw(0, n);
  if( zStmt==0 ){
    sqlite3OomFault(db);
    return 0;
  }
  ((void) (0));
  memcpy(zStmt, "CREATE TABLE ", 13);
  k = 13;
  identPut(zStmt, &k, p->zName);
  zStmt[k++] = '(';
  for(pCol=p->aCol, i=0; i<p->nCol; i++, pCol++){
    static const char * const azType[] = {
                                 "",
                                 " TEXT",
                                 " NUM",
                                 " INT",
                                 " REAL",
                                 " NUM",
    };
    const char *zType;

    len = sqlite3Strlen30(zSep);
    ((void) (0));
    memcpy(&zStmt[k], zSep, len);
    k += len;
    zSep = zSep2;
    identPut(zStmt, &k, pCol->zCnName);
    ((void) (0));
    ((void) (0));
    ((void) (0));
                                               ;
                                               ;
                                                  ;
                                                  ;
                                               ;
                                                  ;

    zType = azType[pCol->affinity - 0x41];
    len = sqlite3Strlen30(zType);
    ((void) (0));


    ((void) (0));
    memcpy(&zStmt[k], zType, len);
    k += len;
    ((void) (0));
  }
  len = sqlite3Strlen30(zEnd);
  ((void) (0));
  memcpy(&zStmt[k], zEnd, len+1);
  return zStmt;
}





static int resizeIndexObject(Parse *pParse, Index *pIdx, int N){
  char *zExtra;
  u64 nByte;
  sqlite3 *db;
  if( pIdx->nColumn>=N ) return 0;
  db = pParse->db;
  ((void) (0));
  ((void) (0));
                                                          ;
  ((void) (0));
  nByte = (sizeof(char*) + sizeof(LogEst) + sizeof(i16) + 1)*(u64)N;
  zExtra = sqlite3DbMallocZero(db, nByte);
  if( zExtra==0 ) return 7;
  memcpy(zExtra, pIdx->azColl, sizeof(char*)*pIdx->nColumn);
  pIdx->azColl = (const char**)zExtra;
  zExtra += sizeof(char*)*N;
  memcpy(zExtra, pIdx->aiRowLogEst, sizeof(LogEst)*(pIdx->nKeyCol+1));
  pIdx->aiRowLogEst = (LogEst*)zExtra;
  zExtra += sizeof(LogEst)*N;
  memcpy(zExtra, pIdx->aiColumn, sizeof(i16)*pIdx->nColumn);
  pIdx->aiColumn = (i16*)zExtra;
  zExtra += sizeof(i16)*N;
  memcpy(zExtra, pIdx->aSortOrder, pIdx->nColumn);
  pIdx->aSortOrder = (u8*)zExtra;
  pIdx->nColumn = (u16)N;
  pIdx->isResized = 1;
  return 0;
}




static void estimateTableWidth(Table *pTab){
  unsigned wTable = 0;
  const Column *pTabCol;
  int i;
  for(i=pTab->nCol, pTabCol=pTab->aCol; i>0; i--, pTabCol++){
    wTable += pTabCol->szEst;
  }
  if( pTab->iPKey<0 ) wTable++;
  pTab->szTabRow = sqlite3LogEst(wTable*4);
}




static void estimateIndexWidth(Index *pIdx){
  unsigned wIndex = 0;
  int i;
  const Column *aCol = pIdx->pTable->aCol;
  for(i=0; i<pIdx->nColumn; i++){
    i16 x = pIdx->aiColumn[i];
    ((void) (0));
    wIndex += x<0 ? 1 : aCol[x].szEst;
  }
  pIdx->szIdxRow = sqlite3LogEst(wIndex*4);
}





static int hasColumn(const i16 *aiCol, int nCol, int x){
  while( nCol-- > 0 ){
    if( x==*(aiCol++) ){
      return 1;
    }
  }
  return 0;
}
# 126618 "c_tests/sqlite3.c"
static int isDupColumn(Index *pIdx, int nKey, Index *pPk, int iCol){
  int i, j;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
                       ;
  j = pPk->aiColumn[iCol];
  ((void) (0));
  for(i=0; i<nKey; i++){
    ((void) (0));
    if( pIdx->aiColumn[i]==j
     && sqlite3StrICmp(pIdx->azColl[i], pPk->azColl[iCol])==0
    ){
      return 1;
    }
  }
  return 0;
}
# 126658 "c_tests/sqlite3.c"
static void recomputeColumnsNotIndexed(Index *pIdx){
  Bitmask m = 0;
  int j;
  Table *pTab = pIdx->pTable;
  for(j=pIdx->nColumn-1; j>=0; j--){
    int x = pIdx->aiColumn[j];
    if( x>=0 && (pTab->aCol[x].colFlags & 0x0020)==0 ){
                          ;
                          ;
      if( x<((int)(sizeof(Bitmask)*8))-1 ) m |= (((Bitmask)1)<<(x));
    }
  }
  pIdx->colNotIdxed = ~m;
  ((void) (0));
}
# 126698 "c_tests/sqlite3.c"
static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){
  Index *pIdx;
  Index *pPk;
  int nPk;
  int nExtra;
  int i, j;
  sqlite3 *db = pParse->db;
  Vdbe *v = pParse->pVdbe;



  if( !db->init.imposterTable ){
    for(i=0; i<pTab->nCol; i++){
      if( (pTab->aCol[i].colFlags & 0x0001)!=0
       && (pTab->aCol[i].notNull==0)
      ){
        pTab->aCol[i].notNull = 2;
      }
    }
    pTab->tabFlags |= 0x00000800;
  }




  ((void) (0));
  if( pParse->u1.cr.addrCrTab ){
    ((void) (0));
    sqlite3VdbeChangeP3(v, pParse->u1.cr.addrCrTab, 2);
  }




  if( pTab->iPKey>=0 ){
    ExprList *pList;
    Token ipkToken;
    sqlite3TokenInit(&ipkToken, pTab->aCol[pTab->iPKey].zCnName);
    pList = sqlite3ExprListAppend(pParse, 0,
                  sqlite3ExprAlloc(db, 60, &ipkToken, 0));
    if( pList==0 ){
      pTab->tabFlags &= ~0x00000080;
      return;
    }
    if( (pParse->eParseMode>=2) ){
      sqlite3RenameTokenRemap(pParse, pList->a[0].pExpr, &pTab->iPKey);
    }
    pList->a[0].fg.sortFlags = pParse->iPkSortOrder;
    ((void) (0));
    pTab->iPKey = -1;
    sqlite3CreateIndex(pParse, 0, 0, 0, pList, pTab->keyConf, 0, 0, 0, 0,
                       2);
    if( pParse->nErr ){
      pTab->tabFlags &= ~0x00000080;
      return;
    }
    ((void) (0));
    pPk = sqlite3PrimaryKeyIndex(pTab);
    ((void) (0));
  }else{
    pPk = sqlite3PrimaryKeyIndex(pTab);
    ((void) (0));






    for(i=j=1; i<pPk->nKeyCol; i++){
      if( isDupColumn(pPk, j, pPk, i) ){
        pPk->nColumn--;
      }else{
                                                                 ;
        pPk->azColl[j] = pPk->azColl[i];
        pPk->aSortOrder[j] = pPk->aSortOrder[i];
        pPk->aiColumn[j++] = pPk->aiColumn[i];
      }
    }
    pPk->nKeyCol = j;
  }
  ((void) (0));
  pPk->isCovering = 1;
  if( !db->init.imposterTable ) pPk->uniqNotNull = 1;
  nPk = pPk->nColumn = pPk->nKeyCol;





  if( v && pPk->tnum>0 ){
    ((void) (0));
    sqlite3VdbeChangeOpcode(v, (int)pPk->tnum, 9);
  }


  pPk->tnum = pTab->tnum;




  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    int n;
    if( ((pIdx)->idxType==2) ) continue;
    for(i=n=0; i<nPk; i++){
      if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){
                                                                              ;
        n++;
      }
    }
    if( n==0 ){

      pIdx->nColumn = pIdx->nKeyCol;
      continue;
    }
    if( resizeIndexObject(pParse, pIdx, pIdx->nKeyCol+n) ) return;
    for(i=0, j=pIdx->nKeyCol; i<nPk; i++){
      if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){
                                                                              ;
        pIdx->aiColumn[j] = pPk->aiColumn[i];
        pIdx->azColl[j] = pPk->azColl[i];
        if( pPk->aSortOrder[i] ){

          pIdx->bAscKeyBug = 1;
        }
        j++;
      }
    }
    ((void) (0));
    ((void) (0));
  }



  nExtra = 0;
  for(i=0; i<pTab->nCol; i++){
    if( !hasColumn(pPk->aiColumn, nPk, i)
     && (pTab->aCol[i].colFlags & 0x0020)==0 ) nExtra++;
  }
  if( resizeIndexObject(pParse, pPk, nPk+nExtra) ) return;
  for(i=0, j=nPk; i<pTab->nCol; i++){
    if( !hasColumn(pPk->aiColumn, j, i)
     && (pTab->aCol[i].colFlags & 0x0020)==0
    ){
      ((void) (0));
      pPk->aiColumn[j] = i;
      pPk->azColl[j] = sqlite3StrBINARY;
      j++;
    }
  }
  ((void) (0));
  ((void) (0));
  recomputeColumnsNotIndexed(pPk);
}







static int sqlite3IsShadowTableOf(sqlite3 *db, Table *pTab, const char *zName){
  int nName;
  Module *pMod;

  if( !((pTab)->eTabType==1) ) return 0;
  nName = sqlite3Strlen30(pTab->zName);
  if( sqlite3_strnicmp(zName, pTab->zName, nName)!=0 ) return 0;
  if( zName[nName]!='_' ) return 0;
  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->u.vtab.azArg[0]);
  if( pMod==0 ) return 0;
  if( pMod->pModule->iVersion<3 ) return 0;
  if( pMod->pModule->xShadowName==0 ) return 0;
  return pMod->pModule->xShadowName(zName+nName+1);
}
# 126881 "c_tests/sqlite3.c"
static void sqlite3MarkAllShadowTablesOf(sqlite3 *db, Table *pTab){
  int nName;
  Module *pMod;
  HashElem *k;

  ((void) (0));
  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->u.vtab.azArg[0]);
  if( pMod==0 ) return;
  if( (pMod->pModule==0) ) return;
  if( pMod->pModule->iVersion<3 ) return;
  if( pMod->pModule->xShadowName==0 ) return;
  ((void) (0));
  nName = sqlite3Strlen30(pTab->zName);
  for(k=((&pTab->pSchema->tblHash)->first); k; k=((k)->next)){
    Table *pOther = ((k)->data);
    ((void) (0));
    if( !((pOther)->eTabType==0) ) continue;
    if( pOther->tabFlags & 0x00001000 ) continue;
    if( sqlite3_strnicmp(pOther->zName, pTab->zName, nName)==0
     && pOther->zName[nName]=='_'
     && pMod->pModule->xShadowName(pOther->zName+nName+1)
    ){
      pOther->tabFlags |= 0x00001000;
    }
  }
}
# 126917 "c_tests/sqlite3.c"
static int sqlite3ShadowTableName(sqlite3 *db, const char *zName){
  char *zTail;
  Table *pTab;
  zTail = strrchr(zName, '_');
  if( zTail==0 ) return 0;
  *zTail = 0;
  pTab = sqlite3FindTable(db, zName, 0);
  *zTail = '_';
  if( pTab==0 ) return 0;
  if( !((pTab)->eTabType==1) ) return 0;
  return sqlite3IsShadowTableOf(db, pTab, zName);
}
# 126979 "c_tests/sqlite3.c"
static void sqlite3EndTable(
  Parse *pParse,
  Token *pCons,
  Token *pEnd,
  u32 tabOpts,
  Select *pSelect
){
  Table *p;
  sqlite3 *db = pParse->db;
  int iDb;
  Index *pIdx;

  if( pEnd==0 && pSelect==0 ){
    return;
  }
  p = pParse->pNewTable;
  if( p==0 ) return;

  if( pSelect==0 && sqlite3ShadowTableName(db, p->zName) ){
    p->tabFlags |= 0x00001000;
  }
# 127010 "c_tests/sqlite3.c"
  if( db->init.busy ){
    if( pSelect || (!((p)->eTabType==0) && db->init.newTnum) ){
      sqlite3ErrorMsg(pParse, "");
      return;
    }
    p->tnum = db->init.newTnum;
    if( p->tnum==1 ) p->tabFlags |= 0x00000001;
  }
# 127028 "c_tests/sqlite3.c"
  if( tabOpts & 0x00010000 ){
    int ii;
    p->tabFlags |= 0x00010000;
    for(ii=0; ii<p->nCol; ii++){
      Column *pCol = &p->aCol[ii];
      if( pCol->eCType==0 ){
        if( pCol->colFlags & 0x0004 ){
          sqlite3ErrorMsg(pParse,
            "unknown datatype for %s.%s: \"%s\"",
            p->zName, pCol->zCnName, sqlite3ColumnType(pCol, "")
          );
        }else{
          sqlite3ErrorMsg(pParse, "missing datatype for %s.%s",
                          p->zName, pCol->zCnName);
        }
        return;
      }else if( pCol->eCType==1 ){
        pCol->affinity = 0x41;
      }
      if( (pCol->colFlags & 0x0001)!=0
       && p->iPKey!=ii
       && pCol->notNull == 0
      ){
        pCol->notNull = 2;
        p->tabFlags |= 0x00000800;
      }
    }
  }

  ((void) (0));

  ((void) (0));



  if( tabOpts & 0x00000080 ){
    if( (p->tabFlags & 0x00000008) ){
      sqlite3ErrorMsg(pParse,
          "AUTOINCREMENT not allowed on WITHOUT ROWID tables");
      return;
    }
    if( (p->tabFlags & 0x00000004)==0 ){
      sqlite3ErrorMsg(pParse, "PRIMARY KEY missing on table %s", p->zName);
      return;
    }
    p->tabFlags |= 0x00000080 | 0x00000200;
    convertToWithoutRowidTable(pParse, p);
  }
  iDb = sqlite3SchemaToIndex(db, p->pSchema);




  if( p->pCheck ){
    sqlite3ResolveSelfReference(pParse, p, 0x000004, 0, p->pCheck);
    if( pParse->nErr ){


      sqlite3ExprListDelete(db, p->pCheck);
      p->pCheck = 0;
    }else{
                                      ;
    }
  }


  if( p->tabFlags & 0x00000060 ){
    int ii, nNG = 0;
                                           ;
                                          ;
    for(ii=0; ii<p->nCol; ii++){
      u32 colFlags = p->aCol[ii].colFlags;
      if( (colFlags & 0x0060)!=0 ){
        Expr *pX = sqlite3ColumnExpr(p, &p->aCol[ii]);
                                              ;
                                             ;
        if( sqlite3ResolveSelfReference(pParse, p, 0x000008, pX, 0) ){






          sqlite3ColumnSetExpr(pParse, p, &p->aCol[ii],
               sqlite3ExprAlloc(db, 122, 0, 0));
        }
      }else{
        nNG++;
      }
    }
    if( nNG==0 ){
      sqlite3ErrorMsg(pParse, "must have at least one non-generated column");
      return;
    }
  }



  estimateTableWidth(p);
  for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
    estimateIndexWidth(pIdx);
  }







  if( !db->init.busy ){
    int n;
    Vdbe *v;
    char *zType;
    char *zType2;
    char *zStmt;

    v = sqlite3GetVdbe(pParse);
    if( (v==0) ) return;

    sqlite3VdbeAddOp1(v, 123, 0);




    if( ((p)->eTabType==0) ){

      zType = "table";
      zType2 = "TABLE";

    }else{

      zType = "view";
      zType2 = "VIEW";

    }
# 127177 "c_tests/sqlite3.c"
    if( pSelect ){
      SelectDest dest;
      int regYield;
      int addrTop;
      int regRec;
      int regRowid;
      int addrInsLoop;
      Table *pSelTab;
      int iCsr;

      if( (pParse->eParseMode!=0) ){
        pParse->rc = 1;
        pParse->nErr++;
        return;
      }
      iCsr = pParse->nTab++;
      regYield = ++pParse->nMem;
      regRec = ++pParse->nMem;
      regRowid = ++pParse->nMem;
      sqlite3MayAbort(pParse);
      ((void) (0));
      sqlite3VdbeAddOp3(v, 114, iCsr, pParse->u1.cr.regRoot, iDb);
      sqlite3VdbeChangeP5(v, 0x10);
      addrTop = sqlite3VdbeCurrentAddr(v) + 1;
      sqlite3VdbeAddOp3(v, 11, regYield, 0, addrTop);
      if( pParse->nErr ) return;
      pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, 0x41);
      if( pSelTab==0 ) return;
      ((void) (0));
      p->nCol = p->nNVCol = pSelTab->nCol;
      p->aCol = pSelTab->aCol;
      pSelTab->nCol = 0;
      pSelTab->aCol = 0;
      sqlite3DeleteTable(db, pSelTab);
      sqlite3SelectDestInit(&dest, 13, regYield);
      sqlite3Select(pParse, pSelect, &dest);
      if( pParse->nErr ) return;
      sqlite3VdbeEndCoroutine(v, regYield);
      sqlite3VdbeJumpHere(v, addrTop - 1);
      addrInsLoop = sqlite3VdbeAddOp1(v, 12, dest.iSDParm);
                     ;
      sqlite3VdbeAddOp3(v, 98, dest.iSdst, dest.nSdst, regRec);
      sqlite3TableAffinity(v, p, 0);
      sqlite3VdbeAddOp2(v, 128, iCsr, regRowid);
      sqlite3VdbeAddOp3(v, 129, iCsr, regRec, regRowid);
      sqlite3VdbeGoto(v, addrInsLoop);
      sqlite3VdbeJumpHere(v, addrInsLoop);
      sqlite3VdbeAddOp1(v, 123, iCsr);
    }


    if( pSelect ){
      zStmt = createTableStmt(db, p);
    }else{
      Token *pEnd2 = tabOpts ? &pParse->sLastToken : pEnd;
      n = (int)(pEnd2->z - pParse->sNameToken.z);
      if( pEnd2->z[0]!=';' ) n += pEnd2->n;
      zStmt = sqlite3MPrintf(db,
          "CREATE %s %.*s", zType2, n, pParse->sNameToken.z
      );
    }





    ((void) (0));
    sqlite3NestedParse(pParse,
      "UPDATE %Q." "sqlite_master"
      " SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q"
      " WHERE rowid=#%d",
      db->aDb[iDb].zDbSName,
      zType,
      p->zName,
      p->zName,
      pParse->u1.cr.regRoot,
      zStmt,
      pParse->u1.cr.regRowid
    );
    sqlite3DbFree(db, zStmt);
    sqlite3ChangeCookie(pParse, iDb);





    if( (p->tabFlags & 0x00000008)!=0 && !(pParse->eParseMode!=0) ){
      Db *pDb = &db->aDb[iDb];
      ((void) (0));
      if( pDb->pSchema->pSeqTab==0 ){
        sqlite3NestedParse(pParse,
          "CREATE TABLE %Q.sqlite_sequence(name,seq)",
          pDb->zDbSName
        );
      }
    }



    sqlite3VdbeAddParseSchemaOp(v, iDb,
           sqlite3MPrintf(db, "tbl_name='%q' AND type!='trigger'", p->zName),0);



    if( p->tabFlags & 0x00000060 ){
      sqlite3VdbeAddOp4(v, 149, 0x0001, 0, 0,
             sqlite3MPrintf(db, "SELECT*FROM\"%w\".\"%w\"",
                   db->aDb[iDb].zDbSName, p->zName), (-6));
    }
  }



  if( db->init.busy ){
    Table *pOld;
    Schema *pSchema = p->pSchema;
    ((void) (0));
    ((void) (0));
    pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, p);
    if( pOld ){
      ((void) (0));
      sqlite3OomFault(db);
      return;
    }
    pParse->pNewTable = 0;
    db->mDbFlags |= 0x0001;




    ((void) (0));

    if( strcmp(p->zName, "sqlite_sequence")==0 ){
      ((void) (0));
      p->pSchema->pSeqTab = p;
    }

  }


  if( !pSelect && ((p)->eTabType==0) ){
    ((void) (0));
    if( pCons->z==0 ){
      pCons = pEnd;
    }
    p->u.tab.addColOffset = 13 + (int)(pCons->z - pParse->sNameToken.z);
  }

}





static void sqlite3CreateView(
  Parse *pParse,
  Token *pBegin,
  Token *pName1,
  Token *pName2,
  ExprList *pCNames,
  Select *pSelect,
  int isTemp,
  int noErr
){
  Table *p;
  int n;
  const char *z;
  Token sEnd;
  DbFixer sFix;
  Token *pName = 0;
  int iDb;
  sqlite3 *db = pParse->db;

  if( pParse->nVar>0 ){
    sqlite3ErrorMsg(pParse, "parameters are not allowed in views");
    goto create_view_fail;
  }
  sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);
  p = pParse->pNewTable;
  if( p==0 || pParse->nErr ) goto create_view_fail;
# 127367 "c_tests/sqlite3.c"
  p->tabFlags |= 0x00000200;


  sqlite3TwoPartName(pParse, pName1, pName2, &pName);
  iDb = sqlite3SchemaToIndex(db, p->pSchema);
  sqlite3FixInit(&sFix, pParse, iDb, "view", pName);
  if( sqlite3FixSelect(&sFix, pSelect) ) goto create_view_fail;






  pSelect->selFlags |= 0x0200000;
  if( (pParse->eParseMode>=2) ){
    p->u.view.pSelect = pSelect;
    pSelect = 0;
  }else{
    p->u.view.pSelect = sqlite3SelectDup(db, pSelect, 0x0001);
  }
  p->pCheck = sqlite3ExprListDup(db, pCNames, 0x0001);
  p->eTabType = 2;
  if( db->mallocFailed ) goto create_view_fail;




  sEnd = pParse->sLastToken;
  ((void) (0));
  if( sEnd.z[0]!=';' ){
    sEnd.z += sEnd.n;
  }
  sEnd.n = 0;
  n = (int)(sEnd.z - pBegin->z);
  ((void) (0));
  z = pBegin->z;
  while( (sqlite3CtypeMap[(unsigned char)(z[n-1])]&0x01) ){ n--; }
  sEnd.z = &z[n-1];
  sEnd.n = 1;


  sqlite3EndTable(pParse, 0, &sEnd, 0, 0);

create_view_fail:
  sqlite3SelectDelete(db, pSelect);
  if( (pParse->eParseMode>=2) ){
    sqlite3RenameExprlistUnmap(pParse, pCNames);
  }
  sqlite3ExprListDelete(db, pCNames);
  return;
}
# 127427 "c_tests/sqlite3.c"
static __attribute__((noinline)) int viewGetColumnNames(Parse *pParse, Table *pTable){
  Table *pSelTab;
  Select *pSel;
  int nErr = 0;
  sqlite3 *db = pParse->db;

  int rc;


  sqlite3_xauth xAuth;


  ((void) (0));


  if( ((pTable)->eTabType==1) ){
    db->nSchemaLock++;
    rc = sqlite3VtabCallConnect(pParse, pTable);
    db->nSchemaLock--;
    return rc;
  }







  ((void) (0));
# 127472 "c_tests/sqlite3.c"
  if( pTable->nCol<0 ){
    sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable->zName);
    return 1;
  }
  ((void) (0));
# 127485 "c_tests/sqlite3.c"
  ((void) (0));
  pSel = sqlite3SelectDup(db, pTable->u.view.pSelect, 0);
  if( pSel ){
    u8 eParseMode = pParse->eParseMode;
    int nTab = pParse->nTab;
    int nSelect = pParse->nSelect;
    pParse->eParseMode = 0;
    sqlite3SrcListAssignCursors(pParse, pSel->pSrc);
    pTable->nCol = -1;
    db->lookaside.bDisable++;db->lookaside.sz=0;

    xAuth = db->xAuth;
    db->xAuth = 0;
    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, 0x40);
    db->xAuth = xAuth;



    pParse->nTab = nTab;
    pParse->nSelect = nSelect;
    if( pSelTab==0 ){
      pTable->nCol = 0;
      nErr++;
    }else if( pTable->pCheck ){






      sqlite3ColumnsFromExprList(pParse, pTable->pCheck,
                                 &pTable->nCol, &pTable->aCol);
      if( pParse->nErr==0
       && pTable->nCol==pSel->pEList->nExpr
      ){
        ((void) (0));
        sqlite3SubqueryColumnTypes(pParse, pTable, pSel, 0x40);
      }
    }else{



      ((void) (0));
      pTable->nCol = pSelTab->nCol;
      pTable->aCol = pSelTab->aCol;
      pTable->tabFlags |= (pSelTab->tabFlags & 0x0062);
      pSelTab->nCol = 0;
      pSelTab->aCol = 0;
      ((void) (0));
    }
    pTable->nNVCol = pTable->nCol;
    sqlite3DeleteTable(db, pSelTab);
    sqlite3SelectDelete(db, pSel);
    db->lookaside.bDisable--; db->lookaside.sz=db->lookaside.bDisable?0:db->lookaside.szTrue;
    pParse->eParseMode = eParseMode;
  } else {
    nErr++;
  }
  pTable->pSchema->schemaFlags |= 0x0002;
  if( db->mallocFailed ){
    sqlite3DeleteColumnNames(db, pTable);
  }

  return nErr + pParse->nErr;
}
static int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){
  ((void) (0));
  if( !((pTable)->eTabType==1) && pTable->nCol>0 ) return 0;
  return viewGetColumnNames(pParse, pTable);
}






static void sqliteViewResetAll(sqlite3 *db, int idx){
  HashElem *i;
  ((void) (0));
  if( !(((db)->aDb[idx].pSchema->schemaFlags&(0x0002))==(0x0002)) ) return;
  for(i=((&db->aDb[idx].pSchema->tblHash)->first); i;i=((i)->next)){
    Table *pTab = ((i)->data);
    if( ((pTab)->eTabType==2) ){
      sqlite3DeleteColumnNames(db, pTab);
    }
  }
  (db)->aDb[idx].pSchema->schemaFlags&=~(0x0002);
}
# 127595 "c_tests/sqlite3.c"
static void sqlite3RootPageMoved(sqlite3 *db, int iDb, Pgno iFrom, Pgno iTo){
  HashElem *pElem;
  Hash *pHash;
  Db *pDb;

  ((void) (0));
  pDb = &db->aDb[iDb];
  pHash = &pDb->pSchema->tblHash;
  for(pElem=((pHash)->first); pElem; pElem=((pElem)->next)){
    Table *pTab = ((pElem)->data);
    if( pTab->tnum==iFrom ){
      pTab->tnum = iTo;
    }
  }
  pHash = &pDb->pSchema->idxHash;
  for(pElem=((pHash)->first); pElem; pElem=((pElem)->next)){
    Index *pIdx = ((pElem)->data);
    if( pIdx->tnum==iFrom ){
      pIdx->tnum = iTo;
    }
  }
}
# 127625 "c_tests/sqlite3.c"
static void destroyRootPage(Parse *pParse, int iTable, int iDb){
  Vdbe *v = sqlite3GetVdbe(pParse);
  int r1 = sqlite3GetTempReg(pParse);
  if( iTable<2 ) sqlite3ErrorMsg(pParse, "corrupt schema");
  sqlite3VdbeAddOp3(v, 145, iTable, r1, iDb);
  sqlite3MayAbort(pParse);
# 127641 "c_tests/sqlite3.c"
  sqlite3NestedParse(pParse,
     "UPDATE %Q." "sqlite_master"
     " SET rootpage=%d WHERE #%d AND rootpage=#%d",
     pParse->db->aDb[iDb].zDbSName, iTable, r1, r1);

  sqlite3ReleaseTempReg(pParse, r1);
}







static void destroyTable(Parse *pParse, Table *pTab){
# 127672 "c_tests/sqlite3.c"
  Pgno iTab = pTab->tnum;
  Pgno iDestroyed = 0;

  while( 1 ){
    Index *pIdx;
    Pgno iLargest = 0;

    if( iDestroyed==0 || iTab<iDestroyed ){
      iLargest = iTab;
    }
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      Pgno iIdx = pIdx->tnum;
      ((void) (0));
      if( (iDestroyed==0 || (iIdx<iDestroyed)) && iIdx>iLargest ){
        iLargest = iIdx;
      }
    }
    if( iLargest==0 ){
      return;
    }else{
      int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
      ((void) (0));
      destroyRootPage(pParse, iLargest, iDb);
      iDestroyed = iLargest;
    }
  }
}





static void sqlite3ClearStatTables(
  Parse *pParse,
  int iDb,
  const char *zType,
  const char *zName
){
  int i;
  const char *zDbName = pParse->db->aDb[iDb].zDbSName;
  for(i=1; i<=4; i++){
    char zTab[24];
    sqlite3_snprintf(sizeof(zTab),zTab,"sqlite_stat%d",i);
    if( sqlite3FindTable(pParse->db, zTab, zDbName) ){
      sqlite3NestedParse(pParse,
        "DELETE FROM %Q.%s WHERE %s=%Q",
        zDbName, zTab, zType, zName
      );
    }
  }
}




static void sqlite3CodeDropTable(Parse *pParse, Table *pTab, int iDb, int isView){
  Vdbe *v;
  sqlite3 *db = pParse->db;
  Trigger *pTrigger;
  Db *pDb = &db->aDb[iDb];

  v = sqlite3GetVdbe(pParse);
  ((void) (0));
  sqlite3BeginWriteOperation(pParse, 1, iDb);


  if( ((pTab)->eTabType==1) ){
    sqlite3VdbeAddOp0(v, 171);
  }






  pTrigger = sqlite3TriggerList(pParse, pTab);
  while( pTrigger ){
    ((void) (0));

    sqlite3DropTriggerPtr(pParse, pTrigger);
    pTrigger = pTrigger->pNext;
  }







  if( pTab->tabFlags & 0x00000008 ){
    sqlite3NestedParse(pParse,
      "DELETE FROM %Q.sqlite_sequence WHERE name=%Q",
      pDb->zDbSName, pTab->zName
    );
  }
# 127776 "c_tests/sqlite3.c"
  sqlite3NestedParse(pParse,
      "DELETE FROM %Q." "sqlite_master"
      " WHERE tbl_name=%Q and type!='trigger'",
      pDb->zDbSName, pTab->zName);
  if( !isView && !((pTab)->eTabType==1) ){
    destroyTable(pParse, pTab);
  }




  if( ((pTab)->eTabType==1) ){
    sqlite3VdbeAddOp4(v, 173, iDb, 0, 0, pTab->zName, 0);
    sqlite3MayAbort(pParse);
  }
  sqlite3VdbeAddOp4(v, 152, iDb, 0, 0, pTab->zName, 0);
  sqlite3ChangeCookie(pParse, iDb);
  sqliteViewResetAll(db, iDb);
}





static int sqlite3ReadOnlyShadowTables(sqlite3 *db){

  if( (db->flags & 0x10000000)!=0
   && db->pVtabCtx==0
   && db->nVdbeExec==0
   && !((db)->nVTrans>0 && (db)->aVTrans==0)
  ){
    return 1;
  }

  return 0;
}




static int tableMayNotBeDropped(sqlite3 *db, Table *pTab){
  if( sqlite3_strnicmp(pTab->zName, "sqlite_", 7)==0 ){
    if( sqlite3_strnicmp(pTab->zName+7, "stat", 4)==0 ) return 0;
    if( sqlite3_strnicmp(pTab->zName+7, "parameters", 10)==0 ) return 0;
    return 1;
  }
  if( (pTab->tabFlags & 0x00001000)!=0 && sqlite3ReadOnlyShadowTables(db) ){
    return 1;
  }
  if( pTab->tabFlags & 0x00008000 ){
    return 1;
  }
  return 0;
}





static void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){
  Table *pTab;
  Vdbe *v;
  sqlite3 *db = pParse->db;
  int iDb;

  if( db->mallocFailed ){
    goto exit_drop_table;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( sqlite3ReadSchema(pParse) ) goto exit_drop_table;
  if( noErr ) db->suppressErr++;
  ((void) (0));
  pTab = sqlite3LocateTableItem(pParse, isView, &pName->a[0]);
  if( noErr ) db->suppressErr--;

  if( pTab==0 ){
    if( noErr ){
      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].u4.zDatabase);
      sqlite3ForceNotReadOnly(pParse);
    }
    goto exit_drop_table;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void) (0));




  if( ((pTab)->eTabType==1) && sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto exit_drop_table;
  }

  {
    int code;
    const char *zTab = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");
    const char *zDb = db->aDb[iDb].zDbSName;
    const char *zArg2 = 0;
    if( sqlite3AuthCheck(pParse, 9, zTab, 0, zDb)){
      goto exit_drop_table;
    }
    if( isView ){
      if( !0 && iDb==1 ){
        code = 15;
      }else{
        code = 17;
      }

    }else if( ((pTab)->eTabType==1) ){
      code = 30;
      zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;

    }else{
      if( !0 && iDb==1 ){
        code = 13;
      }else{
        code = 11;
      }
    }
    if( sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb) ){
      goto exit_drop_table;
    }
    if( sqlite3AuthCheck(pParse, 9, pTab->zName, 0, zDb) ){
      goto exit_drop_table;
    }
  }

  if( tableMayNotBeDropped(db, pTab) ){
    sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab->zName);
    goto exit_drop_table;
  }





  if( isView && !((pTab)->eTabType==2) ){
    sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", pTab->zName);
    goto exit_drop_table;
  }
  if( !isView && ((pTab)->eTabType==2) ){
    sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", pTab->zName);
    goto exit_drop_table;
  }





  v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3BeginWriteOperation(pParse, 1, iDb);
    if( !isView ){
      sqlite3ClearStatTables(pParse, iDb, "tbl", pTab->zName);
      sqlite3FkDropTable(pParse, pName, pTab);
    }
    sqlite3CodeDropTable(pParse, pTab, iDb, isView);
  }

exit_drop_table:
  sqlite3SrcListDelete(db, pName);
}
# 127957 "c_tests/sqlite3.c"
static void sqlite3CreateForeignKey(
  Parse *pParse,
  ExprList *pFromCol,
  Token *pTo,
  ExprList *pToCol,
  int flags
){
  sqlite3 *db = pParse->db;

  FKey *pFKey = 0;
  FKey *pNextTo;
  Table *p = pParse->pNewTable;
  i64 nByte;
  int i;
  int nCol;
  char *z;

  ((void) (0));
  if( p==0 || (pParse->eParseMode==1) ) goto fk_end;
  if( pFromCol==0 ){
    int iCol = p->nCol-1;
    if( (iCol<0) ) goto fk_end;
    if( pToCol && pToCol->nExpr!=1 ){
      sqlite3ErrorMsg(pParse, "foreign key on %s"
         " should reference only one column of table %T",
         p->aCol[iCol].zCnName, pTo);
      goto fk_end;
    }
    nCol = 1;
  }else if( pToCol && pToCol->nExpr!=pFromCol->nExpr ){
    sqlite3ErrorMsg(pParse,
        "number of columns in foreign key does not match the number of "
        "columns in the referenced table");
    goto fk_end;
  }else{
    nCol = pFromCol->nExpr;
  }
  nByte = (__builtin_offsetof(FKey, aCol)+(nCol)*sizeof(struct sColMap)) + pTo->n + 1;
  if( pToCol ){
    for(i=0; i<pToCol->nExpr; i++){
      nByte += sqlite3Strlen30(pToCol->a[i].zEName) + 1;
    }
  }
  pFKey = sqlite3DbMallocZero(db, nByte );
  if( pFKey==0 ){
    goto fk_end;
  }
  pFKey->pFrom = p;
  ((void) (0));
  pFKey->pNextFrom = p->u.tab.pFKey;
  z = (char*)&pFKey->aCol[nCol];
  pFKey->zTo = z;
  if( (pParse->eParseMode>=2) ){
    sqlite3RenameTokenMap(pParse, (void*)z, pTo);
  }
  memcpy(z, pTo->z, pTo->n);
  z[pTo->n] = 0;
  sqlite3Dequote(z);
  z += pTo->n+1;
  pFKey->nCol = nCol;
  if( pFromCol==0 ){
    pFKey->aCol[0].iFrom = p->nCol-1;
  }else{
    for(i=0; i<nCol; i++){
      int j;
      for(j=0; j<p->nCol; j++){
        if( sqlite3StrICmp(p->aCol[j].zCnName, pFromCol->a[i].zEName)==0 ){
          pFKey->aCol[i].iFrom = j;
          break;
        }
      }
      if( j>=p->nCol ){
        sqlite3ErrorMsg(pParse,
          "unknown column \"%s\" in foreign key definition",
          pFromCol->a[i].zEName);
        goto fk_end;
      }
      if( (pParse->eParseMode>=2) ){
        sqlite3RenameTokenRemap(pParse, &pFKey->aCol[i], pFromCol->a[i].zEName);
      }
    }
  }
  if( pToCol ){
    for(i=0; i<nCol; i++){
      int n = sqlite3Strlen30(pToCol->a[i].zEName);
      pFKey->aCol[i].zCol = z;
      if( (pParse->eParseMode>=2) ){
        sqlite3RenameTokenRemap(pParse, z, pToCol->a[i].zEName);
      }
      memcpy(z, pToCol->a[i].zEName, n);
      z[n] = 0;
      z += n+1;
    }
  }
  pFKey->isDeferred = 0;
  pFKey->aAction[0] = (u8)(flags & 0xff);
  pFKey->aAction[1] = (u8)((flags >> 8 ) & 0xff);

  ((void) (0));
  pNextTo = (FKey *)sqlite3HashInsert(&p->pSchema->fkeyHash,
      pFKey->zTo, (void *)pFKey
  );
  if( pNextTo==pFKey ){
    sqlite3OomFault(db);
    goto fk_end;
  }
  if( pNextTo ){
    ((void) (0));
    pFKey->pNextTo = pNextTo;
    pNextTo->pPrevTo = pFKey;
  }



  ((void) (0));
  p->u.tab.pFKey = pFKey;
  pFKey = 0;

fk_end:
  sqlite3DbFree(db, pFKey);

  sqlite3ExprListDelete(db, pFromCol);
  sqlite3ExprListDelete(db, pToCol);
}
# 128089 "c_tests/sqlite3.c"
static void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){

  Table *pTab;
  FKey *pFKey;
  if( (pTab = pParse->pNewTable)==0 ) return;
  if( (!((pTab)->eTabType==0)) ) return;
  if( (pFKey = pTab->u.tab.pFKey)==0 ) return;
  ((void) (0));
  pFKey->isDeferred = (u8)isDeferred;

}
# 128112 "c_tests/sqlite3.c"
static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){
  Table *pTab = pIndex->pTable;
  int iTab = pParse->nTab++;
  int iIdx = pParse->nTab++;
  int iSorter;
  int addr1;
  int addr2;
  Pgno tnum;
  int iPartIdxLabel;
  Vdbe *v;
  KeyInfo *pKey;
  int regRecord;
  sqlite3 *db = pParse->db;
  int iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);


  if( sqlite3AuthCheck(pParse, 27, pIndex->zName, 0,
      db->aDb[iDb].zDbSName ) ){
    return;
  }



  sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);

  v = sqlite3GetVdbe(pParse);
  if( v==0 ) return;
  if( memRootPage>=0 ){
    tnum = (Pgno)memRootPage;
  }else{
    tnum = pIndex->tnum;
  }
  pKey = sqlite3KeyInfoOfIndex(pParse, pIndex);
  ((void) (0));


  iSorter = pParse->nTab++;
  sqlite3VdbeAddOp4(v, 120, iSorter, 0, pIndex->nKeyCol, (char*)
                    sqlite3KeyInfoRef(pKey), (-8));



  sqlite3OpenTable(pParse, iTab, iDb, pTab, 113);
  addr1 = sqlite3VdbeAddOp2(v, 36, iTab, 0); ;
  regRecord = sqlite3GetTempReg(pParse);
  sqlite3MultiWrite(pParse);

  sqlite3GenerateIndexKey(pParse,pIndex,iTab,regRecord,0,&iPartIdxLabel,0,0);
  sqlite3VdbeAddOp2(v, 140, iSorter, regRecord);
  sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);
  sqlite3VdbeAddOp2(v, 40, iTab, addr1+1); ;
  sqlite3VdbeJumpHere(v, addr1);
  if( memRootPage<0 ) sqlite3VdbeAddOp2(v, 146, tnum, iDb);
  sqlite3VdbeAddOp4(v, 114, iIdx, (int)tnum, iDb,
                    (char *)pKey, (-8));
  sqlite3VdbeChangeP5(v, 0x01|((memRootPage>=0)?0x10:0));

  addr1 = sqlite3VdbeAddOp2(v, 34, iSorter, 0); ;
  if( ((pIndex)->onError!=0) ){
    int j2 = sqlite3VdbeGoto(v, 1);
    addr2 = sqlite3VdbeCurrentAddr(v);
                                           ;
    sqlite3VdbeAddOp4Int(v, 133, iSorter, j2, regRecord,
                         pIndex->nKeyCol); ;
    sqlite3UniqueConstraint(pParse, 2, pIndex);
    sqlite3VdbeJumpHere(v, j2);
  }else{







    sqlite3MayAbort(pParse);
    addr2 = sqlite3VdbeCurrentAddr(v);
  }
  sqlite3VdbeAddOp3(v, 134, iSorter, regRecord, iIdx);
  if( !pIndex->bAscKeyBug ){







    sqlite3VdbeAddOp1(v, 138, iIdx);
  }
  sqlite3VdbeAddOp2(v, 139, iIdx, regRecord);
  sqlite3VdbeChangeP5(v, 0x10);
  sqlite3ReleaseTempReg(pParse, regRecord);
  sqlite3VdbeAddOp2(v, 38, iSorter, addr2); ;
  sqlite3VdbeJumpHere(v, addr1);

  sqlite3VdbeAddOp1(v, 123, iTab);
  sqlite3VdbeAddOp1(v, 123, iIdx);
  sqlite3VdbeAddOp1(v, 123, iSorter);
}
# 128218 "c_tests/sqlite3.c"
static Index *sqlite3AllocateIndexObject(
  sqlite3 *db,
  int nCol,
  int nExtra,
  char **ppExtra
){
  Index *p;
  i64 nByte;

  ((void) (0));
  nByte = (((sizeof(Index))+7)&~7) +
          (((sizeof(char*)*nCol)+7)&~7) +
          (((sizeof(LogEst)*(nCol+1) + sizeof(i16)*nCol + sizeof(u8)*nCol)+7)&~7);


  p = sqlite3DbMallocZero(db, nByte + nExtra);
  if( p ){
    char *pExtra = ((char*)p)+(((sizeof(Index))+7)&~7);
    p->azColl = (const char**)pExtra; pExtra += (((sizeof(char*)*nCol)+7)&~7);
    p->aiRowLogEst = (LogEst*)pExtra; pExtra += sizeof(LogEst)*(nCol+1);
    p->aiColumn = (i16*)pExtra; pExtra += sizeof(i16)*nCol;
    p->aSortOrder = (u8*)pExtra;
    ((void) (0));
    p->nColumn = (u16)nCol;
    p->nKeyCol = (u16)(nCol - 1);
    *ppExtra = ((char*)p) + nByte;
  }
  return p;
}






static int sqlite3HasExplicitNulls(Parse *pParse, ExprList *pList){
  if( pList ){
    int i;
    for(i=0; i<pList->nExpr; i++){
      if( pList->a[i].fg.bNulls ){
        u8 sf = pList->a[i].fg.sortFlags;
        sqlite3ErrorMsg(pParse, "unsupported use of NULLS %s",
            (sf==0 || sf==3) ? "FIRST" : "LAST"
        );
        return 1;
      }
    }
  }
  return 0;
}
# 128281 "c_tests/sqlite3.c"
static void sqlite3CreateIndex(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  SrcList *pTblName,
  ExprList *pList,
  int onError,
  Token *pStart,
  Expr *pPIWhere,
  int sortOrder,
  int ifNotExist,
  u8 idxType
){
  Table *pTab = 0;
  Index *pIndex = 0;
  char *zName = 0;
  int nName;
  int i, j;
  DbFixer sFix;
  int sortOrderMask;
  sqlite3 *db = pParse->db;
  Db *pDb;
  int iDb;
  Token *pName = 0;
  struct ExprList_item *pListItem;
  int nExtra = 0;
  int nExtraCol;
  char *zExtra = 0;
  Index *pPk = 0;

  ((void) (0));
  if( pParse->nErr ){
    goto exit_create_index;
  }
  ((void) (0));
  if( (pParse->eParseMode==1) && idxType!=2 ){
    goto exit_create_index;
  }
  if( 0!=sqlite3ReadSchema(pParse) ){
    goto exit_create_index;
  }
  if( sqlite3HasExplicitNulls(pParse, pList) ){
    goto exit_create_index;
  }




  if( pTblName!=0 ){





    ((void) (0));
    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
    if( iDb<0 ) goto exit_create_index;
    ((void) (0));






    if( !db->init.busy ){
      pTab = sqlite3SrcListLookup(pParse, pTblName);
      if( pName2->n==0 && pTab && pTab->pSchema==db->aDb[1].pSchema ){
        iDb = 1;
      }
    }


    sqlite3FixInit(&sFix, pParse, iDb, "index", pName);
    if( sqlite3FixSrcList(&sFix, pTblName) ){


      ((void) (0));
    }
    pTab = sqlite3LocateTableItem(pParse, 0, &pTblName->a[0]);
    ((void) (0));
    if( pTab==0 ) goto exit_create_index;
    if( iDb==1 && db->aDb[iDb].pSchema!=pTab->pSchema ){
      sqlite3ErrorMsg(pParse,
           "cannot create a TEMP index on non-TEMP table \"%s\"",
           pTab->zName);
      goto exit_create_index;
    }
    if( !(((pTab)->tabFlags & 0x00000080)==0) ) pPk = sqlite3PrimaryKeyIndex(pTab);
  }else{
    ((void) (0));
    ((void) (0));
    pTab = pParse->pNewTable;
    if( !pTab ) goto exit_create_index;
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  }
  pDb = &db->aDb[iDb];

  ((void) (0));
  if( sqlite3_strnicmp(pTab->zName, "sqlite_", 7)==0
       && db->init.busy==0
       && pTblName!=0
  ){
    sqlite3ErrorMsg(pParse, "table %s may not be indexed", pTab->zName);
    goto exit_create_index;
  }

  if( ((pTab)->eTabType==2) ){
    sqlite3ErrorMsg(pParse, "views may not be indexed");
    goto exit_create_index;
  }


  if( ((pTab)->eTabType==1) ){
    sqlite3ErrorMsg(pParse, "virtual tables may not be indexed");
    goto exit_create_index;
  }
# 128412 "c_tests/sqlite3.c"
  if( pName ){
    zName = sqlite3NameFromToken(db, pName);
    if( zName==0 ) goto exit_create_index;
    ((void) (0));
    if( 0!=sqlite3CheckObjectName(pParse, zName,"index",pTab->zName) ){
      goto exit_create_index;
    }
    if( !(pParse->eParseMode>=2) ){
      if( !db->init.busy ){
        if( sqlite3FindTable(db, zName, pDb->zDbSName)!=0 ){
          sqlite3ErrorMsg(pParse, "there is already a table named %s", zName);
          goto exit_create_index;
        }
      }
      if( sqlite3FindIndex(db, zName, pDb->zDbSName)!=0 ){
        if( !ifNotExist ){
          sqlite3ErrorMsg(pParse, "index %s already exists", zName);
        }else{
          ((void) (0));
          sqlite3CodeVerifySchema(pParse, iDb);
          sqlite3ForceNotReadOnly(pParse);
        }
        goto exit_create_index;
      }
    }
  }else{
    int n;
    Index *pLoop;
    for(pLoop=pTab->pIndex, n=1; pLoop; pLoop=pLoop->pNext, n++){}
    zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab->zName, n);
    if( zName==0 ){
      goto exit_create_index;
    }






    if( (pParse->eParseMode!=0) ) zName[7]++;
  }




  if( !(pParse->eParseMode>=2) ){
    const char *zDb = pDb->zDbSName;
    if( sqlite3AuthCheck(pParse, 18, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), 0, zDb) ){
      goto exit_create_index;
    }
    i = 1;
    if( !0 && iDb==1 ) i = 3;
    if( sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb) ){
      goto exit_create_index;
    }
  }






  if( pList==0 ){
    Token prevCol;
    Column *pCol = &pTab->aCol[pTab->nCol-1];
    pCol->colFlags |= 0x0008;
    sqlite3TokenInit(&prevCol, pCol->zCnName);
    pList = sqlite3ExprListAppend(pParse, 0,
              sqlite3ExprAlloc(db, 60, &prevCol, 0));
    if( pList==0 ) goto exit_create_index;
    ((void) (0));
    sqlite3ExprListSetSortOrder(pList, sortOrder, -1);
  }else{
    sqlite3ExprListCheckLength(pParse, pList, "index");
    if( pParse->nErr ) goto exit_create_index;
  }




  for(i=0; i<pList->nExpr; i++){
    Expr *pExpr = pList->a[i].pExpr;
    ((void) (0));
    if( pExpr->op==114 ){
      ((void) (0));
      nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken));
    }
  }




  nName = sqlite3Strlen30(zName);
  nExtraCol = pPk ? pPk->nKeyCol : 1;
  ((void) (0));
  pIndex = sqlite3AllocateIndexObject(db, pList->nExpr + nExtraCol,
                                      nName + nExtra + 1, &zExtra);
  if( db->mallocFailed ){
    goto exit_create_index;
  }
  ((void) (0));
  ((void) (0));
  pIndex->zName = zExtra;
  zExtra += nName + 1;
  memcpy(pIndex->zName, zName, nName+1);
  pIndex->pTable = pTab;
  pIndex->onError = (u8)onError;
  pIndex->uniqNotNull = onError!=0;
  pIndex->idxType = idxType;
  pIndex->pSchema = db->aDb[iDb].pSchema;
  pIndex->nKeyCol = pList->nExpr;
  if( pPIWhere ){
    sqlite3ResolveSelfReference(pParse, pTab, 0x000002, pPIWhere, 0);
    pIndex->pPartIdxWhere = pPIWhere;
    pPIWhere = 0;
  }
  ((void) (0));



  if( pDb->pSchema->file_format>=4 ){
    sortOrderMask = -1;
  }else{
    sortOrderMask = 0;
  }
# 128547 "c_tests/sqlite3.c"
  pListItem = pList->a;
  if( (pParse->eParseMode>=2) ){
    pIndex->aColExpr = pList;
    pList = 0;
  }
  for(i=0; i<pIndex->nKeyCol; i++, pListItem++){
    Expr *pCExpr;
    int requestedSortOrder;
    const char *zColl;

    sqlite3StringToId(pListItem->pExpr);
    sqlite3ResolveSelfReference(pParse, pTab, 0x000020, pListItem->pExpr, 0);
    if( pParse->nErr ) goto exit_create_index;
    pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);
    if( pCExpr->op!=168 ){
      if( pTab==pParse->pNewTable ){
        sqlite3ErrorMsg(pParse, "expressions prohibited in PRIMARY KEY and "
                                "UNIQUE constraints");
        goto exit_create_index;
      }
      if( pIndex->aColExpr==0 ){
        pIndex->aColExpr = pList;
        pList = 0;
      }
      j = (-2);
      pIndex->aiColumn[i] = (-2);
      pIndex->uniqNotNull = 0;
      pIndex->bHasExpr = 1;
    }else{
      j = pCExpr->iColumn;
      ((void) (0));
      if( j<0 ){
        j = pTab->iPKey;
      }else{
        if( pTab->aCol[j].notNull==0 ){
          pIndex->uniqNotNull = 0;
        }
        if( pTab->aCol[j].colFlags & 0x0020 ){
          pIndex->bHasVCol = 1;
          pIndex->bHasExpr = 1;
        }
      }
      pIndex->aiColumn[i] = (i16)j;
    }
    zColl = 0;
    if( pListItem->pExpr->op==114 ){
      int nColl;
      ((void) (0));
      zColl = pListItem->pExpr->u.zToken;
      nColl = sqlite3Strlen30(zColl) + 1;
      ((void) (0));
      memcpy(zExtra, zColl, nColl);
      zColl = zExtra;
      zExtra += nColl;
      nExtra -= nColl;
    }else if( j>=0 ){
      zColl = sqlite3ColumnColl(&pTab->aCol[j]);
    }
    if( !zColl ) zColl = sqlite3StrBINARY;
    if( !db->init.busy && !sqlite3LocateCollSeq(pParse, zColl) ){
      goto exit_create_index;
    }
    pIndex->azColl[i] = zColl;
    requestedSortOrder = pListItem->fg.sortFlags & sortOrderMask;
    pIndex->aSortOrder[i] = (u8)requestedSortOrder;
  }





  if( pPk ){
    for(j=0; j<pPk->nKeyCol; j++){
      int x = pPk->aiColumn[j];
      ((void) (0));
      if( isDupColumn(pIndex, pIndex->nKeyCol, pPk, j) ){
        pIndex->nColumn--;
      }else{
                                                                 ;
        pIndex->aiColumn[i] = x;
        pIndex->azColl[i] = pPk->azColl[j];
        pIndex->aSortOrder[i] = pPk->aSortOrder[j];
        i++;
      }
    }
    ((void) (0));
  }else{
    pIndex->aiColumn[i] = (-1);
    pIndex->azColl[i] = sqlite3StrBINARY;
  }
  sqlite3DefaultRowEst(pIndex);
  if( pParse->pNewTable==0 ) estimateIndexWidth(pIndex);



  ((void) (0));

  recomputeColumnsNotIndexed(pIndex);
  if( pTblName!=0 && pIndex->nColumn>=pTab->nCol ){
    pIndex->isCovering = 1;
    for(j=0; j<pTab->nCol; j++){
      if( j==pTab->iPKey ) continue;
      if( sqlite3TableColumnToIndex(pIndex,j)>=0 ) continue;
      pIndex->isCovering = 0;
      break;
    }
  }

  if( pTab==pParse->pNewTable ){
# 128677 "c_tests/sqlite3.c"
    Index *pIdx;
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      int k;
      ((void) (0));
      ((void) (0));
      ((void) (0));

      if( pIdx->nKeyCol!=pIndex->nKeyCol ) continue;
      for(k=0; k<pIdx->nKeyCol; k++){
        const char *z1;
        const char *z2;
        ((void) (0));
        if( pIdx->aiColumn[k]!=pIndex->aiColumn[k] ) break;
        z1 = pIdx->azColl[k];
        z2 = pIndex->azColl[k];
        if( sqlite3StrICmp(z1, z2) ) break;
      }
      if( k==pIdx->nKeyCol ){
        if( pIdx->onError!=pIndex->onError ){







          if( !(pIdx->onError==11 || pIndex->onError==11) ){
            sqlite3ErrorMsg(pParse,
                "conflicting ON CONFLICT clauses specified", 0);
          }
          if( pIdx->onError==11 ){
            pIdx->onError = pIndex->onError;
          }
        }
        if( idxType==2 ) pIdx->idxType = idxType;
        if( (pParse->eParseMode>=2) ){
          pIndex->pNext = pParse->pNewIndex;
          pParse->pNewIndex = pIndex;
          pIndex = 0;
        }
        goto exit_create_index;
      }
    }
  }

  if( !(pParse->eParseMode>=2) ){




    ((void) (0));
    if( db->init.busy ){
      Index *p;
      ((void) (0));
      ((void) (0));
      if( pTblName!=0 ){
        pIndex->tnum = db->init.newTnum;
        if( sqlite3IndexHasDuplicateRootPage(pIndex) ){
          sqlite3ErrorMsg(pParse, "invalid rootpage");
          pParse->rc = sqlite3CorruptError(128736);
          goto exit_create_index;
        }
      }
      p = sqlite3HashInsert(&pIndex->pSchema->idxHash,
          pIndex->zName, pIndex);
      if( p ){
        ((void) (0));
        sqlite3OomFault(db);
        goto exit_create_index;
      }
      db->mDbFlags |= 0x0001;
    }
# 128763 "c_tests/sqlite3.c"
    else if( (((pTab)->tabFlags & 0x00000080)==0) || pTblName!=0 ){
      Vdbe *v;
      char *zStmt;
      int iMem = ++pParse->nMem;

      v = sqlite3GetVdbe(pParse);
      if( v==0 ) goto exit_create_index;

      sqlite3BeginWriteOperation(pParse, 1, iDb);







      pIndex->tnum = (Pgno)sqlite3VdbeAddOp0(v, 188);
      sqlite3VdbeAddOp3(v, 148, iDb, iMem, 2);




      ((void) (0));
      if( pStart ){
        int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;
        if( pName->z[n-1]==';' ) n--;

        zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s",
            onError==0 ? "" : " UNIQUE", n, pName->z);
      }else{


        zStmt = 0;
      }



      sqlite3NestedParse(pParse,
         "INSERT INTO %Q." "sqlite_master" " VALUES('index',%Q,%Q,#%d,%Q);",
         db->aDb[iDb].zDbSName,
         pIndex->zName,
         pTab->zName,
         iMem,
         zStmt
      );
      sqlite3DbFree(db, zStmt);




      if( pTblName ){
        sqlite3RefillIndex(pParse, pIndex, iMem);
        sqlite3ChangeCookie(pParse, iDb);
        sqlite3VdbeAddParseSchemaOp(v, iDb,
            sqlite3MPrintf(db, "name='%q' AND type='index'", pIndex->zName), 0);
        sqlite3VdbeAddOp2(v, 167, 0, 1);
      }

      sqlite3VdbeJumpHere(v, (int)pIndex->tnum);
    }
  }
  if( db->init.busy || pTblName==0 ){
    pIndex->pNext = pTab->pIndex;
    pTab->pIndex = pIndex;
    pIndex = 0;
  }
  else if( (pParse->eParseMode>=2) ){
    ((void) (0));
    pParse->pNewIndex = pIndex;
    pIndex = 0;
  }


exit_create_index:
  if( pIndex ) sqlite3FreeIndex(db, pIndex);
  if( pTab ){




    Index **ppFrom;
    Index *pThis;
    for(ppFrom=&pTab->pIndex; (pThis = *ppFrom)!=0; ppFrom=&pThis->pNext){
      Index *pNext;
      if( pThis->onError!=5 ) continue;
      while( (pNext = pThis->pNext)!=0 && pNext->onError!=5 ){
        *ppFrom = pNext;
        pThis->pNext = pNext->pNext;
        pNext->pNext = pThis;
        ppFrom = &pNext->pNext;
      }
      break;
    }
# 128866 "c_tests/sqlite3.c"
  }
  sqlite3ExprDelete(db, pPIWhere);
  sqlite3ExprListDelete(db, pList);
  sqlite3SrcListDelete(db, pTblName);
  sqlite3DbFree(db, zName);
}
# 128891 "c_tests/sqlite3.c"
static void sqlite3DefaultRowEst(Index *pIdx){

  static const LogEst aVal[] = { 33, 32, 30, 28, 26 };
  LogEst *a = pIdx->aiRowLogEst;
  LogEst x;
  int nCopy = ((((int)(sizeof(aVal)/sizeof(aVal[0]))))<(pIdx->nKeyCol)?(((int)(sizeof(aVal)/sizeof(aVal[0])))):(pIdx->nKeyCol));
  int i;


  ((void) (0));
# 128912 "c_tests/sqlite3.c"
  x = pIdx->pTable->nRowLogEst;
  ((void) (0));
  if( x<99 ){
    pIdx->pTable->nRowLogEst = x = 99;
  }
  if( pIdx->pPartIdxWhere!=0 ){ x -= 10; ((void) (0)); }
  a[0] = x;



  memcpy(&a[1], aVal, nCopy*sizeof(LogEst));
  for(i=nCopy+1; i<=pIdx->nKeyCol; i++){
    a[i] = 23; ((void) (0));
  }

  ((void) (0));
  if( ((pIdx)->onError!=0) ) a[pIdx->nKeyCol] = 0;
}





static void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){
  Index *pIndex;
  Vdbe *v;
  sqlite3 *db = pParse->db;
  int iDb;

  if( db->mallocFailed ){
    goto exit_drop_index;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( 0!=sqlite3ReadSchema(pParse) ){
    goto exit_drop_index;
  }
  pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].u4.zDatabase);
  if( pIndex==0 ){
    if( !ifExists ){
      sqlite3ErrorMsg(pParse, "no such index: %S", pName->a);
    }else{
      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].u4.zDatabase);
      sqlite3ForceNotReadOnly(pParse);
    }
    pParse->checkSchema = 1;
    goto exit_drop_index;
  }
  if( pIndex->idxType!=0 ){
    sqlite3ErrorMsg(pParse, "index associated with UNIQUE "
      "or PRIMARY KEY constraint cannot be dropped", 0);
    goto exit_drop_index;
  }
  iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);

  {
    int code = 10;
    Table *pTab = pIndex->pTable;
    const char *zDb = db->aDb[iDb].zDbSName;
    const char *zTab = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");
    if( sqlite3AuthCheck(pParse, 9, zTab, 0, zDb) ){
      goto exit_drop_index;
    }
    if( !0 && iDb==1 ) code = 12;
    if( sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb) ){
      goto exit_drop_index;
    }
  }



  v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3BeginWriteOperation(pParse, 1, iDb);
    sqlite3NestedParse(pParse,
       "DELETE FROM %Q." "sqlite_master" " WHERE name=%Q AND type='index'",
       db->aDb[iDb].zDbSName, pIndex->zName
    );
    sqlite3ClearStatTables(pParse, iDb, "idx", pIndex->zName);
    sqlite3ChangeCookie(pParse, iDb);
    destroyRootPage(pParse, pIndex->tnum, iDb);
    sqlite3VdbeAddOp4(v, 153, iDb, 0, 0, pIndex->zName, 0);
  }

exit_drop_index:
  sqlite3SrcListDelete(db, pName);
}
# 129019 "c_tests/sqlite3.c"
static void *sqlite3ArrayAllocate(
  sqlite3 *db,
  void *pArray,
  int szEntry,
  int *pnEntry,
  int *pIdx
){
  char *z;
  sqlite3_int64 n = *pIdx = *pnEntry;
  if( (n & (n-1))==0 ){
    sqlite3_int64 sz = (n==0) ? 1 : 2*n;
    void *pNew = sqlite3DbRealloc(db, pArray, sz*szEntry);
    if( pNew==0 ){
      *pIdx = -1;
      return pArray;
    }
    pArray = pNew;
  }
  z = (char*)pArray;
  memset(&z[n * szEntry], 0, szEntry);
  ++*pnEntry;
  return pArray;
}







static IdList *sqlite3IdListAppend(Parse *pParse, IdList *pList, Token *pToken){
  sqlite3 *db = pParse->db;
  int i;
  if( pList==0 ){
    pList = sqlite3DbMallocZero(db, (__builtin_offsetof(IdList, a)+(1)*sizeof(struct IdList_item)));
    if( pList==0 ) return 0;
  }else{
    IdList *pNew;
    pNew = sqlite3DbRealloc(db, pList, (__builtin_offsetof(IdList, a)+(pList->nId+1)*sizeof(struct IdList_item)));
    if( pNew==0 ){
      sqlite3IdListDelete(db, pList);
      return 0;
    }
    pList = pNew;
  }
  i = pList->nId++;
  pList->a[i].zName = sqlite3NameFromToken(db, pToken);
  if( (pParse->eParseMode>=2) && pList->a[i].zName ){
    sqlite3RenameTokenMap(pParse, (void*)pList->a[i].zName, pToken);
  }
  return pList;
}




static void sqlite3IdListDelete(sqlite3 *db, IdList *pList){
  int i;
  ((void) (0));
  if( pList==0 ) return;
  for(i=0; i<pList->nId; i++){
    sqlite3DbFree(db, pList->a[i].zName);
  }
  sqlite3DbNNFreeNN(db, pList);
}





static int sqlite3IdListIndex(IdList *pList, const char *zName){
  int i;
  ((void) (0));
  for(i=0; i<pList->nId; i++){
    if( sqlite3StrICmp(pList->a[i].zName, zName)==0 ) return i;
  }
  return -1;
}
# 129130 "c_tests/sqlite3.c"
static SrcList *sqlite3SrcListEnlarge(
  Parse *pParse,
  SrcList *pSrc,
  int nExtra,
  int iStart
){
  int i;


  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  if( (u32)pSrc->nSrc+nExtra>pSrc->nAlloc ){
    SrcList *pNew;
    sqlite3_int64 nAlloc = 2*(sqlite3_int64)pSrc->nSrc+nExtra;
    sqlite3 *db = pParse->db;

    if( pSrc->nSrc+nExtra>=200 ){
      sqlite3ErrorMsg(pParse, "too many FROM clause terms, max: %d",
                      200);
      return 0;
    }
    if( nAlloc>200 ) nAlloc = 200;
    pNew = sqlite3DbRealloc(db, pSrc, (__builtin_offsetof(SrcList, a)+(nAlloc)*sizeof(SrcItem)));
    if( pNew==0 ){
      ((void) (0));
      return 0;
    }
    pSrc = pNew;
    pSrc->nAlloc = nAlloc;
  }



  for(i=pSrc->nSrc-1; i>=iStart; i--){
    pSrc->a[i+nExtra] = pSrc->a[i];
  }
  pSrc->nSrc += nExtra;


  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);
  for(i=iStart; i<iStart+nExtra; i++){
    pSrc->a[i].iCursor = -1;
  }


  return pSrc;
}
# 129218 "c_tests/sqlite3.c"
static SrcList *sqlite3SrcListAppend(
  Parse *pParse,
  SrcList *pList,
  Token *pTable,
  Token *pDatabase
){
  SrcItem *pItem;
  sqlite3 *db;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  db = pParse->db;
  if( pList==0 ){
    pList = sqlite3DbMallocRawNN(pParse->db, (__builtin_offsetof(SrcList, a)+(1)*sizeof(SrcItem)));
    if( pList==0 ) return 0;
    pList->nAlloc = 1;
    pList->nSrc = 1;
    memset(&pList->a[0], 0, sizeof(pList->a[0]));
    pList->a[0].iCursor = -1;
  }else{
    SrcList *pNew = sqlite3SrcListEnlarge(pParse, pList, 1, pList->nSrc);
    if( pNew==0 ){
      sqlite3SrcListDelete(db, pList);
      return 0;
    }else{
      pList = pNew;
    }
  }
  pItem = &pList->a[pList->nSrc-1];
  if( pDatabase && pDatabase->z==0 ){
    pDatabase = 0;
  }
  ((void) (0));
  ((void) (0));
  if( pDatabase ){
    pItem->zName = sqlite3NameFromToken(db, pDatabase);
    pItem->u4.zDatabase = sqlite3NameFromToken(db, pTable);
  }else{
    pItem->zName = sqlite3NameFromToken(db, pTable);
    pItem->u4.zDatabase = 0;
  }
  return pList;
}




static void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){
  int i;
  SrcItem *pItem;
  ((void) (0));
  if( (pList) ){
    for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){
      if( pItem->iCursor>=0 ) continue;
      pItem->iCursor = pParse->nTab++;
      if( pItem->fg.isSubquery ){
        ((void) (0));
        ((void) (0));
        ((void) (0));
        sqlite3SrcListAssignCursors(pParse, pItem->u4.pSubq->pSelect->pSrc);
      }
    }
  }
}




static void sqlite3SubqueryDelete(sqlite3 *db, Subquery *pSubq){
  ((void) (0));
  sqlite3SelectDelete(db, pSubq->pSelect);
  sqlite3DbFree(db, pSubq);
}





static Select *sqlite3SubqueryDetach(sqlite3 *db, SrcItem *pItem){
  Select *pSel;
  ((void) (0));
  ((void) (0));
  pSel = pItem->u4.pSubq->pSelect;
  sqlite3DbFree(db, pItem->u4.pSubq);
  pItem->u4.pSubq = 0;
  pItem->fg.isSubquery = 0;
  return pSel;
}




static void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){
  int i;
  SrcItem *pItem;
  ((void) (0));
  if( pList==0 ) return;
  for(pItem=pList->a, i=0; i<pList->nSrc; i++, pItem++){


    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));


    if( pItem->zName ) sqlite3DbNNFreeNN(db, pItem->zName);
    if( pItem->zAlias ) sqlite3DbNNFreeNN(db, pItem->zAlias);
    if( pItem->fg.isSubquery ){
      sqlite3SubqueryDelete(db, pItem->u4.pSubq);
    }else if( pItem->fg.fixedSchema==0 && pItem->u4.zDatabase!=0 ){
      sqlite3DbNNFreeNN(db, pItem->u4.zDatabase);
    }
    if( pItem->fg.isIndexedBy ) sqlite3DbFree(db, pItem->u1.zIndexedBy);
    if( pItem->fg.isTabFunc ) sqlite3ExprListDelete(db, pItem->u1.pFuncArg);
    sqlite3DeleteTable(db, pItem->pSTab);
    if( pItem->fg.isUsing ){
      sqlite3IdListDelete(db, pItem->u3.pUsing);
    }else if( pItem->u3.pOn ){
      sqlite3ExprDelete(db, pItem->u3.pOn);
    }
  }
  sqlite3DbNNFreeNN(db, pList);
}
# 129358 "c_tests/sqlite3.c"
static int sqlite3SrcItemAttachSubquery(
  Parse *pParse,
  SrcItem *pItem,
  Select *pSelect,
  int dupSelect
){
  Subquery *p;
  ((void) (0));
  ((void) (0));
  if( pItem->fg.fixedSchema ){
    pItem->u4.pSchema = 0;
    pItem->fg.fixedSchema = 0;
  }else if( pItem->u4.zDatabase!=0 ){
    sqlite3DbFree(pParse->db, pItem->u4.zDatabase);
    pItem->u4.zDatabase = 0;
  }
  if( dupSelect ){
    pSelect = sqlite3SelectDup(pParse->db, pSelect, 0);
    if( pSelect==0 ) return 0;
  }
  p = pItem->u4.pSubq = sqlite3DbMallocRawNN(pParse->db, sizeof(Subquery));
  if( p==0 ){
    sqlite3SelectDelete(pParse->db, pSelect);
    return 0;
  }
  pItem->fg.isSubquery = 1;
  p->pSelect = pSelect;
  ((void) (0));
  memset(((char*)p)+sizeof(p->pSelect), 0, sizeof(*p)-sizeof(p->pSelect));
  return 1;
}
# 129407 "c_tests/sqlite3.c"
static SrcList *sqlite3SrcListAppendFromTerm(
  Parse *pParse,
  SrcList *p,
  Token *pTable,
  Token *pDatabase,
  Token *pAlias,
  Select *pSubquery,
  OnOrUsing *pOnUsing
){
  SrcItem *pItem;
  sqlite3 *db = pParse->db;
  if( !p && pOnUsing!=0 && (pOnUsing->pOn || pOnUsing->pUsing) ){
    sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s",
      (pOnUsing->pOn ? "ON" : "USING")
    );
    goto append_from_error;
  }
  p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);
  if( p==0 ){
    goto append_from_error;
  }
  ((void) (0));
  pItem = &p->a[p->nSrc-1];
  ((void) (0));
  ((void) (0));
  if( (pParse->eParseMode>=2) && pItem->zName ){
    Token *pToken = ((pDatabase) && pDatabase->z) ? pDatabase : pTable;
    sqlite3RenameTokenMap(pParse, pItem->zName, pToken);
  }
  ((void) (0));
  if( pAlias->n ){
    pItem->zAlias = sqlite3NameFromToken(db, pAlias);
  }
  ((void) (0));
  if( pSubquery ){
    if( sqlite3SrcItemAttachSubquery(pParse, pItem, pSubquery, 0) ){
      if( pSubquery->selFlags & 0x0000800 ){
        pItem->fg.isNestedFrom = 1;
      }
    }
  }
  ((void) (0));
  ((void) (0));
  if( pOnUsing==0 ){
    pItem->u3.pOn = 0;
  }else if( pOnUsing->pUsing ){
    pItem->fg.isUsing = 1;
    pItem->u3.pUsing = pOnUsing->pUsing;
  }else{
    pItem->u3.pOn = pOnUsing->pOn;
  }
  return p;

append_from_error:
  ((void) (0));
  sqlite3ClearOnOrUsing(db, pOnUsing);
  sqlite3SelectDelete(db, pSubquery);
  return 0;
}





static void sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pIndexedBy){
  ((void) (0));
  if( p && pIndexedBy->n>0 ){
    SrcItem *pItem;
    ((void) (0));
    pItem = &p->a[p->nSrc-1];
    ((void) (0));
    ((void) (0));
    ((void) (0));
    if( pIndexedBy->n==1 && !pIndexedBy->z ){


      pItem->fg.notIndexed = 1;
    }else{
      pItem->u1.zIndexedBy = sqlite3NameFromToken(pParse->db, pIndexedBy);
      pItem->fg.isIndexedBy = 1;
      ((void) (0));
    }
  }
}






static SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2){
  ((void) (0));
  ((void) (0));
  ((void) (0));
                         ;
  if( p2 ){
    int nOld = p1->nSrc;
    SrcList *pNew = sqlite3SrcListEnlarge(pParse, p1, p2->nSrc, nOld);
    if( pNew==0 ){
      sqlite3SrcListDelete(pParse->db, p2);
    }else{
      p1 = pNew;
      memcpy(&p1->a[nOld], p2->a, p2->nSrc*sizeof(SrcItem));
      ((void) (0));
      ((void) (0));
      p1->a[0].fg.jointype |= (0x40 & p2->a[0].fg.jointype);
      sqlite3DbFree(pParse->db, p2);
    }
  }
  return p1;
}





static void sqlite3SrcListFuncArgs(Parse *pParse, SrcList *p, ExprList *pList){
  if( p ){
    SrcItem *pItem = &p->a[p->nSrc-1];
    ((void) (0));
    ((void) (0));
    ((void) (0));
    pItem->u1.pFuncArg = pList;
    pItem->fg.isTabFunc = 1;
  }else{
    sqlite3ExprListDelete(pParse->db, pList);
  }
}
# 129558 "c_tests/sqlite3.c"
static void sqlite3SrcListShiftJoinType(Parse *pParse, SrcList *p){
  (void)pParse;
  if( p && p->nSrc>1 ){
    int i = p->nSrc-1;
    u8 allFlags = 0;
    do{
      allFlags |= p->a[i].fg.jointype = p->a[i-1].fg.jointype;
    }while( (--i)>0 );
    p->a[0].fg.jointype = 0;



    if( allFlags & 0x10 ){
      for(i=p->nSrc-1; (i>0) && (p->a[i].fg.jointype&0x10)==0; i--){}
      i--;
      ((void) (0));
      do{
        p->a[i].fg.jointype |= 0x40;
      }while( (--i)>=0 );
    }
  }
}




static void sqlite3BeginTransaction(Parse *pParse, int type){
  sqlite3 *db;
  Vdbe *v;
  int i;

  ((void) (0));
  db = pParse->db;
  ((void) (0));
  if( sqlite3AuthCheck(pParse, 22, "BEGIN", 0, 0) ){
    return;
  }
  v = sqlite3GetVdbe(pParse);
  if( !v ) return;
  if( type!=7 ){
    for(i=0; i<db->nDb; i++){
      int eTxnType;
      Btree *pBt = db->aDb[i].pBt;
      if( pBt && sqlite3BtreeIsReadonly(pBt) ){
        eTxnType = 0;
      }else if( type==9 ){
        eTxnType = 2;
      }else{
        eTxnType = 1;
      }
      sqlite3VdbeAddOp2(v, 2, i, eTxnType);
      sqlite3VdbeUsesBtree(v, i);
    }
  }
  sqlite3VdbeAddOp0(v, 1);
}






static void sqlite3EndTransaction(Parse *pParse, int eType){
  Vdbe *v;
  int isRollback;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  isRollback = eType==12;
  if( sqlite3AuthCheck(pParse, 22,
       isRollback ? "ROLLBACK" : "COMMIT", 0, 0) ){
    return;
  }
  v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3VdbeAddOp2(v, 1, 1, isRollback);
  }
}





static void sqlite3Savepoint(Parse *pParse, int op, Token *pName){
  char *zName = sqlite3NameFromToken(pParse->db, pName);
  if( zName ){
    Vdbe *v = sqlite3GetVdbe(pParse);

    static const char * const az[] = { "BEGIN", "RELEASE", "ROLLBACK" };
    ((void) (0));

    if( !v || sqlite3AuthCheck(pParse, 32, az[op], zName, 0) ){
      sqlite3DbFree(pParse->db, zName);
      return;
    }
    sqlite3VdbeAddOp4(v, 0, op, 0, 0, zName, (-6));
  }
}





static int sqlite3OpenTempDatabase(Parse *pParse){
  sqlite3 *db = pParse->db;
  if( db->aDb[1].pBt==0 && !pParse->explain ){
    int rc;
    Btree *pBt;
    static const int flags =
          0x00000002 |
          0x00000004 |
          0x00000010 |
          0x00000008 |
          0x00000200;

    rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pBt, 0, flags);
    if( rc!=0 ){
      sqlite3ErrorMsg(pParse, "unable to open a temporary database "
        "file for storing temporary tables");
      pParse->rc = rc;
      return 1;
    }
    db->aDb[1].pBt = pBt;
    ((void) (0));
    if( 7==sqlite3BtreeSetPageSize(pBt, db->nextPagesize, 0, 0) ){
      sqlite3OomFault(db);
      return 1;
    }
  }
  return 0;
}







static void sqlite3CodeVerifySchemaAtToplevel(Parse *pToplevel, int iDb){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( (((pToplevel->cookieMask)&(((yDbMask)1)<<(iDb)))!=0)==0 ){
    ((pToplevel->cookieMask)|=(((yDbMask)1)<<(iDb)));
    if( !0 && iDb==1 ){
      sqlite3OpenTempDatabase(pToplevel);
    }
  }
}
static void sqlite3CodeVerifySchema(Parse *pParse, int iDb){
  sqlite3CodeVerifySchemaAtToplevel(((pParse)->pToplevel ? (pParse)->pToplevel : (pParse)), iDb);
}






static void sqlite3CodeVerifyNamedSchema(Parse *pParse, const char *zDb){
  sqlite3 *db = pParse->db;
  int i;
  for(i=0; i<db->nDb; i++){
    Db *pDb = &db->aDb[i];
    if( pDb->pBt && (!zDb || 0==sqlite3StrICmp(zDb, pDb->zDbSName)) ){
      sqlite3CodeVerifySchema(pParse, i);
    }
  }
}
# 129742 "c_tests/sqlite3.c"
static void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  sqlite3CodeVerifySchemaAtToplevel(pToplevel, iDb);
  ((pToplevel->writeMask)|=(((yDbMask)1)<<(iDb)));
  pToplevel->isMultiWrite |= setStatement;
}
# 129756 "c_tests/sqlite3.c"
static void sqlite3MultiWrite(Parse *pParse){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  pToplevel->isMultiWrite = 1;
}
# 129777 "c_tests/sqlite3.c"
static void sqlite3MayAbort(Parse *pParse){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  pToplevel->mayAbort = 1;
}






static void sqlite3HaltConstraint(
  Parse *pParse,
  int errCode,
  int onError,
  char *p4,
  i8 p4type,
  u8 p5Errmsg
){
  Vdbe *v;
  ((void) (0));
  v = sqlite3GetVdbe(pParse);
  ((void) (0));
  if( onError==2 ){
    sqlite3MayAbort(pParse);
  }
  sqlite3VdbeAddOp4(v, 71, errCode, onError, 0, p4, p4type);
  sqlite3VdbeChangeP5(v, p5Errmsg);
}




static void sqlite3UniqueConstraint(
  Parse *pParse,
  int onError,
  Index *pIdx
){
  char *zErr;
  int j;
  StrAccum errMsg;
  Table *pTab = pIdx->pTable;

  sqlite3StrAccumInit(&errMsg, pParse->db, 0, 0,
                      pParse->db->aLimit[0]);
  if( pIdx->aColExpr ){
    sqlite3_str_appendf(&errMsg, "index '%q'", pIdx->zName);
  }else{
    for(j=0; j<pIdx->nKeyCol; j++){
      char *zCol;
      ((void) (0));
      zCol = pTab->aCol[pIdx->aiColumn[j]].zCnName;
      if( j ) sqlite3_str_append(&errMsg, ", ", 2);
      sqlite3_str_appendall(&errMsg, pTab->zName);
      sqlite3_str_append(&errMsg, ".", 1);
      sqlite3_str_appendall(&errMsg, zCol);
    }
  }
  zErr = sqlite3StrAccumFinish(&errMsg);
  sqlite3HaltConstraint(pParse,
    ((pIdx)->idxType==2) ? (19 | (6<<8))
                            : (19 | (8<<8)),
    onError, zErr, (-6), 2);
}





static void sqlite3RowidConstraint(
  Parse *pParse,
  int onError,
  Table *pTab
){
  char *zMsg;
  int rc;
  if( pTab->iPKey>=0 ){
    zMsg = sqlite3MPrintf(pParse->db, "%s.%s", pTab->zName,
                          pTab->aCol[pTab->iPKey].zCnName);
    rc = (19 | (6<<8));
  }else{
    zMsg = sqlite3MPrintf(pParse->db, "%s.rowid", pTab->zName);
    rc = (19 |(10<<8));
  }
  sqlite3HaltConstraint(pParse, rc, onError, zMsg, (-6),
                        2);
}






static int collationMatch(const char *zColl, Index *pIndex){
  int i;
  ((void) (0));
  for(i=0; i<pIndex->nColumn; i++){
    const char *z = pIndex->azColl[i];
    ((void) (0));
    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){
      return 1;
    }
  }
  return 0;
}







static void reindexTable(Parse *pParse, Table *pTab, char const *zColl){
  if( !((pTab)->eTabType==1) ){
    Index *pIndex;

    for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){
      if( zColl==0 || collationMatch(zColl, pIndex) ){
        int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
        sqlite3BeginWriteOperation(pParse, 0, iDb);
        sqlite3RefillIndex(pParse, pIndex, -1);
      }
    }
  }
}
# 129909 "c_tests/sqlite3.c"
static void reindexDatabases(Parse *pParse, char const *zColl){
  Db *pDb;
  int iDb;
  sqlite3 *db = pParse->db;
  HashElem *k;
  Table *pTab;

  ((void) (0));
  for(iDb=0, pDb=db->aDb; iDb<db->nDb; iDb++, pDb++){
    ((void) (0));
    for(k=((&pDb->pSchema->tblHash)->first); k; k=((k)->next)){
      pTab = (Table*)((k)->data);
      reindexTable(pParse, pTab, zColl);
    }
  }
}
# 129941 "c_tests/sqlite3.c"
static void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){
  CollSeq *pColl;
  char *z;
  const char *zDb;
  Table *pTab;
  Index *pIndex;
  int iDb;
  sqlite3 *db = pParse->db;
  Token *pObjName;



  if( 0!=sqlite3ReadSchema(pParse) ){
    return;
  }

  if( pName1==0 ){
    reindexDatabases(pParse, 0);
    return;
  }else if( (pName2==0) || pName2->z==0 ){
    char *zColl;
    ((void) (0));
    zColl = sqlite3NameFromToken(pParse->db, pName1);
    if( !zColl ) return;
    pColl = sqlite3FindCollSeq(db, ((db)->enc), zColl, 0);
    if( pColl ){
      reindexDatabases(pParse, zColl);
      sqlite3DbFree(db, zColl);
      return;
    }
    sqlite3DbFree(db, zColl);
  }
  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pObjName);
  if( iDb<0 ) return;
  z = sqlite3NameFromToken(db, pObjName);
  if( z==0 ) return;
  zDb = pName2->n ? db->aDb[iDb].zDbSName : 0;
  pTab = sqlite3FindTable(db, z, zDb);
  if( pTab ){
    reindexTable(pParse, pTab, 0);
    sqlite3DbFree(db, z);
    return;
  }
  pIndex = sqlite3FindIndex(db, z, zDb);
  sqlite3DbFree(db, z);
  if( pIndex ){
    iDb = sqlite3SchemaToIndex(db, pIndex->pTable->pSchema);
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    sqlite3RefillIndex(pParse, pIndex, -1);
    return;
  }
  sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed");
}
# 130002 "c_tests/sqlite3.c"
static KeyInfo *sqlite3KeyInfoOfIndex(Parse *pParse, Index *pIdx){
  int i;
  int nCol = pIdx->nColumn;
  int nKey = pIdx->nKeyCol;
  KeyInfo *pKey;
  if( pParse->nErr ) return 0;
  if( pIdx->uniqNotNull ){
    pKey = sqlite3KeyInfoAlloc(pParse->db, nKey, nCol-nKey);
  }else{
    pKey = sqlite3KeyInfoAlloc(pParse->db, nCol, 0);
  }
  if( pKey ){
    ((void) (0));
    for(i=0; i<nCol; i++){
      const char *zColl = pIdx->azColl[i];
      pKey->aColl[i] = zColl==sqlite3StrBINARY ? 0 :
                        sqlite3LocateCollSeq(pParse, zColl);
      pKey->aSortFlags[i] = pIdx->aSortOrder[i];
      ((void) (0));
    }
    if( pParse->nErr ){
      ((void) (0));
      if( pIdx->bNoQuery==0
       && sqlite3HashFind(&pIdx->pSchema->idxHash, pIdx->zName)
      ){
# 130037 "c_tests/sqlite3.c"
        pIdx->bNoQuery = 1;
        pParse->rc = (1 | (2<<8));
      }
      sqlite3KeyInfoUnref(pKey);
      pKey = 0;
    }
  }
  return pKey;
}





static Cte *sqlite3CteNew(
  Parse *pParse,
  Token *pName,
  ExprList *pArglist,
  Select *pQuery,
  u8 eM10d
){
  Cte *pNew;
  sqlite3 *db = pParse->db;

  pNew = sqlite3DbMallocZero(db, sizeof(*pNew));
  ((void) (0));

  if( db->mallocFailed ){
    sqlite3ExprListDelete(db, pArglist);
    sqlite3SelectDelete(db, pQuery);
  }else{
    pNew->pSelect = pQuery;
    pNew->pCols = pArglist;
    pNew->zName = sqlite3NameFromToken(pParse->db, pName);
    pNew->eM10d = eM10d;
  }
  return pNew;
}





static void cteClear(sqlite3 *db, Cte *pCte){
  ((void) (0));
  sqlite3ExprListDelete(db, pCte->pCols);
  sqlite3SelectDelete(db, pCte->pSelect);
  sqlite3DbFree(db, pCte->zName);
}




static void sqlite3CteDelete(sqlite3 *db, Cte *pCte){
  ((void) (0));
  cteClear(db, pCte);
  sqlite3DbFree(db, pCte);
}







static With *sqlite3WithAdd(
  Parse *pParse,
  With *pWith,
  Cte *pCte
){
  sqlite3 *db = pParse->db;
  With *pNew;
  char *zName;

  if( pCte==0 ){
    return pWith;
  }



  zName = pCte->zName;
  if( zName && pWith ){
    int i;
    for(i=0; i<pWith->nCte; i++){
      if( sqlite3StrICmp(zName, pWith->a[i].zName)==0 ){
        sqlite3ErrorMsg(pParse, "duplicate WITH table name: %s", zName);
      }
    }
  }

  if( pWith ){
    pNew = sqlite3DbRealloc(db, pWith, (__builtin_offsetof(With, a) + (pWith->nCte+1)*sizeof(Cte)));
  }else{
    pNew = sqlite3DbMallocZero(db, (__builtin_offsetof(With, a) + (1)*sizeof(Cte)));
  }
  ((void) (0));

  if( db->mallocFailed ){
    sqlite3CteDelete(db, pCte);
    pNew = pWith;
  }else{
    pNew->a[pNew->nCte++] = *pCte;
    sqlite3DbFree(db, pCte);
  }

  return pNew;
}




static void sqlite3WithDelete(sqlite3 *db, With *pWith){
  if( pWith ){
    int i;
    for(i=0; i<pWith->nCte; i++){
      cteClear(db, &pWith->a[i]);
    }
    sqlite3DbFree(db, pWith);
  }
}
static void sqlite3WithDeleteGeneric(sqlite3 *db, void *pWith){
  sqlite3WithDelete(db, (With*)pWith);
}
# 130186 "c_tests/sqlite3.c"
static void callCollNeeded(sqlite3 *db, int enc, const char *zName){
  ((void) (0));
  if( db->xCollNeeded ){
    char *zExternal = sqlite3DbStrDup(db, zName);
    if( !zExternal ) return;
    db->xCollNeeded(db->pCollNeededArg, db, enc, zExternal);
    sqlite3DbFree(db, zExternal);
  }

  if( db->xCollNeeded16 ){
    char const *zExternal;
    sqlite3_value *pTmp = sqlite3ValueNew(db);
    sqlite3ValueSetStr(pTmp, -1, zName, 1, ((sqlite3_destructor_type)0));
    zExternal = sqlite3ValueText(pTmp, 2);
    if( zExternal ){
      db->xCollNeeded16(db->pCollNeededArg, db, (int)((db)->enc), zExternal);
    }
    sqlite3ValueFree(pTmp);
  }

}
# 130215 "c_tests/sqlite3.c"
static int synthCollSeq(sqlite3 *db, CollSeq *pColl){
  CollSeq *pColl2;
  char *z = pColl->zName;
  int i;
  static const u8 aEnc[] = { 3, 2, 1 };
  for(i=0; i<3; i++){
    pColl2 = sqlite3FindCollSeq(db, aEnc[i], z, 0);
    if( pColl2->xCmp!=0 ){
      memcpy(pColl, pColl2, sizeof(CollSeq));
      pColl->xDel = 0;
      return 0;
    }
  }
  return 1;
}
# 130242 "c_tests/sqlite3.c"
static int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl){
  if( pColl && pColl->xCmp==0 ){
    const char *zName = pColl->zName;
    sqlite3 *db = pParse->db;
    CollSeq *p = sqlite3GetCollSeq(pParse, ((db)->enc), pColl, zName);
    if( !p ){
      return 1;
    }
    ((void) (0));
  }
  return 0;
}
# 130270 "c_tests/sqlite3.c"
static CollSeq *findCollSeqEntry(
  sqlite3 *db,
  const char *zName,
  int create
){
  CollSeq *pColl;
  pColl = sqlite3HashFind(&db->aCollSeq, zName);

  if( 0==pColl && create ){
    int nName = sqlite3Strlen30(zName) + 1;
    pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl) + nName);
    if( pColl ){
      CollSeq *pDel = 0;
      pColl[0].zName = (char*)&pColl[3];
      pColl[0].enc = 1;
      pColl[1].zName = (char*)&pColl[3];
      pColl[1].enc = 2;
      pColl[2].zName = (char*)&pColl[3];
      pColl[2].enc = 3;
      memcpy(pColl[0].zName, zName, nName);
      pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, pColl);





      ((void) (0));
      if( pDel!=0 ){
        sqlite3OomFault(db);
        sqlite3DbFree(db, pDel);
        pColl = 0;
      }
    }
  }
  return pColl;
}
# 130322 "c_tests/sqlite3.c"
static CollSeq *sqlite3FindCollSeq(
  sqlite3 *db,
  u8 enc,
  const char *zName,
  int create
){
  CollSeq *pColl;
  ((void) (0));
  ((void) (0));
  if( zName ){
    pColl = findCollSeqEntry(db, zName, create);
    if( pColl ) pColl += enc-1;
  }else{
    pColl = db->pDfltColl;
  }
  return pColl;
}





static void sqlite3SetTextEncoding(sqlite3 *db, u8 enc){
  ((void) (0));
  db->enc = enc;



  db->pDfltColl = sqlite3FindCollSeq(db, enc, sqlite3StrBINARY, 0);
  sqlite3ExpirePreparedStatements(db, 1);
}
# 130368 "c_tests/sqlite3.c"
static CollSeq *sqlite3GetCollSeq(
  Parse *pParse,
  u8 enc,
  CollSeq *pColl,
  const char *zName
){
  CollSeq *p;
  sqlite3 *db = pParse->db;

  p = pColl;
  if( !p ){
    p = sqlite3FindCollSeq(db, enc, zName, 0);
  }
  if( !p || !p->xCmp ){



    callCollNeeded(db, enc, zName);
    p = sqlite3FindCollSeq(db, enc, zName, 0);
  }
  if( p && !p->xCmp && synthCollSeq(db, p) ){
    p = 0;
  }
  ((void) (0));
  if( p==0 ){
    sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName);
    pParse->rc = (1 | (1<<8));
  }
  return p;
}
# 130419 "c_tests/sqlite3.c"
static CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName){
  sqlite3 *db = pParse->db;
  u8 enc = ((db)->enc);
  u8 initbusy = db->init.busy;
  CollSeq *pColl;

  pColl = sqlite3FindCollSeq(db, enc, zName, initbusy);
  if( !initbusy && (!pColl || !pColl->xCmp) ){
    pColl = sqlite3GetCollSeq(pParse, enc, pColl, zName);
  }

  return pColl;
}
# 130462 "c_tests/sqlite3.c"
static int matchQuality(
  FuncDef *p,
  int nArg,
  u8 enc
){
  int match;
  ((void) (0));
  ((void) (0));


  if( p->nArg!=nArg ){
    if( nArg==(-2) ) return p->xSFunc==0 ? 0 : 6;
    if( p->nArg>=0 ) return 0;




    if( p->nArg<(-2) && nArg<(-2-p->nArg) ) return 0;
  }



  if( p->nArg==nArg ){
    match = 4;
  }else{
    match = 1;
  }


  if( enc==(p->funcFlags & 0x0003) ){
    match += 2;
  }else if( (enc & p->funcFlags & 2)!=0 ){
    match += 1;
  }

  return match;
}





static FuncDef *sqlite3FunctionSearch(
  int h,
  const char *zFunc
){
  FuncDef *p;
  for(p=sqlite3BuiltinFunctions.a[h]; p; p=p->u.pHash){
    ((void) (0));
    if( sqlite3StrICmp(p->zName, zFunc)==0 ){
      return p;
    }
  }
  return 0;
}




static void sqlite3InsertBuiltinFuncs(
  FuncDef *aDef,
  int nDef
){
  int i;
  for(i=0; i<nDef; i++){
    FuncDef *pOther;
    const char *zName = aDef[i].zName;
    int nName = sqlite3Strlen30(zName);
    int h = (((zName[0])+(nName))%23);
    ((void) (0));
    pOther = sqlite3FunctionSearch(h, zName);
    if( pOther ){
      ((void) (0));
      aDef[i].pNext = pOther->pNext;
      pOther->pNext = &aDef[i];
    }else{
      aDef[i].pNext = 0;
      aDef[i].u.pHash = sqlite3BuiltinFunctions.a[h];
      sqlite3BuiltinFunctions.a[h] = &aDef[i];
    }
  }
}
# 130566 "c_tests/sqlite3.c"
static FuncDef *sqlite3FindFunction(
  sqlite3 *db,
  const char *zName,
  int nArg,
  u8 enc,
  u8 createFlag
){
  FuncDef *p;
  FuncDef *pBest = 0;
  int bestScore = 0;
  int h;
  int nName;

  ((void) (0));
  ((void) (0));
  nName = sqlite3Strlen30(zName);



  p = (FuncDef*)sqlite3HashFind(&db->aFunc, zName);
  while( p ){
    int score = matchQuality(p, nArg, enc);
    if( score>bestScore ){
      pBest = p;
      bestScore = score;
    }
    p = p->pNext;
  }
# 130607 "c_tests/sqlite3.c"
  if( !createFlag && (pBest==0 || (db->mDbFlags & 0x0002)!=0) ){
    bestScore = 0;
    h = (((sqlite3UpperToLower[(u8)zName[0]])+(nName))%23);
    p = sqlite3FunctionSearch(h, zName);
    while( p ){
      int score = matchQuality(p, nArg, enc);
      if( score>bestScore ){
        pBest = p;
        bestScore = score;
      }
      p = p->pNext;
    }
  }





  if( createFlag && bestScore<6 &&
      (pBest = sqlite3DbMallocZero(db, sizeof(*pBest)+nName+1))!=0 ){
    FuncDef *pOther;
    u8 *z;
    pBest->zName = (const char*)&pBest[1];
    pBest->nArg = (u16)nArg;
    pBest->funcFlags = enc;
    memcpy((char*)&pBest[1], zName, nName+1);
    for(z=(u8*)pBest->zName; *z; z++) *z = sqlite3UpperToLower[*z];
    pOther = (FuncDef*)sqlite3HashInsert(&db->aFunc, pBest->zName, pBest);
    if( pOther==pBest ){
      sqlite3DbFree(db, pBest);
      sqlite3OomFault(db);
      return 0;
    }else{
      pBest->pNext = pOther;
    }
  }

  if( pBest && (pBest->xSFunc || createFlag) ){
    return pBest;
  }
  return 0;
}
# 130658 "c_tests/sqlite3.c"
static void sqlite3SchemaClear(void *p){
  Hash temp1;
  Hash temp2;
  HashElem *pElem;
  Schema *pSchema = (Schema *)p;
  sqlite3 xdb;

  memset(&xdb, 0, sizeof(xdb));
  temp1 = pSchema->tblHash;
  temp2 = pSchema->trigHash;
  sqlite3HashInit(&pSchema->trigHash);
  sqlite3HashClear(&pSchema->idxHash);
  for(pElem=((&temp2)->first); pElem; pElem=((pElem)->next)){
    sqlite3DeleteTrigger(&xdb, (Trigger*)((pElem)->data));
  }

  sqlite3HashClear(&temp2);
  sqlite3HashInit(&pSchema->tblHash);
  for(pElem=((&temp1)->first); pElem; pElem=((pElem)->next)){
    Table *pTab = ((pElem)->data);
    sqlite3DeleteTable(&xdb, pTab);
  }
  sqlite3HashClear(&temp1);
  sqlite3HashClear(&pSchema->fkeyHash);
  pSchema->pSeqTab = 0;
  if( pSchema->schemaFlags & 0x0001 ){
    pSchema->iGeneration++;
  }
  pSchema->schemaFlags &= ~(0x0001|0x0008);
}





static Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt){
  Schema * p;
  if( pBt ){
    p = (Schema *)sqlite3BtreeSchema(pBt, sizeof(Schema), sqlite3SchemaClear);
  }else{
    p = (Schema *)sqlite3DbMallocZero(0, sizeof(Schema));
  }
  if( !p ){
    sqlite3OomFault(db);
  }else if ( 0==p->file_format ){
    sqlite3HashInit(&p->tblHash);
    sqlite3HashInit(&p->idxHash);
    sqlite3HashInit(&p->trigHash);
    sqlite3HashInit(&p->fkeyHash);
    p->enc = 1;
  }
  return p;
}
# 130744 "c_tests/sqlite3.c"
static Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){
  SrcItem *pItem = pSrc->a;
  Table *pTab;
  ((void) (0));
  pTab = sqlite3LocateTableItem(pParse, 0, pItem);
  if( pItem->pSTab ) sqlite3DeleteTable(pParse->db, pItem->pSTab);
  pItem->pSTab = pTab;
  pItem->fg.notCte = 1;
  if( pTab ){
    pTab->nTabRef++;
    if( pItem->fg.isIndexedBy && sqlite3IndexedByLookup(pParse, pItem) ){
      pTab = 0;
    }
  }
  return pTab;
}




static void sqlite3CodeChangeCount(Vdbe *v, int regCounter, const char *zColName){
  sqlite3VdbeAddOp0(v, 84);
  sqlite3VdbeAddOp2(v, 85, regCounter, 1);
  sqlite3VdbeSetNumCols(v, 1);
  sqlite3VdbeSetColName(v, 0, 0, zColName, ((sqlite3_destructor_type)0));
}
# 130790 "c_tests/sqlite3.c"
static int vtabIsReadOnly(Parse *pParse, Table *pTab){
  ((void) (0));
  if( sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0 ){
    return 1;
  }







  if( pParse->pToplevel!=0
   && pTab->u.vtab.p->eVtabRisk >
           ((pParse->db->flags & 0x00000080)!=0)
  ){
    sqlite3ErrorMsg(pParse, "unsafe use of virtual table \"%s\"",
      pTab->zName);
  }
  return 0;
}
static int tabIsReadOnly(Parse *pParse, Table *pTab){
  sqlite3 *db;
  if( ((pTab)->eTabType==1) ){
    return vtabIsReadOnly(pParse, pTab);
  }
  if( (pTab->tabFlags & (0x00000001|0x00001000))==0 ) return 0;
  db = pParse->db;
  if( (pTab->tabFlags & 0x00000001)!=0 ){
    return sqlite3WritableSchema(db)==0 && pParse->nested==0;
  }
  ((void) (0));
  return sqlite3ReadOnlyShadowTables(db);
}
# 130832 "c_tests/sqlite3.c"
static int sqlite3IsReadOnly(Parse *pParse, Table *pTab, Trigger *pTrigger){
  if( tabIsReadOnly(pParse, pTab) ){
    sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab->zName);
    return 1;
  }

  if( ((pTab)->eTabType==2)
   && (pTrigger==0 || (pTrigger->bReturning && pTrigger->pNext==0))
  ){
    sqlite3ErrorMsg(pParse,"cannot modify %s because it is a view",pTab->zName);
    return 1;
  }

  return 0;
}
# 130855 "c_tests/sqlite3.c"
static void sqlite3MaterializeView(
  Parse *pParse,
  Table *pView,
  Expr *pWhere,
  ExprList *pOrderBy,
  Expr *pLimit,
  int iCur
){
  SelectDest dest;
  Select *pSel;
  SrcList *pFrom;
  sqlite3 *db = pParse->db;
  int iDb = sqlite3SchemaToIndex(db, pView->pSchema);
  pWhere = sqlite3ExprDup(db, pWhere, 0);
  pFrom = sqlite3SrcListAppend(pParse, 0, 0, 0);
  if( pFrom ){
    ((void) (0));
    pFrom->a[0].zName = sqlite3DbStrDup(db, pView->zName);
    ((void) (0));
    pFrom->a[0].u4.zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);
    ((void) (0));
    ((void) (0));
  }
  pSel = sqlite3SelectNew(pParse, 0, pFrom, pWhere, 0, 0, pOrderBy,
                          0x0020000, pLimit);
  sqlite3SelectDestInit(&dest, 12, iCur);
  sqlite3Select(pParse, pSel, &dest);
  sqlite3SelectDelete(db, pSel);
}
# 131001 "c_tests/sqlite3.c"
static void sqlite3DeleteFrom(
  Parse *pParse,
  SrcList *pTabList,
  Expr *pWhere,
  ExprList *pOrderBy,
  Expr *pLimit
){
  Vdbe *v;
  Table *pTab;
  int i;
  WhereInfo *pWInfo;
  Index *pIdx;
  int iTabCur;
  int iDataCur = 0;
  int iIdxCur = 0;
  int nIdx;
  sqlite3 *db;
  AuthContext sContext;
  NameContext sNC;
  int iDb;
  int memCnt = 0;
  int rcauth;
  int eOnePass;
  int aiCurOnePass[2];
  u8 *aToOpen = 0;
  Index *pPk;
  int iPk = 0;
  i16 nPk = 1;
  int iKey;
  i16 nKey;
  int iEphCur = 0;
  int iRowSet = 0;
  int addrBypass = 0;
  int addrLoop = 0;
  int addrEphOpen = 0;
  int bComplex;



  int isView;
  Trigger *pTrigger;


  memset(&sContext, 0, sizeof(sContext));
  db = pParse->db;
  ((void) (0));
  if( pParse->nErr ){
    goto delete_from_cleanup;
  }
  ((void) (0));
  ((void) (0));






  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if( pTab==0 ) goto delete_from_cleanup;





  pTrigger = sqlite3TriggersExist(pParse, pTab, 129, 0, 0);
  isView = ((pTab)->eTabType==2);




  bComplex = pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0);
# 131097 "c_tests/sqlite3.c"
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto delete_from_cleanup;
  }

  if( sqlite3IsReadOnly(pParse, pTab, pTrigger) ){
    goto delete_from_cleanup;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void) (0));
  rcauth = sqlite3AuthCheck(pParse, 9, pTab->zName, 0,
                            db->aDb[iDb].zDbSName);
  ((void) (0));
  if( rcauth==1 ){
    goto delete_from_cleanup;
  }
  ((void) (0));



  ((void) (0));
  iTabCur = pTabList->a[0].iCursor = pParse->nTab++;
  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){
    pParse->nTab++;
  }



  if( isView ){
    sqlite3AuthContextPush(pParse, &sContext, pTab->zName);
  }



  v = sqlite3GetVdbe(pParse);
  if( v==0 ){
    goto delete_from_cleanup;
  }
  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
  sqlite3BeginWriteOperation(pParse, bComplex, iDb);





  if( isView ){
    sqlite3MaterializeView(pParse, pTab,
        pWhere, pOrderBy, pLimit, iTabCur
    );
    iDataCur = iIdxCur = iTabCur;
    pOrderBy = 0;
    pLimit = 0;
  }




  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  if( sqlite3ResolveExprNames(&sNC, pWhere) ){
    goto delete_from_cleanup;
  }




  if( (db->flags & ((u64)(0x00001)<<32))!=0
   && !pParse->nested
   && !pParse->pTriggerTab
   && !pParse->bReturning
  ){
    memCnt = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 72, 0, memCnt);
  }
# 131184 "c_tests/sqlite3.c"
  if( rcauth==0
   && pWhere==0
   && !bComplex
   && !((pTab)->eTabType==1)



  ){
    ((void) (0));
    sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);
    if( (((pTab)->tabFlags & 0x00000080)==0) ){
      sqlite3VdbeAddOp4(v, 146, pTab->tnum, iDb, memCnt ? memCnt : -1,
                        pTab->zName, (-1));
    }
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      ((void) (0));
      if( ((pIdx)->idxType==2) && !(((pTab)->tabFlags & 0x00000080)==0) ){
        sqlite3VdbeAddOp3(v, 146, pIdx->tnum, iDb, memCnt ? memCnt : -1);
      }else{
        sqlite3VdbeAddOp2(v, 146, pIdx->tnum, iDb);
      }
    }
  }else

  {
    u16 wcf = 0x0004|0x0010;
    if( sNC.ncFlags & 0x000040 ) bComplex = 1;
    wcf |= (bComplex ? 0 : 0x0008);
    if( (((pTab)->tabFlags & 0x00000080)==0) ){

      pPk = 0;
      ((void) (0));
      iRowSet = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, 76, 0, iRowSet);
    }else{


      pPk = sqlite3PrimaryKeyIndex(pTab);
      ((void) (0));
      nPk = pPk->nKeyCol;
      iPk = pParse->nMem+1;
      pParse->nMem += nPk;
      iEphCur = pParse->nTab++;
      addrEphOpen = sqlite3VdbeAddOp2(v, 119, iEphCur, nPk);
      sqlite3VdbeSetP4KeyInfo(pParse, pPk);
    }
# 131239 "c_tests/sqlite3.c"
    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0,0,wcf,iTabCur+1);
    if( pWInfo==0 ) goto delete_from_cleanup;
    eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
    ((void) (0));
    ((void) (0));

    if( eOnePass!=1 ) sqlite3MultiWrite(pParse);
    if( sqlite3WhereUsesDeferredSeek(pWInfo) ){
      sqlite3VdbeAddOp1(v, 144, iTabCur);
    }


    if( memCnt ){
      sqlite3VdbeAddOp2(v, 87, memCnt, 1);
    }


    if( pPk ){
      for(i=0; i<nPk; i++){
        ((void) (0));
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur,
                                        pPk->aiColumn[i], iPk+i);
      }
      iKey = iPk;
    }else{
      iKey = ++pParse->nMem;
      sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, -1, iKey);
    }

    if( eOnePass!=0 ){



      nKey = nPk;
      aToOpen = sqlite3DbMallocRawNN(db, nIdx+2);
      if( aToOpen==0 ){
        sqlite3WhereEnd(pWInfo);
        goto delete_from_cleanup;
      }
      memset(aToOpen, 1, nIdx+1);
      aToOpen[nIdx+1] = 0;
      if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iTabCur] = 0;
      if( aiCurOnePass[1]>=0 ) aToOpen[aiCurOnePass[1]-iTabCur] = 0;
      if( addrEphOpen ) sqlite3VdbeChangeToNoop(v, addrEphOpen);
      addrBypass = sqlite3VdbeMakeLabel(pParse);
    }else{
      if( pPk ){

        iKey = ++pParse->nMem;
        nKey = 0;
        sqlite3VdbeAddOp4(v, 98, iPk, nPk, iKey,
            sqlite3IndexAffinityStr(pParse->db, pPk), nPk);
        sqlite3VdbeAddOp4Int(v, 139, iEphCur, iKey, iPk, nPk);
      }else{

        nKey = 1;
        sqlite3VdbeAddOp2(v, 157, iRowSet, iKey);
      }
      sqlite3WhereEnd(pWInfo);
    }






    if( !isView ){
      int iAddrOnce = 0;
      if( eOnePass==2 ){
        iAddrOnce = sqlite3VdbeAddOp0(v, 15); ;
      }
                                 ;
      sqlite3OpenTableAndIndices(pParse, pTab, 114, 0x08,
                                 iTabCur, aToOpen, &iDataCur, &iIdxCur);
      ((void) (0));
      ((void) (0));
      if( eOnePass==2 ){
        sqlite3VdbeJumpHereOrPopInst(v, iAddrOnce);
      }
    }




    if( eOnePass!=0 ){
      ((void) (0));
      if( !((pTab)->eTabType==1) && aToOpen[iDataCur-iTabCur] ){
        ((void) (0));
        sqlite3VdbeAddOp4Int(v, 28, iDataCur, addrBypass, iKey, nKey);
                       ;
      }
    }else if( pPk ){
      addrLoop = sqlite3VdbeAddOp1(v, 36, iEphCur); ;
      if( ((pTab)->eTabType==1) ){
        sqlite3VdbeAddOp3(v, 95, iEphCur, 0, iKey);
      }else{
        sqlite3VdbeAddOp2(v, 135, iEphCur, iKey);
      }
      ((void) (0));
    }else{
      addrLoop = sqlite3VdbeAddOp3(v, 47, iRowSet, 0, iKey);
                     ;
      ((void) (0));
    }



    if( ((pTab)->eTabType==1) ){
      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
      sqlite3VtabMakeWritable(pParse, pTab);
      ((void) (0));
      sqlite3MayAbort(pParse);
      if( eOnePass==1 ){
        sqlite3VdbeAddOp1(v, 123, iTabCur);
        if( ((pParse)->pToplevel==0) ){
          pParse->isMultiWrite = 0;
        }
      }
      sqlite3VdbeAddOp4(v, 7, 0, 1, iKey, pVTab, (-11));
      sqlite3VdbeChangeP5(v, 2);
    }else

    {
      int count = (pParse->nested==0);
      sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
          iKey, nKey, count, 11, eOnePass, aiCurOnePass[1]);
    }


    if( eOnePass!=0 ){
      sqlite3VdbeResolveLabel(v, addrBypass);
      sqlite3WhereEnd(pWInfo);
    }else if( pPk ){
      sqlite3VdbeAddOp2(v, 40, iEphCur, addrLoop+1); ;
      sqlite3VdbeJumpHere(v, addrLoop);
    }else{
      sqlite3VdbeGoto(v, addrLoop);
      sqlite3VdbeJumpHere(v, addrLoop);
    }
  }





  if( pParse->nested==0 && pParse->pTriggerTab==0 ){
    sqlite3AutoincrementEnd(pParse);
  }





  if( memCnt ){
    sqlite3CodeChangeCount(v, memCnt, "rows deleted");
  }

delete_from_cleanup:
  sqlite3AuthContextPop(&sContext);
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprDelete(db, pWhere);




  if( aToOpen ) sqlite3DbNNFreeNN(db, aToOpen);
  return;
}
# 131458 "c_tests/sqlite3.c"
static void sqlite3GenerateRowDelete(
  Parse *pParse,
  Table *pTab,
  Trigger *pTrigger,
  int iDataCur,
  int iIdxCur,
  int iPk,
  i16 nPk,
  u8 count,
  u8 onconf,
  u8 eMode,
  int iIdxNoSeek
){
  Vdbe *v = pParse->pVdbe;
  int iOld = 0;
  int iLabel;
  u8 opSeek;


  ((void) (0));

                                                           ;




  iLabel = sqlite3VdbeMakeLabel(pParse);
  opSeek = (((pTab)->tabFlags & 0x00000080)==0) ? 31 : 28;
  if( eMode==0 ){
    sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);
                                           ;
                                          ;
  }



  if( sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger ){
    u32 mask;
    int iCol;
    int addrStart;



    mask = sqlite3TriggerColmask(
        pParse, pTrigger, 0, 0, 1|2, pTab, onconf
    );
    mask |= sqlite3FkOldmask(pParse, pTab);
    iOld = pParse->nMem+1;
    pParse->nMem += (1 + pTab->nCol);



    sqlite3VdbeAddOp2(v, 81, iPk, iOld);
    for(iCol=0; iCol<pTab->nCol; iCol++){
                                              ;
                                              ;
      if( mask==0xffffffff || (iCol<=31 && (mask & (((unsigned int)1)<<(iCol)))!=0) ){
        int kk = sqlite3TableColumnToStorage(pTab, iCol);
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+kk+1);
      }
    }


    addrStart = sqlite3VdbeCurrentAddr(v);
    sqlite3CodeRowTrigger(pParse, pTrigger,
        129, 0, 1, pTab, iOld, onconf, iLabel
    );
# 131534 "c_tests/sqlite3.c"
    if( addrStart<sqlite3VdbeCurrentAddr(v) ){
      sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);
                                             ;
                                            ;
                               ;
      iIdxNoSeek = -1;
    }




    sqlite3FkCheck(pParse, pTab, iOld, 0, 0, 0);
  }
# 131558 "c_tests/sqlite3.c"
  if( !((pTab)->eTabType==2) ){
    u8 p5 = 0;
    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur,0,iIdxNoSeek);
    sqlite3VdbeAddOp2(v, 131, iDataCur, (count?0x01:0));
    if( pParse->nested==0 || 0==sqlite3_stricmp(pTab->zName, "sqlite_stat1") ){
      sqlite3VdbeAppendP4(v, (char*)pTab, (-5));
    }
    if( eMode!=0 ){
      sqlite3VdbeChangeP5(v, 0x04);
    }
    if( iIdxNoSeek>=0 && iIdxNoSeek!=iDataCur ){
      sqlite3VdbeAddOp1(v, 131, iIdxNoSeek);
    }
    if( eMode==2 ) p5 |= 0x02;
    sqlite3VdbeChangeP5(v, p5);
  }




  sqlite3FkActions(pParse, pTab, 0, iOld, 0, 0);


  if( pTrigger ){
    sqlite3CodeRowTrigger(pParse, pTrigger,
        129, 0, 2, pTab, iOld, onconf, iLabel
    );
  }




  sqlite3VdbeResolveLabel(v, iLabel);
                                            ;
}
# 131612 "c_tests/sqlite3.c"
static void sqlite3GenerateRowIndexDelete(
  Parse *pParse,
  Table *pTab,
  int iDataCur,
  int iIdxCur,
  int *aRegIdx,
  int iIdxNoSeek
){
  int i;
  int r1 = -1;
  int iPartIdxLabel;
  Index *pIdx;
  Index *pPrior = 0;
  Vdbe *v;
  Index *pPk;

  v = pParse->pVdbe;
  pPk = (((pTab)->tabFlags & 0x00000080)==0) ? 0 : sqlite3PrimaryKeyIndex(pTab);
  for(i=0, pIdx=pTab->pIndex; pIdx; i++, pIdx=pIdx->pNext){
    ((void) (0));
    if( aRegIdx!=0 && aRegIdx[i]==0 ) continue;
    if( pIdx==pPk ) continue;
    if( iIdxCur+i==iIdxNoSeek ) continue;
                                                              ;
    r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 1,
        &iPartIdxLabel, pPrior, r1);
    sqlite3VdbeAddOp3(v, 141, iIdxCur+i, r1,
        pIdx->uniqNotNull ? pIdx->nKeyCol : pIdx->nColumn);
    sqlite3VdbeChangeP5(v, 1);
    sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);
    pPrior = pIdx;
  }
}
# 131677 "c_tests/sqlite3.c"
static int sqlite3GenerateIndexKey(
  Parse *pParse,
  Index *pIdx,
  int iDataCur,
  int regOut,
  int prefixOnly,
  int *piPartIdxLabel,
  Index *pPrior,
  int regPrior
){
  Vdbe *v = pParse->pVdbe;
  int j;
  int regBase;
  int nCol;

  if( piPartIdxLabel ){
    if( pIdx->pPartIdxWhere ){
      *piPartIdxLabel = sqlite3VdbeMakeLabel(pParse);
      pParse->iSelfTab = iDataCur + 1;
      sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, *piPartIdxLabel,
                            0x10);
      pParse->iSelfTab = 0;
      pPrior = 0;

    }else{
      *piPartIdxLabel = 0;
    }
  }
  nCol = (prefixOnly && pIdx->uniqNotNull) ? pIdx->nKeyCol : pIdx->nColumn;
  regBase = sqlite3GetTempRange(pParse, nCol);
  if( pPrior && (regBase!=regPrior || pPrior->pPartIdxWhere) ) pPrior = 0;
  for(j=0; j<nCol; j++){
    if( pPrior
     && pPrior->aiColumn[j]==pIdx->aiColumn[j]
     && pPrior->aiColumn[j]!=(-2)
    ){

      continue;
    }
    sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iDataCur, j, regBase+j);
    if( pIdx->aiColumn[j]>=0 ){






      sqlite3VdbeDeletePriorOpcode(v, 88);
    }
  }
  if( regOut ){
    sqlite3VdbeAddOp3(v, 98, regBase, nCol, regOut);
  }
  sqlite3ReleaseTempRange(pParse, regBase, nCol);
  return regBase;
}






static void sqlite3ResolvePartIdxLabel(Parse *pParse, int iLabel){
  if( iLabel ){
    sqlite3VdbeResolveLabel(pParse->pVdbe, iLabel);
  }
}
# 131773 "c_tests/sqlite3.c"
static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){
  VdbeOp *pOp;
  ((void) (0));
  pOp = &context->pVdbe->aOp[context->iOp-1];
  ((void) (0));
  ((void) (0));
  return pOp->p4.pColl;
}





static void sqlite3SkipAccumulatorLoad(sqlite3_context *context){
  ((void) (0));
  context->isError = -1;
  context->skipFlag = 1;
}




static void minmaxFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int i;
  int mask;
  int iBest;
  CollSeq *pColl;

  ((void) (0));
  mask = sqlite3_user_data(context)==0 ? 0 : -1;
  pColl = sqlite3GetFuncCollSeq(context);
  ((void) (0));
  ((void) (0));
  iBest = 0;
  if( sqlite3_value_type(argv[0])==5 ) return;
  for(i=1; i<argc; i++){
    if( sqlite3_value_type(argv[i])==5 ) return;
    if( (sqlite3MemCompare(argv[iBest], argv[i], pColl)^mask)>=0 ){
                         ;
      iBest = i;
    }
  }
  sqlite3_result_value(context, argv[iBest]);
}




static void typeofFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  static const char *azType[] = { "integer", "real", "text", "blob", "null" };
  int i = sqlite3_value_type(argv[0]) - 1;
  (void)(NotUsed);
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));




  sqlite3_result_text(context, azType[i], -1, ((sqlite3_destructor_type)0));
}





static void subtypeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  (void)(argc);
  sqlite3_result_int(context, sqlite3_value_subtype(argv[0]));
}




static void lengthFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  ((void) (0));
  (void)(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case 4:
    case 1:
    case 2: {
      sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));
      break;
    }
    case 3: {
      const unsigned char *z = sqlite3_value_text(argv[0]);
      const unsigned char *z0;
      unsigned char c;
      if( z==0 ) return;
      z0 = z;
      while( (c = *z)!=0 ){
        z++;
        if( c>=0xc0 ){
          while( (*z & 0xc0)==0x80 ){ z++; z0++; }
        }
      }
      sqlite3_result_int(context, (int)(z-z0));
      break;
    }
    default: {
      sqlite3_result_null(context);
      break;
    }
  }
}




static void bytelengthFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  ((void) (0));
  (void)(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case 4: {
      sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));
      break;
    }
    case 1:
    case 2: {
      i64 m = sqlite3_context_db_handle(context)->enc<=1 ? 1 : 2;
      sqlite3_result_int64(context, sqlite3_value_bytes(argv[0])*m);
      break;
    }
    case 3: {
      if( sqlite3_value_encoding(argv[0])<=1 ){
        sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));
      }else{
        sqlite3_result_int(context, sqlite3_value_bytes16(argv[0]));
      }
      break;
    }
    default: {
      sqlite3_result_null(context);
      break;
    }
  }
}







static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  ((void) (0));
  (void)(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case 1: {
      i64 iVal = sqlite3_value_int64(argv[0]);
      if( iVal<0 ){
        if( iVal==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ){



          sqlite3_result_error(context, "integer overflow", -1);
          return;
        }
        iVal = -iVal;
      }
      sqlite3_result_int64(context, iVal);
      break;
    }
    case 5: {

      sqlite3_result_null(context);
      break;
    }
    default: {





      double rVal = sqlite3_value_double(argv[0]);
      if( rVal<0 ) rVal = -rVal;
      sqlite3_result_double(context, rVal);
      break;
    }
  }
}
# 131989 "c_tests/sqlite3.c"
static void instrFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zHaystack;
  const unsigned char *zNeedle;
  int nHaystack;
  int nNeedle;
  int typeHaystack, typeNeedle;
  int N = 1;
  int isText;
  unsigned char firstChar;
  sqlite3_value *pC1 = 0;
  sqlite3_value *pC2 = 0;

  (void)(argc);
  typeHaystack = sqlite3_value_type(argv[0]);
  typeNeedle = sqlite3_value_type(argv[1]);
  if( typeHaystack==5 || typeNeedle==5 ) return;
  nHaystack = sqlite3_value_bytes(argv[0]);
  nNeedle = sqlite3_value_bytes(argv[1]);
  if( nNeedle>0 ){
    if( typeHaystack==4 && typeNeedle==4 ){
      zHaystack = sqlite3_value_blob(argv[0]);
      zNeedle = sqlite3_value_blob(argv[1]);
      isText = 0;
    }else if( typeHaystack!=4 && typeNeedle!=4 ){
      zHaystack = sqlite3_value_text(argv[0]);
      zNeedle = sqlite3_value_text(argv[1]);
      isText = 1;
    }else{
      pC1 = sqlite3_value_dup(argv[0]);
      zHaystack = sqlite3_value_text(pC1);
      if( zHaystack==0 ) goto endInstrOOM;
      nHaystack = sqlite3_value_bytes(pC1);
      pC2 = sqlite3_value_dup(argv[1]);
      zNeedle = sqlite3_value_text(pC2);
      if( zNeedle==0 ) goto endInstrOOM;
      nNeedle = sqlite3_value_bytes(pC2);
      isText = 1;
    }
    if( zNeedle==0 || (nHaystack && zHaystack==0) ) goto endInstrOOM;
    firstChar = zNeedle[0];
    while( nNeedle<=nHaystack
       && (zHaystack[0]!=firstChar || memcmp(zHaystack, zNeedle, nNeedle)!=0)
    ){
      N++;
      do{
        nHaystack--;
        zHaystack++;
      }while( isText && (zHaystack[0]&0xc0)==0x80 );
    }
    if( nNeedle>nHaystack ) N = 0;
  }
  sqlite3_result_int(context, N);
endInstr:
  sqlite3_value_free(pC1);
  sqlite3_value_free(pC2);
  return;
endInstrOOM:
  sqlite3_result_error_nomem(context);
  goto endInstr;
}




static void printfFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  PrintfArguments x;
  StrAccum str;
  const char *zFormat;
  int n;
  sqlite3 *db = sqlite3_context_db_handle(context);

  if( argc>=1 && (zFormat = (const char*)sqlite3_value_text(argv[0]))!=0 ){
    x.nArg = argc-1;
    x.nUsed = 0;
    x.apArg = argv+1;
    sqlite3StrAccumInit(&str, db, 0, 0, db->aLimit[0]);
    str.printfFlags = 0x02;
    sqlite3_str_appendf(&str, zFormat, &x);
    n = str.nChar;
    sqlite3_result_text(context, sqlite3StrAccumFinish(&str), n,
                        ((sqlite3_destructor_type)sqlite3RowSetClear));
  }
}
# 132093 "c_tests/sqlite3.c"
static void substrFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *z;
  const unsigned char *z2;
  int len;
  int p0type;
  i64 p1, p2;

  ((void) (0));
  p0type = sqlite3_value_type(argv[0]);
  p1 = sqlite3_value_int64(argv[1]);
  if( p0type==4 ){
    len = sqlite3_value_bytes(argv[0]);
    z = sqlite3_value_blob(argv[0]);
    if( z==0 ) return;
    ((void) (0));
  }else{
    z = sqlite3_value_text(argv[0]);
    if( z==0 ) return;
    len = 0;
    if( p1<0 ){
      for(z2=z; *z2; len++){
        { if( (*(z2++))>=0xc0 ){ while( (*z2 & 0xc0)==0x80 ){ z2++; } } };
      }
    }
  }
  if( argc==3 ){
    p2 = sqlite3_value_int64(argv[2]);
    if( p2==0 && sqlite3_value_type(argv[2])==5 ) return;
  }else{
    p2 = sqlite3_context_db_handle(context)->aLimit[0];
  }
  if( p1==0 ){
# 132137 "c_tests/sqlite3.c"
    if( sqlite3_value_type(argv[1])==5 ) return;
  }
  if( p1<0 ){
    p1 += len;
    if( p1<0 ){
      if( p2<0 ){
        p2 = 0;
      }else{
        p2 += p1;
      }
      p1 = 0;
    }
  }else if( p1>0 ){
    p1--;
  }else if( p2>0 ){
    p2--;
  }
  if( p2<0 ){
    if( p2<-p1 ){
      p2 = p1;
    }else{
      p2 = -p2;
    }
    p1 -= p2;
  }
  ((void) (0));
  if( p0type!=4 ){
    while( *z && p1 ){
      { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
      p1--;
    }
    for(z2=z; *z2 && p2; p2--){
      { if( (*(z2++))>=0xc0 ){ while( (*z2 & 0xc0)==0x80 ){ z2++; } } };
    }
    sqlite3_result_text64(context, (char*)z, z2-z, ((sqlite3_destructor_type)-1),
                          1);
  }else{
    if( p1>=len ){
      p1 = p2 = 0;
    }else if( p2>len-p1 ){
      p2 = len-p1;
      ((void) (0));
    }
    sqlite3_result_blob64(context, (char*)&z[p1], (u64)p2, ((sqlite3_destructor_type)-1));
  }
}





static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  i64 n = 0;
  double r;
  char *zBuf;
  ((void) (0));
  if( argc==2 ){
    if( 5==sqlite3_value_type(argv[1]) ) return;
    n = sqlite3_value_int64(argv[1]);
    if( n>30 ) n = 30;
    if( n<0 ) n = 0;
  }
  if( sqlite3_value_type(argv[0])==5 ) return;
  r = sqlite3_value_double(argv[0]);




  if( r<-4503599627370496.0 || r>+4503599627370496.0 ){

  }else if( n==0 ){
    r = (double)((sqlite_int64)(r+(r<0?-0.5:+0.5)));
  }else{
    zBuf = sqlite3_mprintf("%!.*f",(int)n,r);
    if( zBuf==0 ){
      sqlite3_result_error_nomem(context);
      return;
    }
    sqlite3AtoF(zBuf, &r, sqlite3Strlen30(zBuf), 1);
    sqlite3_free(zBuf);
  }
  sqlite3_result_double(context, r);
}
# 132229 "c_tests/sqlite3.c"
static void *contextMalloc(sqlite3_context *context, i64 nByte){
  char *z;
  sqlite3 *db = sqlite3_context_db_handle(context);
  ((void) (0));
                                                    ;
                                                           ;
  if( nByte>db->aLimit[0] ){
    sqlite3_result_error_toobig(context);
    z = 0;
  }else{
    z = sqlite3Malloc(nByte);
    if( !z ){
      sqlite3_result_error_nomem(context);
    }
  }
  return z;
}




static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  char *z1;
  const char *z2;
  int i, n;
  (void)(argc);
  z2 = (char*)sqlite3_value_text(argv[0]);
  n = sqlite3_value_bytes(argv[0]);

  ((void) (0));
  if( z2 ){
    z1 = contextMalloc(context, ((i64)n)+1);
    if( z1 ){
      for(i=0; i<n; i++){
        z1[i] = (char)((z2[i])&~(sqlite3CtypeMap[(unsigned char)(z2[i])]&0x20));
      }
      sqlite3_result_text(context, z1, n, sqlite3_free);
    }
  }
}
static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  char *z1;
  const char *z2;
  int i, n;
  (void)(argc);
  z2 = (char*)sqlite3_value_text(argv[0]);
  n = sqlite3_value_bytes(argv[0]);

  ((void) (0));
  if( z2 ){
    z1 = contextMalloc(context, ((i64)n)+1);
    if( z1 ){
      for(i=0; i<n; i++){
        z1[i] = (sqlite3UpperToLower[(unsigned char)(z2[i])]);
      }
      sqlite3_result_text(context, z1, n, sqlite3_free);
    }
  }
}
# 132302 "c_tests/sqlite3.c"
static void randomFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite_int64 r;
  (void)(NotUsed),(void)(NotUsed2);
  sqlite3_randomness(sizeof(r), &r);
  if( r<0 ){
# 132319 "c_tests/sqlite3.c"
    r = -(r & (0xffffffff|(((i64)0x7fffffff)<<32)));
  }
  sqlite3_result_int64(context, r);
}





static void randomBlob(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  sqlite3_int64 n;
  unsigned char *p;
  ((void) (0));
  (void)(argc);
  n = sqlite3_value_int64(argv[0]);
  if( n<1 ){
    n = 1;
  }
  p = contextMalloc(context, n);
  if( p ){
    sqlite3_randomness(n, p);
    sqlite3_result_blob(context, (char*)p, n, sqlite3_free);
  }
}





static void last_insert_rowid(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  (void)(NotUsed),(void)(NotUsed2);



  sqlite3_result_int64(context, sqlite3_last_insert_rowid(db));
}
# 132372 "c_tests/sqlite3.c"
static void changes(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  (void)(NotUsed),(void)(NotUsed2);
  sqlite3_result_int64(context, sqlite3_changes64(db));
}





static void total_changes(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  (void)(NotUsed),(void)(NotUsed2);


  sqlite3_result_int64(context, sqlite3_total_changes64(db));
}




struct compareInfo {
  u8 matchAll;
  u8 matchOne;
  u8 matchSet;
  u8 noCase;
};
# 132421 "c_tests/sqlite3.c"
static const struct compareInfo globInfo = { '*', '?', '[', 0 };


static const struct compareInfo likeInfoNorm = { '%', '_', 0, 1 };


static const struct compareInfo likeInfoAlt = { '%', '_', 0, 0 };
# 132474 "c_tests/sqlite3.c"
static int patternCompare(
  const u8 *zPattern,
  const u8 *zString,
  const struct compareInfo *pInfo,
  u32 matchOther
){
  u32 c, c2;
  u32 matchOne = pInfo->matchOne;
  u32 matchAll = pInfo->matchAll;
  u8 noCase = pInfo->noCase;
  const u8 *zEscaped = 0;

  while( (c = (zPattern[0]<0x80?*(zPattern++):sqlite3Utf8Read(&zPattern)))!=0 ){
    if( c==matchAll ){



      while( (c=(zPattern[0]<0x80?*(zPattern++):sqlite3Utf8Read(&zPattern))) == matchAll
             || (c == matchOne && matchOne!=0) ){
        if( c==matchOne && sqlite3Utf8Read(&zString)==0 ){
          return 2;
        }
      }
      if( c==0 ){
        return 0;
      }else if( c==matchOther ){
        if( pInfo->matchSet==0 ){
          c = sqlite3Utf8Read(&zPattern);
          if( c==0 ) return 2;
        }else{


          ((void) (0));
          while( *zString ){
            int bMatch = patternCompare(&zPattern[-1],zString,pInfo,matchOther);
            if( bMatch!=1 ) return bMatch;
            { if( (*(zString++))>=0xc0 ){ while( (*zString & 0xc0)==0x80 ){ zString++; } } };
          }
          return 2;
        }
      }
# 132525 "c_tests/sqlite3.c"
      if( c<0x80 ){
        char zStop[3];
        int bMatch;
        if( noCase ){
          zStop[0] = ((c)&~(sqlite3CtypeMap[(unsigned char)(c)]&0x20));
          zStop[1] = (sqlite3UpperToLower[(unsigned char)(c)]);
          zStop[2] = 0;
        }else{
          zStop[0] = c;
          zStop[1] = 0;
        }
        while(1){
          zString += strcspn((const char*)zString, zStop);
          if( zString[0]==0 ) break;
          zString++;
          bMatch = patternCompare(zPattern,zString,pInfo,matchOther);
          if( bMatch!=1 ) return bMatch;
        }
      }else{
        int bMatch;
        while( (c2 = (zString[0]<0x80?*(zString++):sqlite3Utf8Read(&zString)))!=0 ){
          if( c2!=c ) continue;
          bMatch = patternCompare(zPattern,zString,pInfo,matchOther);
          if( bMatch!=1 ) return bMatch;
        }
      }
      return 2;
    }
    if( c==matchOther ){
      if( pInfo->matchSet==0 ){
        c = sqlite3Utf8Read(&zPattern);
        if( c==0 ) return 1;
        zEscaped = zPattern;
      }else{
        u32 prior_c = 0;
        int seen = 0;
        int invert = 0;
        c = sqlite3Utf8Read(&zString);
        if( c==0 ) return 1;
        c2 = sqlite3Utf8Read(&zPattern);
        if( c2=='^' ){
          invert = 1;
          c2 = sqlite3Utf8Read(&zPattern);
        }
        if( c2==']' ){
          if( c==']' ) seen = 1;
          c2 = sqlite3Utf8Read(&zPattern);
        }
        while( c2 && c2!=']' ){
          if( c2=='-' && zPattern[0]!=']' && zPattern[0]!=0 && prior_c>0 ){
            c2 = sqlite3Utf8Read(&zPattern);
            if( c>=prior_c && c<=c2 ) seen = 1;
            prior_c = 0;
          }else{
            if( c==c2 ){
              seen = 1;
            }
            prior_c = c2;
          }
          c2 = sqlite3Utf8Read(&zPattern);
        }
        if( c2==0 || (seen ^ invert)==0 ){
          return 1;
        }
        continue;
      }
    }
    c2 = (zString[0]<0x80?*(zString++):sqlite3Utf8Read(&zString));
    if( c==c2 ) continue;
    if( noCase && (sqlite3UpperToLower[(unsigned char)(c)])==(sqlite3UpperToLower[(unsigned char)(c2)]) && c<0x80 && c2<0x80 ){
      continue;
    }
    if( c==matchOne && zPattern!=zEscaped && c2!=0 ) continue;
    return 1;
  }
  return *zString==0 ? 0 : 1;
}





           int sqlite3_strglob(const char *zGlobPattern, const char *zString){
  if( zString==0 ){
    return zGlobPattern!=0;
  }else if( zGlobPattern==0 ){
    return 1;
  }else {
    return patternCompare((u8*)zGlobPattern, (u8*)zString, &globInfo, '[');
  }
}





           int sqlite3_strlike(const char *zPattern, const char *zStr, unsigned int esc){
  if( zStr==0 ){
    return zPattern!=0;
  }else if( zPattern==0 ){
    return 1;
  }else{
    return patternCompare((u8*)zPattern, (u8*)zStr, &likeInfoNorm, esc);
  }
}
# 132653 "c_tests/sqlite3.c"
static void likeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zA, *zB;
  u32 escape;
  int nPat;
  sqlite3 *db = sqlite3_context_db_handle(context);
  struct compareInfo *pInfo = sqlite3_user_data(context);
  struct compareInfo backupInfo;
# 132680 "c_tests/sqlite3.c"
  nPat = sqlite3_value_bytes(argv[0]);
                                                                ;
                                                                  ;
  if( nPat > db->aLimit[8] ){
    sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
    return;
  }
  if( argc==3 ){



    const unsigned char *zEsc = sqlite3_value_text(argv[2]);
    if( zEsc==0 ) return;
    if( sqlite3Utf8CharLen((char*)zEsc, -1)!=1 ){
      sqlite3_result_error(context,
          "ESCAPE expression must be a single character", -1);
      return;
    }
    escape = sqlite3Utf8Read(&zEsc);
    if( escape==pInfo->matchAll || escape==pInfo->matchOne ){
      memcpy(&backupInfo, pInfo, sizeof(backupInfo));
      pInfo = &backupInfo;
      if( escape==pInfo->matchAll ) pInfo->matchAll = 0;
      if( escape==pInfo->matchOne ) pInfo->matchOne = 0;
    }
  }else{
    escape = pInfo->matchSet;
  }
  zB = sqlite3_value_text(argv[0]);
  zA = sqlite3_value_text(argv[1]);
  if( zA && zB ){



    sqlite3_result_int(context,
                      patternCompare(zB, zA, pInfo, escape)==0);
  }
}






static void nullifFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  CollSeq *pColl = sqlite3GetFuncCollSeq(context);
  (void)(NotUsed);
  if( sqlite3MemCompare(argv[0], argv[1], pColl)!=0 ){
    sqlite3_result_value(context, argv[0]);
  }
}





static void versionFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);


  sqlite3_result_text(context, sqlite3_libversion(), -1, ((sqlite3_destructor_type)0));
}






static void sourceidFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);


  sqlite3_result_text(context, sqlite3_sourceid(), -1, ((sqlite3_destructor_type)0));
}






static void errlogFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  (void)(argc);
  (void)(context);
  sqlite3_log(sqlite3_value_int(argv[0]), "%s", sqlite3_value_text(argv[1]));
}







static void compileoptionusedFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const char *zOptName;
  ((void) (0));
  (void)(argc);




  if( (zOptName = (const char*)sqlite3_value_text(argv[0]))!=0 ){
    sqlite3_result_int(context, sqlite3_compileoption_used(zOptName));
  }
}
# 132812 "c_tests/sqlite3.c"
static void compileoptiongetFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int n;
  ((void) (0));
  (void)(argc);



  n = sqlite3_value_int(argv[0]);
  sqlite3_result_text(context, sqlite3_compileoption_get(n), -1, ((sqlite3_destructor_type)0));
}




static const char hexdigits[] = {
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};





static void sqlite3QuoteValue(StrAccum *pStr, sqlite3_value *pValue, int bEscape){



  ((void) (0));

  switch( sqlite3_value_type(pValue) ){
    case 2: {
      double r1, r2;
      const char *zVal;
      r1 = sqlite3_value_double(pValue);
      sqlite3_str_appendf(pStr, "%!0.15g", r1);
      zVal = sqlite3_str_value(pStr);
      if( zVal ){
        sqlite3AtoF(zVal, &r2, pStr->nChar, 1);
        if( r1!=r2 ){
          sqlite3_str_reset(pStr);
          sqlite3_str_appendf(pStr, "%!0.20e", r1);
        }
      }
      break;
    }
    case 1: {
      sqlite3_str_appendf(pStr, "%lld", sqlite3_value_int64(pValue));
      break;
    }
    case 4: {
      char const *zBlob = sqlite3_value_blob(pValue);
      i64 nBlob = sqlite3_value_bytes(pValue);
      ((void) (0));
      sqlite3StrAccumEnlarge(pStr, nBlob*2 + 4);
      if( pStr->accError==0 ){
        char *zText = pStr->zText;
        int i;
        for(i=0; i<nBlob; i++){
          zText[(i*2)+2] = hexdigits[(zBlob[i]>>4)&0x0F];
          zText[(i*2)+3] = hexdigits[(zBlob[i])&0x0F];
        }
        zText[(nBlob*2)+2] = '\'';
        zText[(nBlob*2)+3] = '\0';
        zText[0] = 'X';
        zText[1] = '\'';
        pStr->nChar = nBlob*2 + 3;
      }
      break;
    }
    case 3: {
      const unsigned char *zArg = sqlite3_value_text(pValue);
      sqlite3_str_appendf(pStr, bEscape ? "%#Q" : "%Q", zArg);
      break;
    }
    default: {
      ((void) (0));
      sqlite3_str_append(pStr, "NULL", 4);
      break;
    }
  }
}






static int isNHex(const char *z, int N, u32 *pVal){
  int i;
  u32 v = 0;
  for(i=0; i<N; i++){
    if( !(sqlite3CtypeMap[(unsigned char)(z[i])]&0x08) ) return 0;
    v = (v<<4) + sqlite3HexToInt(z[i]);
  }
  *pVal = v;
  return 1;
}
# 132927 "c_tests/sqlite3.c"
static void unistrFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  char *zOut;
  const char *zIn;
  int nIn;
  int i, j, n;
  u32 v;

  ((void) (0));
  (void)(argc);
  zIn = (const char*)sqlite3_value_text(argv[0]);
  if( zIn==0 ) return;
  nIn = sqlite3_value_bytes(argv[0]);
  zOut = sqlite3_malloc64(nIn+1);
  if( zOut==0 ){
    sqlite3_result_error_nomem(context);
    return;
  }
  i = j = 0;
  while( i<nIn ){
    char *z = strchr(&zIn[i],'\\');
    if( z==0 ){
      n = nIn - i;
      memmove(&zOut[j], &zIn[i], n);
      j += n;
      break;
    }
    n = z - &zIn[i];
    if( n>0 ){
      memmove(&zOut[j], &zIn[i], n);
      j += n;
      i += n;
    }
    if( zIn[i+1]=='\\' ){
      i += 2;
      zOut[j++] = '\\';
    }else if( (sqlite3CtypeMap[(unsigned char)(zIn[i+1])]&0x08) ){
      if( !isNHex(&zIn[i+1], 4, &v) ) goto unistr_error;
      i += 5;
      j += sqlite3AppendOneUtf8Character(&zOut[j], v);
    }else if( zIn[i+1]=='+' ){
      if( !isNHex(&zIn[i+2], 6, &v) ) goto unistr_error;
      i += 8;
      j += sqlite3AppendOneUtf8Character(&zOut[j], v);
    }else if( zIn[i+1]=='u' ){
      if( !isNHex(&zIn[i+2], 4, &v) ) goto unistr_error;
      i += 6;
      j += sqlite3AppendOneUtf8Character(&zOut[j], v);
    }else if( zIn[i+1]=='U' ){
      if( !isNHex(&zIn[i+2], 8, &v) ) goto unistr_error;
      i += 10;
      j += sqlite3AppendOneUtf8Character(&zOut[j], v);
    }else{
      goto unistr_error;
    }
  }
  zOut[j] = 0;
  sqlite3_result_text64(context, zOut, j, sqlite3_free, 1);
  return;

unistr_error:
  sqlite3_free(zOut);
  sqlite3_result_error(context, "invalid Unicode escape", -1);
  return;
}
# 133011 "c_tests/sqlite3.c"
static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  sqlite3_str str;
  sqlite3 *db = sqlite3_context_db_handle(context);
  ((void) (0));
  (void)(argc);
  sqlite3StrAccumInit(&str, db, 0, 0, db->aLimit[0]);
  sqlite3QuoteValue(&str,argv[0],((int)(long int)(sqlite3_user_data(context))));
  sqlite3_result_text(context, sqlite3StrAccumFinish(&str), str.nChar,
                      ((sqlite3_destructor_type)sqlite3RowSetClear));
  if( str.accError!=0 ){
    sqlite3_result_null(context);
    sqlite3_result_error_code(context, str.accError);
  }
}





static void unicodeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *z = sqlite3_value_text(argv[0]);
  (void)argc;
  if( z && z[0] ) sqlite3_result_int(context, sqlite3Utf8Read(&z));
}






static void charFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  unsigned char *z, *zOut;
  int i;
  zOut = z = sqlite3_malloc64( argc*4+1 );
  if( z==0 ){
    sqlite3_result_error_nomem(context);
    return;
  }
  for(i=0; i<argc; i++){
    sqlite3_int64 x;
    unsigned c;
    x = sqlite3_value_int64(argv[i]);
    if( x<0 || x>0x10ffff ) x = 0xfffd;
    c = (unsigned)(x & 0x1fffff);
    if( c<0x00080 ){
      *zOut++ = (u8)(c&0xFF);
    }else if( c<0x00800 ){
      *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);
      *zOut++ = 0x80 + (u8)(c & 0x3F);
    }else if( c<0x10000 ){
      *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);
      *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);
      *zOut++ = 0x80 + (u8)(c & 0x3F);
    }else{
      *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);
      *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);
      *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);
      *zOut++ = 0x80 + (u8)(c & 0x3F);
    } }

  *zOut = 0;
  sqlite3_result_text64(context, (char*)z, zOut-z, sqlite3_free, 1);
}





static void hexFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int i, n;
  const unsigned char *pBlob;
  char *zHex, *z;
  ((void) (0));
  (void)(argc);
  pBlob = sqlite3_value_blob(argv[0]);
  n = sqlite3_value_bytes(argv[0]);
  ((void) (0));
  z = zHex = contextMalloc(context, ((i64)n)*2 + 1);
  if( zHex ){
    for(i=0; i<n; i++, pBlob++){
      unsigned char c = *pBlob;
      *(z++) = hexdigits[(c>>4)&0xf];
      *(z++) = hexdigits[c&0xf];
    }
    *z = 0;
    sqlite3_result_text64(context, zHex, (u64)(z-zHex),
                          sqlite3_free, 1);
  }
}





static int strContainsChar(const u8 *zStr, int nStr, u32 ch){
  const u8 *zEnd = &zStr[nStr];
  const u8 *z = zStr;
  while( z<zEnd ){
    u32 tst = (z[0]<0x80?*(z++):sqlite3Utf8Read(&z));
    if( tst==ch ) return 1;
  }
  return 0;
}
# 133149 "c_tests/sqlite3.c"
static void unhexFunc(
  sqlite3_context *pCtx,
  int argc,
  sqlite3_value **argv
){
  const u8 *zPass = (const u8*)"";
  int nPass = 0;
  const u8 *zHex = sqlite3_value_text(argv[0]);
  int nHex = sqlite3_value_bytes(argv[0]);



  u8 *pBlob = 0;
  u8 *p = 0;

  ((void) (0));
  if( argc==2 ){
    zPass = sqlite3_value_text(argv[1]);
    nPass = sqlite3_value_bytes(argv[1]);
  }
  if( !zHex || !zPass ) return;

  p = pBlob = contextMalloc(pCtx, (nHex/2)+1);
  if( pBlob ){
    u8 c;
    u8 d;

    while( (c = *zHex)!=0x00 ){
      while( !(sqlite3CtypeMap[(unsigned char)(c)]&0x08) ){
        u32 ch = (zHex[0]<0x80?*(zHex++):sqlite3Utf8Read(&zHex));
        ((void) (0));
        if( !strContainsChar(zPass, nPass, ch) ) goto unhex_null;
        c = *zHex;
        if( c==0x00 ) goto unhex_done;
      }
      zHex++;
      ((void) (0));
      ((void) (0));
      d = *(zHex++);
      if( !(sqlite3CtypeMap[(unsigned char)(d)]&0x08) ) goto unhex_null;
      *(p++) = (sqlite3HexToInt(c)<<4) | sqlite3HexToInt(d);
    }
  }

 unhex_done:
  sqlite3_result_blob(pCtx, pBlob, (p - pBlob), sqlite3_free);
  return;

 unhex_null:
  sqlite3_free(pBlob);
  return;
}





static void zeroblobFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  i64 n;
  int rc;
  ((void) (0));
  (void)(argc);
  n = sqlite3_value_int64(argv[0]);
  if( n<0 ) n = 0;
  rc = sqlite3_result_zeroblob64(context, n);
  if( rc ){
    sqlite3_result_error_code(context, rc);
  }
}







static void replaceFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zStr;
  const unsigned char *zPattern;
  const unsigned char *zRep;
  unsigned char *zOut;
  int nStr;
  int nPattern;
  int nRep;
  i64 nOut;
  int loopLimit;
  int i, j;
  unsigned cntExpand;
  sqlite3 *db = sqlite3_context_db_handle(context);

  ((void) (0));
  (void)(argc);
  zStr = sqlite3_value_text(argv[0]);
  if( zStr==0 ) return;
  nStr = sqlite3_value_bytes(argv[0]);
  ((void) (0));
  zPattern = sqlite3_value_text(argv[1]);
  if( zPattern==0 ){
    ((void) (0));

    return;
  }
  if( zPattern[0]==0 ){
    ((void) (0));
    sqlite3_result_text(context, (const char*)zStr, nStr, ((sqlite3_destructor_type)-1));
    return;
  }
  nPattern = sqlite3_value_bytes(argv[1]);
  ((void) (0));
  zRep = sqlite3_value_text(argv[2]);
  if( zRep==0 ) return;
  nRep = sqlite3_value_bytes(argv[2]);
  ((void) (0));
  nOut = nStr + 1;
  ((void) (0));
  zOut = contextMalloc(context, nOut);
  if( zOut==0 ){
    return;
  }
  loopLimit = nStr - nPattern;
  cntExpand = 0;
  for(i=j=0; i<=loopLimit; i++){
    if( zStr[i]!=zPattern[0] || memcmp(&zStr[i], zPattern, nPattern) ){
      zOut[j++] = zStr[i];
    }else{
      if( nRep>nPattern ){
        nOut += nRep - nPattern;
                                                           ;
                                                           ;
        if( nOut-1>db->aLimit[0] ){
          sqlite3_result_error_toobig(context);
          sqlite3_free(zOut);
          return;
        }
        cntExpand++;
        if( (cntExpand&(cntExpand-1))==0 ){


          u8 *zOld;
          zOld = zOut;
          zOut = sqlite3Realloc(zOut, (int)nOut + (nOut - nStr - 1));
          if( zOut==0 ){
            sqlite3_result_error_nomem(context);
            sqlite3_free(zOld);
            return;
          }
        }
      }
      memcpy(&zOut[j], zRep, nRep);
      j += nRep;
      i += nPattern-1;
    }
  }
  ((void) (0));
  memcpy(&zOut[j], &zStr[i], nStr-i);
  j += nStr - i;
  ((void) (0));
  zOut[j] = 0;
  sqlite3_result_text(context, (char*)zOut, j, sqlite3_free);
}





static void trimFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zIn;
  const unsigned char *zCharSet;
  unsigned int nIn;
  int flags;
  int i;
  unsigned int *aLen = 0;
  unsigned char **azChar = 0;
  int nChar;

  if( sqlite3_value_type(argv[0])==5 ){
    return;
  }
  zIn = sqlite3_value_text(argv[0]);
  if( zIn==0 ) return;
  nIn = (unsigned)sqlite3_value_bytes(argv[0]);
  ((void) (0));
  if( argc==1 ){
    static const unsigned lenOne[] = { 1 };
    static unsigned char * const azOne[] = { (u8*)" " };
    nChar = 1;
    aLen = (unsigned*)lenOne;
    azChar = (unsigned char **)azOne;
    zCharSet = 0;
  }else if( (zCharSet = sqlite3_value_text(argv[1]))==0 ){
    return;
  }else{
    const unsigned char *z;
    for(z=zCharSet, nChar=0; *z; nChar++){
      { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
    }
    if( nChar>0 ){
      azChar = contextMalloc(context,
                     ((i64)nChar)*(sizeof(char*)+sizeof(unsigned)));
      if( azChar==0 ){
        return;
      }
      aLen = (unsigned*)&azChar[nChar];
      for(z=zCharSet, nChar=0; *z; nChar++){
        azChar[nChar] = (unsigned char *)z;
        { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
        aLen[nChar] = (unsigned)(z - azChar[nChar]);
      }
    }
  }
  if( nChar>0 ){
    flags = ((int)(long int)(sqlite3_user_data(context)));
    if( flags & 1 ){
      while( nIn>0 ){
        unsigned int len = 0;
        for(i=0; i<nChar; i++){
          len = aLen[i];
          if( len<=nIn && memcmp(zIn, azChar[i], len)==0 ) break;
        }
        if( i>=nChar ) break;
        zIn += len;
        nIn -= len;
      }
    }
    if( flags & 2 ){
      while( nIn>0 ){
        unsigned int len = 0;
        for(i=0; i<nChar; i++){
          len = aLen[i];
          if( len<=nIn && memcmp(&zIn[nIn-len],azChar[i],len)==0 ) break;
        }
        if( i>=nChar ) break;
        nIn -= len;
      }
    }
    if( zCharSet ){
      sqlite3_free(azChar);
    }
  }
  sqlite3_result_text(context, (char*)zIn, nIn, ((sqlite3_destructor_type)-1));
}







static void concatFuncCore(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv,
  int nSep,
  const char *zSep
){
  i64 j, n = 0;
  int i;
  int bNotNull = 0;
  char *z;
  for(i=0; i<argc; i++){
    n += sqlite3_value_bytes(argv[i]);
  }
  n += (argc-1)*(i64)nSep;
  z = sqlite3_malloc64(n+1);
  if( z==0 ){
    sqlite3_result_error_nomem(context);
    return;
  }
  j = 0;
  for(i=0; i<argc; i++){
    if( sqlite3_value_type(argv[i])!=5 ){
      int k = sqlite3_value_bytes(argv[i]);
      const char *v = (const char*)sqlite3_value_text(argv[i]);
      if( v!=0 ){
        if( bNotNull && nSep>0 ){
          memcpy(&z[j], zSep, nSep);
          j += nSep;
        }
        memcpy(&z[j], v, k);
        j += k;
        bNotNull = 1;
      }
    }
  }
  z[j] = 0;
  ((void) (0));
  sqlite3_result_text64(context, z, j, sqlite3_free, 1);
}





static void concatFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  concatFuncCore(context, argc, argv, 0, "");
}
# 133469 "c_tests/sqlite3.c"
static void concatwsFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int nSep = sqlite3_value_bytes(argv[0]);
  const char *zSep = (const char*)sqlite3_value_text(argv[0]);
  if( zSep==0 ) return;
  concatFuncCore(context, argc-1, argv+1, nSep, zSep);
}
# 133568 "c_tests/sqlite3.c"
static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){
  const char *zFile = (const char *)sqlite3_value_text(argv[0]);
  const char *zProc;
  sqlite3 *db = sqlite3_context_db_handle(context);
  char *zErrMsg = 0;




  if( (db->flags & 0x00020000)==0 ){
    sqlite3_result_error(context, "not authorized", -1);
    return;
  }

  if( argc==2 ){
    zProc = (const char *)sqlite3_value_text(argv[1]);
  }else{
    zProc = 0;
  }
  if( zFile && sqlite3_load_extension(db, zFile, zProc, &zErrMsg) ){
    sqlite3_result_error(context, zErrMsg, -1);
    sqlite3_free(zErrMsg);
  }
}







typedef struct SumCtx SumCtx;
struct SumCtx {
  double rSum;
  double rErr;
  i64 iSum;
  i64 cnt;
  u8 approx;
  u8 ovrfl;
};
# 133617 "c_tests/sqlite3.c"
static void kahanBabuskaNeumaierStep(
  volatile SumCtx *pSum,
  volatile double r
){
  volatile double s = pSum->rSum;
  volatile double t = s + r;
  if( fabs(s) > fabs(r) ){
    pSum->rErr += (s - t) + r;
  }else{
    pSum->rErr += (r - t) + s;
  }
  pSum->rSum = t;
}




static void kahanBabuskaNeumaierStepInt64(volatile SumCtx *pSum, i64 iVal){
  if( iVal<=-4503599627370496LL || iVal>=+4503599627370496LL ){
    i64 iBig, iSm;
    iSm = iVal % 16384;
    iBig = iVal - iSm;
    kahanBabuskaNeumaierStep(pSum, iBig);
    kahanBabuskaNeumaierStep(pSum, iSm);
  }else{
    kahanBabuskaNeumaierStep(pSum, (double)iVal);
  }
}




static void kahanBabuskaNeumaierInit(
  volatile SumCtx *p,
  i64 iVal
){
  if( iVal<=-4503599627370496LL || iVal>=+4503599627370496LL ){
    i64 iSm = iVal % 16384;
    p->rSum = (double)(iVal - iSm);
    p->rErr = (double)iSm;
  }else{
    p->rSum = (double)iVal;
    p->rErr = 0.0;
  }
}
# 133673 "c_tests/sqlite3.c"
static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){
  SumCtx *p;
  int type;
  ((void) (0));
  (void)(argc);
  p = sqlite3_aggregate_context(context, sizeof(*p));
  type = sqlite3_value_numeric_type(argv[0]);
  if( p && type!=5 ){
    p->cnt++;
    if( p->approx==0 ){
      if( type!=1 ){
        kahanBabuskaNeumaierInit(p, p->iSum);
        p->approx = 1;
        kahanBabuskaNeumaierStep(p, sqlite3_value_double(argv[0]));
      }else{
        i64 x = p->iSum;
        if( sqlite3AddInt64(&x, sqlite3_value_int64(argv[0]))==0 ){
          p->iSum = x;
        }else{
          p->ovrfl = 1;
          kahanBabuskaNeumaierInit(p, p->iSum);
          p->approx = 1;
          kahanBabuskaNeumaierStepInt64(p, sqlite3_value_int64(argv[0]));
        }
      }
    }else{
      if( type==1 ){
        kahanBabuskaNeumaierStepInt64(p, sqlite3_value_int64(argv[0]));
      }else{
        p->ovrfl = 0;
        kahanBabuskaNeumaierStep(p, sqlite3_value_double(argv[0]));
      }
    }
  }
}

static void sumInverse(sqlite3_context *context, int argc, sqlite3_value**argv){
  SumCtx *p;
  int type;
  ((void) (0));
  (void)(argc);
  p = sqlite3_aggregate_context(context, sizeof(*p));
  type = sqlite3_value_numeric_type(argv[0]);


  if( (p) && type!=5 ){
    ((void) (0));
    p->cnt--;
    if( !p->approx ){
      if( sqlite3SubInt64(&p->iSum, sqlite3_value_int64(argv[0])) ){
        p->ovrfl = 1;
        p->approx = 1;
      }
    }else if( type==1 ){
      i64 iVal = sqlite3_value_int64(argv[0]);
      if( iVal!=(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ){
        kahanBabuskaNeumaierStepInt64(p, -iVal);
      }else{
        kahanBabuskaNeumaierStepInt64(p, (0xffffffff|(((i64)0x7fffffff)<<32)));
        kahanBabuskaNeumaierStepInt64(p, 1);
      }
    }else{
      kahanBabuskaNeumaierStep(p, -sqlite3_value_double(argv[0]));
    }
  }
}



static void sumFinalize(sqlite3_context *context){
  SumCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  if( p && p->cnt>0 ){
    if( p->approx ){
      if( p->ovrfl ){
        sqlite3_result_error(context,"integer overflow",-1);
      }else if( !sqlite3IsOverflow(p->rErr) ){
        sqlite3_result_double(context, p->rSum+p->rErr);
      }else{
        sqlite3_result_double(context, p->rSum);
      }
    }else{
      sqlite3_result_int64(context, p->iSum);
    }
  }
}
static void avgFinalize(sqlite3_context *context){
  SumCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  if( p && p->cnt>0 ){
    double r;
    if( p->approx ){
      r = p->rSum;
      if( !sqlite3IsOverflow(p->rErr) ) r += p->rErr;
    }else{
      r = (double)(p->iSum);
    }
    sqlite3_result_double(context, r/(double)p->cnt);
  }
}
static void totalFinalize(sqlite3_context *context){
  SumCtx *p;
  double r = 0.0;
  p = sqlite3_aggregate_context(context, 0);
  if( p ){
    if( p->approx ){
      r = p->rSum;
      if( !sqlite3IsOverflow(p->rErr) ) r += p->rErr;
    }else{
      r = (double)(p->iSum);
    }
  }
  sqlite3_result_double(context, r);
}





typedef struct CountCtx CountCtx;
struct CountCtx {
  i64 n;



};




static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){
  CountCtx *p;
  p = sqlite3_aggregate_context(context, sizeof(*p));
  if( (argc==0 || 5!=sqlite3_value_type(argv[0])) && p ){
    p->n++;
  }






  ((void) (0));


}
static void countFinalize(sqlite3_context *context){
  CountCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  sqlite3_result_int64(context, p ? p->n : 0);
}

static void countInverse(sqlite3_context *ctx, int argc, sqlite3_value **argv){
  CountCtx *p;
  p = sqlite3_aggregate_context(ctx, sizeof(*p));

  if( (argc==0 || 5!=sqlite3_value_type(argv[0])) && (p) ){
    p->n--;



  }
}







static void minmaxStep(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  Mem *pArg = (Mem *)argv[0];
  Mem *pBest;
  (void)(NotUsed);

  pBest = (Mem *)sqlite3_aggregate_context(context, sizeof(*pBest));
  if( !pBest ) return;

  if( sqlite3_value_type(pArg)==5 ){
    if( pBest->flags ) sqlite3SkipAccumulatorLoad(context);
  }else if( pBest->flags ){
    int max;
    int cmp;
    CollSeq *pColl = sqlite3GetFuncCollSeq(context);
# 133869 "c_tests/sqlite3.c"
    max = sqlite3_user_data(context)!=0;
    cmp = sqlite3MemCompare(pBest, pArg, pColl);
    if( (max && cmp<0) || (!max && cmp>0) ){
      sqlite3VdbeMemCopy(pBest, pArg);
    }else{
      sqlite3SkipAccumulatorLoad(context);
    }
  }else{
    pBest->db = sqlite3_context_db_handle(context);
    sqlite3VdbeMemCopy(pBest, pArg);
  }
}
static void minMaxValueFinalize(sqlite3_context *context, int bValue){
  sqlite3_value *pRes;
  pRes = (sqlite3_value *)sqlite3_aggregate_context(context, 0);
  if( pRes ){
    if( pRes->flags ){
      sqlite3_result_value(context, pRes);
    }
    if( bValue==0 ) sqlite3VdbeMemRelease(pRes);
  }
}

static void minMaxValue(sqlite3_context *context){
  minMaxValueFinalize(context, 1);
}



static void minMaxFinalize(sqlite3_context *context){
  minMaxValueFinalize(context, 0);
}
# 133916 "c_tests/sqlite3.c"
typedef struct {
  StrAccum str;

  int nAccum;
  int nFirstSepLength;





  int *pnSepLengths;

} GroupConcatCtx;

static void groupConcatStep(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const char *zVal;
  GroupConcatCtx *pGCC;
  const char *zSep;
  int nVal, nSep;
  ((void) (0));
  if( sqlite3_value_type(argv[0])==5 ) return;
  pGCC = (GroupConcatCtx*)sqlite3_aggregate_context(context, sizeof(*pGCC));
  if( pGCC ){
    sqlite3 *db = sqlite3_context_db_handle(context);
    int firstTerm = pGCC->str.mxAlloc==0;
    pGCC->str.mxAlloc = db->aLimit[0];
    if( argc==1 ){
      if( !firstTerm ){
        sqlite3_str_appendchar(&pGCC->str, 1, ',');
      }

      else{
        pGCC->nFirstSepLength = 1;
      }

    }else if( !firstTerm ){
      zSep = (char*)sqlite3_value_text(argv[1]);
      nSep = sqlite3_value_bytes(argv[1]);
      if( zSep ){
        sqlite3_str_append(&pGCC->str, zSep, nSep);
      }

      else{
        nSep = 0;
      }
      if( nSep != pGCC->nFirstSepLength || pGCC->pnSepLengths != 0 ){
        int *pnsl = pGCC->pnSepLengths;
        if( pnsl == 0 ){

          pnsl = (int*)sqlite3_malloc64((pGCC->nAccum+1) * sizeof(int));
          if( pnsl!=0 ){
            int i = 0, nA = pGCC->nAccum-1;
            while( i<nA ) pnsl[i++] = pGCC->nFirstSepLength;
          }
        }else{
          pnsl = (int*)sqlite3_realloc64(pnsl, pGCC->nAccum * sizeof(int));
        }
        if( pnsl!=0 ){
          if( (pGCC->nAccum>0) ){
            pnsl[pGCC->nAccum-1] = nSep;
          }
          pGCC->pnSepLengths = pnsl;
        }else{
          sqlite3StrAccumSetError(&pGCC->str, 7);
        }
      }

    }

    else{
      pGCC->nFirstSepLength = sqlite3_value_bytes(argv[1]);
    }
    pGCC->nAccum += 1;

    zVal = (char*)sqlite3_value_text(argv[0]);
    nVal = sqlite3_value_bytes(argv[0]);
    if( zVal ) sqlite3_str_append(&pGCC->str, zVal, nVal);
  }
}


static void groupConcatInverse(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  GroupConcatCtx *pGCC;
  ((void) (0));
  (void)argc;
  if( sqlite3_value_type(argv[0])==5 ) return;
  pGCC = (GroupConcatCtx*)sqlite3_aggregate_context(context, sizeof(*pGCC));


  if( (pGCC) ){
    int nVS;


    (void)sqlite3_value_text(argv[0]);
    nVS = sqlite3_value_bytes(argv[0]);
    pGCC->nAccum -= 1;
    if( pGCC->pnSepLengths!=0 ){
      ((void) (0));
      if( pGCC->nAccum>0 ){
        nVS += *pGCC->pnSepLengths;
        memmove(pGCC->pnSepLengths, pGCC->pnSepLengths+1,
               (pGCC->nAccum-1)*sizeof(int));
      }
    }else{

      nVS += pGCC->nFirstSepLength;
    }
    if( nVS>=(int)pGCC->str.nChar ){
      pGCC->str.nChar = 0;
    }else{
      pGCC->str.nChar -= nVS;
      memmove(pGCC->str.zText, &pGCC->str.zText[nVS], pGCC->str.nChar);
    }
    if( pGCC->str.nChar==0 ){
      pGCC->str.mxAlloc = 0;
      sqlite3_free(pGCC->pnSepLengths);
      pGCC->pnSepLengths = 0;
    }
  }
}



static void groupConcatFinalize(sqlite3_context *context){
  GroupConcatCtx *pGCC
    = (GroupConcatCtx*)sqlite3_aggregate_context(context, 0);
  if( pGCC ){
    sqlite3ResultStrAccum(context, &pGCC->str);

    sqlite3_free(pGCC->pnSepLengths);

  }
}

static void groupConcatValue(sqlite3_context *context){
  GroupConcatCtx *pGCC
    = (GroupConcatCtx*)sqlite3_aggregate_context(context, 0);
  if( pGCC ){
    StrAccum *pAccum = &pGCC->str;
    if( pAccum->accError==18 ){
      sqlite3_result_error_toobig(context);
    }else if( pAccum->accError==7 ){
      sqlite3_result_error_nomem(context);
    }else if( pGCC->nAccum>0 && pAccum->nChar==0 ){
      sqlite3_result_text(context, "", 1, ((sqlite3_destructor_type)0));
    }else{
      const char *zText = sqlite3_str_value(pAccum);
      sqlite3_result_text(context, zText, pAccum->nChar, ((sqlite3_destructor_type)-1));
    }
  }
}
# 134084 "c_tests/sqlite3.c"
static void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3 *db){
  int rc = sqlite3_overload_function(db, "MATCH", 2);
  ((void) (0));
  if( rc==7 ){
    sqlite3OomFault(db);
  }
}






static void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){
  FuncDef *pDef;
  struct compareInfo *pInfo;
  int flags;
  int nArg;
  if( caseSensitive ){
    pInfo = (struct compareInfo*)&likeInfoAlt;
    flags = 0x0004 | 0x0008;
  }else{
    pInfo = (struct compareInfo*)&likeInfoNorm;
    flags = 0x0004;
  }
  for(nArg=2; nArg<=3; nArg++){
    sqlite3CreateFunc(db, "like", nArg, 1, pInfo, likeFunc,
                      0, 0, 0, 0, 0);
    pDef = sqlite3FindFunction(db, "like", nArg, 1, 0);
    pDef->funcFlags |= flags;
    pDef->funcFlags &= ~0x00200000;
  }
}
# 134135 "c_tests/sqlite3.c"
static int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){
  FuncDef *pDef;
  int nExpr;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( !pExpr->x.pList ){
    return 0;
  }
  nExpr = pExpr->x.pList->nExpr;
  ((void) (0));
  pDef = sqlite3FindFunction(db, pExpr->u.zToken, nExpr, 1, 0);



  if( (pDef==0) || (pDef->funcFlags & 0x0004)==0 ){
    return 0;
  }





  memcpy(aWc, pDef->pUserData, 3);
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( nExpr<3 ){
    aWc[3] = 0;
  }else{
    Expr *pEscape = pExpr->x.pList->a[2].pExpr;
    char *zEscape;
    if( pEscape->op!=118 ) return 0;
    ((void) (0));
    zEscape = pEscape->u.zToken;
    if( zEscape[0]==0 || zEscape[1]!=0 ) return 0;
    if( zEscape[0]==aWc[0] ) return 0;
    if( zEscape[0]==aWc[1] ) return 0;
    aWc[3] = zEscape[0];
  }

  *pIsNocase = (pDef->funcFlags & 0x0008)==0;
  return 1;
}
# 134372 "c_tests/sqlite3.c"
static void signFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int type0;
  double x;
  (void)(argc);
  ((void) (0));
  type0 = sqlite3_value_numeric_type(argv[0]);
  if( type0!=1 && type0!=2 ) return;
  x = sqlite3_value_double(argv[0]);
  sqlite3_result_int(context, x<0.0 ? -1 : x>0.0 ? +1 : 0);
}
# 135004 "c_tests/sqlite3.c"
static void sqlite3RegisterBuiltinFunctions(void){
# 135015 "c_tests/sqlite3.c"
  static FuncDef aBuiltinFunc[] = {


    {2, 0x00800000| 1|0x00040000|0x4000| 0x00400000|0x0800|(0), ((void*)(long int)(1)), 0, versionFunc, 0, 0, 0, "implies_nonnull_row", {0} },
    {2, 0x00800000| 1|0x00040000|0x4000| 0x00400000|0x0800|(0), ((void*)(long int)(3)), 0, versionFunc, 0, 0, 0, "expr_compare", {0} },
    {2, 0x00800000| 1|0x00040000|0x4000| 0x00400000|0x0800|(0), ((void*)(long int)(2)), 0, versionFunc, 0, 0, 0, "expr_implies_expr", {0} },
    {1, 0x00800000| 1|0x00040000|0x4000| 0x00400000|0x0800|(0), ((void*)(long int)(4)), 0, versionFunc, 0, 0, 0, "affinity", {0} },






    {1, 0x00800000|1|0x000080000|0x00200000, ((void*)(long int)(0)), 0, loadExt, 0, 0, 0, "load_extension", {0} },
    {2, 0x00800000|1|0x000080000|0x00200000, ((void*)(long int)(0)), 0, loadExt, 0, 0, 0, "load_extension", {0} },


    {1, 0x00800000|0x2000|1, 0, 0, compileoptionusedFunc, 0, 0, 0, "sqlite_compileoption_used", {0} },
    {1, 0x00800000|0x2000|1, 0, 0, compileoptiongetFunc, 0, 0, 0, "sqlite_compileoption_get", {0} },

    {1, 0x00800000| 1|0x00400000|0x0800|(0x0400), ((void*)(long int)(99)), 0, versionFunc, 0, 0, 0, "unlikely", {0} },
    {2, 0x00800000| 1|0x00400000|0x0800|(0x0400), ((void*)(long int)(99)), 0, versionFunc, 0, 0, 0, "likelihood", {0} },
    {1, 0x00800000| 1|0x00400000|0x0800|(0x0400), ((void*)(long int)(99)), 0, versionFunc, 0, 0, 0, "likely", {0} },






    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(1)), 0, trimFunc, 0, 0, 0, "ltrim", {0} },
    {2, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(1)), 0, trimFunc, 0, 0, 0, "ltrim", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(2)), 0, trimFunc, 0, 0, 0, "rtrim", {0} },
    {2, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(2)), 0, trimFunc, 0, 0, 0, "rtrim", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(3)), 0, trimFunc, 0, 0, 0, "trim", {0} },
    {2, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(3)), 0, trimFunc, 0, 0, 0, "trim", {0} },
    {-3, 0x00800000| 0x0800|1|(1*0x0020), ((void*)(long int)(0)), 0, minmaxFunc, 0, 0, 0, "min", {0} },
    {1, 0x00800000|1|(1*0x0020)|0x1000|0x08000000, ((void*)(long int)(0)), 0, minmaxStep,minMaxFinalize,minMaxValue,0,"min", {0}},

    {-3, 0x00800000| 0x0800|1|(1*0x0020), ((void*)(long int)(1)), 0, minmaxFunc, 0, 0, 0, "max", {0} },
    {1, 0x00800000|1|(1*0x0020)|0x1000|0x08000000, ((void*)(long int)(1)), 0, minmaxStep,minMaxFinalize,minMaxValue,0,"max", {0}},

    {1, 0x00800000| 0x0800|1|(0*0x0020)|0x0080, ((void*)(long int)(0)), 0, typeofFunc, 0, 0, 0, "typeof", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020)|0x0080|0x000100000, ((void*)(long int)(0)), 0, subtypeFunc, 0, 0, 0, "subtype", {0} },

    {1, 0x00800000| 0x0800|1|(0*0x0020)|0x0040, ((void*)(long int)(0)), 0, lengthFunc, 0, 0, 0, "length", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020)|0x00c0, ((void*)(long int)(0)), 0, bytelengthFunc, 0, 0, 0, "octet_length", {0} },
    {2, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, instrFunc, 0, 0, 0, "instr", {0} },
    {-1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, printfFunc, 0, 0, 0, "printf", {0} },
    {-1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, printfFunc, 0, 0, 0, "format", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, unicodeFunc, 0, 0, 0, "unicode", {0} },
    {-1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, charFunc, 0, 0, 0, "char", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, absFunc, 0, 0, 0, "abs", {0} },





    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, roundFunc, 0, 0, 0, "round", {0} },
    {2, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, roundFunc, 0, 0, 0, "round", {0} },

    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, upperFunc, 0, 0, 0, "upper", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, lowerFunc, 0, 0, 0, "lower", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, hexFunc, 0, 0, 0, "hex", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, unhexFunc, 0, 0, 0, "unhex", {0} },
    {2, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, unhexFunc, 0, 0, 0, "unhex", {0} },
    {-3, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, concatFunc, 0, 0, 0, "concat", {0} },
    {-4, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, concatwsFunc, 0, 0, 0, "concat_ws", {0} },
    {2, 0x00800000| 1|0x00400000|0x0800|(0), ((void*)(long int)(0)), 0, versionFunc, 0, 0, 0, "ifnull", {0} },
    {0, 0x00800000|1|(0*0x0020), ((void*)(long int)(0)), 0, randomFunc, 0, 0, 0, "random", {0} },
    {1, 0x00800000|1|(0*0x0020), ((void*)(long int)(0)), 0, randomBlob, 0, 0, 0, "randomblob", {0} },
    {2, 0x00800000| 0x0800|1|(1*0x0020), ((void*)(long int)(0)), 0, nullifFunc, 0, 0, 0, "nullif", {0} },
    {0, 0x00800000|0x2000|1, 0, 0, versionFunc, 0, 0, 0, "sqlite_version", {0} },
    {0, 0x00800000|0x2000|1, 0, 0, sourceidFunc, 0, 0, 0, "sqlite_source_id", {0} },
    {2, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, errlogFunc, 0, 0, 0, "sqlite_log", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, unistrFunc, 0, 0, 0, "unistr", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, quoteFunc, 0, 0, 0, "quote", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(1)), 0, quoteFunc, 0, 0, 0, "unistr_quote", {0} },
    {0, 0x00800000|1|(0*0x0020), ((void*)(long int)(0)), 0, last_insert_rowid, 0, 0, 0, "last_insert_rowid", {0} },
    {0, 0x00800000|1|(0*0x0020), ((void*)(long int)(0)), 0, changes, 0, 0, 0, "changes", {0} },
    {0, 0x00800000|1|(0*0x0020), ((void*)(long int)(0)), 0, total_changes, 0, 0, 0, "total_changes", {0} },
    {3, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, replaceFunc, 0, 0, 0, "replace", {0} },
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, zeroblobFunc, 0, 0, 0, "zeroblob", {0} },
    {2, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, substrFunc, 0, 0, 0, "substr", {0} },
    {3, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, substrFunc, 0, 0, 0, "substr", {0} },
    {2, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, substrFunc, 0, 0, 0, "substring", {0} },
    {3, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, substrFunc, 0, 0, 0, "substring", {0} },
    {1, 0x00800000|1|(0*0x0020)|0, ((void*)(long int)(0)), 0, sumStep,sumFinalize,sumFinalize,sumInverse,"sum", {0}},
    {1, 0x00800000|1|(0*0x0020)|0, ((void*)(long int)(0)), 0, sumStep,totalFinalize,totalFinalize,sumInverse,"total", {0}},
    {1, 0x00800000|1|(0*0x0020)|0, ((void*)(long int)(0)), 0, sumStep,avgFinalize,avgFinalize,sumInverse,"avg", {0}},
    {0, 0x00800000|1|(0*0x0020)|0x0100|0x08000000, ((void*)(long int)(0)), 0, countStep,countFinalize,countFinalize,countInverse,"count", {0}},


    {1, 0x00800000|1|(0*0x0020)|0x08000000, ((void*)(long int)(0)), 0, countStep,countFinalize,countFinalize,countInverse,"count", {0}},

    {1, 0x00800000|1|(0*0x0020)|0, ((void*)(long int)(0)), 0, groupConcatStep,groupConcatFinalize,groupConcatValue,groupConcatInverse,"group_concat", {0}},

    {2, 0x00800000|1|(0*0x0020)|0, ((void*)(long int)(0)), 0, groupConcatStep,groupConcatFinalize,groupConcatValue,groupConcatInverse,"group_concat", {0}},

    {2, 0x00800000|1|(0*0x0020)|0, ((void*)(long int)(0)), 0, groupConcatStep,groupConcatFinalize,groupConcatValue,groupConcatInverse,"string_agg", {0}},
# 135131 "c_tests/sqlite3.c"
    {2, 0x00800000|0x0800|1|0x0004|0x0008, (void *)&globInfo, 0, likeFunc, 0, 0, 0, "glob", {0} },




    {2, 0x00800000|0x0800|1|0x0004, (void *)&likeInfoNorm, 0, likeFunc, 0, 0, 0, "like", {0} },
    {3, 0x00800000|0x0800|1|0x0004, (void *)&likeInfoNorm, 0, likeFunc, 0, 0, 0, "like", {0} },
# 135178 "c_tests/sqlite3.c"
    {1, 0x00800000| 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, signFunc, 0, 0, 0, "sign", {0} },
    {-4, 0x00800000| 1|0x00400000|0x0800|(0), ((void*)(long int)(0)), 0, versionFunc, 0, 0, 0, "coalesce", {0} },
    {-4, 0x00800000| 1|0x00400000|0x0800|(0), ((void*)(long int)(5)), 0, versionFunc, 0, 0, 0, "iif", {0} },
    {-4, 0x00800000| 1|0x00400000|0x0800|(0), ((void*)(long int)(5)), 0, versionFunc, 0, 0, 0, "if", {0} },
  };

  sqlite3AlterFunctions();

  sqlite3WindowFunctions();
  sqlite3RegisterDateTimeFunctions();
  sqlite3RegisterJsonFunctions();
  sqlite3InsertBuiltinFuncs(aBuiltinFunc, ((int)(sizeof(aBuiltinFunc)/sizeof(aBuiltinFunc[0]))));
# 135207 "c_tests/sqlite3.c"
}
# 135393 "c_tests/sqlite3.c"
static int sqlite3FkLocateIndex(
  Parse *pParse,
  Table *pParent,
  FKey *pFKey,
  Index **ppIdx,
  int **paiCol
){
  Index *pIdx = 0;
  int *aiCol = 0;
  int nCol = pFKey->nCol;
  char *zKey = pFKey->aCol[0].zCol;


  ((void) (0));
  ((void) (0));
  ((void) (0));
# 135418 "c_tests/sqlite3.c"
  if( nCol==1 ){







    if( pParent->iPKey>=0 ){
      if( !zKey ) return 0;
      if( !sqlite3StrICmp(pParent->aCol[pParent->iPKey].zCnName, zKey) ){
        return 0;
      }
    }
  }else if( paiCol ){
    ((void) (0));
    aiCol = (int *)sqlite3DbMallocRawNN(pParse->db, nCol*sizeof(int));
    if( !aiCol ) return 1;
    *paiCol = aiCol;
  }

  for(pIdx=pParent->pIndex; pIdx; pIdx=pIdx->pNext){
    if( pIdx->nKeyCol==nCol && ((pIdx)->onError!=0) && pIdx->pPartIdxWhere==0 ){




      if( zKey==0 ){



        if( ((pIdx)->idxType==2) ){
          if( aiCol ){
            int i;
            for(i=0; i<nCol; i++) aiCol[i] = pFKey->aCol[i].iFrom;
          }
          break;
        }
      }else{




        int i, j;
        for(i=0; i<nCol; i++){
          i16 iCol = pIdx->aiColumn[i];
          const char *zDfltColl;
          char *zIdxCol;

          if( iCol<0 ) break;




          zDfltColl = sqlite3ColumnColl(&pParent->aCol[iCol]);
          if( !zDfltColl ) zDfltColl = sqlite3StrBINARY;
          if( sqlite3StrICmp(pIdx->azColl[i], zDfltColl) ) break;

          zIdxCol = pParent->aCol[iCol].zCnName;
          for(j=0; j<nCol; j++){
            if( sqlite3StrICmp(pFKey->aCol[j].zCol, zIdxCol)==0 ){
              if( aiCol ) aiCol[i] = pFKey->aCol[j].iFrom;
              break;
            }
          }
          if( j==nCol ) break;
        }
        if( i==nCol ) break;
      }
    }
  }

  if( !pIdx ){
    if( !pParse->disableTriggers ){
      sqlite3ErrorMsg(pParse,
           "foreign key mismatch - \"%w\" referencing \"%w\"",
           pFKey->pFrom->zName, pFKey->zTo);
    }
    sqlite3DbFree(pParse->db, aiCol);
    return 1;
  }

  *ppIdx = pIdx;
  return 0;
}
# 135530 "c_tests/sqlite3.c"
static void fkLookupParent(
  Parse *pParse,
  int iDb,
  Table *pTab,
  Index *pIdx,
  FKey *pFKey,
  int *aiCol,
  int regData,
  int nIncr,
  int isIgnore
){
  int i;
  Vdbe *v = sqlite3GetVdbe(pParse);
  int iCur = pParse->nTab - 1;
  int iOk = sqlite3VdbeMakeLabel(pParse);





                                                       ;
# 135559 "c_tests/sqlite3.c"
  if( nIncr<0 ){
    sqlite3VdbeAddOp2(v, 50, pFKey->isDeferred, iOk);
                   ;
  }
  for(i=0; i<pFKey->nCol; i++){
    int iReg = sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[i]) + regData + 1;
    sqlite3VdbeAddOp2(v, 51, iReg, iOk); ;
  }

  if( isIgnore==0 ){
    if( pIdx==0 ){


      int iMustBeInt;
      int regTemp = sqlite3GetTempReg(pParse);






      sqlite3VdbeAddOp2(v, 82,
        sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[0])+1+regData, regTemp);
      iMustBeInt = sqlite3VdbeAddOp2(v, 13, regTemp, 0);
                     ;





      if( pTab==pFKey->pFrom && nIncr==1 ){
        sqlite3VdbeAddOp3(v, 54, regData, iOk, regTemp); ;
        sqlite3VdbeChangeP5(v, 0x90);
      }

      sqlite3OpenTable(pParse, iCur, iDb, pTab, 113);
      sqlite3VdbeAddOp3(v, 31, iCur, 0, regTemp); ;
      sqlite3VdbeGoto(v, iOk);
      sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
      sqlite3VdbeJumpHere(v, iMustBeInt);
      sqlite3ReleaseTempReg(pParse, regTemp);
    }else{
      int nCol = pFKey->nCol;
      int regTemp = sqlite3GetTempRange(pParse, nCol);

      sqlite3VdbeAddOp3(v, 113, iCur, pIdx->tnum, iDb);
      sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
      for(i=0; i<nCol; i++){
        sqlite3VdbeAddOp2(v, 81,
               sqlite3TableColumnToStorage(pFKey->pFrom, aiCol[i])+1+regData,
               regTemp+i);
      }
# 135622 "c_tests/sqlite3.c"
      if( pTab==pFKey->pFrom && nIncr==1 ){
        int iJump = sqlite3VdbeCurrentAddr(v) + nCol + 1;
        for(i=0; i<nCol; i++){
          int iChild = sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[i])
                              +1+regData;
          int iParent = 1+regData;
          iParent += sqlite3TableColumnToStorage(pIdx->pTable,
                                                 pIdx->aiColumn[i]);
          ((void) (0));
          ((void) (0));
          if( pIdx->aiColumn[i]==pTab->iPKey ){

            iParent = regData;
          }
          sqlite3VdbeAddOp3(v, 53, iChild, iJump, iParent); ;
          sqlite3VdbeChangeP5(v, 0x10);
        }
        sqlite3VdbeGoto(v, iOk);
      }

      sqlite3VdbeAddOp4(v, 97, regTemp, nCol, 0,
                        sqlite3IndexAffinityStr(pParse->db,pIdx), nCol);
      sqlite3VdbeAddOp4Int(v, 29, iCur, iOk, regTemp, nCol);
                     ;
      sqlite3ReleaseTempRange(pParse, regTemp, nCol);
    }
  }

  if( !pFKey->isDeferred && !(pParse->db->flags & 0x00080000)
   && !pParse->pToplevel
   && !pParse->isMultiWrite
  ){




    ((void) (0));
    sqlite3HaltConstraint(pParse, (19 | (3<<8)),
        2, 0, (-1), 4);
  }else{
    if( nIncr>0 && pFKey->isDeferred==0 ){
      sqlite3MayAbort(pParse);
    }
    sqlite3VdbeAddOp2(v, 159, pFKey->isDeferred, nIncr);
  }

  sqlite3VdbeResolveLabel(v, iOk);
  sqlite3VdbeAddOp1(v, 123, iCur);
}
# 135681 "c_tests/sqlite3.c"
static Expr *exprTableRegister(
  Parse *pParse,
  Table *pTab,
  int regBase,
  i16 iCol
){
  Expr *pExpr;
  Column *pCol;
  const char *zColl;
  sqlite3 *db = pParse->db;

  pExpr = sqlite3Expr(db, 176, 0);
  if( pExpr ){
    if( iCol>=0 && iCol!=pTab->iPKey ){
      pCol = &pTab->aCol[iCol];
      pExpr->iTable = regBase + sqlite3TableColumnToStorage(pTab,iCol) + 1;
      pExpr->affExpr = pCol->affinity;
      zColl = sqlite3ColumnColl(pCol);
      if( zColl==0 ) zColl = db->pDfltColl->zName;
      pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl);
    }else{
      pExpr->iTable = regBase;
      pExpr->affExpr = 0x44;
    }
  }
  return pExpr;
}





static Expr *exprTableColumn(
  sqlite3 *db,
  Table *pTab,
  int iCursor,
  i16 iCol
){
  Expr *pExpr = sqlite3Expr(db, 168, 0);
  if( pExpr ){
    ((void) (0));
    pExpr->y.pTab = pTab;
    pExpr->iTable = iCursor;
    pExpr->iColumn = iCol;
  }
  return pExpr;
}
# 135757 "c_tests/sqlite3.c"
static void fkScanChildren(
  Parse *pParse,
  SrcList *pSrc,
  Table *pTab,
  Index *pIdx,
  FKey *pFKey,
  int *aiCol,
  int regData,
  int nIncr
){
  sqlite3 *db = pParse->db;
  int i;
  Expr *pWhere = 0;
  NameContext sNameContext;
  WhereInfo *pWInfo;
  int iFkIfZero = 0;
  Vdbe *v = sqlite3GetVdbe(pParse);

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( nIncr<0 ){
    iFkIfZero = sqlite3VdbeAddOp2(v, 50, pFKey->isDeferred, 0);
                   ;
  }
# 135793 "c_tests/sqlite3.c"
  for(i=0; i<pFKey->nCol; i++){
    Expr *pLeft;
    Expr *pRight;
    Expr *pEq;
    i16 iCol;
    const char *zCol;

    iCol = pIdx ? pIdx->aiColumn[i] : -1;
    pLeft = exprTableRegister(pParse, pTab, regData, iCol);
    iCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
    ((void) (0));
    zCol = pFKey->pFrom->aCol[iCol].zCnName;
    pRight = sqlite3Expr(db, 60, zCol);
    pEq = sqlite3PExpr(pParse, 54, pLeft, pRight);
    pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
  }
# 135824 "c_tests/sqlite3.c"
  if( pTab==pFKey->pFrom && nIncr>0 ){
    Expr *pNe;
    Expr *pLeft;
    Expr *pRight;
    if( (((pTab)->tabFlags & 0x00000080)==0) ){
      pLeft = exprTableRegister(pParse, pTab, regData, -1);
      pRight = exprTableColumn(db, pTab, pSrc->a[0].iCursor, -1);
      pNe = sqlite3PExpr(pParse, 53, pLeft, pRight);
    }else{
      Expr *pEq, *pAll = 0;
      ((void) (0));
      for(i=0; i<pIdx->nKeyCol; i++){
        i16 iCol = pIdx->aiColumn[i];
        ((void) (0));
        pLeft = exprTableRegister(pParse, pTab, regData, iCol);
        pRight = sqlite3Expr(db, 60, pTab->aCol[iCol].zCnName);
        pEq = sqlite3PExpr(pParse, 45, pLeft, pRight);
        pAll = sqlite3ExprAnd(pParse, pAll, pEq);
      }
      pNe = sqlite3PExpr(pParse, 19, pAll, 0);
    }
    pWhere = sqlite3ExprAnd(pParse, pWhere, pNe);
  }


  memset(&sNameContext, 0, sizeof(NameContext));
  sNameContext.pSrcList = pSrc;
  sNameContext.pParse = pParse;
  sqlite3ResolveExprNames(&sNameContext, pWhere);




  if( pParse->nErr==0 ){
    pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0, 0, 0, 0);
    sqlite3VdbeAddOp2(v, 159, pFKey->isDeferred, nIncr);
    if( pWInfo ){
      sqlite3WhereEnd(pWInfo);
    }
  }


  sqlite3ExprDelete(db, pWhere);
  if( iFkIfZero ){
    sqlite3VdbeJumpHereOrPopInst(v, iFkIfZero);
  }
}
# 135886 "c_tests/sqlite3.c"
static FKey *sqlite3FkReferences(Table *pTab){
  return (FKey *)sqlite3HashFind(&pTab->pSchema->fkeyHash, pTab->zName);
}
# 135898 "c_tests/sqlite3.c"
static void fkTriggerDelete(sqlite3 *dbMem, Trigger *p){
  if( p ){
    TriggerStep *pStep = p->step_list;
    sqlite3ExprDelete(dbMem, pStep->pWhere);
    sqlite3ExprListDelete(dbMem, pStep->pExprList);
    sqlite3SelectDelete(dbMem, pStep->pSelect);
    sqlite3ExprDelete(dbMem, p->pWhen);
    sqlite3DbFree(dbMem, p);
  }
}






static void sqlite3FkClearTriggerCache(sqlite3 *db, int iDb){
  HashElem *k;
  Hash *pHash = &db->aDb[iDb].pSchema->tblHash;
  for(k=((pHash)->first); k; k=((k)->next)){
    Table *pTab = ((k)->data);
    FKey *pFKey;
    if( !((pTab)->eTabType==0) ) continue;
    for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){
      fkTriggerDelete(db, pFKey->apTrigger[0]); pFKey->apTrigger[0] = 0;
      fkTriggerDelete(db, pFKey->apTrigger[1]); pFKey->apTrigger[1] = 0;
    }
  }
}
# 135945 "c_tests/sqlite3.c"
static void sqlite3FkDropTable(Parse *pParse, SrcList *pName, Table *pTab){
  sqlite3 *db = pParse->db;
  if( (db->flags&0x00004000) && ((pTab)->eTabType==0) ){
    int iSkip = 0;
    Vdbe *v = sqlite3GetVdbe(pParse);

    ((void) (0));
    ((void) (0));
    if( sqlite3FkReferences(pTab)==0 ){





      FKey *p;
      for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){
        if( p->isDeferred || (db->flags & 0x00080000) ) break;
      }
      if( !p ) return;
      iSkip = sqlite3VdbeMakeLabel(pParse);
      sqlite3VdbeAddOp2(v, 50, 1, iSkip); ;
    }

    pParse->disableTriggers = 1;
    sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, 0), 0, 0, 0);
    pParse->disableTriggers = 0;
# 135981 "c_tests/sqlite3.c"
    if( (db->flags & 0x00080000)==0 ){
                                             ;
      sqlite3VdbeAddOp2(v, 50, 0, sqlite3VdbeCurrentAddr(v)+2);
                     ;
      sqlite3HaltConstraint(pParse, (19 | (3<<8)),
          2, 0, (-1), 4);
    }

    if( iSkip ){
      sqlite3VdbeResolveLabel(v, iSkip);
    }
  }
}
# 136008 "c_tests/sqlite3.c"
static int fkChildIsModified(
  Table *pTab,
  FKey *p,
  int *aChange,
  int bChngRowid
){
  int i;
  for(i=0; i<p->nCol; i++){
    int iChildKey = p->aCol[i].iFrom;
    if( aChange[iChildKey]>=0 ) return 1;
    if( iChildKey==pTab->iPKey && bChngRowid ) return 1;
  }
  return 0;
}
# 136035 "c_tests/sqlite3.c"
static int fkParentIsModified(
  Table *pTab,
  FKey *p,
  int *aChange,
  int bChngRowid
){
  int i;
  for(i=0; i<p->nCol; i++){
    char *zKey = p->aCol[i].zCol;
    int iKey;
    for(iKey=0; iKey<pTab->nCol; iKey++){
      if( aChange[iKey]>=0 || (iKey==pTab->iPKey && bChngRowid) ){
        Column *pCol = &pTab->aCol[iKey];
        if( zKey ){
          if( 0==sqlite3StrICmp(pCol->zCnName, zKey) ) return 1;
        }else if( pCol->colFlags & 0x0001 ){
          return 1;
        }
      }
    }
  }
  return 0;
}






static int isSetNullAction(Parse *pParse, FKey *pFKey){
  Parse *pTop = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  if( pTop->pTriggerPrg ){
    Trigger *p = pTop->pTriggerPrg->pTrigger;
    if( (p==pFKey->apTrigger[0] && pFKey->aAction[0]==8)
     || (p==pFKey->apTrigger[1] && pFKey->aAction[1]==8)
    ){
      ((void) (0));
      return 1;
    }
  }
  return 0;
}
# 136098 "c_tests/sqlite3.c"
static void sqlite3FkCheck(
  Parse *pParse,
  Table *pTab,
  int regOld,
  int regNew,
  int *aChange,
  int bChngRowid
){
  sqlite3 *db = pParse->db;
  FKey *pFKey;
  int iDb;
  const char *zDb;
  int isIgnoreErrors = pParse->disableTriggers;


  ((void) (0));


  if( (db->flags&0x00004000)==0 ) return;
  if( !((pTab)->eTabType==0) ) return;

  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  zDb = db->aDb[iDb].zDbSName;



  for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){
    Table *pTo;
    Index *pIdx = 0;
    int *aiFree = 0;
    int *aiCol;
    int iCol;
    int i;
    int bIgnore = 0;

    if( aChange
     && sqlite3_stricmp(pTab->zName, pFKey->zTo)!=0
     && fkChildIsModified(pTab, pFKey, aChange, bChngRowid)==0
    ){
      continue;
    }





    if( pParse->disableTriggers ){
      pTo = sqlite3FindTable(db, pFKey->zTo, zDb);
    }else{
      pTo = sqlite3LocateTable(pParse, 0, pFKey->zTo, zDb);
    }
    if( !pTo || sqlite3FkLocateIndex(pParse, pTo, pFKey, &pIdx, &aiFree) ){
      ((void) (0));
      if( !isIgnoreErrors || db->mallocFailed ) return;
      if( pTo==0 ){







        Vdbe *v = sqlite3GetVdbe(pParse);
        int iJump = sqlite3VdbeCurrentAddr(v) + pFKey->nCol + 1;
        for(i=0; i<pFKey->nCol; i++){
          int iFromCol, iReg;
          iFromCol = pFKey->aCol[i].iFrom;
          iReg = sqlite3TableColumnToStorage(pFKey->pFrom,iFromCol) + regOld+1;
          sqlite3VdbeAddOp2(v, 51, iReg, iJump); ;
        }
        sqlite3VdbeAddOp2(v, 159, pFKey->isDeferred, -1);
      }
      continue;
    }
    ((void) (0));

    if( aiFree ){
      aiCol = aiFree;
    }else{
      iCol = pFKey->aCol[0].iFrom;
      aiCol = &iCol;
    }
    for(i=0; i<pFKey->nCol; i++){
      if( aiCol[i]==pTab->iPKey ){
        aiCol[i] = -1;
      }
      ((void) (0));




      if( db->xAuth ){
        int rcauth;
        char *zCol = pTo->aCol[pIdx ? pIdx->aiColumn[i] : pTo->iPKey].zCnName;
        rcauth = sqlite3AuthReadCol(pParse, pTo->zName, zCol, iDb);
        bIgnore = (rcauth==2);
      }

    }




    sqlite3TableLock(pParse, iDb, pTo->tnum, 0, pTo->zName);
    pParse->nTab++;

    if( regOld!=0 ){



      fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regOld, -1, bIgnore);
    }
    if( regNew!=0 && !isSetNullAction(pParse, pFKey) ){
# 136219 "c_tests/sqlite3.c"
      fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regNew, +1, bIgnore);
    }

    sqlite3DbFree(db, aiFree);
  }



  for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){
    Index *pIdx = 0;
    SrcList *pSrc;
    int *aiCol = 0;

    if( aChange && fkParentIsModified(pTab, pFKey, aChange, bChngRowid)==0 ){
      continue;
    }

    if( !pFKey->isDeferred && !(db->flags & 0x00080000)
     && !pParse->pToplevel && !pParse->isMultiWrite
    ){
      ((void) (0));


      continue;
    }

    if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ){
      if( !isIgnoreErrors || db->mallocFailed ) return;
      continue;
    }
    ((void) (0));



    pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
    if( pSrc ){
      SrcItem *pItem = pSrc->a;
      pItem->pSTab = pFKey->pFrom;
      pItem->zName = pFKey->pFrom->zName;
      pItem->pSTab->nTabRef++;
      pItem->iCursor = pParse->nTab++;

      if( regNew!=0 ){
        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regNew, -1);
      }
      if( regOld!=0 ){
        int eAction = pFKey->aAction[aChange!=0];
        if( (db->flags & ((u64)(0x00008)<<32)) ) eAction = 0;

        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regOld, 1);
# 136286 "c_tests/sqlite3.c"
        if( !pFKey->isDeferred && eAction!=10 && eAction!=8 ){
          sqlite3MayAbort(pParse);
        }
      }
      pItem->zName = 0;
      sqlite3SrcListDelete(db, pSrc);
    }
    sqlite3DbFree(db, aiCol);
  }
}







static u32 sqlite3FkOldmask(
  Parse *pParse,
  Table *pTab
){
  u32 mask = 0;
  if( pParse->db->flags&0x00004000 && ((pTab)->eTabType==0) ){
    FKey *p;
    int i;
    for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){
      for(i=0; i<p->nCol; i++) mask |= (((p->aCol[i].iFrom)>31) ? 0xffffffff : ((u32)1<<(p->aCol[i].iFrom)));
    }
    for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
      Index *pIdx = 0;
      sqlite3FkLocateIndex(pParse, pTab, p, &pIdx, 0);
      if( pIdx ){
        for(i=0; i<pIdx->nKeyCol; i++){
          ((void) (0));
          mask |= (((pIdx->aiColumn[i])>31) ? 0xffffffff : ((u32)1<<(pIdx->aiColumn[i])));
        }
      }
    }
  }
  return mask;
}
# 136353 "c_tests/sqlite3.c"
static int sqlite3FkRequired(
  Parse *pParse,
  Table *pTab,
  int *aChange,
  int chngRowid
){
  int eRet = 1;
  int bHaveFK = 0;
  if( pParse->db->flags&0x00004000 && ((pTab)->eTabType==0) ){
    if( !aChange ){



      bHaveFK = (sqlite3FkReferences(pTab) || pTab->u.tab.pFKey);
    }else{


      FKey *p;


      for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){
        if( fkChildIsModified(pTab, p, aChange, chngRowid) ){
          if( 0==sqlite3_stricmp(pTab->zName, p->zTo) ) eRet = 2;
          bHaveFK = 1;
        }
      }


      for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
        if( fkParentIsModified(pTab, p, aChange, chngRowid) ){
          if( (pParse->db->flags & ((u64)(0x00008)<<32))==0
           && p->aAction[1]!=0
          ){
            return 2;
          }
          bHaveFK = 1;
        }
      }
    }
  }
  return bHaveFK ? eRet : 0;
}
# 136425 "c_tests/sqlite3.c"
static Trigger *fkActionTrigger(
  Parse *pParse,
  Table *pTab,
  FKey *pFKey,
  ExprList *pChanges
){
  sqlite3 *db = pParse->db;
  int action;
  Trigger *pTrigger;
  int iAction = (pChanges!=0);

  action = pFKey->aAction[iAction];
  if( (db->flags & ((u64)(0x00008)<<32)) ) action = 0;
  if( action==7 && (db->flags & 0x00080000) ){
    return 0;
  }
  pTrigger = pFKey->apTrigger[iAction];

  if( action!=0 && !pTrigger ){
    char const *zFrom;
    int nFrom;
    Index *pIdx = 0;
    int *aiCol = 0;
    TriggerStep *pStep = 0;
    Expr *pWhere = 0;
    ExprList *pList = 0;
    Select *pSelect = 0;
    int i;
    Expr *pWhen = 0;

    if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ) return 0;
    ((void) (0));

    for(i=0; i<pFKey->nCol; i++){
      Token tOld = { "old", 3 };
      Token tNew = { "new", 3 };
      Token tFromCol;
      Token tToCol;
      int iFromCol;
      Expr *pEq;

      iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      sqlite3TokenInit(&tToCol,
                   pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zCnName);
      sqlite3TokenInit(&tFromCol, pFKey->pFrom->aCol[iFromCol].zCnName);





      pEq = sqlite3PExpr(pParse, 54,
          sqlite3PExpr(pParse, 142,
            sqlite3ExprAlloc(db, 60, &tOld, 0),
            sqlite3ExprAlloc(db, 60, &tToCol, 0)),
          sqlite3ExprAlloc(db, 60, &tFromCol, 0)
      );
      pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);






      if( pChanges ){
        pEq = sqlite3PExpr(pParse, 45,
            sqlite3PExpr(pParse, 142,
              sqlite3ExprAlloc(db, 60, &tOld, 0),
              sqlite3ExprAlloc(db, 60, &tToCol, 0)),
            sqlite3PExpr(pParse, 142,
              sqlite3ExprAlloc(db, 60, &tNew, 0),
              sqlite3ExprAlloc(db, 60, &tToCol, 0))
            );
        pWhen = sqlite3ExprAnd(pParse, pWhen, pEq);
      }

      if( action!=7 && (action!=10 || pChanges) ){
        Expr *pNew;
        if( action==10 ){
          pNew = sqlite3PExpr(pParse, 142,
            sqlite3ExprAlloc(db, 60, &tNew, 0),
            sqlite3ExprAlloc(db, 60, &tToCol, 0));
        }else if( action==9 ){
          Column *pCol = pFKey->pFrom->aCol + iFromCol;
          Expr *pDflt;
          if( pCol->colFlags & 0x0060 ){
                                                        ;
                                                       ;
            pDflt = 0;
          }else{
            pDflt = sqlite3ColumnExpr(pFKey->pFrom, pCol);
          }
          if( pDflt ){
            pNew = sqlite3ExprDup(db, pDflt, 0);
          }else{
            pNew = sqlite3ExprAlloc(db, 122, 0, 0);
          }
        }else{
          pNew = sqlite3ExprAlloc(db, 122, 0, 0);
        }
        pList = sqlite3ExprListAppend(pParse, pList, pNew);
        sqlite3ExprListSetName(pParse, pList, &tFromCol, 0);
      }
    }
    sqlite3DbFree(db, aiCol);

    zFrom = pFKey->pFrom->zName;
    nFrom = sqlite3Strlen30(zFrom);

    if( action==7 ){
      int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
      SrcList *pSrc;
      Expr *pRaise;

      pRaise = sqlite3Expr(db, 118, "FOREIGN KEY constraint failed"),
      pRaise = sqlite3PExpr(pParse, 72, pRaise, 0);
      if( pRaise ){
        pRaise->affExpr = 2;
      }
      pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
      if( pSrc ){
        ((void) (0));
        pSrc->a[0].zName = sqlite3DbStrDup(db, zFrom);
        ((void) (0));
        pSrc->a[0].u4.zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);
      }
      pSelect = sqlite3SelectNew(pParse,
          sqlite3ExprListAppend(pParse, 0, pRaise),
          pSrc,
          pWhere,
          0, 0, 0, 0, 0
      );
      pWhere = 0;
    }


    db->lookaside.bDisable++;db->lookaside.sz=0;

    pTrigger = (Trigger *)sqlite3DbMallocZero(db,
        sizeof(Trigger) +
        sizeof(TriggerStep) +
        nFrom + 1
    );
    if( pTrigger ){
      pStep = pTrigger->step_list = (TriggerStep *)&pTrigger[1];
      pStep->zTarget = (char *)&pStep[1];
      memcpy((char *)pStep->zTarget, zFrom, nFrom);

      pStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001);
      pStep->pExprList = sqlite3ExprListDup(db, pList, 0x0001);
      pStep->pSelect = sqlite3SelectDup(db, pSelect, 0x0001);
      if( pWhen ){
        pWhen = sqlite3PExpr(pParse, 19, pWhen, 0);
        pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 0x0001);
      }
    }


    db->lookaside.bDisable--; db->lookaside.sz=db->lookaside.bDisable?0:db->lookaside.szTrue;

    sqlite3ExprDelete(db, pWhere);
    sqlite3ExprDelete(db, pWhen);
    sqlite3ExprListDelete(db, pList);
    sqlite3SelectDelete(db, pSelect);
    if( db->mallocFailed==1 ){
      fkTriggerDelete(db, pTrigger);
      return 0;
    }
    ((void) (0));
    ((void) (0));

    switch( action ){
      case 7:
        pStep->op = 139;
        break;
      case 10:
        if( !pChanges ){
          pStep->op = 129;
          break;
        }
                       __attribute__((fallthrough));
      default:
        pStep->op = 130;
    }
    pStep->pTrig = pTrigger;
    pTrigger->pSchema = pTab->pSchema;
    pTrigger->pTabSchema = pTab->pSchema;
    pFKey->apTrigger[iAction] = pTrigger;
    pTrigger->op = (pChanges ? 130 : 129);
  }

  return pTrigger;
}





static void sqlite3FkActions(
  Parse *pParse,
  Table *pTab,
  ExprList *pChanges,
  int regOld,
  int *aChange,
  int bChngRowid
){




  if( pParse->db->flags&0x00004000 ){
    FKey *pFKey;
    for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){
      if( aChange==0 || fkParentIsModified(pTab, pFKey, aChange, bChngRowid) ){
        Trigger *pAct = fkActionTrigger(pParse, pTab, pFKey, pChanges);
        if( pAct ){
          sqlite3CodeRowTriggerDirect(pParse, pAct, pTab, regOld, 2, 0);
        }
      }
    }
  }
}
# 136657 "c_tests/sqlite3.c"
static void sqlite3FkDelete(sqlite3 *db, Table *pTab){
  FKey *pFKey;
  FKey *pNext;

  ((void) (0));
  ((void) (0));
  for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pNext){
    ((void) (0));


    if( db->pnBytesFreed==0 ){
      if( pFKey->pPrevTo ){
        pFKey->pPrevTo->pNextTo = pFKey->pNextTo;
      }else{
        const char *z = (pFKey->pNextTo ? pFKey->pNextTo->zTo : pFKey->zTo);
        sqlite3HashInsert(&pTab->pSchema->fkeyHash, z, pFKey->pNextTo);
      }
      if( pFKey->pNextTo ){
        pFKey->pNextTo->pPrevTo = pFKey->pPrevTo;
      }
    }




    ((void) (0));



    fkTriggerDelete(db, pFKey->apTrigger[0]);
    fkTriggerDelete(db, pFKey->apTrigger[1]);


    pNext = pFKey->pNextFrom;
    sqlite3DbFree(db, pFKey);
  }
}
# 136723 "c_tests/sqlite3.c"
static void sqlite3OpenTable(
  Parse *pParse,
  int iCur,
  int iDb,
  Table *pTab,
  int opcode
){
  Vdbe *v;
  ((void) (0));
  ((void) (0));
  v = pParse->pVdbe;
  ((void) (0));
  if( !pParse->db->noSharedCache ){
    sqlite3TableLock(pParse, iDb, pTab->tnum,
                     (opcode==114)?1:0, pTab->zName);
  }
  if( (((pTab)->tabFlags & 0x00000080)==0) ){
    sqlite3VdbeAddOp4Int(v, opcode, iCur, pTab->tnum, iDb, pTab->nNVCol);
                                       ;
  }else{
    Index *pPk = sqlite3PrimaryKeyIndex(pTab);
    ((void) (0));
    ((void) (0));
    sqlite3VdbeAddOp3(v, opcode, iCur, pPk->tnum, iDb);
    sqlite3VdbeSetP4KeyInfo(pParse, pPk);
                                       ;
  }
}
# 136772 "c_tests/sqlite3.c"
static __attribute__((noinline)) const char *computeIndexAffStr(sqlite3 *db, Index *pIdx){
# 136781 "c_tests/sqlite3.c"
  int n;
  Table *pTab = pIdx->pTable;
  pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn+1);
  if( !pIdx->zColAff ){
    sqlite3OomFault(db);
    return 0;
  }
  for(n=0; n<pIdx->nColumn; n++){
    i16 x = pIdx->aiColumn[n];
    char aff;
    if( x>=0 ){
      aff = pTab->aCol[x].affinity;
    }else if( x==(-1) ){
      aff = 0x44;
    }else{
      ((void) (0));
      ((void) (0));
      ((void) (0));
      aff = sqlite3ExprAffinity(pIdx->aColExpr->a[n].pExpr);
    }
    if( aff<0x41 ) aff = 0x41;
    if( aff>0x43) aff = 0x43;
    pIdx->zColAff[n] = aff;
  }
  pIdx->zColAff[n] = 0;
  return pIdx->zColAff;
}
static const char *sqlite3IndexAffinityStr(sqlite3 *db, Index *pIdx){
  if( !pIdx->zColAff ) return computeIndexAffStr(db, pIdx);
  return pIdx->zColAff;
}







static char *sqlite3TableAffinityStr(sqlite3 *db, const Table *pTab){
  char *zColAff;
  zColAff = (char *)sqlite3DbMallocRaw(db, pTab->nCol+1);
  if( zColAff ){
    int i, j;
    for(i=j=0; i<pTab->nCol; i++){
      if( (pTab->aCol[i].colFlags & 0x0020)==0 ){
        zColAff[j++] = pTab->aCol[i].affinity;
      }
    }
    do{
      zColAff[j--] = 0;
    }while( j>=0 && zColAff[j]<=0x41 );
  }
  return zColAff;
}
# 136876 "c_tests/sqlite3.c"
static void sqlite3TableAffinity(Vdbe *v, Table *pTab, int iReg){
  int i;
  char *zColAff;
  if( pTab->tabFlags & 0x00010000 ){
    if( iReg==0 ){



      VdbeOp *pPrev;
      int p3;
      sqlite3VdbeAppendP4(v, pTab, (-5));
      pPrev = sqlite3VdbeGetLastOp(v);
      ((void) (0));
      ((void) (0));
      pPrev->opcode = 96;
      p3 = pPrev->p3;
      pPrev->p3 = 0;
      sqlite3VdbeAddOp3(v, 98, pPrev->p1, pPrev->p2, p3);
    }else{

      sqlite3VdbeAddOp2(v, 96, iReg, pTab->nNVCol);
      sqlite3VdbeAppendP4(v, pTab, (-5));
    }
    return;
  }
  zColAff = pTab->zColAff;
  if( zColAff==0 ){
    zColAff = sqlite3TableAffinityStr(0, pTab);
    if( !zColAff ){
      sqlite3OomFault(sqlite3VdbeDb(v));
      return;
    }
    pTab->zColAff = zColAff;
  }
  ((void) (0));
  i = (strlen(zColAff)&0x3fffffff);
  if( i ){
    if( iReg ){
      sqlite3VdbeAddOp4(v, 97, iReg, i, 0, zColAff, i);
    }else{
      ((void) (0));

      sqlite3VdbeChangeP4(v, -1, zColAff, i);
    }
  }
}







static int readsTable(Parse *p, int iDb, Table *pTab){
  Vdbe *v = sqlite3GetVdbe(p);
  int i;
  int iEnd = sqlite3VdbeCurrentAddr(v);

  VTable *pVTab = ((pTab)->eTabType==1) ? sqlite3GetVTable(p->db, pTab) : 0;


  for(i=1; i<iEnd; i++){
    VdbeOp *pOp = sqlite3VdbeGetOp(v, i);
    ((void) (0));
    if( pOp->opcode==113 && pOp->p3==iDb ){
      Index *pIndex;
      Pgno tnum = pOp->p2;
      if( tnum==pTab->tnum ){
        return 1;
      }
      for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){
        if( tnum==pIndex->tnum ){
          return 1;
        }
      }
    }

    if( pOp->opcode==174 && pOp->p4.pVtab==pVTab ){
      ((void) (0));
      ((void) (0));
      return 1;
    }

  }
  return 0;
}




static int exprColumnFlagUnion(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==168 && pExpr->iColumn>=0 ){
    ((void) (0));
    pWalker->eCode |= pWalker->u.pTab->aCol[pExpr->iColumn].colFlags;
  }
  return 0;
}
# 136982 "c_tests/sqlite3.c"
static void sqlite3ComputeGeneratedColumns(
  Parse *pParse,
  int iRegStore,
  Table *pTab
){
  int i;
  Walker w;
  Column *pRedo;
  int eProgress;
  VdbeOp *pOp;

  ((void) (0));
                                            ;
                                           ;




  sqlite3TableAffinity(pParse->pVdbe, pTab, iRegStore);
  if( (pTab->tabFlags & 0x00000040)!=0 ){
    pOp = sqlite3VdbeGetLastOp(pParse->pVdbe);
    if( pOp->opcode==97 ){



      int ii, jj;
      char *zP4 = pOp->p4.z;
      ((void) (0));
      ((void) (0));
      for(ii=jj=0; zP4[jj]; ii++){
        if( pTab->aCol[ii].colFlags & 0x0020 ){
          continue;
        }
        if( pTab->aCol[ii].colFlags & 0x0040 ){
          zP4[jj] = 0x40;
        }
        jj++;
      }
    }else if( pOp->opcode==96 ){



      pOp->p3 = 1;
    }
  }





  for(i=0; i<pTab->nCol; i++){
    if( pTab->aCol[i].colFlags & 0x0060 ){
                                                          ;
                                                         ;
      pTab->aCol[i].colFlags |= 0x0080;
    }
  }

  w.u.pTab = pTab;
  w.xExprCallback = exprColumnFlagUnion;
  w.xSelectCallback = 0;
  w.xSelectCallback2 = 0;






  pParse->iSelfTab = -iRegStore;
  do{
    eProgress = 0;
    pRedo = 0;
    for(i=0; i<pTab->nCol; i++){
      Column *pCol = pTab->aCol + i;
      if( (pCol->colFlags & 0x0080)!=0 ){
        int x;
        pCol->colFlags |= 0x0100;
        w.eCode = 0;
        sqlite3WalkExpr(&w, sqlite3ColumnExpr(pTab, pCol));
        pCol->colFlags &= ~0x0100;
        if( w.eCode & 0x0080 ){
          pRedo = pCol;
          continue;
        }
        eProgress = 1;
        ((void) (0));
        x = sqlite3TableColumnToStorage(pTab, i) + iRegStore;
        sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, x);
        pCol->colFlags &= ~0x0080;
      }
    }
  }while( pRedo && eProgress );
  if( pRedo ){
    sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pRedo->zCnName);
  }
  pParse->iSelfTab = 0;
}
# 137106 "c_tests/sqlite3.c"
static int autoIncBegin(
  Parse *pParse,
  int iDb,
  Table *pTab
){
  int memId = 0;
  ((void) (0));
  if( (pTab->tabFlags & 0x00000008)!=0
   && (pParse->db->mDbFlags & 0x0004)==0
  ){
    Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
    AutoincInfo *pInfo;
    Table *pSeqTab = pParse->db->aDb[iDb].pSchema->pSeqTab;




    if( pSeqTab==0
     || !(((pSeqTab)->tabFlags & 0x00000080)==0)
     || (((pSeqTab)->eTabType==1))
     || pSeqTab->nCol!=2
    ){
      pParse->nErr++;
      pParse->rc = (11 | (2<<8));
      return 0;
    }

    pInfo = pToplevel->pAinc;
    while( pInfo && pInfo->pTab!=pTab ){ pInfo = pInfo->pNext; }
    if( pInfo==0 ){
      pInfo = sqlite3DbMallocRawNN(pParse->db, sizeof(*pInfo));
      sqlite3ParserAddCleanup(pToplevel, sqlite3DbFree, pInfo);
                                      ;
      if( pParse->db->mallocFailed ) return 0;
      pInfo->pNext = pToplevel->pAinc;
      pToplevel->pAinc = pInfo;
      pInfo->pTab = pTab;
      pInfo->iDb = iDb;
      pToplevel->nMem++;
      pInfo->regCtr = ++pToplevel->nMem;
      pToplevel->nMem +=2;
    }
    memId = pInfo->regCtr;
  }
  return memId;
}





static void sqlite3AutoincrementBegin(Parse *pParse){
  AutoincInfo *p;
  sqlite3 *db = pParse->db;
  Db *pDb;
  int memId;
  Vdbe *v = pParse->pVdbe;



  ((void) (0));
  ((void) (0));

  ((void) (0));
  for(p = pParse->pAinc; p; p = p->pNext){
    static const int iLn = 0;
    static const VdbeOpList autoInc[] = {
               {76, 0, 0, 0},
               {36, 0, 10, 0},
               {95, 0, 0, 0},
               {53, 0, 9, 0},
               {136, 0, 0, 0},
               {95, 0, 1, 0},
               {87, 0, 0, 0},
               {81, 0, 0, 0},
               {9, 0, 11, 0},
               {40, 0, 2, 0},
               {72, 0, 0, 0},
               {123, 0, 0, 0}
    };
    VdbeOp *aOp;
    pDb = &db->aDb[p->iDb];
    memId = p->regCtr;
    ((void) (0));
    sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, 113);
    sqlite3VdbeLoadString(v, memId-1, p->pTab->zName);
    aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(autoInc)/sizeof(autoInc[0]))), autoInc, iLn);
    if( aOp==0 ) break;
    aOp[0].p2 = memId;
    aOp[0].p3 = memId+2;
    aOp[2].p3 = memId;
    aOp[3].p1 = memId-1;
    aOp[3].p3 = memId;
    aOp[3].p5 = 0x10;
    aOp[4].p2 = memId+1;
    aOp[5].p3 = memId;
    aOp[6].p1 = memId;
    aOp[7].p2 = memId+2;
    aOp[7].p1 = memId;
    aOp[10].p2 = memId;
    if( pParse->nTab==0 ) pParse->nTab = 1;
  }
}
# 137218 "c_tests/sqlite3.c"
static void autoIncStep(Parse *pParse, int memId, int regRowid){
  if( memId>0 ){
    sqlite3VdbeAddOp2(pParse->pVdbe, 160, memId, regRowid);
  }
}
# 137231 "c_tests/sqlite3.c"
static __attribute__((noinline)) void autoIncrementEnd(Parse *pParse){
  AutoincInfo *p;
  Vdbe *v = pParse->pVdbe;
  sqlite3 *db = pParse->db;

  ((void) (0));
  for(p = pParse->pAinc; p; p = p->pNext){
    static const int iLn = 0;
    static const VdbeOpList autoIncEnd[] = {
              {52, 0, 2, 0},
              {128, 0, 0, 0},
              {98, 0, 2, 0},
              {129, 0, 0, 0},
              {123, 0, 0, 0}
    };
    VdbeOp *aOp;
    Db *pDb = &db->aDb[p->iDb];
    int iRec;
    int memId = p->regCtr;

    iRec = sqlite3GetTempReg(pParse);
    ((void) (0));
    sqlite3VdbeAddOp3(v, 56, memId+2, sqlite3VdbeCurrentAddr(v)+7, memId);
                   ;
    sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, 114);
    aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(autoIncEnd)/sizeof(autoIncEnd[0]))), autoIncEnd, iLn);
    if( aOp==0 ) break;
    aOp[0].p1 = memId+1;
    aOp[1].p2 = memId+1;
    aOp[2].p1 = memId-1;
    aOp[2].p3 = iRec;
    aOp[3].p2 = iRec;
    aOp[3].p3 = memId+1;
    aOp[3].p5 = 0x08;
    sqlite3ReleaseTempReg(pParse, iRec);
  }
}
static void sqlite3AutoincrementEnd(Parse *pParse){
  if( pParse->pAinc ) autoIncrementEnd(pParse);
}
# 137285 "c_tests/sqlite3.c"
static void sqlite3MultiValuesEnd(Parse *pParse, Select *pVal){
  if( (pVal) && pVal->pSrc->nSrc>0 ){
    SrcItem *pItem = &pVal->pSrc->a[0];
    ((void) (0));
    if( pItem->fg.isSubquery ){
      sqlite3VdbeEndCoroutine(pParse->pVdbe, pItem->u4.pSubq->regReturn);
      sqlite3VdbeJumpHere(pParse->pVdbe, pItem->u4.pSubq->addrFillSub - 1);
    }
  }
}





static int exprListIsConstant(Parse *pParse, ExprList *pRow){
  int ii;
  for(ii=0; ii<pRow->nExpr; ii++){
    if( 0==sqlite3ExprIsConstant(pParse, pRow->a[ii].pExpr) ) return 0;
  }
  return 1;
}





static int exprListIsNoAffinity(Parse *pParse, ExprList *pRow){
  int ii;
  if( exprListIsConstant(pParse,pRow)==0 ) return 0;
  for(ii=0; ii<pRow->nExpr; ii++){
    Expr *pExpr = pRow->a[ii].pExpr;
    ((void) (0));
    ((void) (0));
    if( 0!=sqlite3ExprAffinity(pExpr) ) return 0;
  }
  return 1;

}
# 137376 "c_tests/sqlite3.c"
static Select *sqlite3MultiValues(Parse *pParse, Select *pLeft, ExprList *pRow){

  if( pParse->bHasWith
   || pParse->db->init.busy
   || exprListIsConstant(pParse,pRow)==0
   || (pLeft->pSrc->nSrc==0 &&
       exprListIsNoAffinity(pParse,pLeft->pEList)==0)
   || (pParse->eParseMode!=0)
  ){

    Select *pSelect = 0;
    int f = 0x0000200 | 0x0000400;
    if( pLeft->pSrc->nSrc ){
      sqlite3MultiValuesEnd(pParse, pLeft);
      f = 0x0000200;
    }else if( pLeft->pPrior ){

      f = (f & pLeft->selFlags);
    }
    pSelect = sqlite3SelectNew(pParse, pRow, 0, 0, 0, 0, 0, f, 0);
    pLeft->selFlags &= ~(u32)0x0000400;
    if( pSelect ){
      pSelect->op = 136;
      pSelect->pPrior = pLeft;
      pLeft = pSelect;
    }
  }else{
    SrcItem *p = 0;

    if( pLeft->pSrc->nSrc==0 ){



      Vdbe *v = sqlite3GetVdbe(pParse);
      Select *pRet = sqlite3SelectNew(pParse, 0, 0, 0, 0, 0, 0, 0, 0);



      if( (pParse->db->mDbFlags & 0x0010)==0 ){
        sqlite3ReadSchema(pParse);
      }

      if( pRet ){
        SelectDest dest;
        Subquery *pSubq;
        pRet->pSrc->nSrc = 1;
        pRet->pPrior = pLeft->pPrior;
        pRet->op = pLeft->op;
        if( pRet->pPrior ) pRet->selFlags |= 0x0000200;
        pLeft->pPrior = 0;
        pLeft->op = 139;
        ((void) (0));
        ((void) (0));
        p = &pRet->pSrc->a[0];
        p->fg.viaCoroutine = 1;
        p->iCursor = -1;
        ((void) (0));
        p->u1.nRow = 2;
        if( sqlite3SrcItemAttachSubquery(pParse, p, pLeft, 0) ){
          pSubq = p->u4.pSubq;
          pSubq->addrFillSub = sqlite3VdbeCurrentAddr(v) + 1;
          pSubq->regReturn = ++pParse->nMem;
          sqlite3VdbeAddOp3(v, 11,
                            pSubq->regReturn, 0, pSubq->addrFillSub);
          sqlite3SelectDestInit(&dest, 13, pSubq->regReturn);






          dest.iSdst = pParse->nMem + 3;
          dest.nSdst = pLeft->pEList->nExpr;
          pParse->nMem += 2 + dest.nSdst;

          pLeft->selFlags |= 0x0000400;
          sqlite3Select(pParse, pLeft, &dest);
          pSubq->regResult = dest.iSdst;
          ((void) (0));
        }
        pLeft = pRet;
      }
    }else{
      p = &pLeft->pSrc->a[0];
      ((void) (0));
      p->u1.nRow++;
    }

    if( pParse->nErr==0 ){
      Subquery *pSubq;
      ((void) (0));
      ((void) (0));
      pSubq = p->u4.pSubq;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      if( pSubq->pSelect->pEList->nExpr!=pRow->nExpr ){
        sqlite3SelectWrongNumTermsError(pParse, pSubq->pSelect);
      }else{
        sqlite3ExprCodeExprList(pParse, pRow, pSubq->regResult, 0, 0);
        sqlite3VdbeAddOp1(pParse->pVdbe, 12, pSubq->regReturn);
      }
    }
    sqlite3ExprListDelete(pParse->db, pRow);
  }

  return pLeft;
}


static int xferOptimization(
  Parse *pParse,
  Table *pDest,
  Select *pSelect,
  int onError,
  int iDbDest
);
# 137591 "c_tests/sqlite3.c"
static void sqlite3Insert(
  Parse *pParse,
  SrcList *pTabList,
  Select *pSelect,
  IdList *pColumn,
  int onError,
  Upsert *pUpsert
){
  sqlite3 *db;
  Table *pTab;
  int i, j;
  Vdbe *v;
  Index *pIdx;
  int nColumn;
  int nHidden = 0;
  int iDataCur = 0;
  int iIdxCur = 0;
  int ipkColumn = -1;
  int endOfLoop;
  int srcTab = 0;
  int addrInsTop = 0;
  int addrCont = 0;
  SelectDest dest;
  int iDb;
  u8 useTempTable = 0;
  u8 appendFlag = 0;
  u8 withoutRowid;
  u8 bIdListInOrder;
  ExprList *pList = 0;
  int iRegStore;


  int regFromSelect = 0;
  int regAutoinc = 0;
  int regRowCount = 0;
  int regIns;
  int regRowid;
  int regData;
  int *aRegIdx = 0;
  int *aTabColMap = 0;


  int isView;
  Trigger *pTrigger;
  int tmask;


  db = pParse->db;
  ((void) (0));
  if( pParse->nErr ){
    goto insert_cleanup;
  }
  ((void) (0));
  dest.iSDParm = 0;





  if( pSelect && (pSelect->selFlags & 0x0000200)!=0 && pSelect->pPrior==0 ){
    pList = pSelect->pEList;
    pSelect->pEList = 0;
    sqlite3SelectDelete(db, pSelect);
    pSelect = 0;
  }



  ((void) (0));
  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if( pTab==0 ){
    goto insert_cleanup;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void) (0));
  if( sqlite3AuthCheck(pParse, 18, pTab->zName, 0,
                       db->aDb[iDb].zDbSName) ){
    goto insert_cleanup;
  }
  withoutRowid = !(((pTab)->tabFlags & 0x00000080)==0);





  pTrigger = sqlite3TriggersExist(pParse, pTab, 128, 0, &tmask);
  isView = ((pTab)->eTabType==2);
# 137687 "c_tests/sqlite3.c"
  ((void) (0));
# 137700 "c_tests/sqlite3.c"
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto insert_cleanup;
  }



  if( sqlite3IsReadOnly(pParse, pTab, pTrigger) ){
    goto insert_cleanup;
  }



  v = sqlite3GetVdbe(pParse);
  if( v==0 ) goto insert_cleanup;
  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
  sqlite3BeginWriteOperation(pParse, pSelect || pTrigger, iDb);
# 137727 "c_tests/sqlite3.c"
  if( pColumn==0
   && pSelect!=0
   && pTrigger==0
   && xferOptimization(pParse, pTab, pSelect, onError, iDb)
  ){
    ((void) (0));
    ((void) (0));
    goto insert_end;
  }





  regAutoinc = autoIncBegin(pParse, iDb, pTab);




  regRowid = regIns = pParse->nMem+1;
  pParse->nMem += pTab->nCol + 1;
  if( ((pTab)->eTabType==1) ){
    regRowid++;
    pParse->nMem++;
  }
  regData = regRowid+1;
# 137773 "c_tests/sqlite3.c"
  bIdListInOrder = (pTab->tabFlags & (0x00000400|0x00000040))==0;
  if( pColumn ){
    aTabColMap = sqlite3DbMallocZero(db, pTab->nCol*sizeof(int));
    if( aTabColMap==0 ) goto insert_cleanup;
    for(i=0; i<pColumn->nId; i++){
      j = sqlite3ColumnIndex(pTab, pColumn->a[i].zName);
      if( j>=0 ){
        if( aTabColMap[j]==0 ) aTabColMap[j] = i+1;
        if( i!=j ) bIdListInOrder = 0;
        if( j==pTab->iPKey ){
          ipkColumn = i; ((void) (0));
        }

        if( pTab->aCol[j].colFlags & (0x0040|0x0020) ){
          sqlite3ErrorMsg(pParse,
             "cannot INSERT into generated column \"%s\"",
             pTab->aCol[j].zCnName);
          goto insert_cleanup;
        }

      }else{
        if( sqlite3IsRowid(pColumn->a[i].zName) && !withoutRowid ){
          ipkColumn = i;
          bIdListInOrder = 0;
        }else{
          sqlite3ErrorMsg(pParse, "table %S has no column named %s",
              pTabList->a, pColumn->a[i].zName);
          pParse->checkSchema = 1;
          goto insert_cleanup;
        }
      }
    }
  }






  if( pSelect ){


    int rc;

    if( pSelect->pSrc->nSrc==1
     && pSelect->pSrc->a[0].fg.viaCoroutine
     && pSelect->pPrior==0
    ){
      SrcItem *pItem = &pSelect->pSrc->a[0];
      Subquery *pSubq;
      ((void) (0));
      pSubq = pItem->u4.pSubq;
      dest.iSDParm = pSubq->regReturn;
      regFromSelect = pSubq->regResult;
      ((void) (0));
      ((void) (0));
      nColumn = pSubq->pSelect->pEList->nExpr;
      sqlite3VdbeExplain (pParse, 0, "SCAN %S", pItem);
      if( bIdListInOrder && nColumn==pTab->nCol ){
        regData = regFromSelect;
        regRowid = regData - 1;
        regIns = regRowid - (((pTab)->eTabType==1) ? 1 : 0);
      }
    }else{
      int addrTop;
      int regYield = ++pParse->nMem;
      addrTop = sqlite3VdbeCurrentAddr(v) + 1;
      sqlite3VdbeAddOp3(v, 11, regYield, 0, addrTop);
      sqlite3SelectDestInit(&dest, 13, regYield);
      dest.iSdst = bIdListInOrder ? regData : 0;
      dest.nSdst = pTab->nCol;
      rc = sqlite3Select(pParse, pSelect, &dest);
      regFromSelect = dest.iSdst;
      ((void) (0));
      if( rc || pParse->nErr ) goto insert_cleanup;
      ((void) (0));
      sqlite3VdbeEndCoroutine(v, regYield);
      sqlite3VdbeJumpHere(v, addrTop - 1);
      ((void) (0));
      nColumn = pSelect->pEList->nExpr;
    }
# 137864 "c_tests/sqlite3.c"
    if( pTrigger || readsTable(pParse, iDb, pTab) ){
      useTempTable = 1;
    }

    if( useTempTable ){
# 137879 "c_tests/sqlite3.c"
      int regRec;
      int regTempRowid;
      int addrL;

      srcTab = pParse->nTab++;
      regRec = sqlite3GetTempReg(pParse);
      regTempRowid = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp2(v, 119, srcTab, nColumn);
      addrL = sqlite3VdbeAddOp1(v, 12, dest.iSDParm); ;
      sqlite3VdbeAddOp3(v, 98, regFromSelect, nColumn, regRec);
      sqlite3VdbeAddOp2(v, 128, srcTab, regTempRowid);
      sqlite3VdbeAddOp3(v, 129, srcTab, regRec, regTempRowid);
      sqlite3VdbeGoto(v, addrL);
      sqlite3VdbeJumpHere(v, addrL);
      sqlite3ReleaseTempReg(pParse, regRec);
      sqlite3ReleaseTempReg(pParse, regTempRowid);
    }
  }else{



    NameContext sNC;
    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    srcTab = -1;
    ((void) (0));
    if( pList ){
      nColumn = pList->nExpr;
      if( sqlite3ResolveExprListNames(&sNC, pList) ){
        goto insert_cleanup;
      }
    }else{
      nColumn = 0;
    }
  }





  if( pColumn==0 && nColumn>0 ){
    ipkColumn = pTab->iPKey;

    if( ipkColumn>=0 && (pTab->tabFlags & 0x00000060)!=0 ){
                                                ;
                                               ;
      for(i=ipkColumn-1; i>=0; i--){
        if( pTab->aCol[i].colFlags & 0x0060 ){
                                                              ;
                                                             ;
          ipkColumn--;
        }
      }
    }





    ((void) (0));
    ((void) (0));
    ((void) (0));
    if( (pTab->tabFlags & (0x00000060|0x00000002))!=0 ){
      for(i=0; i<pTab->nCol; i++){
        if( pTab->aCol[i].colFlags & 0x0062 ) nHidden++;
      }
    }
    if( nColumn!=(pTab->nCol-nHidden) ){
      sqlite3ErrorMsg(pParse,
         "table %S has %d columns but %d values were supplied",
         pTabList->a, pTab->nCol-nHidden, nColumn);
     goto insert_cleanup;
    }
  }
  if( pColumn!=0 && nColumn!=pColumn->nId ){
    sqlite3ErrorMsg(pParse, "%d values for %d columns", nColumn, pColumn->nId);
    goto insert_cleanup;
  }



  if( (db->flags & ((u64)(0x00001)<<32))!=0
   && !pParse->nested
   && !pParse->pTriggerTab
   && !pParse->bReturning
  ){
    regRowCount = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 72, 0, regRowCount);
  }


  if( !isView ){
    int nIdx;
    nIdx = sqlite3OpenTableAndIndices(pParse, pTab, 114, 0, -1, 0,
                                      &iDataCur, &iIdxCur);
    aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+2));
    if( aRegIdx==0 ){
      goto insert_cleanup;
    }
    for(i=0, pIdx=pTab->pIndex; i<nIdx; pIdx=pIdx->pNext, i++){
      ((void) (0));
      aRegIdx[i] = ++pParse->nMem;
      pParse->nMem += pIdx->nColumn;
    }
    aRegIdx[i] = ++pParse->nMem;
  }

  if( pUpsert ){
    Upsert *pNx;
    if( ((pTab)->eTabType==1) ){
      sqlite3ErrorMsg(pParse, "UPSERT not implemented for virtual table \"%s\"",
              pTab->zName);
      goto insert_cleanup;
    }
    if( ((pTab)->eTabType==2) ){
      sqlite3ErrorMsg(pParse, "cannot UPSERT a view");
      goto insert_cleanup;
    }
    if( sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget) ){
      goto insert_cleanup;
    }
    pTabList->a[0].iCursor = iDataCur;
    pNx = pUpsert;
    do{
      pNx->pUpsertSrc = pTabList;
      pNx->regData = regData;
      pNx->iDataCur = iDataCur;
      pNx->iIdxCur = iIdxCur;
      if( pNx->pUpsertTarget ){
        if( sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx, pUpsert) ){
          goto insert_cleanup;
        }
      }
      pNx = pNx->pNextUpsert;
    }while( pNx!=0 );
  }




  if( useTempTable ){
# 138029 "c_tests/sqlite3.c"
    addrInsTop = sqlite3VdbeAddOp1(v, 36, srcTab); ;
    addrCont = sqlite3VdbeCurrentAddr(v);
  }else if( pSelect ){
# 138040 "c_tests/sqlite3.c"
                                                                  ;
    addrInsTop = addrCont = sqlite3VdbeAddOp1(v, 12, dest.iSDParm);
                   ;
    if( ipkColumn>=0 ){



      sqlite3VdbeAddOp2(v, 81, regFromSelect+ipkColumn, regRowid);
    }
  }
# 138058 "c_tests/sqlite3.c"
  nHidden = 0;
  iRegStore = regData; ((void) (0));
  for(i=0; i<pTab->nCol; i++, iRegStore++){
    int k;
    u32 colFlags;
    ((void) (0));
    if( i==pTab->iPKey ){




      sqlite3VdbeAddOp1(v, 77, iRegStore);
      continue;
    }
    if( ((colFlags = pTab->aCol[i].colFlags) & 0x0062)!=0 ){
      nHidden++;
      if( (colFlags & 0x0020)!=0 ){



        iRegStore--;
        continue;
      }else if( (colFlags & 0x0040)!=0 ){




        if( tmask & 1 ){
          sqlite3VdbeAddOp1(v, 77, iRegStore);
        }
        continue;
      }else if( pColumn==0 ){


        sqlite3ExprCodeFactorable(pParse,
            sqlite3ColumnExpr(pTab, &pTab->aCol[i]),
            iRegStore);
        continue;
      }
    }
    if( pColumn ){
      j = aTabColMap[i];
      ((void) (0));
      if( j==0 ){


        sqlite3ExprCodeFactorable(pParse,
            sqlite3ColumnExpr(pTab, &pTab->aCol[i]),
            iRegStore);
        continue;
      }
      k = j - 1;
    }else if( nColumn==0 ){

      sqlite3ExprCodeFactorable(pParse,
          sqlite3ColumnExpr(pTab, &pTab->aCol[i]),
          iRegStore);
      continue;
    }else{
      k = i - nHidden;
    }

    if( useTempTable ){
      sqlite3VdbeAddOp3(v, 95, srcTab, k, iRegStore);
    }else if( pSelect ){
      if( regFromSelect!=regData ){
        sqlite3VdbeAddOp2(v, 82, regFromSelect+k, iRegStore);
      }
    }else{
      Expr *pX = pList->a[k].pExpr;
      int y = sqlite3ExprCodeTarget(pParse, pX, iRegStore);
      if( y!=iRegStore ){
        sqlite3VdbeAddOp2(v,
          (((pX)->flags&(u32)(0x400000))!=0) ? 81 : 82, y, iRegStore);
      }
    }
  }




  endOfLoop = sqlite3VdbeMakeLabel(pParse);
  if( tmask & 1 ){
    int regCols = sqlite3GetTempRange(pParse, pTab->nCol+1);







    if( ipkColumn<0 ){
      sqlite3VdbeAddOp2(v, 72, -1, regCols);
    }else{
      int addr1;
      ((void) (0));
      if( useTempTable ){
        sqlite3VdbeAddOp3(v, 95, srcTab, ipkColumn, regCols);
      }else{
        ((void) (0));
        sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regCols);
      }
      addr1 = sqlite3VdbeAddOp1(v, 52, regCols); ;
      sqlite3VdbeAddOp2(v, 72, -1, regCols);
      sqlite3VdbeJumpHere(v, addr1);
      sqlite3VdbeAddOp1(v, 13, regCols); ;
    }


    ((void) (0));
    sqlite3VdbeAddOp3(v, 81, regRowid+1, regCols+1, pTab->nNVCol-1);






    if( pTab->tabFlags & 0x00000060 ){
                                                ;
                                               ;
      sqlite3ComputeGeneratedColumns(pParse, regCols+1, pTab);
    }







    if( !isView ){
      sqlite3TableAffinity(v, pTab, regCols+1);
    }


    sqlite3CodeRowTrigger(pParse, pTrigger, 128, 0, 1,
        pTab, regCols-pTab->nCol-1, onError, endOfLoop);

    sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol+1);
  }

  if( !isView ){
    if( ((pTab)->eTabType==1) ){

      sqlite3VdbeAddOp2(v, 76, 0, regIns);
    }
    if( ipkColumn>=0 ){

      if( useTempTable ){
        sqlite3VdbeAddOp3(v, 95, srcTab, ipkColumn, regRowid);
      }else if( pSelect ){

      }else{
        Expr *pIpk = pList->a[ipkColumn].pExpr;
        if( pIpk->op==122 && !((pTab)->eTabType==1) ){
          sqlite3VdbeAddOp3(v, 128, iDataCur, regRowid, regAutoinc);
          appendFlag = 1;
        }else{
          sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);
        }
      }



      if( !appendFlag ){
        int addr1;
        if( !((pTab)->eTabType==1) ){
          addr1 = sqlite3VdbeAddOp1(v, 52, regRowid); ;
          sqlite3VdbeAddOp3(v, 128, iDataCur, regRowid, regAutoinc);
          sqlite3VdbeJumpHere(v, addr1);
        }else{
          addr1 = sqlite3VdbeCurrentAddr(v);
          sqlite3VdbeAddOp2(v, 51, regRowid, addr1+2); ;
        }
        sqlite3VdbeAddOp1(v, 13, regRowid); ;
      }
    }else if( ((pTab)->eTabType==1) || withoutRowid ){
      sqlite3VdbeAddOp2(v, 76, 0, regRowid);
    }else{
      sqlite3VdbeAddOp3(v, 128, iDataCur, regRowid, regAutoinc);
      appendFlag = 1;
    }
    autoIncStep(pParse, regAutoinc, regRowid);






    if( pTab->tabFlags & 0x00000060 ){
      sqlite3ComputeGeneratedColumns(pParse, regRowid+1, pTab);
    }






    if( ((pTab)->eTabType==1) ){
      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
      sqlite3VtabMakeWritable(pParse, pTab);
      sqlite3VdbeAddOp4(v, 7, 1, pTab->nCol+2, regIns, pVTab, (-11));
      sqlite3VdbeChangeP5(v, onError==11 ? 2 : onError);
      sqlite3MayAbort(pParse);
    }else

    {
      int isReplace = 0;
      int bUseSeek;
      sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,
          regIns, 0, ipkColumn>=0, onError, endOfLoop, &isReplace, 0, pUpsert
      );
      if( db->flags & 0x00004000 ){
        sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);
      }
# 138281 "c_tests/sqlite3.c"
      bUseSeek = (isReplace==0 || !sqlite3VdbeHasSubProgram(v));
      sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur,
          regIns, aRegIdx, 0, appendFlag, bUseSeek
      );
    }







  }



  if( regRowCount ){
    sqlite3VdbeAddOp2(v, 87, regRowCount, 1);
  }

  if( pTrigger ){

    sqlite3CodeRowTrigger(pParse, pTrigger, 128, 0, 2,
        pTab, regData-2-pTab->nCol, onError, endOfLoop);
  }




  sqlite3VdbeResolveLabel(v, endOfLoop);
  if( useTempTable ){
    sqlite3VdbeAddOp2(v, 40, srcTab, addrCont); ;
    sqlite3VdbeJumpHere(v, addrInsTop);
    sqlite3VdbeAddOp1(v, 123, srcTab);
  }else if( pSelect ){
    sqlite3VdbeGoto(v, addrCont);
# 138326 "c_tests/sqlite3.c"
    sqlite3VdbeJumpHere(v, addrInsTop);
  }


insert_end:





  if( pParse->nested==0 && pParse->pTriggerTab==0 ){
    sqlite3AutoincrementEnd(pParse);
  }






  if( regRowCount ){
    sqlite3CodeChangeCount(v, regRowCount, "rows inserted");
  }

insert_cleanup:
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprListDelete(db, pList);
  sqlite3UpsertDelete(db, pUpsert);
  sqlite3SelectDelete(db, pSelect);
  if( pColumn ){
    sqlite3IdListDelete(db, pColumn);
    sqlite3DbFree(db, aTabColMap);
  }
  if( aRegIdx ) sqlite3DbNNFreeNN(db, aRegIdx);
}
# 138386 "c_tests/sqlite3.c"
static int checkConstraintExprNode(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==168 ){
    ((void) (0));
    if( pExpr->iColumn>=0 ){
      if( pWalker->u.aiCol[pExpr->iColumn]>=0 ){
        pWalker->eCode |= 0x01;
      }
    }else{
      pWalker->eCode |= 0x02;
    }
  }
  return 0;
}
# 138415 "c_tests/sqlite3.c"
static int sqlite3ExprReferencesUpdatedColumn(
  Expr *pExpr,
  int *aiChng,
  int chngRowid
){
  Walker w;
  memset(&w, 0, sizeof(w));
  w.eCode = 0;
  w.xExprCallback = checkConstraintExprNode;
  w.u.aiCol = aiChng;
  sqlite3WalkExpr(&w, pExpr);
  if( !chngRowid ){
                                              ;
    w.eCode &= ~0x02;
  }
                        ;
                                       ;
                                      ;
                                                         ;
  return w.eCode!=0;
}
# 138448 "c_tests/sqlite3.c"
typedef struct IndexListTerm IndexListTerm;
typedef struct IndexIterator IndexIterator;
struct IndexIterator {
  int eType;
  int i;
  union {
    struct {
      Index *pIdx;
    } lx;
    struct {
      int nIdx;
      IndexListTerm *aIdx;
    } ax;
  } u;
};




struct IndexListTerm {
  Index *p;
  int ix;
};


static Index *indexIteratorFirst(IndexIterator *pIter, int *pIx){
  ((void) (0));
  if( pIter->eType ){
    *pIx = pIter->u.ax.aIdx[0].ix;
    return pIter->u.ax.aIdx[0].p;
  }else{
    *pIx = 0;
    return pIter->u.lx.pIdx;
  }
}


static Index *indexIteratorNext(IndexIterator *pIter, int *pIx){
  if( pIter->eType ){
    int i = ++pIter->i;
    if( i>=pIter->u.ax.nIdx ){
      *pIx = i;
      return 0;
    }
    *pIx = pIter->u.ax.aIdx[i].ix;
    return pIter->u.ax.aIdx[i].p;
  }else{
    ++(*pIx);
    pIter->u.lx.pIdx = pIter->u.lx.pIdx->pNext;
    return pIter->u.lx.pIdx;
  }
}
# 138592 "c_tests/sqlite3.c"
static void sqlite3GenerateConstraintChecks(
  Parse *pParse,
  Table *pTab,
  int *aRegIdx,
  int iDataCur,
  int iIdxCur,
  int regNewData,
  int regOldData,
  u8 pkChng,
  u8 overrideError,
  int ignoreDest,
  int *pbMayReplace,
  int *aiChng,
  Upsert *pUpsert
){
  Vdbe *v;
  Index *pIdx;
  Index *pPk = 0;
  sqlite3 *db;
  int i;
  int ix;
  int nCol;
  int onError;
  int seenReplace = 0;
  int nPkField;
  Upsert *pUpsertClause = 0;
  u8 isUpdate;
  u8 bAffinityDone = 0;
  int upsertIpkReturn = 0;
  int upsertIpkDelay = 0;
  int ipkTop = 0;
  int ipkBottom = 0;


  int regTrigCnt;
  int addrRecheck = 0;
  int lblRecheckOk = 0;
  Trigger *pTrigger;
  int nReplaceTrig = 0;
  IndexIterator sIdxIter;

  isUpdate = regOldData!=0;
  db = pParse->db;
  v = pParse->pVdbe;
  ((void) (0));
  ((void) (0));
  nCol = pTab->nCol;





  if( (((pTab)->tabFlags & 0x00000080)==0) ){
    pPk = 0;
    nPkField = 1;
  }else{
    pPk = sqlite3PrimaryKeyIndex(pTab);
    nPkField = pPk->nKeyCol;
  }



                                                                        ;



  if( pTab->tabFlags & 0x00000800 ){
    int b2ndPass = 0;
    int nSeenReplace = 0;
    int nGenerated = 0;
    while(1){
      for(i=0; i<nCol; i++){
        int iReg;
        Column *pCol = &pTab->aCol[i];
        int isGenerated;
        onError = pCol->notNull;
        if( onError==0 ) continue;
        if( i==pTab->iPKey ){
          continue;
        }
        isGenerated = pCol->colFlags & 0x0060;
        if( isGenerated && !b2ndPass ){
          nGenerated++;
          continue;
        }
        if( aiChng && aiChng[i]<0 && !isGenerated ){

          continue;
        }
        if( overrideError!=11 ){
          onError = overrideError;
        }else if( onError==11 ){
          onError = 2;
        }
        if( onError==5 ){
          if( b2ndPass
           || pCol->iDflt==0
          ){
                                                        ;
                                                       ;
                                                          ;
            onError = 2;
          }else{
            ((void) (0));
          }
        }else if( b2ndPass && !isGenerated ){
          continue;
        }
        ((void) (0));

                                                           ;
        iReg = sqlite3TableColumnToStorage(pTab, i) + regNewData + 1;
        switch( onError ){
          case 5: {
            int addr1 = sqlite3VdbeAddOp1(v, 52, iReg);
                           ;
            ((void) (0));
            nSeenReplace++;
            sqlite3ExprCodeCopy(pParse,
               sqlite3ColumnExpr(pTab, pCol), iReg);
            sqlite3VdbeJumpHere(v, addr1);
            break;
          }
          case 2:
            sqlite3MayAbort(pParse);
                           __attribute__((fallthrough));
          case 1:
          case 3: {
            char *zMsg = sqlite3MPrintf(db, "%s.%s", pTab->zName,
                                        pCol->zCnName);
                                                      ;
            sqlite3VdbeAddOp3(v, 70, (19 | (5<<8)),
                              onError, iReg);
            sqlite3VdbeAppendP4(v, zMsg, (-6));
            sqlite3VdbeChangeP5(v, 1);
                           ;
            break;
          }
          default: {
            ((void) (0));
            sqlite3VdbeAddOp2(v, 51, iReg, ignoreDest);
                           ;
            break;
          }
        }
      }
      if( nGenerated==0 && nSeenReplace==0 ){



        break;
      }
      if( b2ndPass ) break;
      b2ndPass = 1;

      if( nSeenReplace>0 && (pTab->tabFlags & 0x00000060)!=0 ){




        sqlite3ComputeGeneratedColumns(pParse, regNewData+1, pTab);
      }

    }
  }




  if( pTab->pCheck && (db->flags & 0x00000200)==0 ){
    ExprList *pCheck = pTab->pCheck;
    pParse->iSelfTab = -(regNewData+1);
    onError = overrideError!=11 ? overrideError : 2;
    for(i=0; i<pCheck->nExpr; i++){
      int allOk;
      Expr *pCopy;
      Expr *pExpr = pCheck->a[i].pExpr;
      if( aiChng
       && !sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, pkChng)
      ){


        continue;
      }
      if( bAffinityDone==0 ){
        sqlite3TableAffinity(v, pTab, regNewData+1);
        bAffinityDone = 1;
      }
      allOk = sqlite3VdbeMakeLabel(pParse);
                                            ;
      pCopy = sqlite3ExprDup(db, pExpr, 0);
      if( !db->mallocFailed ){
        sqlite3ExprIfTrue(pParse, pCopy, allOk, 0x10);
      }
      sqlite3ExprDelete(db, pCopy);
      if( onError==4 ){
        sqlite3VdbeGoto(v, ignoreDest);
      }else{
        char *zName = pCheck->a[i].zEName;
        ((void) (0));
        if( onError==5 ) onError = 2;
        sqlite3HaltConstraint(pParse, (19 | (1<<8)),
                              onError, zName, 0,
                              3);
      }
      sqlite3VdbeResolveLabel(v, allOk);
    }
    pParse->iSelfTab = 0;
  }
# 138831 "c_tests/sqlite3.c"
  sIdxIter.eType = 0;
  sIdxIter.i = 0;
  sIdxIter.u.ax.aIdx = 0;
  sIdxIter.u.lx.pIdx = pTab->pIndex;
  if( pUpsert ){
    if( pUpsert->pUpsertTarget==0 ){

      ((void) (0));
      if( pUpsert->isDoUpdate==0 ){


        overrideError = 4;
        pUpsert = 0;
      }else{

        overrideError = 6;
      }
    }else if( pTab->pIndex!=0 ){



      int nIdx, jj;
      u64 nByte;
      Upsert *pTerm;
      u8 *bUsed;
      for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){
         ((void) (0));
      }
      sIdxIter.eType = 1;
      sIdxIter.u.ax.nIdx = nIdx;
      nByte = (sizeof(IndexListTerm)+1)*nIdx + nIdx;
      sIdxIter.u.ax.aIdx = sqlite3DbMallocZero(db, nByte);
      if( sIdxIter.u.ax.aIdx==0 ) return;
      bUsed = (u8*)&sIdxIter.u.ax.aIdx[nIdx];
      pUpsert->pToFree = sIdxIter.u.ax.aIdx;
      for(i=0, pTerm=pUpsert; pTerm; pTerm=pTerm->pNextUpsert){
        if( pTerm->pUpsertTarget==0 ) break;
        if( pTerm->pUpsertIdx==0 ) continue;
        jj = 0;
        pIdx = pTab->pIndex;
        while( (pIdx!=0) && pIdx!=pTerm->pUpsertIdx ){
           pIdx = pIdx->pNext;
           jj++;
        }
        if( bUsed[jj] ) continue;
        bUsed[jj] = 1;
        sIdxIter.u.ax.aIdx[i].p = pIdx;
        sIdxIter.u.ax.aIdx[i].ix = jj;
        i++;
      }
      for(jj=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, jj++){
        if( bUsed[jj] ) continue;
        sIdxIter.u.ax.aIdx[i].p = pIdx;
        sIdxIter.u.ax.aIdx[i].ix = jj;
        i++;
      }
      ((void) (0));
    }
  }
# 138911 "c_tests/sqlite3.c"
  if( (db->flags & (0x00002000|0x00004000))==0 ){


    pTrigger = 0;
    regTrigCnt = 0;
  }else{
    if( db->flags&0x00002000 ){
      pTrigger = sqlite3TriggersExist(pParse, pTab, 129, 0, 0);
      regTrigCnt = pTrigger!=0 || sqlite3FkRequired(pParse, pTab, 0, 0);
    }else{
      pTrigger = 0;
      regTrigCnt = sqlite3FkRequired(pParse, pTab, 0, 0);
    }
    if( regTrigCnt ){


      regTrigCnt = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, 72, 0, regTrigCnt);
                                       ;
      lblRecheckOk = sqlite3VdbeMakeLabel(pParse);
      addrRecheck = lblRecheckOk;
    }
  }




  if( pkChng && pPk==0 ){
    int addrRowidOk = sqlite3VdbeMakeLabel(pParse);


    onError = pTab->keyConf;
    if( overrideError!=11 ){
      onError = overrideError;
    }else if( onError==11 ){
      onError = 2;
    }


    if( pUpsert ){
      pUpsertClause = sqlite3UpsertOfIndex(pUpsert,0);
      if( pUpsertClause!=0 ){
        if( pUpsertClause->isDoUpdate==0 ){
          onError = 4;
        }else{
          onError = 6;
        }
      }
      if( pUpsertClause!=pUpsert ){



        upsertIpkDelay = sqlite3VdbeAddOp0(v, 9);
      }
    }






    if( onError==5
     && onError!=overrideError
     && pTab->pIndex
     && !upsertIpkDelay
    ){
      ipkTop = sqlite3VdbeAddOp0(v, 9)+1;
                                                      ;
    }

    if( isUpdate ){



      sqlite3VdbeAddOp3(v, 54, regNewData, addrRowidOk, regOldData);
      sqlite3VdbeChangeP5(v, 0x90);
                     ;
    }



                                                      ;
                                          ;
    sqlite3VdbeAddOp3(v, 31, iDataCur, addrRowidOk, regNewData);
                   ;

    switch( onError ){
      default: {
        onError = 2;
                       __attribute__((fallthrough));
      }
      case 1:
      case 2:
      case 3: {
                                        ;
                                     ;
                                    ;
        sqlite3RowidConstraint(pParse, onError, pTab);
        break;
      }
      case 5: {
# 139034 "c_tests/sqlite3.c"
        if( regTrigCnt ){
          sqlite3MultiWrite(pParse);
          sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
                                   regNewData, 1, 0, 5, 1, -1);
          sqlite3VdbeAddOp2(v, 87, regTrigCnt, 1);
          nReplaceTrig++;
        }else{
# 139050 "c_tests/sqlite3.c"
          if( pTab->pIndex ){
            sqlite3MultiWrite(pParse);
            sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur,0,-1);
          }
        }
        seenReplace = 1;
        break;
      }

      case 6: {
        sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, 0, iDataCur);
                       __attribute__((fallthrough));
      }

      case 4: {
                                      ;
        sqlite3VdbeGoto(v, ignoreDest);
        break;
      }
    }
    sqlite3VdbeResolveLabel(v, addrRowidOk);
    if( pUpsert && pUpsertClause!=pUpsert ){
      upsertIpkReturn = sqlite3VdbeAddOp0(v, 9);
    }else if( ipkTop ){
      ipkBottom = sqlite3VdbeAddOp0(v, 9);
      sqlite3VdbeJumpHere(v, ipkTop-1);
    }
  }
# 139086 "c_tests/sqlite3.c"
  for(pIdx = indexIteratorFirst(&sIdxIter, &ix);
      pIdx;
      pIdx = indexIteratorNext(&sIdxIter, &ix)
  ){
    int regIdx;
    int regR;
    int iThisCur;
    int addrUniqueOk;
    int addrConflictCk;

    if( aRegIdx[ix]==0 ) continue;
    if( pUpsert ){
      pUpsertClause = sqlite3UpsertOfIndex(pUpsert, pIdx);
      if( upsertIpkDelay && pUpsertClause==pUpsert ){
        sqlite3VdbeJumpHere(v, upsertIpkDelay);
      }
    }
    addrUniqueOk = sqlite3VdbeMakeLabel(pParse);
    if( bAffinityDone==0 ){
      sqlite3TableAffinity(v, pTab, regNewData+1);
      bAffinityDone = 1;
    }
                                                      ;
    iThisCur = iIdxCur+ix;



    if( pIdx->pPartIdxWhere ){
      sqlite3VdbeAddOp2(v, 76, 0, aRegIdx[ix]);
      pParse->iSelfTab = -(regNewData+1);
      sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, addrUniqueOk,
                            0x10);
      pParse->iSelfTab = 0;
    }




    regIdx = aRegIdx[ix]+1;
    for(i=0; i<pIdx->nColumn; i++){
      int iField = pIdx->aiColumn[i];
      int x;
      if( iField==(-2) ){
        pParse->iSelfTab = -(regNewData+1);
        sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[i].pExpr, regIdx+i);
        pParse->iSelfTab = 0;
                                                        ;
      }else if( iField==(-1) || iField==pTab->iPKey ){
        x = regNewData;
        sqlite3VdbeAddOp2(v, 83, x, regIdx+i);
                                 ;
      }else{
                                                                     ;
        x = sqlite3TableColumnToStorage(pTab, iField) + regNewData + 1;
        sqlite3VdbeAddOp2(v, 82, x, regIdx+i);
                                                          ;
      }
    }
    sqlite3VdbeAddOp3(v, 98, regIdx, pIdx->nColumn, aRegIdx[ix]);
                                           ;





                                                                    ;





    if( isUpdate && pPk==pIdx && pkChng==0 ){
      sqlite3VdbeResolveLabel(v, addrUniqueOk);
      continue;
    }


    onError = pIdx->onError;
    if( onError==0 ){
      sqlite3VdbeResolveLabel(v, addrUniqueOk);
      continue;
    }
    if( overrideError!=11 ){
      onError = overrideError;
    }else if( onError==11 ){
      onError = 2;
    }


    if( pUpsertClause ){
      if( pUpsertClause->isDoUpdate==0 ){
        onError = 4;
      }else{
        onError = 6;
      }
    }
# 139193 "c_tests/sqlite3.c"
    ((void) (0));

    if( (ix==0 && pIdx->pNext==0)
     && pPk==pIdx
     && onError==5
     && ( 0==(db->flags&0x00002000) ||
          0==sqlite3TriggersExist(pParse, pTab, 129, 0, 0))
     && ( 0==(db->flags&0x00004000) ||
         (0==pTab->u.tab.pFKey && 0==sqlite3FkReferences(pTab)))
    ){
      sqlite3VdbeResolveLabel(v, addrUniqueOk);
      continue;
    }



                                          ;
    addrConflictCk =
      sqlite3VdbeAddOp4Int(v, 27, iThisCur, addrUniqueOk,
                           regIdx, pIdx->nKeyCol); ;


    regR = pIdx==pPk ? regIdx : sqlite3GetTempRange(pParse, nPkField);
    if( isUpdate || onError==5 ){
      if( (((pTab)->tabFlags & 0x00000080)==0) ){
        sqlite3VdbeAddOp2(v, 143, iThisCur, regR);


        if( isUpdate ){
          sqlite3VdbeAddOp3(v, 54, regR, addrUniqueOk, regOldData);
          sqlite3VdbeChangeP5(v, 0x90);
                         ;
        }
      }else{
        int x;


        if( pIdx!=pPk ){
          for(i=0; i<pPk->nKeyCol; i++){
            ((void) (0));
            x = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);
            sqlite3VdbeAddOp3(v, 95, iThisCur, x, regR+i);

                                                               ;
          }
        }
        if( isUpdate ){







          int addrJump = sqlite3VdbeCurrentAddr(v)+pPk->nKeyCol;
          int op = 53;
          int regCmp = (((pIdx)->idxType==2) ? regIdx : regR);

          for(i=0; i<pPk->nKeyCol; i++){
            char *p4 = (char*)sqlite3LocateCollSeq(pParse, pPk->azColl[i]);
            x = pPk->aiColumn[i];
            ((void) (0));
            if( i==(pPk->nKeyCol-1) ){
              addrJump = addrUniqueOk;
              op = 54;
            }
            x = sqlite3TableColumnToStorage(pTab, x);
            sqlite3VdbeAddOp4(v, op,
                regOldData+1+x, addrJump, regCmp+i, p4, (-2)
            );
            sqlite3VdbeChangeP5(v, 0x90);
                                        ;
                                        ;
          }
        }
      }
    }


    ((void) (0));

    switch( onError ){
      case 1:
      case 2:
      case 3: {
                                        ;
                                     ;
                                    ;
        sqlite3UniqueConstraint(pParse, onError, pIdx);
        break;
      }

      case 6: {
        sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, iIdxCur+ix);
                       __attribute__((fallthrough));
      }

      case 4: {
                                      ;
        sqlite3VdbeGoto(v, ignoreDest);
        break;
      }
      default: {
        int nConflictCk;

        ((void) (0));
        nConflictCk = sqlite3VdbeCurrentAddr(v) - addrConflictCk;
        ((void) (0));
                                  ;
                                 ;
        if( regTrigCnt ){
          sqlite3MultiWrite(pParse);
          nReplaceTrig++;
        }
        if( pTrigger && isUpdate ){
          sqlite3VdbeAddOp1(v, 168, iDataCur);
        }
        sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
            regR, nPkField, 0, 5,
            (pIdx==pPk ? 1 : 0), iThisCur);
        if( pTrigger && isUpdate ){
          sqlite3VdbeAddOp1(v, 169, iDataCur);
        }
        if( regTrigCnt ){
          int addrBypass;

          sqlite3VdbeAddOp2(v, 87, regTrigCnt, 1);
          addrBypass = sqlite3VdbeAddOp0(v, 9);
                                            ;




          sqlite3VdbeResolveLabel(v, lblRecheckOk);
          lblRecheckOk = sqlite3VdbeMakeLabel(pParse);
          if( pIdx->pPartIdxWhere ){


            sqlite3VdbeAddOp2(v, 51, regIdx-1, lblRecheckOk);
                           ;
          }



          while( nConflictCk>0 ){
            VdbeOp x;



            x = *sqlite3VdbeGetOp(v, addrConflictCk);
            if( x.opcode!=143 ){
              int p2;
              const char *zP4;
              if( sqlite3OpcodeProperty[x.opcode]&0x01 ){
                p2 = lblRecheckOk;
              }else{
                p2 = x.p2;
              }
              zP4 = x.p4type==(-3) ? ((void*)(long int)(x.p4.i)) : x.p4.z;
              sqlite3VdbeAddOp4(v, x.opcode, x.p1, p2, x.p3, zP4, x.p4type);
              sqlite3VdbeChangeP5(v, x.p5);
                                         ;
            }
            nConflictCk--;
            addrConflictCk++;
          }

          sqlite3UniqueConstraint(pParse, 2, pIdx);

          sqlite3VdbeJumpHere(v, addrBypass);
        }
        seenReplace = 1;
        break;
      }
    }
    sqlite3VdbeResolveLabel(v, addrUniqueOk);
    if( regR!=regIdx ) sqlite3ReleaseTempRange(pParse, regR, nPkField);
    if( pUpsertClause
     && upsertIpkReturn
     && sqlite3UpsertNextIsIPK(pUpsertClause)
    ){
      sqlite3VdbeGoto(v, upsertIpkDelay+1);
      sqlite3VdbeJumpHere(v, upsertIpkReturn);
      upsertIpkReturn = 0;
    }
  }


  if( ipkTop ){
    sqlite3VdbeGoto(v, ipkTop);
                                      ;
    ((void) (0));
    sqlite3VdbeJumpHere(v, ipkBottom);
  }


                                              ;
  ((void) (0));
  if( nReplaceTrig ){
    sqlite3VdbeAddOp2(v, 17, regTrigCnt, lblRecheckOk);;
    if( !pPk ){
      if( isUpdate ){
        sqlite3VdbeAddOp3(v, 54, regNewData, addrRecheck, regOldData);
        sqlite3VdbeChangeP5(v, 0x90);
                       ;
      }
      sqlite3VdbeAddOp3(v, 31, iDataCur, addrRecheck, regNewData);
                     ;
      sqlite3RowidConstraint(pParse, 2, pTab);
    }else{
      sqlite3VdbeGoto(v, addrRecheck);
    }
    sqlite3VdbeResolveLabel(v, lblRecheckOk);
  }


  if( (((pTab)->tabFlags & 0x00000080)==0) ){
    int regRec = aRegIdx[ix];
    sqlite3VdbeAddOp3(v, 98, regNewData+1, pTab->nNVCol, regRec);
                                   ;
    if( !bAffinityDone ){
      sqlite3TableAffinity(v, pTab, 0);
    }
  }

  *pbMayReplace = seenReplace;
                                                            ;
}
# 139479 "c_tests/sqlite3.c"
static void sqlite3CompleteInsertion(
  Parse *pParse,
  Table *pTab,
  int iDataCur,
  int iIdxCur,
  int regNewData,
  int *aRegIdx,
  int update_flags,
  int appendBias,
  int useSeekResult
){
  Vdbe *v;
  Index *pIdx;
  u8 pik_flags;
  int i;

  ((void) (0));




  v = pParse->pVdbe;
  ((void) (0));
  ((void) (0));
  for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){

    ((void) (0));


    if( aRegIdx[i]==0 ) continue;
    if( pIdx->pPartIdxWhere ){
      sqlite3VdbeAddOp2(v, 51, aRegIdx[i], sqlite3VdbeCurrentAddr(v)+2);
                     ;
    }
    pik_flags = (useSeekResult ? 0x10 : 0);
    if( ((pIdx)->idxType==2) && !(((pTab)->tabFlags & 0x00000080)==0) ){
      pik_flags |= 0x01;
      pik_flags |= (update_flags & 0x02);
      if( update_flags==0 ){
                                                                      ;
      }
    }
    sqlite3VdbeAddOp4Int(v, 139, iIdxCur+i, aRegIdx[i],
                         aRegIdx[i]+1,
                         pIdx->uniqNotNull ? pIdx->nKeyCol: pIdx->nColumn);
    sqlite3VdbeChangeP5(v, pik_flags);
  }
  if( !(((pTab)->tabFlags & 0x00000080)==0) ) return;
  if( pParse->nested ){
    pik_flags = 0;
  }else{
    pik_flags = 0x01;
    pik_flags |= (update_flags?update_flags:0x20);
  }
  if( appendBias ){
    pik_flags |= 0x08;
  }
  if( useSeekResult ){
    pik_flags |= 0x10;
  }
  sqlite3VdbeAddOp3(v, 129, iDataCur, aRegIdx[i], regNewData);
  if( !pParse->nested ){
    sqlite3VdbeAppendP4(v, pTab, (-5));
  }
  sqlite3VdbeChangeP5(v, pik_flags);
}
# 139567 "c_tests/sqlite3.c"
static int sqlite3OpenTableAndIndices(
  Parse *pParse,
  Table *pTab,
  int op,
  u8 p5,
  int iBase,
  u8 *aToOpen,
  int *piDataCur,
  int *piIdxCur
){
  int i;
  int iDb;
  int iDataCur;
  Index *pIdx;
  Vdbe *v;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( ((pTab)->eTabType==1) ){



    *piDataCur = *piIdxCur = -999;
    return 0;
  }
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  v = pParse->pVdbe;
  ((void) (0));
  if( iBase<0 ) iBase = pParse->nTab;
  iDataCur = iBase++;
  *piDataCur = iDataCur;
  if( (((pTab)->tabFlags & 0x00000080)==0) && (aToOpen==0 || aToOpen[0]) ){
    sqlite3OpenTable(pParse, iDataCur, iDb, pTab, op);
  }else if( pParse->db->noSharedCache==0 ){
    sqlite3TableLock(pParse, iDb, pTab->tnum, op==114, pTab->zName);
  }
  *piIdxCur = iBase;
  for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){
    int iIdxCur = iBase++;
    ((void) (0));
    if( ((pIdx)->idxType==2) && !(((pTab)->tabFlags & 0x00000080)==0) ){
      *piDataCur = iIdxCur;
      p5 = 0;
    }
    if( aToOpen==0 || aToOpen[i+1] ){
      sqlite3VdbeAddOp3(v, op, iIdxCur, pIdx->tnum, iDb);
      sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
      sqlite3VdbeChangeP5(v, p5);
                                         ;
    }
  }
  if( iBase>pParse->nTab ) pParse->nTab = iBase;
  return i;
}
# 139648 "c_tests/sqlite3.c"
static int xferCompatibleIndex(Index *pDest, Index *pSrc){
  int i;
  ((void) (0));
  ((void) (0));
  if( pDest->nKeyCol!=pSrc->nKeyCol || pDest->nColumn!=pSrc->nColumn ){
    return 0;
  }
  if( pDest->onError!=pSrc->onError ){
    return 0;
  }
  for(i=0; i<pSrc->nKeyCol; i++){
    if( pSrc->aiColumn[i]!=pDest->aiColumn[i] ){
      return 0;
    }
    if( pSrc->aiColumn[i]==(-2) ){
      ((void) (0));
      if( sqlite3ExprCompare(0, pSrc->aColExpr->a[i].pExpr,
                             pDest->aColExpr->a[i].pExpr, -1)!=0 ){
        return 0;
      }
    }
    if( pSrc->aSortOrder[i]!=pDest->aSortOrder[i] ){
      return 0;
    }
    if( sqlite3_stricmp(pSrc->azColl[i],pDest->azColl[i])!=0 ){
      return 0;
    }
  }
  if( sqlite3ExprCompare(0, pSrc->pPartIdxWhere, pDest->pPartIdxWhere, -1) ){
    return 0;
  }


  return 1;
}
# 139709 "c_tests/sqlite3.c"
static int xferOptimization(
  Parse *pParse,
  Table *pDest,
  Select *pSelect,
  int onError,
  int iDbDest
){
  sqlite3 *db = pParse->db;
  ExprList *pEList;
  Table *pSrc;
  Index *pSrcIdx, *pDestIdx;
  SrcItem *pItem;
  int i;
  int iDbSrc;
  int iSrc, iDest;
  int addr1, addr2;
  int emptyDestTest = 0;
  int emptySrcTest = 0;
  Vdbe *v;
  int regAutoinc;
  int destHasUniqueIdx = 0;
  int regData, regRowid;

  ((void) (0));
  if( pParse->pWith || pSelect->pWith ){



    return 0;
  }

  if( ((pDest)->eTabType==1) ){
    return 0;
  }

  if( onError==11 ){
    if( pDest->iPKey>=0 ) onError = pDest->keyConf;
    if( onError==11 ) onError = 2;
  }
  ((void) (0));
  if( pSelect->pSrc->nSrc!=1 ){
    return 0;
  }
  if( pSelect->pSrc->a[0].fg.isSubquery ){
    return 0;
  }
  if( pSelect->pWhere ){
    return 0;
  }
  if( pSelect->pOrderBy ){
    return 0;
  }


  if( pSelect->pGroupBy ){
    return 0;
  }
  if( pSelect->pLimit ){
    return 0;
  }
  if( pSelect->pPrior ){
    return 0;
  }
  if( pSelect->selFlags & 0x0000001 ){
    return 0;
  }
  pEList = pSelect->pEList;
  ((void) (0));
  if( pEList->nExpr!=1 ){
    return 0;
  }
  ((void) (0));
  if( pEList->a[0].pExpr->op!=180 ){
    return 0;
  }





  pItem = pSelect->pSrc->a;
  pSrc = sqlite3LocateTableItem(pParse, 0, pItem);
  if( pSrc==0 ){
    return 0;
  }
  if( pSrc->tnum==pDest->tnum && pSrc->pSchema==pDest->pSchema ){
                           ;
    return 0;
  }
  if( (((pDest)->tabFlags & 0x00000080)==0)!=(((pSrc)->tabFlags & 0x00000080)==0) ){
    return 0;
  }
  if( !((pSrc)->eTabType==0) ){
    return 0;
  }
  if( pDest->nCol!=pSrc->nCol ){
    return 0;
  }
  if( pDest->iPKey!=pSrc->iPKey ){
    return 0;
  }
  if( (pDest->tabFlags & 0x00010000)!=0 && (pSrc->tabFlags & 0x00010000)==0 ){
    return 0;
  }
  for(i=0; i<pDest->nCol; i++){
    Column *pDestCol = &pDest->aCol[i];
    Column *pSrcCol = &pSrc->aCol[i];
# 139840 "c_tests/sqlite3.c"
    if( (pDestCol->colFlags & 0x0060) !=
        (pSrcCol->colFlags & 0x0060) ){
      return 0;
    }




    if( (pDestCol->colFlags & 0x0060)!=0 ){
      if( sqlite3ExprCompare(0,
             sqlite3ColumnExpr(pSrc, pSrcCol),
             sqlite3ColumnExpr(pDest, pDestCol), -1)!=0 ){
                                                        ;
                                                       ;
        return 0;
      }
    }

    if( pDestCol->affinity!=pSrcCol->affinity ){
      return 0;
    }
    if( sqlite3_stricmp(sqlite3ColumnColl(pDestCol),
                        sqlite3ColumnColl(pSrcCol))!=0 ){
      return 0;
    }
    if( pDestCol->notNull && !pSrcCol->notNull ){
      return 0;
    }

    if( (pDestCol->colFlags & 0x0060)==0 && i>0 ){
      Expr *pDestExpr = sqlite3ColumnExpr(pDest, pDestCol);
      Expr *pSrcExpr = sqlite3ColumnExpr(pSrc, pSrcCol);
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      if( (pDestExpr==0)!=(pSrcExpr==0)
       || (pDestExpr!=0 && strcmp(pDestExpr->u.zToken,
                                       pSrcExpr->u.zToken)!=0)
      ){
        return 0;
      }
    }
  }
  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){
    if( ((pDestIdx)->onError!=0) ){
      destHasUniqueIdx = 1;
    }
    for(pSrcIdx=pSrc->pIndex; pSrcIdx; pSrcIdx=pSrcIdx->pNext){
      if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;
    }
    if( pSrcIdx==0 ){
      return 0;
    }
    if( pSrcIdx->tnum==pDestIdx->tnum && pSrc->pSchema==pDest->pSchema
         && sqlite3FaultSim(411)==0 ){



      return 0;
    }
  }

  if( pDest->pCheck
   && (db->mDbFlags & 0x0004)==0
   && sqlite3ExprListCompare(pSrc->pCheck,pDest->pCheck,-1)
  ){
    return 0;
  }
# 139918 "c_tests/sqlite3.c"
  ((void) (0));
  if( (db->flags & 0x00004000)!=0 && pDest->u.tab.pFKey!=0 ){
    return 0;
  }

  if( (db->flags & ((u64)(0x00001)<<32))!=0 ){
    return 0;
  }
# 139934 "c_tests/sqlite3.c"
  iDbSrc = sqlite3SchemaToIndex(db, pSrc->pSchema);
  v = sqlite3GetVdbe(pParse);
  sqlite3CodeVerifySchema(pParse, iDbSrc);
  iSrc = pParse->nTab++;
  iDest = pParse->nTab++;
  regAutoinc = autoIncBegin(pParse, iDbDest, pDest);
  regData = sqlite3GetTempReg(pParse);
  sqlite3VdbeAddOp2(v, 76, 0, regData);
  regRowid = sqlite3GetTempReg(pParse);
  sqlite3OpenTable(pParse, iDest, iDbDest, pDest, 114);
  ((void) (0));
  if( (db->mDbFlags & 0x0004)==0 && (
      (pDest->iPKey<0 && pDest->pIndex!=0)
   || destHasUniqueIdx
   || (onError!=2 && onError!=1)
  )){
# 139967 "c_tests/sqlite3.c"
    addr1 = sqlite3VdbeAddOp2(v, 36, iDest, 0); ;
    emptyDestTest = sqlite3VdbeAddOp0(v, 9);
    sqlite3VdbeJumpHere(v, addr1);
  }
  if( (((pSrc)->tabFlags & 0x00000080)==0) ){
    u8 insFlags;
    sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, 113);
    emptySrcTest = sqlite3VdbeAddOp2(v, 36, iSrc, 0); ;
    if( pDest->iPKey>=0 ){
      addr1 = sqlite3VdbeAddOp2(v, 136, iSrc, regRowid);
      if( (db->mDbFlags & 0x0004)==0 ){
                                              ;
        addr2 = sqlite3VdbeAddOp3(v, 31, iDest, 0, regRowid);
                       ;
        sqlite3RowidConstraint(pParse, onError, pDest);
        sqlite3VdbeJumpHere(v, addr2);
      }
      autoIncStep(pParse, regAutoinc, regRowid);
    }else if( pDest->pIndex==0 && !(db->mDbFlags & 0x0008) ){
      addr1 = sqlite3VdbeAddOp2(v, 128, iDest, regRowid);
    }else{
      addr1 = sqlite3VdbeAddOp2(v, 136, iSrc, regRowid);
      ((void) (0));
    }

    if( db->mDbFlags & 0x0004 ){
      sqlite3VdbeAddOp1(v, 138, iDest);
      insFlags = 0x08|0x10|0x80;
    }else{
      insFlags = 0x01|0x20|0x08|0x80;
    }






    {
      sqlite3VdbeAddOp3(v, 130, iDest, iSrc, regRowid);
    }
    sqlite3VdbeAddOp3(v, 129, iDest, regData, regRowid);
    if( (db->mDbFlags & 0x0004)==0 ){
      sqlite3VdbeChangeP4(v, -1, (char*)pDest, (-5));
    }
    sqlite3VdbeChangeP5(v, insFlags);

    sqlite3VdbeAddOp2(v, 40, iSrc, addr1); ;
    sqlite3VdbeAddOp2(v, 123, iSrc, 0);
    sqlite3VdbeAddOp2(v, 123, iDest, 0);
  }else{
    sqlite3TableLock(pParse, iDbDest, pDest->tnum, 1, pDest->zName);
    sqlite3TableLock(pParse, iDbSrc, pSrc->tnum, 0, pSrc->zName);
  }
  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){
    u8 idxInsFlags = 0;
    for(pSrcIdx=pSrc->pIndex; (pSrcIdx); pSrcIdx=pSrcIdx->pNext){
      if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;
    }
    ((void) (0));
    sqlite3VdbeAddOp3(v, 113, iSrc, pSrcIdx->tnum, iDbSrc);
    sqlite3VdbeSetP4KeyInfo(pParse, pSrcIdx);
                                          ;
    sqlite3VdbeAddOp3(v, 114, iDest, pDestIdx->tnum, iDbDest);
    sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx);
    sqlite3VdbeChangeP5(v, 0x01);
                                           ;
    addr1 = sqlite3VdbeAddOp2(v, 36, iSrc, 0); ;
    if( db->mDbFlags & 0x0004 ){
# 140049 "c_tests/sqlite3.c"
      for(i=0; i<pSrcIdx->nColumn; i++){
        const char *zColl = pSrcIdx->azColl[i];
        if( sqlite3_stricmp(sqlite3StrBINARY, zColl) ) break;
      }
      if( i==pSrcIdx->nColumn ){
        idxInsFlags = 0x10|0x80;
        sqlite3VdbeAddOp1(v, 138, iDest);
        sqlite3VdbeAddOp2(v, 130, iDest, iSrc);
      }
    }else if( !(((pSrc)->tabFlags & 0x00000080)==0) && pDestIdx->idxType==2 ){
      idxInsFlags |= 0x01;
    }
    if( idxInsFlags!=(0x10|0x80) ){
      sqlite3VdbeAddOp3(v, 135, iSrc, regData, 1);
      if( (db->mDbFlags & 0x0004)==0
       && !(((pDest)->tabFlags & 0x00000080)==0)
       && ((pDestIdx)->idxType==2)
      ){
                                                                ;
      }
    }
    sqlite3VdbeAddOp2(v, 139, iDest, regData);
    sqlite3VdbeChangeP5(v, idxInsFlags|0x08);
    sqlite3VdbeAddOp2(v, 40, iSrc, addr1+1); ;
    sqlite3VdbeJumpHere(v, addr1);
    sqlite3VdbeAddOp2(v, 123, iSrc, 0);
    sqlite3VdbeAddOp2(v, 123, iDest, 0);
  }
  if( emptySrcTest ) sqlite3VdbeJumpHere(v, emptySrcTest);
  sqlite3ReleaseTempReg(pParse, regRowid);
  sqlite3ReleaseTempReg(pParse, regData);
  if( emptyDestTest ){
    sqlite3AutoincrementEnd(pParse);
    sqlite3VdbeAddOp2(v, 71, 0, 0);
    sqlite3VdbeJumpHere(v, emptyDestTest);
    sqlite3VdbeAddOp2(v, 123, iDest, 0);
    return 0;
  }else{
    return 1;
  }
}
# 140123 "c_tests/sqlite3.c"
           int sqlite3_exec(
  sqlite3 *db,
  const char *zSql,
  sqlite3_callback xCallback,
  void *pArg,
  char **pzErrMsg
){
  int rc = 0;
  const char *zLeftover;
  sqlite3_stmt *pStmt = 0;
  char **azCols = 0;
  int callbackIsInit;

  if( !sqlite3SafetyCheckOk(db) ) return sqlite3MisuseError(140136);
  if( zSql==0 ) zSql = "";

  sqlite3_mutex_enter(db->mutex);
  sqlite3Error(db, 0);
  while( rc==0 && zSql[0] ){
    int nCol = 0;
    char **azVals = 0;

    pStmt = 0;
    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
    ((void) (0));
    if( rc!=0 ){
      continue;
    }
    if( !pStmt ){

      zSql = zLeftover;
      continue;
    }
    callbackIsInit = 0;

    while( 1 ){
      int i;
      rc = sqlite3_step(pStmt);


      if( xCallback && (100==rc ||
          (101==rc && !callbackIsInit
                           && db->flags&0x00000100)) ){
        if( !callbackIsInit ){
          nCol = sqlite3_column_count(pStmt);
          azCols = sqlite3DbMallocRaw(db, (2*nCol+1)*sizeof(const char*));
          if( azCols==0 ){
            goto exec_out;
          }
          for(i=0; i<nCol; i++){
            azCols[i] = (char *)sqlite3_column_name(pStmt, i);


            ((void) (0));
          }
          callbackIsInit = 1;
        }
        if( rc==100 ){
          azVals = &azCols[nCol];
          for(i=0; i<nCol; i++){
            azVals[i] = (char *)sqlite3_column_text(pStmt, i);
            if( !azVals[i] && sqlite3_column_type(pStmt, i)!=5 ){
              sqlite3OomFault(db);
              goto exec_out;
            }
          }
          azVals[i] = 0;
        }
        if( xCallback(pArg, nCol, azVals, azCols) ){



          rc = 4;
          sqlite3VdbeFinalize((Vdbe *)pStmt);
          pStmt = 0;
          sqlite3Error(db, 4);
          goto exec_out;
        }
      }

      if( rc!=100 ){
        rc = sqlite3VdbeFinalize((Vdbe *)pStmt);
        pStmt = 0;
        zSql = zLeftover;
        while( (sqlite3CtypeMap[(unsigned char)(zSql[0])]&0x01) ) zSql++;
        break;
      }
    }

    sqlite3DbFree(db, azCols);
    azCols = 0;
  }

exec_out:
  if( pStmt ) sqlite3VdbeFinalize((Vdbe *)pStmt);
  sqlite3DbFree(db, azCols);

  rc = sqlite3ApiExit(db, rc);
  if( rc!=0 && pzErrMsg ){
    *pzErrMsg = sqlite3DbStrDup(0, sqlite3_errmsg(db));
    if( *pzErrMsg==0 ){
      rc = 7;
      sqlite3Error(db, 7);
    }
  }else if( pzErrMsg ){
    *pzErrMsg = 0;
  }

  ((void) (0));
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 140289 "c_tests/sqlite3.c"
struct sqlite3_api_routines {
  void * (*aggregate_context)(sqlite3_context*,int nBytes);
  int (*aggregate_count)(sqlite3_context*);
  int (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*));
  int (*bind_double)(sqlite3_stmt*,int,double);
  int (*bind_int)(sqlite3_stmt*,int,int);
  int (*bind_int64)(sqlite3_stmt*,int,sqlite_int64);
  int (*bind_null)(sqlite3_stmt*,int);
  int (*bind_parameter_count)(sqlite3_stmt*);
  int (*bind_parameter_index)(sqlite3_stmt*,const char*zName);
  const char * (*bind_parameter_name)(sqlite3_stmt*,int);
  int (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*));
  int (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*));
  int (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*);
  int (*busy_handler)(sqlite3*,int(*)(void*,int),void*);
  int (*busy_timeout)(sqlite3*,int ms);
  int (*changes)(sqlite3*);
  int (*close)(sqlite3*);
  int (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,
                           int eTextRep,const char*));
  int (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,
                             int eTextRep,const void*));
  const void * (*column_blob)(sqlite3_stmt*,int iCol);
  int (*column_bytes)(sqlite3_stmt*,int iCol);
  int (*column_bytes16)(sqlite3_stmt*,int iCol);
  int (*column_count)(sqlite3_stmt*pStmt);
  const char * (*column_database_name)(sqlite3_stmt*,int);
  const void * (*column_database_name16)(sqlite3_stmt*,int);
  const char * (*column_decltype)(sqlite3_stmt*,int i);
  const void * (*column_decltype16)(sqlite3_stmt*,int);
  double (*column_double)(sqlite3_stmt*,int iCol);
  int (*column_int)(sqlite3_stmt*,int iCol);
  sqlite_int64 (*column_int64)(sqlite3_stmt*,int iCol);
  const char * (*column_name)(sqlite3_stmt*,int);
  const void * (*column_name16)(sqlite3_stmt*,int);
  const char * (*column_origin_name)(sqlite3_stmt*,int);
  const void * (*column_origin_name16)(sqlite3_stmt*,int);
  const char * (*column_table_name)(sqlite3_stmt*,int);
  const void * (*column_table_name16)(sqlite3_stmt*,int);
  const unsigned char * (*column_text)(sqlite3_stmt*,int iCol);
  const void * (*column_text16)(sqlite3_stmt*,int iCol);
  int (*column_type)(sqlite3_stmt*,int iCol);
  sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol);
  void * (*commit_hook)(sqlite3*,int(*)(void*),void*);
  int (*complete)(const char*sql);
  int (*complete16)(const void*sql);
  int (*create_collation)(sqlite3*,const char*,int,void*,
                           int(*)(void*,int,const void*,int,const void*));
  int (*create_collation16)(sqlite3*,const void*,int,void*,
                             int(*)(void*,int,const void*,int,const void*));
  int (*create_function)(sqlite3*,const char*,int,int,void*,
                          void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
                          void (*xStep)(sqlite3_context*,int,sqlite3_value**),
                          void (*xFinal)(sqlite3_context*));
  int (*create_function16)(sqlite3*,const void*,int,int,void*,
                            void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),
                            void (*xFinal)(sqlite3_context*));
  int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*);
  int (*data_count)(sqlite3_stmt*pStmt);
  sqlite3 * (*db_handle)(sqlite3_stmt*);
  int (*declare_vtab)(sqlite3*,const char*);
  int (*enable_shared_cache)(int);
  int (*errcode)(sqlite3*db);
  const char * (*errmsg)(sqlite3*);
  const void * (*errmsg16)(sqlite3*);
  int (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**);
  int (*expired)(sqlite3_stmt*);
  int (*finalize)(sqlite3_stmt*pStmt);
  void (*free)(void*);
  void (*free_table)(char**result);
  int (*get_autocommit)(sqlite3*);
  void * (*get_auxdata)(sqlite3_context*,int);
  int (*get_table)(sqlite3*,const char*,char***,int*,int*,char**);
  int (*global_recover)(void);
  void (*interruptx)(sqlite3*);
  sqlite_int64 (*last_insert_rowid)(sqlite3*);
  const char * (*libversion)(void);
  int (*libversion_number)(void);
  void *(*malloc)(int);
  char * (*mprintf)(const char*,...);
  int (*open)(const char*,sqlite3**);
  int (*open16)(const void*,sqlite3**);
  int (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);
  int (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);
  void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*);
  void (*progress_handler)(sqlite3*,int,int(*)(void*),void*);
  void *(*realloc)(void*,int);
  int (*reset)(sqlite3_stmt*pStmt);
  void (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_double)(sqlite3_context*,double);
  void (*result_error)(sqlite3_context*,const char*,int);
  void (*result_error16)(sqlite3_context*,const void*,int);
  void (*result_int)(sqlite3_context*,int);
  void (*result_int64)(sqlite3_context*,sqlite_int64);
  void (*result_null)(sqlite3_context*);
  void (*result_text)(sqlite3_context*,const char*,int,void(*)(void*));
  void (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_value)(sqlite3_context*,sqlite3_value*);
  void * (*rollback_hook)(sqlite3*,void(*)(void*),void*);
  int (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,
                         const char*,const char*),void*);
  void (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*));
  char * (*xsnprintf)(int,char*,const char*,...);
  int (*step)(sqlite3_stmt*);
  int (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,
                                char const**,char const**,int*,int*,int*);
  void (*thread_cleanup)(void);
  int (*total_changes)(sqlite3*);
  void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*);
  int (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*);
  void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,
                                         sqlite_int64),void*);
  void * (*user_data)(sqlite3_context*);
  const void * (*value_blob)(sqlite3_value*);
  int (*value_bytes)(sqlite3_value*);
  int (*value_bytes16)(sqlite3_value*);
  double (*value_double)(sqlite3_value*);
  int (*value_int)(sqlite3_value*);
  sqlite_int64 (*value_int64)(sqlite3_value*);
  int (*value_numeric_type)(sqlite3_value*);
  const unsigned char * (*value_text)(sqlite3_value*);
  const void * (*value_text16)(sqlite3_value*);
  const void * (*value_text16be)(sqlite3_value*);
  const void * (*value_text16le)(sqlite3_value*);
  int (*value_type)(sqlite3_value*);
  char *(*vmprintf)(const char*,va_list);

  int (*overload_function)(sqlite3*, const char *zFuncName, int nArg);

  int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);
  int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);
  int (*clear_bindings)(sqlite3_stmt*);

  int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,
                          void (*xDestroy)(void *));

  int (*bind_zeroblob)(sqlite3_stmt*,int,int);
  int (*blob_bytes)(sqlite3_blob*);
  int (*blob_close)(sqlite3_blob*);
  int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,
                   int,sqlite3_blob**);
  int (*blob_read)(sqlite3_blob*,void*,int,int);
  int (*blob_write)(sqlite3_blob*,const void*,int,int);
  int (*create_collation_v2)(sqlite3*,const char*,int,void*,
                             int(*)(void*,int,const void*,int,const void*),
                             void(*)(void*));
  int (*file_control)(sqlite3*,const char*,int,void*);
  sqlite3_int64 (*memory_highwater)(int);
  sqlite3_int64 (*memory_used)(void);
  sqlite3_mutex *(*mutex_alloc)(int);
  void (*mutex_enter)(sqlite3_mutex*);
  void (*mutex_free)(sqlite3_mutex*);
  void (*mutex_leave)(sqlite3_mutex*);
  int (*mutex_try)(sqlite3_mutex*);
  int (*open_v2)(const char*,sqlite3**,int,const char*);
  int (*release_memory)(int);
  void (*result_error_nomem)(sqlite3_context*);
  void (*result_error_toobig)(sqlite3_context*);
  int (*sleep)(int);
  void (*soft_heap_limit)(int);
  sqlite3_vfs *(*vfs_find)(const char*);
  int (*vfs_register)(sqlite3_vfs*,int);
  int (*vfs_unregister)(sqlite3_vfs*);
  int (*xthreadsafe)(void);
  void (*result_zeroblob)(sqlite3_context*,int);
  void (*result_error_code)(sqlite3_context*,int);
  int (*test_control)(int, ...);
  void (*randomness)(int,void*);
  sqlite3 *(*context_db_handle)(sqlite3_context*);
  int (*extended_result_codes)(sqlite3*,int);
  int (*limit)(sqlite3*,int,int);
  sqlite3_stmt *(*next_stmt)(sqlite3*,sqlite3_stmt*);
  const char *(*sql)(sqlite3_stmt*);
  int (*status)(int,int*,int*,int);
  int (*backup_finish)(sqlite3_backup*);
  sqlite3_backup *(*backup_init)(sqlite3*,const char*,sqlite3*,const char*);
  int (*backup_pagecount)(sqlite3_backup*);
  int (*backup_remaining)(sqlite3_backup*);
  int (*backup_step)(sqlite3_backup*,int);
  const char *(*compileoption_get)(int);
  int (*compileoption_used)(const char*);
  int (*create_function_v2)(sqlite3*,const char*,int,int,void*,
                            void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),
                            void (*xFinal)(sqlite3_context*),
                            void(*xDestroy)(void*));
  int (*db_config)(sqlite3*,int,...);
  sqlite3_mutex *(*db_mutex)(sqlite3*);
  int (*db_status)(sqlite3*,int,int*,int*,int);
  int (*extended_errcode)(sqlite3*);
  void (*log)(int,const char*,...);
  sqlite3_int64 (*soft_heap_limit64)(sqlite3_int64);
  const char *(*sourceid)(void);
  int (*stmt_status)(sqlite3_stmt*,int,int);
  int (*strnicmp)(const char*,const char*,int);
  int (*unlock_notify)(sqlite3*,void(*)(void**,int),void*);
  int (*wal_autocheckpoint)(sqlite3*,int);
  int (*wal_checkpoint)(sqlite3*,const char*);
  void *(*wal_hook)(sqlite3*,int(*)(void*,sqlite3*,const char*,int),void*);
  int (*blob_reopen)(sqlite3_blob*,sqlite3_int64);
  int (*vtab_config)(sqlite3*,int op,...);
  int (*vtab_on_conflict)(sqlite3*);

  int (*close_v2)(sqlite3*);
  const char *(*db_filename)(sqlite3*,const char*);
  int (*db_readonly)(sqlite3*,const char*);
  int (*db_release_memory)(sqlite3*);
  const char *(*errstr)(int);
  int (*stmt_busy)(sqlite3_stmt*);
  int (*stmt_readonly)(sqlite3_stmt*);
  int (*stricmp)(const char*,const char*);
  int (*uri_boolean)(const char*,const char*,int);
  sqlite3_int64 (*uri_int64)(const char*,const char*,sqlite3_int64);
  const char *(*uri_parameter)(const char*,const char*);
  char *(*xvsnprintf)(int,char*,const char*,va_list);
  int (*wal_checkpoint_v2)(sqlite3*,const char*,int,int*,int*);

  int (*auto_extension)(void(*)(void));
  int (*bind_blob64)(sqlite3_stmt*,int,const void*,sqlite3_uint64,
                     void(*)(void*));
  int (*bind_text64)(sqlite3_stmt*,int,const char*,sqlite3_uint64,
                      void(*)(void*),unsigned char);
  int (*cancel_auto_extension)(void(*)(void));
  int (*load_extension)(sqlite3*,const char*,const char*,char**);
  void *(*malloc64)(sqlite3_uint64);
  sqlite3_uint64 (*msize)(void*);
  void *(*realloc64)(void*,sqlite3_uint64);
  void (*reset_auto_extension)(void);
  void (*result_blob64)(sqlite3_context*,const void*,sqlite3_uint64,
                        void(*)(void*));
  void (*result_text64)(sqlite3_context*,const char*,sqlite3_uint64,
                         void(*)(void*), unsigned char);
  int (*strglob)(const char*,const char*);

  sqlite3_value *(*value_dup)(const sqlite3_value*);
  void (*value_free)(sqlite3_value*);
  int (*result_zeroblob64)(sqlite3_context*,sqlite3_uint64);
  int (*bind_zeroblob64)(sqlite3_stmt*, int, sqlite3_uint64);

  unsigned int (*value_subtype)(sqlite3_value*);
  void (*result_subtype)(sqlite3_context*,unsigned int);

  int (*status64)(int,sqlite3_int64*,sqlite3_int64*,int);
  int (*strlike)(const char*,const char*,unsigned int);
  int (*db_cacheflush)(sqlite3*);

  int (*system_errno)(sqlite3*);

  int (*trace_v2)(sqlite3*,unsigned,int(*)(unsigned,void*,void*,void*),void*);
  char *(*expanded_sql)(sqlite3_stmt*);

  void (*set_last_insert_rowid)(sqlite3*,sqlite3_int64);

  int (*prepare_v3)(sqlite3*,const char*,int,unsigned int,
                    sqlite3_stmt**,const char**);
  int (*prepare16_v3)(sqlite3*,const void*,int,unsigned int,
                      sqlite3_stmt**,const void**);
  int (*bind_pointer)(sqlite3_stmt*,int,void*,const char*,void(*)(void*));
  void (*result_pointer)(sqlite3_context*,void*,const char*,void(*)(void*));
  void *(*value_pointer)(sqlite3_value*,const char*);
  int (*vtab_nochange)(sqlite3_context*);
  int (*value_nochange)(sqlite3_value*);
  const char *(*vtab_collation)(sqlite3_index_info*,int);

  int (*keyword_count)(void);
  int (*keyword_name)(int,const char**,int*);
  int (*keyword_check)(const char*,int);
  sqlite3_str *(*str_new)(sqlite3*);
  char *(*str_finish)(sqlite3_str*);
  void (*str_appendf)(sqlite3_str*, const char *zFormat, ...);
  void (*str_vappendf)(sqlite3_str*, const char *zFormat, va_list);
  void (*str_append)(sqlite3_str*, const char *zIn, int N);
  void (*str_appendall)(sqlite3_str*, const char *zIn);
  void (*str_appendchar)(sqlite3_str*, int N, char C);
  void (*str_reset)(sqlite3_str*);
  int (*str_errcode)(sqlite3_str*);
  int (*str_length)(sqlite3_str*);
  char *(*str_value)(sqlite3_str*);

  int (*create_window_function)(sqlite3*,const char*,int,int,void*,
                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),
                            void (*xFinal)(sqlite3_context*),
                            void (*xValue)(sqlite3_context*),
                            void (*xInv)(sqlite3_context*,int,sqlite3_value**),
                            void(*xDestroy)(void*));

  const char *(*normalized_sql)(sqlite3_stmt*);

  int (*stmt_isexplain)(sqlite3_stmt*);
  int (*value_frombind)(sqlite3_value*);

  int (*drop_modules)(sqlite3*,const char**);

  sqlite3_int64 (*hard_heap_limit64)(sqlite3_int64);
  const char *(*uri_key)(const char*,int);
  const char *(*filename_database)(const char*);
  const char *(*filename_journal)(const char*);
  const char *(*filename_wal)(const char*);

  const char *(*create_filename)(const char*,const char*,const char*,
                           int,const char**);
  void (*free_filename)(const char*);
  sqlite3_file *(*database_file_object)(const char*);

  int (*txn_state)(sqlite3*,const char*);

  sqlite3_int64 (*changes64)(sqlite3*);
  sqlite3_int64 (*total_changes64)(sqlite3*);

  int (*autovacuum_pages)(sqlite3*,
     unsigned int(*)(void*,const char*,unsigned int,unsigned int,unsigned int),
     void*, void(*)(void*));

  int (*error_offset)(sqlite3*);
  int (*vtab_rhs_value)(sqlite3_index_info*,int,sqlite3_value**);
  int (*vtab_distinct)(sqlite3_index_info*);
  int (*vtab_in)(sqlite3_index_info*,int,int);
  int (*vtab_in_first)(sqlite3_value*,sqlite3_value**);
  int (*vtab_in_next)(sqlite3_value*,sqlite3_value**);

  int (*deserialize)(sqlite3*,const char*,unsigned char*,
                     sqlite3_int64,sqlite3_int64,unsigned);
  unsigned char *(*serialize)(sqlite3*,const char *,sqlite3_int64*,
                              unsigned int);
  const char *(*db_name)(sqlite3*,int);

  int (*value_encoding)(sqlite3_value*);

  int (*is_interrupted)(sqlite3*);

  int (*stmt_explain)(sqlite3_stmt*,int);

  void *(*get_clientdata)(sqlite3*,const char*);
  int (*set_clientdata)(sqlite3*, const char*, void*, void(*)(void*));

  int (*setlk_timeout)(sqlite3*,int,int);

  int (*set_errmsg)(sqlite3*,int,const char*);
  int (*db_status64)(sqlite3*,int,sqlite3_int64*,sqlite3_int64*,int);

};





typedef int (*sqlite3_loadext_entry)(
  sqlite3 *db,
  char **pzErrMsg,
  const sqlite3_api_routines *pThunk
);
# 141104 "c_tests/sqlite3.c"
static const sqlite3_api_routines sqlite3Apis = {
  sqlite3_aggregate_context,

  sqlite3_aggregate_count,



  sqlite3_bind_blob,
  sqlite3_bind_double,
  sqlite3_bind_int,
  sqlite3_bind_int64,
  sqlite3_bind_null,
  sqlite3_bind_parameter_count,
  sqlite3_bind_parameter_index,
  sqlite3_bind_parameter_name,
  sqlite3_bind_text,
  sqlite3_bind_text16,
  sqlite3_bind_value,
  sqlite3_busy_handler,
  sqlite3_busy_timeout,
  sqlite3_changes,
  sqlite3_close,
  sqlite3_collation_needed,
  sqlite3_collation_needed16,
  sqlite3_column_blob,
  sqlite3_column_bytes,
  sqlite3_column_bytes16,
  sqlite3_column_count,
  0,
  0,
  sqlite3_column_decltype,
  sqlite3_column_decltype16,
  sqlite3_column_double,
  sqlite3_column_int,
  sqlite3_column_int64,
  sqlite3_column_name,
  sqlite3_column_name16,
  0,
  0,
  0,
  0,
  sqlite3_column_text,
  sqlite3_column_text16,
  sqlite3_column_type,
  sqlite3_column_value,
  sqlite3_commit_hook,
  sqlite3_complete,
  sqlite3_complete16,
  sqlite3_create_collation,
  sqlite3_create_collation16,
  sqlite3_create_function,
  sqlite3_create_function16,
  sqlite3_create_module,
  sqlite3_data_count,
  sqlite3_db_handle,
  sqlite3_declare_vtab,
  sqlite3_enable_shared_cache,
  sqlite3_errcode,
  sqlite3_errmsg,
  sqlite3_errmsg16,
  sqlite3_exec,

  sqlite3_expired,



  sqlite3_finalize,
  sqlite3_free,
  sqlite3_free_table,
  sqlite3_get_autocommit,
  sqlite3_get_auxdata,
  sqlite3_get_table,
  0,
  sqlite3_interrupt,
  sqlite3_last_insert_rowid,
  sqlite3_libversion,
  sqlite3_libversion_number,
  sqlite3_malloc,
  sqlite3_mprintf,
  sqlite3_open,
  sqlite3_open16,
  sqlite3_prepare,
  sqlite3_prepare16,
  sqlite3_profile,
  sqlite3_progress_handler,
  sqlite3_realloc,
  sqlite3_reset,
  sqlite3_result_blob,
  sqlite3_result_double,
  sqlite3_result_error,
  sqlite3_result_error16,
  sqlite3_result_int,
  sqlite3_result_int64,
  sqlite3_result_null,
  sqlite3_result_text,
  sqlite3_result_text16,
  sqlite3_result_text16be,
  sqlite3_result_text16le,
  sqlite3_result_value,
  sqlite3_rollback_hook,
  sqlite3_set_authorizer,
  sqlite3_set_auxdata,
  sqlite3_snprintf,
  sqlite3_step,
  sqlite3_table_column_metadata,

  sqlite3_thread_cleanup,



  sqlite3_total_changes,
  sqlite3_trace,

  sqlite3_transfer_bindings,



  sqlite3_update_hook,
  sqlite3_user_data,
  sqlite3_value_blob,
  sqlite3_value_bytes,
  sqlite3_value_bytes16,
  sqlite3_value_double,
  sqlite3_value_int,
  sqlite3_value_int64,
  sqlite3_value_numeric_type,
  sqlite3_value_text,
  sqlite3_value_text16,
  sqlite3_value_text16be,
  sqlite3_value_text16le,
  sqlite3_value_type,
  sqlite3_vmprintf,
# 141244 "c_tests/sqlite3.c"
  sqlite3_overload_function,




  sqlite3_prepare_v2,
  sqlite3_prepare16_v2,
  sqlite3_clear_bindings,




  sqlite3_create_module_v2,




  sqlite3_bind_zeroblob,
  sqlite3_blob_bytes,
  sqlite3_blob_close,
  sqlite3_blob_open,
  sqlite3_blob_read,
  sqlite3_blob_write,
  sqlite3_create_collation_v2,
  sqlite3_file_control,
  sqlite3_memory_highwater,
  sqlite3_memory_used,







  sqlite3_mutex_alloc,
  sqlite3_mutex_enter,
  sqlite3_mutex_free,
  sqlite3_mutex_leave,
  sqlite3_mutex_try,

  sqlite3_open_v2,
  sqlite3_release_memory,
  sqlite3_result_error_nomem,
  sqlite3_result_error_toobig,
  sqlite3_sleep,
  sqlite3_soft_heap_limit,
  sqlite3_vfs_find,
  sqlite3_vfs_register,
  sqlite3_vfs_unregister,




  sqlite3_threadsafe,
  sqlite3_result_zeroblob,
  sqlite3_result_error_code,
  sqlite3_test_control,
  sqlite3_randomness,
  sqlite3_context_db_handle,




  sqlite3_extended_result_codes,
  sqlite3_limit,
  sqlite3_next_stmt,
  sqlite3_sql,
  sqlite3_status,




  sqlite3_backup_finish,
  sqlite3_backup_init,
  sqlite3_backup_pagecount,
  sqlite3_backup_remaining,
  sqlite3_backup_step,

  sqlite3_compileoption_get,
  sqlite3_compileoption_used,




  sqlite3_create_function_v2,
  sqlite3_db_config,
  sqlite3_db_mutex,
  sqlite3_db_status,
  sqlite3_extended_errcode,
  sqlite3_log,
  sqlite3_soft_heap_limit64,
  sqlite3_sourceid,
  sqlite3_stmt_status,
  sqlite3_strnicmp,



  0,


  sqlite3_wal_autocheckpoint,
  sqlite3_wal_checkpoint,
  sqlite3_wal_hook,





  sqlite3_blob_reopen,
  sqlite3_vtab_config,
  sqlite3_vtab_on_conflict,
  sqlite3_close_v2,
  sqlite3_db_filename,
  sqlite3_db_readonly,
  sqlite3_db_release_memory,
  sqlite3_errstr,
  sqlite3_stmt_busy,
  sqlite3_stmt_readonly,
  sqlite3_stricmp,
  sqlite3_uri_boolean,
  sqlite3_uri_int64,
  sqlite3_uri_parameter,
  sqlite3_vsnprintf,
  sqlite3_wal_checkpoint_v2,

  sqlite3_auto_extension,
  sqlite3_bind_blob64,
  sqlite3_bind_text64,
  sqlite3_cancel_auto_extension,
  sqlite3_load_extension,
  sqlite3_malloc64,
  sqlite3_msize,
  sqlite3_realloc64,
  sqlite3_reset_auto_extension,
  sqlite3_result_blob64,
  sqlite3_result_text64,
  sqlite3_strglob,

  (sqlite3_value*(*)(const sqlite3_value*))sqlite3_value_dup,
  sqlite3_value_free,
  sqlite3_result_zeroblob64,
  sqlite3_bind_zeroblob64,

  sqlite3_value_subtype,
  sqlite3_result_subtype,

  sqlite3_status64,
  sqlite3_strlike,
  sqlite3_db_cacheflush,

  sqlite3_system_errno,

  sqlite3_trace_v2,
  sqlite3_expanded_sql,

  sqlite3_set_last_insert_rowid,

  sqlite3_prepare_v3,
  sqlite3_prepare16_v3,
  sqlite3_bind_pointer,
  sqlite3_result_pointer,
  sqlite3_value_pointer,

  sqlite3_vtab_nochange,
  sqlite3_value_nochange,
  sqlite3_vtab_collation,

  sqlite3_keyword_count,
  sqlite3_keyword_name,
  sqlite3_keyword_check,
  sqlite3_str_new,
  sqlite3_str_finish,
  sqlite3_str_appendf,
  sqlite3_str_vappendf,
  sqlite3_str_append,
  sqlite3_str_appendall,
  sqlite3_str_appendchar,
  sqlite3_str_reset,
  sqlite3_str_errcode,
  sqlite3_str_length,
  sqlite3_str_value,

  sqlite3_create_window_function,




  0,


  sqlite3_stmt_isexplain,
  sqlite3_value_frombind,


  sqlite3_drop_modules,




  sqlite3_hard_heap_limit64,
  sqlite3_uri_key,
  sqlite3_filename_database,
  sqlite3_filename_journal,
  sqlite3_filename_wal,

  sqlite3_create_filename,
  sqlite3_free_filename,
  sqlite3_database_file_object,

  sqlite3_txn_state,

  sqlite3_changes64,
  sqlite3_total_changes64,

  sqlite3_autovacuum_pages,

  sqlite3_error_offset,

  sqlite3_vtab_rhs_value,
  sqlite3_vtab_distinct,
  sqlite3_vtab_in,
  sqlite3_vtab_in_first,
  sqlite3_vtab_in_next,
# 141476 "c_tests/sqlite3.c"
  sqlite3_deserialize,
  sqlite3_serialize,




  sqlite3_db_name,

  sqlite3_value_encoding,

  sqlite3_is_interrupted,

  sqlite3_stmt_explain,

  sqlite3_get_clientdata,
  sqlite3_set_clientdata,

  sqlite3_setlk_timeout,

  sqlite3_set_errmsg,
  sqlite3_db_status64
};
# 141519 "c_tests/sqlite3.c"
static int sqlite3LoadExtension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
){
  sqlite3_vfs *pVfs = db->pVfs;
  void *handle;
  sqlite3_loadext_entry xInit;
  char *zErrmsg = 0;
  const char *zEntry;
  char *zAltEntry = 0;
  void **aHandle;
  u64 nMsg = strlen(zFile);
  int ii;
  int rc;


  static const char *azEndings[] = {





     "so"

  };


  if( pzErrMsg ) *pzErrMsg = 0;
# 141557 "c_tests/sqlite3.c"
  if( (db->flags & 0x00010000)==0 ){
    if( pzErrMsg ){
      *pzErrMsg = sqlite3_mprintf("not authorized");
    }
    return 1;
  }

  zEntry = zProc ? zProc : "sqlite3_extension_init";
# 141574 "c_tests/sqlite3.c"
  if( nMsg>4096 ) goto extension_not_found;



  if( nMsg==0 ) goto extension_not_found;

  handle = sqlite3OsDlOpen(pVfs, zFile);

  for(ii=0; ii<((int)(sizeof(azEndings)/sizeof(azEndings[0]))) && handle==0; ii++){
    char *zAltFile = sqlite3_mprintf("%s.%s", zFile, azEndings[ii]);
    if( zAltFile==0 ) return 7;
    if( nMsg+strlen(azEndings[ii])+1<=4096 ){
      handle = sqlite3OsDlOpen(pVfs, zAltFile);
    }
    sqlite3_free(zAltFile);
  }

  if( handle==0 ) goto extension_not_found;
  xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);
# 141605 "c_tests/sqlite3.c"
  if( xInit==0 && zProc==0 ){
    int iFile, iEntry, c;
    int ncFile = sqlite3Strlen30(zFile);
    zAltEntry = sqlite3_malloc64(ncFile+30);
    if( zAltEntry==0 ){
      sqlite3OsDlClose(pVfs, handle);
      return 7;
    }
    memcpy(zAltEntry, "sqlite3_", 8);
    for(iFile=ncFile-1; iFile>=0 && !((zFile[iFile])=='/'); iFile--){}
    iFile++;
    if( sqlite3_strnicmp(zFile+iFile, "lib", 3)==0 ) iFile += 3;
    for(iEntry=8; (c = zFile[iFile])!=0 && c!='.'; iFile++){
      if( (sqlite3CtypeMap[(unsigned char)(c)]&0x02) ){
        zAltEntry[iEntry++] = (char)sqlite3UpperToLower[(unsigned)c];
      }
    }
    memcpy(zAltEntry+iEntry, "_init", 6);
    zEntry = zAltEntry;
    xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);
  }
  if( xInit==0 ){
    if( pzErrMsg ){
      nMsg += strlen(zEntry) + 300;
      *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);
      if( zErrmsg ){
        ((void) (0));
        sqlite3_snprintf((int)nMsg, zErrmsg,
            "no entry point [%s] in shared library [%s]", zEntry, zFile);
        sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);
      }
    }
    sqlite3OsDlClose(pVfs, handle);
    sqlite3_free(zAltEntry);
    return 1;
  }
  sqlite3_free(zAltEntry);
  rc = xInit(db, &zErrmsg, &sqlite3Apis);
  if( rc ){
    if( rc==(0 | (1<<8)) ) return 0;
    if( pzErrMsg ){
      *pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg);
    }
    sqlite3_free(zErrmsg);
    sqlite3OsDlClose(pVfs, handle);
    return 1;
  }


  aHandle = sqlite3DbMallocZero(db, sizeof(handle)*(db->nExtension+1));
  if( aHandle==0 ){
    return 7;
  }
  if( db->nExtension>0 ){
    memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension);
  }
  sqlite3DbFree(db, db->aExtension);
  db->aExtension = aHandle;

  db->aExtension[db->nExtension++] = handle;
  return 0;

extension_not_found:
  if( pzErrMsg ){
    nMsg += 300;
    *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);
    if( zErrmsg ){
      ((void) (0));
      sqlite3_snprintf((int)nMsg, zErrmsg,
          "unable to open shared library [%.*s]", 4096, zFile);
      sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);
    }
  }
  return 1;
}
           int sqlite3_load_extension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
){
  int rc;
  sqlite3_mutex_enter(db->mutex);
  rc = sqlite3LoadExtension(db, zFile, zProc, pzErrMsg);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}





static void sqlite3CloseExtensions(sqlite3 *db){
  int i;
  ((void) (0));
  for(i=0; i<db->nExtension; i++){
    sqlite3OsDlClose(db->pVfs, db->aExtension[i]);
  }
  sqlite3DbFree(db, db->aExtension);
}





           int sqlite3_enable_load_extension(sqlite3 *db, int onoff){



  sqlite3_mutex_enter(db->mutex);
  if( onoff ){
    db->flags |= 0x00010000|0x00020000;
  }else{
    db->flags &= ~(u64)(0x00010000|0x00020000);
  }
  sqlite3_mutex_leave(db->mutex);
  return 0;
}
# 141734 "c_tests/sqlite3.c"
typedef struct sqlite3AutoExtList sqlite3AutoExtList;
static struct sqlite3AutoExtList {
  u32 nExt;
  void (**aExt)(void);
} sqlite3Autoext = { 0, 0 };
# 141760 "c_tests/sqlite3.c"
           int sqlite3_auto_extension(
  void (*xInit)(void)
){
  int rc = 0;




  rc = sqlite3_initialize();
  if( rc ){
    return rc;
  }else

  {
    u32 i;

    sqlite3_mutex *mutex = sqlite3MutexAlloc(2);

                  ;
    sqlite3_mutex_enter(mutex);
    for(i=0; i<sqlite3Autoext.nExt; i++){
      if( sqlite3Autoext.aExt[i]==xInit ) break;
    }
    if( i==sqlite3Autoext.nExt ){
      u64 nByte = (sqlite3Autoext.nExt+1)*sizeof(sqlite3Autoext.aExt[0]);
      void (**aNew)(void);
      aNew = sqlite3_realloc64(sqlite3Autoext.aExt, nByte);
      if( aNew==0 ){
        rc = 7;
      }else{
        sqlite3Autoext.aExt = aNew;
        sqlite3Autoext.aExt[sqlite3Autoext.nExt] = xInit;
        sqlite3Autoext.nExt++;
      }
    }
    sqlite3_mutex_leave(mutex);
    ((void) (0));
    return rc;
  }
}
# 141810 "c_tests/sqlite3.c"
           int sqlite3_cancel_auto_extension(
  void (*xInit)(void)
){

  sqlite3_mutex *mutex = sqlite3MutexAlloc(2);

  int i;
  int n = 0;
                ;



  sqlite3_mutex_enter(mutex);
  for(i=(int)sqlite3Autoext.nExt-1; i>=0; i--){
    if( sqlite3Autoext.aExt[i]==xInit ){
      sqlite3Autoext.nExt--;
      sqlite3Autoext.aExt[i] = sqlite3Autoext.aExt[sqlite3Autoext.nExt];
      n++;
      break;
    }
  }
  sqlite3_mutex_leave(mutex);
  return n;
}




           void sqlite3_reset_auto_extension(void){

  if( sqlite3_initialize()==0 )

  {

    sqlite3_mutex *mutex = sqlite3MutexAlloc(2);

                  ;
    sqlite3_mutex_enter(mutex);
    sqlite3_free(sqlite3Autoext.aExt);
    sqlite3Autoext.aExt = 0;
    sqlite3Autoext.nExt = 0;
    sqlite3_mutex_leave(mutex);
  }
}






static void sqlite3AutoLoadExtensions(sqlite3 *db){
  u32 i;
  int go = 1;
  int rc;
  sqlite3_loadext_entry xInit;

                ;
  if( sqlite3Autoext.nExt==0 ){

    return;
  }
  for(i=0; go; i++){
    char *zErrmsg;

    sqlite3_mutex *mutex = sqlite3MutexAlloc(2);




    const sqlite3_api_routines *pThunk = &sqlite3Apis;

    sqlite3_mutex_enter(mutex);
    if( i>=sqlite3Autoext.nExt ){
      xInit = 0;
      go = 0;
    }else{
      xInit = (sqlite3_loadext_entry)sqlite3Autoext.aExt[i];
    }
    sqlite3_mutex_leave(mutex);
    zErrmsg = 0;
    if( xInit && (rc = xInit(db, &zErrmsg, pThunk))!=0 ){
      sqlite3ErrorWithMsg(db, rc,
            "automatic extension loading failed: %s", zErrmsg);
      go = 0;
    }
    sqlite3_free(zErrmsg);
  }
}
# 142001 "c_tests/sqlite3.c"
static const char *const pragCName[] = {
            "id",
            "seq",
            "table",
            "from",
            "to",
            "on_update",
            "on_delete",
            "match",
            "cid",
            "name",
            "type",
            "notnull",
            "dflt_value",
            "pk",
            "hidden",

            "name",
            "builtin",
            "type",
            "enc",
            "narg",
            "flags",
            "schema",
            "name",
            "type",
            "ncol",
            "wr",
            "strict",
            "seqno",
            "cid",
            "name",
            "desc",
            "coll",
            "key",
            "seq",
            "name",
            "unique",
            "origin",
            "partial",
            "tbl",
            "idx",
            "wdth",
            "hght",
            "flgs",
            "table",
            "rowid",
            "parent",
            "fkid",
            "busy",
            "log",
            "checkpointed",
            "seq",
            "name",
            "file",

            "database",
            "status",

            "cache_size",

            "timeout",
};


typedef struct PragmaName {
  const char *const zName;
  u8 ePragTyp;
  u8 mPragFlg;
  u8 iPragCName;
  u8 nPragCName;
  u64 iArg;
} PragmaName;
static const PragmaName aPragmaName[] = {







 { "analysis_limit",
                   1,
                   0x10,
                   0, 0,
                   0 },

 { "application_id",
                   2,
                   0x04|0x10,
                   0, 0,
                   8 },


 { "auto_vacuum",
                   3,
                   0x01|0x10|0x80|0x04,
                   0, 0,
                   0 },



 { "automatic_index",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00008000 },


 { "busy_timeout",
                   5,
                   0x10,
                   56, 1,
                   0 },

 { "cache_size",
                   6,
                   0x01|0x10|0x80|0x04,
                   0, 0,
                   0 },


 { "cache_spill",
                   7,
                   0x10|0x80|0x04,
                   0, 0,
                   0 },


 { "case_sensitive_like",
                   8,
                   0x02,
                   0, 0,
                   0 },

 { "cell_size_check",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00200000 },

 { "checkpoint_fullfsync",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00000010 },


 { "collation_list",
                   9,
                   0x10,
                   33, 2,
                   0 },


 { "compile_options",
                   10,
                   0x10,
                   0, 0,
                   0 },


 { "count_changes",
                   4,
                   0x10|0x04,
                   0, 0,
                   ((u64)(0x00001)<<32) },
# 142177 "c_tests/sqlite3.c"
 { "data_version",
                   2,
                   0x08|0x10,
                   0, 0,
                   15 },


 { "database_list",
                   12,
                   0x10,
                   50, 3,
                   0 },


 { "default_cache_size",
                   13,
                   0x01|0x10|0x80|0x04,
                   55, 1,
                   0 },



 { "defer_foreign_keys",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00080000 },



 { "empty_result_callbacks",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00000100 },


 { "encoding",
                   14,
                   0x10|0x04,
                   0, 0,
                   0 },


 { "foreign_key_check",
                   15,
                   0x01|0x10|0x20|0x40,
                   43, 4,
                   0 },


 { "foreign_key_list",
                   16,
                   0x01|0x20|0x40,
                   0, 8,
                   0 },



 { "foreign_keys",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00004000 },



 { "freelist_count",
                   2,
                   0x08|0x10,
                   0, 0,
                   0 },


 { "full_column_names",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00000004 },
 { "fullfsync",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00000008 },



 { "function_list",
                   17,
                   0x10,
                   15, 6,
                   0 },


 { "hard_heap_limit",
                   18,
                   0x10,
                   0, 0,
                   0 },


 { "ignore_check_constraints",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00000200 },



 { "incremental_vacuum",
                   19,
                   0x01|0x02,
                   0, 0,
                   0 },


 { "index_info",
                   20,
                   0x01|0x20|0x40,
                   27, 3,
                   0 },
 { "index_list",
                   21,
                   0x01|0x20|0x40,
                   33, 5,
                   0 },
 { "index_xinfo",
                   20,
                   0x01|0x20|0x40,
                   27, 6,
                   1 },


 { "integrity_check",
                   22,
                   0x01|0x10|0x20|0x40,
                   0, 0,
                   0 },


 { "journal_mode",
                   23,
                   0x01|0x10|0x80,
                   0, 0,
                   0 },
 { "journal_size_limit",
                   24,
                   0x10|0x80,
                   0, 0,
                   0 },


 { "legacy_alter_table",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x04000000 },
# 142350 "c_tests/sqlite3.c"
 { "locking_mode",
                   26,
                   0x10|0x80,
                   0, 0,
                   0 },
 { "max_page_count",
                   27,
                   0x01|0x10|0x80,
                   0, 0,
                   0 },
 { "mmap_size",
                   28,
                   0,
                   0, 0,
                   0 },




 { "module_list",
                   29,
                   0x10,
                   9, 1,
                   0 },



 { "optimize",
                   30,
                   0x20|0x01,
                   0, 0,
                   0 },

 { "page_count",
                   27,
                   0x01|0x10|0x80,
                   0, 0,
                   0 },
 { "page_size",
                   31,
                   0x10|0x80|0x04,
                   0, 0,
                   0 },
# 142404 "c_tests/sqlite3.c"
 { "pragma_list",
                   32,
                   0x10,
                   9, 1,
                   0 },


 { "query_only",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00100000 },


 { "quick_check",
                   22,
                   0x01|0x10|0x20|0x40,
                   0, 0,
                   0 },


 { "read_uncommitted",
                   4,
                   0x10|0x04,
                   0, 0,
                   ((u64)(0x00004)<<32) },
 { "recursive_triggers",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00002000 },
 { "reverse_unordered_selects",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00001000 },


 { "schema_version",
                   2,
                   0x04|0x10,
                   0, 0,
                   1 },


 { "secure_delete",
                   33,
                   0x10,
                   0, 0,
                   0 },


 { "short_column_names",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00000040 },

 { "shrink_memory",
                   34,
                   0x02,
                   0, 0,
                   0 },
 { "soft_heap_limit",
                   35,
                   0x10,
                   0, 0,
                   0 },
# 142489 "c_tests/sqlite3.c"
 { "synchronous",
                   36,
                   0x01|0x10|0x80|0x04,
                   0, 0,
                   0 },


 { "table_info",
                   37,
                   0x01|0x20|0x40,
                   8, 6,
                   0 },
 { "table_list",
                   38,
                   0x01|0x20,
                   21, 6,
                   0 },
 { "table_xinfo",
                   37,
                   0x01|0x20|0x40,
                   8, 7,
                   1 },


 { "temp_store",
                   39,
                   0x10|0x04,
                   0, 0,
                   0 },
 { "temp_store_directory",
                   40,
                   0x04,
                   0, 0,
                   0 },

 { "threads",
                   41,
                   0x10,
                   0, 0,
                   0 },

 { "trusted_schema",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00000080 },


 { "user_version",
                   2,
                   0x04|0x10,
                   0, 0,
                   6 },
# 142573 "c_tests/sqlite3.c"
 { "wal_autocheckpoint",
                   42,
                   0,
                   0, 0,
                   0 },
 { "wal_checkpoint",
                   43,
                   0x01,
                   47, 3,
                   0 },


 { "writable_schema",
                   4,
                   0x10|0x04,
                   0, 0,
                   0x00000001|0x08000000 },

};
# 142636 "c_tests/sqlite3.c"
static u8 getSafetyLevel(const char *z, int omitFull, u8 dflt){

  static const char zText[] = "onoffalseyestruextrafull";
  static const u8 iOffset[] = {0, 1, 2, 4, 9, 12, 15, 20};
  static const u8 iLength[] = {2, 2, 3, 5, 3, 4, 5, 4};
  static const u8 iValue[] = {1, 0, 0, 0, 1, 1, 3, 2};

  int i, n;
  if( (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){
    return (u8)sqlite3Atoi(z);
  }
  n = sqlite3Strlen30(z);
  for(i=0; i<((int)(sizeof(iLength)/sizeof(iLength[0]))); i++){
    if( iLength[i]==n && sqlite3_strnicmp(&zText[iOffset[i]],z,n)==0
     && (!omitFull || iValue[i]<=1)
    ){
      return iValue[i];
    }
  }
  return dflt;
}




static u8 sqlite3GetBoolean(const char *z, u8 dflt){
  return getSafetyLevel(z,1,dflt)!=0;
}
# 142674 "c_tests/sqlite3.c"
static int getLockingMode(const char *z){
  if( z ){
    if( 0==sqlite3StrICmp(z, "exclusive") ) return 1;
    if( 0==sqlite3StrICmp(z, "normal") ) return 0;
  }
  return -1;
}
# 142689 "c_tests/sqlite3.c"
static int getAutoVacuum(const char *z){
  int i;
  if( 0==sqlite3StrICmp(z, "none") ) return 0;
  if( 0==sqlite3StrICmp(z, "full") ) return 1;
  if( 0==sqlite3StrICmp(z, "incremental") ) return 2;
  i = sqlite3Atoi(z);
  return (u8)((i>=0&&i<=2)?i:0);
}
# 142705 "c_tests/sqlite3.c"
static int getTempStore(const char *z){
  if( z[0]>='0' && z[0]<='2' ){
    return z[0] - '0';
  }else if( sqlite3StrICmp(z, "file")==0 ){
    return 1;
  }else if( sqlite3StrICmp(z, "memory")==0 ){
    return 2;
  }else{
    return 0;
  }
}







static int invalidateTempStorage(Parse *pParse){
  sqlite3 *db = pParse->db;
  if( db->aDb[1].pBt!=0 ){
    if( !db->autoCommit
     || sqlite3BtreeTxnState(db->aDb[1].pBt)!=0
    ){
      sqlite3ErrorMsg(pParse, "temporary storage cannot be changed "
        "from within a transaction");
      return 1;
    }
    sqlite3BtreeClose(db->aDb[1].pBt);
    db->aDb[1].pBt = 0;
    sqlite3ResetAllSchemasOfConnection(db);
  }
  return 0;
}
# 142747 "c_tests/sqlite3.c"
static int changeTempStorage(Parse *pParse, const char *zStorageType){
  int ts = getTempStore(zStorageType);
  sqlite3 *db = pParse->db;
  if( db->temp_store==ts ) return 0;
  if( invalidateTempStorage( pParse ) != 0 ){
    return 1;
  }
  db->temp_store = (u8)ts;
  return 0;
}





static void setPragmaResultColumnNames(
  Vdbe *v,
  const PragmaName *pPragma
){
  u8 n = pPragma->nPragCName;
  sqlite3VdbeSetNumCols(v, n==0 ? 1 : n);
  if( n==0 ){
    sqlite3VdbeSetColName(v, 0, 0, pPragma->zName, ((sqlite3_destructor_type)0));
  }else{
    int i, j;
    for(i=0, j=pPragma->iPragCName; i<n; i++, j++){
      sqlite3VdbeSetColName(v, i, 0, pragCName[j], ((sqlite3_destructor_type)0));
    }
  }
}




static void returnSingleInt(Vdbe *v, i64 value){
  sqlite3VdbeAddOp4Dup8(v, 73, 0, 1, 0, (const u8*)&value, (-13));
  sqlite3VdbeAddOp2(v, 85, 1, 1);
}




static void returnSingleText(
  Vdbe *v,
  const char *zValue
){
  if( zValue ){
    sqlite3VdbeLoadString(v, 1, (const char*)zValue);
    sqlite3VdbeAddOp2(v, 85, 1, 1);
  }
}







static void setAllPagerFlags(sqlite3 *db){
  if( db->autoCommit ){
    Db *pDb = db->aDb;
    int n = db->nDb;
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));

    ((void) (0));
    while( (n--) > 0 ){
      if( pDb->pBt ){
        sqlite3BtreeSetPagerFlags(pDb->pBt,
                 pDb->safety_level | (db->flags & 0x38) );
      }
      pDb++;
    }
  }
}
# 142833 "c_tests/sqlite3.c"
static const char *actionName(u8 action){
  const char *zName;
  switch( action ){
    case 8: zName = "SET NULL"; break;
    case 9: zName = "SET DEFAULT"; break;
    case 10: zName = "CASCADE"; break;
    case 7: zName = "RESTRICT"; break;
    default: zName = "NO ACTION";
                      ((void) (0)); break;
  }
  return zName;
}
# 142853 "c_tests/sqlite3.c"
static const char *sqlite3JournalModename(int eMode){
  static char * const azModeName[] = {
    "delete", "persist", "off", "truncate", "memory"

     , "wal"

  };
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( eMode==((int)(sizeof(azModeName)/sizeof(azModeName[0]))) ) return 0;
  return azModeName[eMode];
}




static const PragmaName *pragmaLocate(const char *zName){
  int upr, lwr, mid = 0, rc;
  lwr = 0;
  upr = ((int)(sizeof(aPragmaName)/sizeof(aPragmaName[0])))-1;
  while( lwr<=upr ){
    mid = (lwr+upr)/2;
    rc = sqlite3_stricmp(zName, aPragmaName[mid].zName);
    if( rc==0 ) break;
    if( rc<0 ){
      upr = mid - 1;
    }else{
      lwr = mid + 1;
    }
  }
  return lwr>upr ? 0 : &aPragmaName[mid];
}





static void pragmaFunclistLine(
  Vdbe *v,
  FuncDef *p,
  int isBuiltin,
  int showInternFuncs
){
  u32 mask =
      0x000000800 |
      0x000080000 |
      0x000100000 |
      0x000200000 |
      0x00040000
  ;
  if( showInternFuncs ) mask = 0xffffffff;
  for(; p; p=p->pNext){
    const char *zType;
    static const char *azEnc[] = { 0, "utf8", "utf16le", "utf16be" };

    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));

    if( p->xSFunc==0 ) continue;
    if( (p->funcFlags & 0x00040000)!=0
     && showInternFuncs==0
    ){
      continue;
    }
    if( p->xValue!=0 ){
      zType = "w";
    }else if( p->xFinalize!=0 ){
      zType = "a";
    }else{
      zType = "s";
    }
    sqlite3VdbeMultiLoad(v, 1, "sissii",
       p->zName, isBuiltin,
       zType, azEnc[p->funcFlags&0x0003],
       p->nArg,
       (p->funcFlags & mask) ^ 0x000200000
    );
  }
}
# 142949 "c_tests/sqlite3.c"
static int integrityCheckResultRow(Vdbe *v){
  int addr;
  sqlite3VdbeAddOp2(v, 85, 3, 1);
  addr = sqlite3VdbeAddOp3(v, 60, 1, sqlite3VdbeCurrentAddr(v)+2, 1);
                 ;
  sqlite3VdbeAddOp0(v, 71);
  return addr;
}
# 142966 "c_tests/sqlite3.c"
static int tableSkipIntegrityCheck(const Table *pTab, const Table *pObjTab){
  if( pObjTab ){
    return pTab!=pObjTab;
  }else{
    return (pTab->tabFlags & 0x00020000)!=0;
  }
}
# 142989 "c_tests/sqlite3.c"
static void sqlite3Pragma(
  Parse *pParse,
  Token *pId1,
  Token *pId2,
  Token *pValue,
  int minusFlag
){
  char *zLeft = 0;
  char *zRight = 0;
  const char *zDb = 0;
  Token *pId;
  char *aFcntl[4];
  int iDb;
  int rc;
  sqlite3 *db = pParse->db;
  Db *pDb;
  Vdbe *v = sqlite3GetVdbe(pParse);
  const PragmaName *pPragma;

  if( v==0 ) return;
  sqlite3VdbeRunOnlyOnce(v);
  pParse->nMem = 2;



  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);
  if( iDb<0 ) return;
  pDb = &db->aDb[iDb];




  if( iDb==1 && sqlite3OpenTempDatabase(pParse) ){
    return;
  }

  zLeft = sqlite3NameFromToken(db, pId);
  if( !zLeft ) return;
  if( minusFlag ){
    zRight = sqlite3MPrintf(db, "-%T", pValue);
  }else{
    zRight = sqlite3NameFromToken(db, pValue);
  }

  ((void) (0));
  zDb = pId2->n>0 ? pDb->zDbSName : 0;
  if( sqlite3AuthCheck(pParse, 19, zLeft, zRight, zDb) ){
    goto pragma_out;
  }
# 143054 "c_tests/sqlite3.c"
  aFcntl[0] = 0;
  aFcntl[1] = zLeft;
  aFcntl[2] = zRight;
  aFcntl[3] = 0;
  db->busyHandler.nBusy = 0;
  rc = sqlite3_file_control(db, zDb, 14, (void*)aFcntl);
  if( rc==0 ){
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, aFcntl[0], ((sqlite3_destructor_type)-1));
    returnSingleText(v, aFcntl[0]);
    sqlite3_free(aFcntl[0]);
    goto pragma_out;
  }
  if( rc!=12 ){
    if( aFcntl[0] ){
      sqlite3ErrorMsg(pParse, "%s", aFcntl[0]);
      sqlite3_free(aFcntl[0]);
    }
    pParse->nErr++;
    pParse->rc = rc;
    goto pragma_out;
  }


  pPragma = pragmaLocate(zLeft);
  if( pPragma==0 ){


    goto pragma_out;
  }


  if( (pPragma->mPragFlg & 0x01)!=0 ){
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
  }


  if( (pPragma->mPragFlg & 0x02)==0
   && ((pPragma->mPragFlg & 0x04)==0 || zRight==0)
  ){
    setPragmaResultColumnNames(v, pPragma);
  }


  switch( pPragma->ePragTyp ){
# 143117 "c_tests/sqlite3.c"
  case 13: {
    static const int iLn = 0;
    static const VdbeOpList getCacheSize[] = {
      { 2, 0, 0, 0},
      { 100, 0, 1, 3},
      { 60, 1, 8, 0},
      { 72, 0, 2, 0},
      { 108, 1, 2, 1},
      { 60, 1, 8, 0},
      { 72, 0, 1, 0},
      { 188, 0, 0, 0},
      { 85, 1, 1, 0},
    };
    VdbeOp *aOp;
    sqlite3VdbeUsesBtree(v, iDb);
    if( !zRight ){
      pParse->nMem += 2;
                                                                   ;
      aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(getCacheSize)/sizeof(getCacheSize[0]))), getCacheSize, iLn);
      if( (0) ) break;
      aOp[0].p1 = iDb;
      aOp[1].p1 = iDb;
      aOp[6].p1 = -2000;
    }else{
      int size = sqlite3AbsInt32(sqlite3Atoi(zRight));
      sqlite3BeginWriteOperation(pParse, 0, iDb);
      sqlite3VdbeAddOp3(v, 101, iDb, 3, size);
      ((void) (0));
      pDb->pSchema->cache_size = size;
      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
    }
    break;
  }
# 143162 "c_tests/sqlite3.c"
  case 31: {
    Btree *pBt = pDb->pBt;
    ((void) (0));
    if( !zRight ){
      int size = (pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;
      returnSingleInt(v, size);
    }else{



      db->nextPagesize = sqlite3Atoi(zRight);
      if( 7==sqlite3BtreeSetPageSize(pBt, db->nextPagesize,0,0) ){
        sqlite3OomFault(db);
      }
    }
    break;
  }
# 143188 "c_tests/sqlite3.c"
  case 33: {
    Btree *pBt = pDb->pBt;
    int b = -1;
    ((void) (0));
    if( zRight ){
      if( sqlite3_stricmp(zRight, "fast")==0 ){
        b = 2;
      }else{
        b = sqlite3GetBoolean(zRight, 0);
      }
    }
    if( pId2->n==0 && b>=0 ){
      int ii;
      for(ii=0; ii<db->nDb; ii++){
        sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);
      }
    }
    b = sqlite3BtreeSecureDelete(pBt, b);
    returnSingleInt(v, b);
    break;
  }
# 143227 "c_tests/sqlite3.c"
  case 27: {
    int iReg;
    i64 x = 0;
    sqlite3CodeVerifySchema(pParse, iDb);
    iReg = ++pParse->nMem;
    if( (sqlite3UpperToLower[(unsigned char)(zLeft[0])])=='p' ){
      sqlite3VdbeAddOp2(v, 179, iDb, iReg);
    }else{
      if( zRight && sqlite3DecOrHexToI64(zRight,&x)==0 ){
        if( x<0 ) x = 0;
        else if( x>0xfffffffe ) x = 0xfffffffe;
      }else{
        x = 0;
      }
      sqlite3VdbeAddOp3(v, 180, iDb, iReg, (int)x);
    }
    sqlite3VdbeAddOp2(v, 85, iReg, 1);
    break;
  }





  case 26: {
    const char *zRet = "normal";
    int eMode = getLockingMode(zRight);

    if( pId2->n==0 && eMode==-1 ){




      eMode = db->dfltLockMode;
    }else{
      Pager *pPager;
      if( pId2->n==0 ){
# 143272 "c_tests/sqlite3.c"
        int ii;
        ((void) (0));
        for(ii=2; ii<db->nDb; ii++){
          pPager = sqlite3BtreePager(db->aDb[ii].pBt);
          sqlite3PagerLockingMode(pPager, eMode);
        }
        db->dfltLockMode = (u8)eMode;
      }
      pPager = sqlite3BtreePager(pDb->pBt);
      eMode = sqlite3PagerLockingMode(pPager, eMode);
    }

    ((void) (0));

    if( eMode==1 ){
      zRet = "exclusive";
    }
    returnSingleText(v, zRet);
    break;
  }






  case 23: {
    int eMode;
    int ii;

    if( zRight==0 ){


      eMode = (-1);
    }else{
      const char *zMode;
      int n = sqlite3Strlen30(zRight);
      for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++){
        if( sqlite3_strnicmp(zRight, zMode, n)==0 ) break;
      }
      if( !zMode ){


        eMode = (-1);
      }
      if( eMode==2 && (db->flags & 0x10000000)!=0 ){


        eMode = (-1);
      }
    }
    if( eMode==(-1) && pId2->n==0 ){

      iDb = 0;
      pId2->n = 1;
    }
    for(ii=db->nDb-1; ii>=0; ii--){
      if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){
        sqlite3VdbeUsesBtree(v, ii);
        sqlite3VdbeAddOp3(v, 4, ii, 1, eMode);
      }
    }
    sqlite3VdbeAddOp2(v, 85, 1, 1);
    break;
  }







  case 24: {
    Pager *pPager = sqlite3BtreePager(pDb->pBt);
    i64 iLimit = -2;
    if( zRight ){
      sqlite3DecOrHexToI64(zRight, &iLimit);
      if( iLimit<-1 ) iLimit = -1;
    }
    iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);
    returnSingleInt(v, iLimit);
    break;
  }
# 143366 "c_tests/sqlite3.c"
  case 3: {
    Btree *pBt = pDb->pBt;
    ((void) (0));
    if( !zRight ){
      returnSingleInt(v, sqlite3BtreeGetAutoVacuum(pBt));
    }else{
      int eAuto = getAutoVacuum(zRight);
      ((void) (0));
      db->nextAutovac = (u8)eAuto;





      rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);
      if( rc==0 && (eAuto==1 || eAuto==2) ){





        static const int iLn = 0;
        static const VdbeOpList setMeta6[] = {
          { 2, 0, 1, 0},
          { 100, 0, 1, 4},
          { 16, 1, 0, 0},
          { 71, 0, 2, 0},
          { 101, 0, 7, 0},
        };
        VdbeOp *aOp;
        int iAddr = sqlite3VdbeCurrentAddr(v);
                                                                 ;
        aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(setMeta6)/sizeof(setMeta6[0]))), setMeta6, iLn);
        if( (0) ) break;
        aOp[0].p1 = iDb;
        aOp[1].p1 = iDb;
        aOp[2].p2 = iAddr+4;
        aOp[4].p1 = iDb;
        aOp[4].p3 = eAuto - 1;
        sqlite3VdbeUsesBtree(v, iDb);
      }
    }
    break;
  }
# 143418 "c_tests/sqlite3.c"
  case 19: {
    int iLimit = 0, addr;
    if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){
      iLimit = 0x7fffffff;
    }
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    sqlite3VdbeAddOp2(v, 72, iLimit, 1);
    addr = sqlite3VdbeAddOp1(v, 63, iDb); ;
    sqlite3VdbeAddOp1(v, 85, 1);
    sqlite3VdbeAddOp2(v, 87, 1, -1);
    sqlite3VdbeAddOp2(v, 60, 1, addr); ;
    sqlite3VdbeJumpHere(v, addr);
    break;
  }
# 143446 "c_tests/sqlite3.c"
  case 6: {
    ((void) (0));
    if( !zRight ){
      returnSingleInt(v, pDb->pSchema->cache_size);
    }else{
      int size = sqlite3Atoi(zRight);
      pDb->pSchema->cache_size = size;
      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
    }
    break;
  }
# 143480 "c_tests/sqlite3.c"
  case 7: {
    ((void) (0));
    if( !zRight ){
      returnSingleInt(v,
         (db->flags & 0x00000020)==0 ? 0 :
            sqlite3BtreeSetSpillSize(pDb->pBt,0));
    }else{
      int size = 1;
      if( sqlite3GetInt32(zRight, &size) ){
        sqlite3BtreeSetSpillSize(pDb->pBt, size);
      }
      if( sqlite3GetBoolean(zRight, size!=0) ){
        db->flags |= 0x00000020;
      }else{
        db->flags &= ~(u64)0x00000020;
      }
      setAllPagerFlags(db);
    }
    break;
  }
# 143515 "c_tests/sqlite3.c"
  case 28: {
    sqlite3_int64 sz;

    ((void) (0));
    if( zRight ){
      int ii;
      sqlite3DecOrHexToI64(zRight, &sz);
      if( sz<0 ) sz = sqlite3Config.szMmap;
      if( pId2->n==0 ) db->szMmap = sz;
      for(ii=db->nDb-1; ii>=0; ii--){
        if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){
          sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);
        }
      }
    }
    sz = -1;
    rc = sqlite3_file_control(db, zDb, 18, &sz);




    if( rc==0 ){
      returnSingleInt(v, sz);
    }else if( rc!=12 ){
      pParse->nErr++;
      pParse->rc = rc;
    }
    break;
  }
# 143556 "c_tests/sqlite3.c"
  case 39: {
    if( !zRight ){
      returnSingleInt(v, db->temp_store);
    }else{
      changeTempStorage(pParse, zRight);
    }
    break;
  }
# 143575 "c_tests/sqlite3.c"
  case 40: {
    sqlite3_mutex_enter(sqlite3MutexAlloc(11));
    if( !zRight ){
      returnSingleText(v, sqlite3_temp_directory);
    }else{

      if( zRight[0] ){
        int res;
        rc = sqlite3OsAccess(db->pVfs, zRight, 1, &res);
        if( rc!=0 || res==0 ){
          sqlite3ErrorMsg(pParse, "not a writable directory");
          sqlite3_mutex_leave(sqlite3MutexAlloc(11));
          goto pragma_out;
        }
      }
      if( 1==0
       || (1==1 && db->temp_store<=1)
       || (1==2 && db->temp_store==1)
      ){
        invalidateTempStorage(pParse);
      }
      sqlite3_free(sqlite3_temp_directory);
      if( zRight[0] ){
        sqlite3_temp_directory = sqlite3_mprintf("%s", zRight);
      }else{
        sqlite3_temp_directory = 0;
      }

    }
    sqlite3_mutex_leave(sqlite3MutexAlloc(11));
    break;
  }
# 143696 "c_tests/sqlite3.c"
  case 36: {
    if( !zRight ){
      returnSingleInt(v, pDb->safety_level-1);
    }else{
      if( !db->autoCommit ){
        sqlite3ErrorMsg(pParse,
            "Safety level may not be changed inside a transaction");
      }else if( iDb!=1 ){
        int iLevel = (getSafetyLevel(zRight,0,1)+1) & 0x07;
        if( iLevel==0 ) iLevel = 1;
        pDb->safety_level = iLevel;
        pDb->bSyncSet = 1;
        setAllPagerFlags(db);
      }
    }
    break;
  }



  case 4: {
    if( zRight==0 ){
      setPragmaResultColumnNames(v, pPragma);
      returnSingleInt(v, (db->flags & pPragma->iArg)!=0 );
    }else{
      u64 mask = pPragma->iArg;
      if( db->autoCommit==0 ){


        mask &= ~(0x00004000);
      }

      if( sqlite3GetBoolean(zRight, 0) ){
        if( (mask & 0x00000001)==0
         || (db->flags & 0x10000000)==0
        ){
          db->flags |= mask;
        }
      }else{
        db->flags &= ~mask;
        if( mask==0x00080000 ){
          db->nDeferredImmCons = 0;
          db->nDeferredCons = 0;
        }
        if( (mask & 0x00000001)!=0
         && sqlite3_stricmp(zRight, "reset")==0
        ){



          sqlite3ResetAllSchemasOfConnection(db);
        }
      }





      sqlite3VdbeAddOp0(v, 167);
      setAllPagerFlags(db);
    }
    break;
  }
# 143775 "c_tests/sqlite3.c"
  case 37: if( zRight ){
    Table *pTab;
    sqlite3CodeVerifyNamedSchema(pParse, zDb);
    pTab = sqlite3LocateTable(pParse, 0x02, zRight, zDb);
    if( pTab ){
      int i, k;
      int nHidden = 0;
      Column *pCol;
      Index *pPk = sqlite3PrimaryKeyIndex(pTab);
      pParse->nMem = 7;
      sqlite3ViewGetColumnNames(pParse, pTab);
      for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){
        int isHidden = 0;
        const Expr *pColExpr;
        if( pCol->colFlags & 0x0062 ){
          if( pPragma->iArg==0 ){
            nHidden++;
            continue;
          }
          if( pCol->colFlags & 0x0020 ){
            isHidden = 2;
          }else if( pCol->colFlags & 0x0040 ){
            isHidden = 3;
          }else{ ((void) (0));
            isHidden = 1;
          }
        }
        if( (pCol->colFlags & 0x0001)==0 ){
          k = 0;
        }else if( pPk==0 ){
          k = 1;
        }else{
          for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++){}
        }
        pColExpr = sqlite3ColumnExpr(pTab,pCol);
        ((void) (0));
        ((void) (0));

        sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? "issisii" : "issisi",
               i-nHidden,
               pCol->zCnName,
               sqlite3ColumnType(pCol,""),
               pCol->notNull ? 1 : 0,
               (isHidden>=2 || pColExpr==0) ? 0 : pColExpr->u.zToken,
               k,
               isHidden);
      }
    }
  }
  break;
# 143839 "c_tests/sqlite3.c"
  case 38: {
    int ii;
    pParse->nMem = 6;
    sqlite3CodeVerifyNamedSchema(pParse, zDb);
    for(ii=0; ii<db->nDb; ii++){
      HashElem *k;
      Hash *pHash;
      int initNCol;
      if( zDb && sqlite3_stricmp(zDb, db->aDb[ii].zDbSName)!=0 ) continue;






      pHash = &db->aDb[ii].pSchema->tblHash;
      initNCol = ((pHash)->count);
      while( initNCol-- ){
        for(k=((pHash)->first); 1; k=((k)->next) ){
          Table *pTab;
          if( k==0 ){ initNCol = 0; break; }
          pTab = ((k)->data);
          if( pTab->nCol==0 ){
            char *zSql = sqlite3MPrintf(db, "SELECT*FROM\"%w\"", pTab->zName);
            if( zSql ){
              sqlite3_stmt *pDummy = 0;
              (void)sqlite3_prepare_v3(db, zSql, -1, 0x10,
                                       &pDummy, 0);
              (void)sqlite3_finalize(pDummy);
              sqlite3DbFree(db, zSql);
            }
            if( db->mallocFailed ){
              sqlite3ErrorMsg(db->pParse, "out of memory");
              db->pParse->rc = 7;
            }
            pHash = &db->aDb[ii].pSchema->tblHash;
            break;
          }
        }
      }

      for(k=((pHash)->first); k; k=((k)->next) ){
        Table *pTab = ((k)->data);
        const char *zType;
        if( zRight && sqlite3_stricmp(zRight, pTab->zName)!=0 ) continue;
        if( ((pTab)->eTabType==2) ){
          zType = "view";
        }else if( ((pTab)->eTabType==1) ){
          zType = "virtual";
        }else if( pTab->tabFlags & 0x00001000 ){
          zType = "shadow";
        }else{
          zType = "table";
        }
        sqlite3VdbeMultiLoad(v, 1, "sssiii",
           db->aDb[ii].zDbSName,
           sqlite3PreferredTableName(pTab->zName),
           zType,
           pTab->nCol,
           (pTab->tabFlags & 0x00000080)!=0,
           (pTab->tabFlags & 0x00010000)!=0
        );
      }
    }
  }
  break;
# 143933 "c_tests/sqlite3.c"
  case 20: if( zRight ){
    Index *pIdx;
    Table *pTab;
    pIdx = sqlite3FindIndex(db, zRight, zDb);
    if( pIdx==0 ){



      pTab = sqlite3LocateTable(pParse, 0x02, zRight, zDb);
      if( pTab && !(((pTab)->tabFlags & 0x00000080)==0) ){
        pIdx = sqlite3PrimaryKeyIndex(pTab);
      }
    }
    if( pIdx ){
      int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);
      int i;
      int mx;
      if( pPragma->iArg ){

        mx = pIdx->nColumn;
        pParse->nMem = 6;
      }else{

        mx = pIdx->nKeyCol;
        pParse->nMem = 3;
      }
      pTab = pIdx->pTable;
      sqlite3CodeVerifySchema(pParse, iIdxDb);
      ((void) (0));
      for(i=0; i<mx; i++){
        i16 cnum = pIdx->aiColumn[i];
        sqlite3VdbeMultiLoad(v, 1, "iisX", i, cnum,
                             cnum<0 ? 0 : pTab->aCol[cnum].zCnName);
        if( pPragma->iArg ){
          sqlite3VdbeMultiLoad(v, 4, "isiX",
            pIdx->aSortOrder[i],
            pIdx->azColl[i],
            i<pIdx->nKeyCol);
        }
        sqlite3VdbeAddOp2(v, 85, 1, pParse->nMem);
      }
    }
  }
  break;

  case 21: if( zRight ){
    Index *pIdx;
    Table *pTab;
    int i;
    pTab = sqlite3FindTable(db, zRight, zDb);
    if( pTab ){
      int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
      pParse->nMem = 5;
      sqlite3CodeVerifySchema(pParse, iTabDb);
      for(pIdx=pTab->pIndex, i=0; pIdx; pIdx=pIdx->pNext, i++){
        const char *azOrigin[] = { "c", "u", "pk" };
        sqlite3VdbeMultiLoad(v, 1, "isisi",
           i,
           pIdx->zName,
           ((pIdx)->onError!=0),
           azOrigin[pIdx->idxType],
           pIdx->pPartIdxWhere!=0);
      }
    }
  }
  break;

  case 12: {
    int i;
    pParse->nMem = 3;
    for(i=0; i<db->nDb; i++){
      if( db->aDb[i].pBt==0 ) continue;
      ((void) (0));
      sqlite3VdbeMultiLoad(v, 1, "iss",
         i,
         db->aDb[i].zDbSName,
         sqlite3BtreeGetFilename(db->aDb[i].pBt));
    }
  }
  break;

  case 9: {
    int i = 0;
    HashElem *p;
    pParse->nMem = 2;
    for(p=((&db->aCollSeq)->first); p; p=((p)->next)){
      CollSeq *pColl = (CollSeq *)((p)->data);
      sqlite3VdbeMultiLoad(v, 1, "is", i++, pColl->zName);
    }
  }
  break;


  case 17: {
    int i;
    HashElem *j;
    FuncDef *p;
    int showInternFunc = (db->mDbFlags & 0x0020)!=0;
    pParse->nMem = 6;
    for(i=0; i<23; i++){
      for(p=sqlite3BuiltinFunctions.a[i]; p; p=p->u.pHash ){
        ((void) (0));
        pragmaFunclistLine(v, p, 1, showInternFunc);
      }
    }
    for(j=((&db->aFunc)->first); j; j=((j)->next)){
      p = (FuncDef*)((j)->data);
      ((void) (0));
      pragmaFunclistLine(v, p, 0, showInternFunc);
    }
  }
  break;


  case 29: {
    HashElem *j;
    pParse->nMem = 1;
    for(j=((&db->aModule)->first); j; j=((j)->next)){
      Module *pMod = (Module*)((j)->data);
      sqlite3VdbeMultiLoad(v, 1, "s", pMod->zName);
    }
  }
  break;


  case 32: {
    int i;
    for(i=0; i<((int)(sizeof(aPragmaName)/sizeof(aPragmaName[0]))); i++){
      sqlite3VdbeMultiLoad(v, 1, "s", aPragmaName[i].zName);
    }
  }
  break;





  case 16: if( zRight ){
    FKey *pFK;
    Table *pTab;
    pTab = sqlite3FindTable(db, zRight, zDb);
    if( pTab && ((pTab)->eTabType==0) ){
      pFK = pTab->u.tab.pFKey;
      if( pFK ){
        int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
        int i = 0;
        pParse->nMem = 8;
        sqlite3CodeVerifySchema(pParse, iTabDb);
        while(pFK){
          int j;
          for(j=0; j<pFK->nCol; j++){
            sqlite3VdbeMultiLoad(v, 1, "iissssss",
                   i,
                   j,
                   pFK->zTo,
                   pTab->aCol[pFK->aCol[j].iFrom].zCnName,
                   pFK->aCol[j].zCol,
                   actionName(pFK->aAction[1]),
                   actionName(pFK->aAction[0]),
                   "NONE");
          }
          ++i;
          pFK = pFK->pNextFrom;
        }
      }
    }
  }
  break;




  case 15: {
    FKey *pFK;
    Table *pTab;
    Table *pParent;
    Index *pIdx;
    int i;
    int j;
    HashElem *k;
    int x;
    int regResult;
    int regRow;
    int addrTop;
    int addrOk;
    int *aiCols;

    regResult = pParse->nMem+1;
    pParse->nMem += 4;
    regRow = ++pParse->nMem;
    k = ((&db->aDb[iDb].pSchema->tblHash)->first);
    while( k ){
      if( zRight ){
        pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);
        k = 0;
      }else{
        pTab = (Table*)((k)->data);
        k = ((k)->next);
      }
      if( pTab==0 || !((pTab)->eTabType==0) || pTab->u.tab.pFKey==0 ) continue;
      iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
      zDb = db->aDb[iDb].zDbSName;
      sqlite3CodeVerifySchema(pParse, iDb);
      sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
      sqlite3TouchRegister(pParse, pTab->nCol+regRow);
      sqlite3OpenTable(pParse, 0, iDb, pTab, 113);
      sqlite3VdbeLoadString(v, regResult, pTab->zName);
      ((void) (0));
      for(i=1, pFK=pTab->u.tab.pFKey; pFK; i++, pFK=pFK->pNextFrom){
        pParent = sqlite3FindTable(db, pFK->zTo, zDb);
        if( pParent==0 ) continue;
        pIdx = 0;
        sqlite3TableLock(pParse, iDb, pParent->tnum, 0, pParent->zName);
        x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);
        if( x==0 ){
          if( pIdx==0 ){
            sqlite3OpenTable(pParse, i, iDb, pParent, 113);
          }else{
            sqlite3VdbeAddOp3(v, 113, i, pIdx->tnum, iDb);
            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
          }
        }else{
          k = 0;
          break;
        }
      }
      ((void) (0));
      if( pFK ) break;
      if( pParse->nTab<i ) pParse->nTab = i;
      addrTop = sqlite3VdbeAddOp1(v, 36, 0); ;
      ((void) (0));
      for(i=1, pFK=pTab->u.tab.pFKey; pFK; i++, pFK=pFK->pNextFrom){
        pParent = sqlite3FindTable(db, pFK->zTo, zDb);
        pIdx = 0;
        aiCols = 0;
        if( pParent ){
          x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);
          ((void) (0));
        }
        addrOk = sqlite3VdbeMakeLabel(pParse);





        sqlite3TouchRegister(pParse, regRow + pFK->nCol);
        for(j=0; j<pFK->nCol; j++){
          int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;
          sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow+j);
          sqlite3VdbeAddOp2(v, 51, regRow+j, addrOk); ;
        }



        if( pIdx ){
          sqlite3VdbeAddOp4(v, 97, regRow, pFK->nCol, 0,
              sqlite3IndexAffinityStr(db,pIdx), pFK->nCol);
          sqlite3VdbeAddOp4Int(v, 29, i, addrOk, regRow, pFK->nCol);
                         ;
        }else if( pParent ){
          int jmp = sqlite3VdbeCurrentAddr(v)+2;
          sqlite3VdbeAddOp3(v, 30, i, jmp, regRow); ;
          sqlite3VdbeGoto(v, addrOk);
          ((void) (0));
        }


        if( (((pTab)->tabFlags & 0x00000080)==0) ){
          sqlite3VdbeAddOp2(v, 136, 0, regResult+1);
        }else{
          sqlite3VdbeAddOp2(v, 76, 0, regResult+1);
        }
        sqlite3VdbeMultiLoad(v, regResult+2, "siX", pFK->zTo, i-1);
        sqlite3VdbeAddOp2(v, 85, regResult, 4);
        sqlite3VdbeResolveLabel(v, addrOk);
        sqlite3DbFree(db, aiCols);
      }
      sqlite3VdbeAddOp2(v, 40, 0, addrTop+1); ;
      sqlite3VdbeJumpHere(v, addrTop);
    }
  }
  break;







  case 8: {
    if( zRight ){
      sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));
    }
  }
  break;
# 144259 "c_tests/sqlite3.c"
  case 22: {
    int i, j, addr, mxErr;
    Table *pObjTab = 0;

    int isQuick = ((sqlite3UpperToLower[(unsigned char)(zLeft[0])])=='q');
# 144274 "c_tests/sqlite3.c"
    ((void) (0));
    ((void) (0));
    if( pId2->z==0 ) iDb = -1;


    pParse->nMem = 6;


    mxErr = 100;
    if( zRight ){
      if( sqlite3GetInt32(pValue->z, &mxErr) ){
        if( mxErr<=0 ){
          mxErr = 100;
        }
      }else{
        pObjTab = sqlite3LocateTable(pParse, 0, zRight,
                      iDb>=0 ? db->aDb[iDb].zDbSName : 0);
      }
    }
    sqlite3VdbeAddOp2(v, 72, mxErr-1, 1);


    for(i=0; i<db->nDb; i++){
      HashElem *x;
      Hash *pTbls;
      int *aRoot;
      int cnt = 0;

      if( 0 && i==1 ) continue;
      if( iDb>=0 && i!=iDb ) continue;

      sqlite3CodeVerifySchema(pParse, i);
      pParse->okConstFactor = 0;






      ((void) (0));
      pTbls = &db->aDb[i].pSchema->tblHash;
      for(cnt=0, x=((pTbls)->first); x; x=((x)->next)){
        Table *pTab = ((x)->data);
        Index *pIdx;
        int nIdx;
        if( tableSkipIntegrityCheck(pTab,pObjTab) ) continue;
        if( (((pTab)->tabFlags & 0x00000080)==0) ) cnt++;
        for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){ cnt++; }
      }
      if( cnt==0 ) continue;
      if( pObjTab ) cnt++;
      aRoot = sqlite3DbMallocRawNN(db, sizeof(int)*(cnt+1));
      if( aRoot==0 ) break;
      cnt = 0;
      if( pObjTab ) aRoot[++cnt] = 0;
      for(x=((pTbls)->first); x; x=((x)->next)){
        Table *pTab = ((x)->data);
        Index *pIdx;
        if( tableSkipIntegrityCheck(pTab,pObjTab) ) continue;
        if( (((pTab)->tabFlags & 0x00000080)==0) ) aRoot[++cnt] = pTab->tnum;
        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
          aRoot[++cnt] = pIdx->tnum;
        }
      }
      aRoot[0] = cnt;


      sqlite3TouchRegister(pParse, 8+cnt);
      sqlite3VdbeAddOp3(v, 76, 0, 8, 8+cnt);
      sqlite3ClearTempRegCache(pParse);


      sqlite3VdbeAddOp4(v, 156, 1, cnt, 8, (char*)aRoot,(-14));
      sqlite3VdbeChangeP5(v, (u16)i);
      addr = sqlite3VdbeAddOp1(v, 51, 2); ;
      sqlite3VdbeAddOp4(v, 118, 0, 3, 0,
         sqlite3MPrintf(db, "*** in database %s ***\n", db->aDb[i].zDbSName),
         (-6));
      sqlite3VdbeAddOp3(v, 112, 2, 3, 3);
      integrityCheckResultRow(v);
      sqlite3VdbeJumpHere(v, addr);


      cnt = pObjTab ? 1 : 0;
      sqlite3VdbeLoadString(v, 2, "wrong # of entries in index ");
      for(x=((pTbls)->first); x; x=((x)->next)){
        int iTab = 0;
        Table *pTab = ((x)->data);
        Index *pIdx;
        if( tableSkipIntegrityCheck(pTab,pObjTab) ) continue;
        if( (((pTab)->tabFlags & 0x00000080)==0) ){
          iTab = cnt++;
        }else{
          iTab = cnt;
          for(pIdx=pTab->pIndex; (pIdx); pIdx=pIdx->pNext){
            if( ((pIdx)->idxType==2) ) break;
            iTab++;
          }
        }
        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
          if( pIdx->pPartIdxWhere==0 ){
            addr = sqlite3VdbeAddOp3(v, 54, 8+cnt, 0, 8+iTab);
                                    ;
            sqlite3VdbeLoadString(v, 4, pIdx->zName);
            sqlite3VdbeAddOp3(v, 112, 4, 2, 3);
            integrityCheckResultRow(v);
            sqlite3VdbeJumpHere(v, addr);
          }
          cnt++;
        }
      }



      for(x=((pTbls)->first); x; x=((x)->next)){
        Table *pTab = ((x)->data);
        Index *pIdx, *pPk;
        Index *pPrior = 0;
        int loopTop;
        int iDataCur, iIdxCur;
        int r1 = -1;
        int bStrict;
        int r2;
        int mxCol;

        if( tableSkipIntegrityCheck(pTab,pObjTab) ) continue;
        if( !((pTab)->eTabType==0) ) continue;
        if( isQuick || (((pTab)->tabFlags & 0x00000080)==0) ){
          pPk = 0;
          r2 = 0;
        }else{
          pPk = sqlite3PrimaryKeyIndex(pTab);
          r2 = sqlite3GetTempRange(pParse, pPk->nKeyCol);
          sqlite3VdbeAddOp3(v, 76, 1, r2, r2+pPk->nKeyCol-1);
        }
        sqlite3OpenTableAndIndices(pParse, pTab, 113, 0,
                                   1, 0, &iDataCur, &iIdxCur);



        sqlite3VdbeAddOp2(v, 72, 0, 7);
        for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
          sqlite3VdbeAddOp2(v, 72, 0, 8+j);
        }
        ((void) (0));
        ((void) (0));
        sqlite3VdbeAddOp2(v, 36, iDataCur, 0); ;
        loopTop = sqlite3VdbeAddOp2(v, 87, 7, 1);






        ((void) (0));
        if( (((pTab)->tabFlags & 0x00000080)==0) ){
          mxCol = -1;
          for(j=0; j<pTab->nCol; j++){
            if( (pTab->aCol[j].colFlags & 0x0020)==0 ) mxCol++;
          }
          if( mxCol==pTab->iPKey ) mxCol--;
        }else{



          mxCol = sqlite3PrimaryKeyIndex(pTab)->nColumn-1;
        }
        if( mxCol>=0 ){
          sqlite3VdbeAddOp3(v, 95, iDataCur, mxCol, 3);
          sqlite3VdbeTypeofColumn(v, 3);
        }

        if( !isQuick ){
          if( pPk ){

            int a1;
            char *zErr;
            a1 = sqlite3VdbeAddOp4Int(v, 42, iDataCur, 0,r2,pPk->nKeyCol);
                           ;
            sqlite3VdbeAddOp1(v, 51, r2); ;
            zErr = sqlite3MPrintf(db,
                   "row not in PRIMARY KEY order for %s",
                    pTab->zName);
            sqlite3VdbeAddOp4(v, 118, 0, 3, 0, zErr, (-6));
            integrityCheckResultRow(v);
            sqlite3VdbeJumpHere(v, a1);
            sqlite3VdbeJumpHere(v, a1+1);
            for(j=0; j<pPk->nKeyCol; j++){
              sqlite3ExprCodeLoadIndexColumn(pParse, pPk, iDataCur, j, r2+j);
            }
          }
        }
# 144475 "c_tests/sqlite3.c"
        bStrict = (pTab->tabFlags & 0x00010000)!=0;
        for(j=0; j<pTab->nCol; j++){
          char *zErr;
          Column *pCol = pTab->aCol + j;
          int labelError;
          int labelOk;
          int p1, p3, p4;
          int doTypeCheck;

          if( j==pTab->iPKey ) continue;
          if( bStrict ){
            doTypeCheck = pCol->eCType>1;
          }else{
            doTypeCheck = pCol->affinity>0x41;
          }
          if( pCol->notNull==0 && !doTypeCheck ) continue;


          p4 = 5;
          if( pCol->colFlags & 0x0020 ){
            sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);
            p1 = -1;
            p3 = 3;
          }else{
            if( pCol->iDflt ){
              sqlite3_value *pDfltValue = 0;
              sqlite3ValueFromExpr(db, sqlite3ColumnExpr(pTab,pCol), ((db)->enc),
                                   pCol->affinity, &pDfltValue);
              if( pDfltValue ){
                p4 = sqlite3_value_type(pDfltValue);
                sqlite3ValueFree(pDfltValue);
              }
            }
            p1 = iDataCur;
            if( !(((pTab)->tabFlags & 0x00000080)==0) ){
                                                                 ;
              p3 = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), j);
            }else{
              p3 = sqlite3TableColumnToStorage(pTab,j);
                              ;
            }
          }

          labelError = sqlite3VdbeMakeLabel(pParse);
          labelOk = sqlite3VdbeMakeLabel(pParse);
          if( pCol->notNull ){

            int jmp3;
            int jmp2 = sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);
                           ;
            if( p1<0 ){
              sqlite3VdbeChangeP5(v, 0x0f);
              jmp3 = jmp2;
            }else{
              sqlite3VdbeChangeP5(v, 0x0d);




              sqlite3VdbeAddOp3(v, 95, p1, p3, 3);
              sqlite3ColumnDefault(v, pTab, j, 3);
              jmp3 = sqlite3VdbeAddOp2(v, 52, 3, labelOk);
                             ;
            }
            zErr = sqlite3MPrintf(db, "NULL value in %s.%s", pTab->zName,
                                pCol->zCnName);
            sqlite3VdbeAddOp4(v, 118, 0, 3, 0, zErr, (-6));
            if( doTypeCheck ){
              sqlite3VdbeGoto(v, labelError);
              sqlite3VdbeJumpHere(v, jmp2);
              sqlite3VdbeJumpHere(v, jmp3);
            }else{

            }
          }
          if( bStrict && doTypeCheck ){

            static unsigned char aStdTypeMask[] = {
               0x1f,
               0x18,
               0x11,
               0x11,
               0x13,
               0x14
            };
            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);
            ((void) (0));
            sqlite3VdbeChangeP5(v, aStdTypeMask[pCol->eCType-1]);
                           ;
            zErr = sqlite3MPrintf(db, "non-%s value in %s.%s",
                                  sqlite3StdType[pCol->eCType-1],
                                  pTab->zName, pTab->aCol[j].zCnName);
            sqlite3VdbeAddOp4(v, 118, 0, 3, 0, zErr, (-6));
          }else if( !bStrict && pCol->affinity==0x42 ){


            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);
            sqlite3VdbeChangeP5(v, 0x1c);
                           ;
            zErr = sqlite3MPrintf(db, "NUMERIC value in %s.%s",
                                  pTab->zName, pTab->aCol[j].zCnName);
            sqlite3VdbeAddOp4(v, 118, 0, 3, 0, zErr, (-6));
          }else if( !bStrict && pCol->affinity>=0x43 ){


            sqlite3VdbeAddOp4Int(v, 18, p1, labelOk, p3, p4);
            sqlite3VdbeChangeP5(v, 0x1b);
                           ;
            if( p1>=0 ){
              sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);
            }
            sqlite3VdbeAddOp4(v, 97, 3, 1, 0, "C", (-1));
            sqlite3VdbeAddOp4Int(v, 18, -1, labelOk, 3, p4);
            sqlite3VdbeChangeP5(v, 0x1c);
                           ;
            zErr = sqlite3MPrintf(db, "TEXT value in %s.%s",
                                  pTab->zName, pTab->aCol[j].zCnName);
            sqlite3VdbeAddOp4(v, 118, 0, 3, 0, zErr, (-6));
          }
          sqlite3VdbeResolveLabel(v, labelError);
          integrityCheckResultRow(v);
          sqlite3VdbeResolveLabel(v, labelOk);
        }

        if( pTab->pCheck && (db->flags & 0x00000200)==0 ){
          ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);
          if( db->mallocFailed==0 ){
            int addrCkFault = sqlite3VdbeMakeLabel(pParse);
            int addrCkOk = sqlite3VdbeMakeLabel(pParse);
            char *zErr;
            int k;
            pParse->iSelfTab = iDataCur + 1;
            for(k=pCheck->nExpr-1; k>0; k--){
              sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);
            }
            sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk,
                0x10);
            sqlite3VdbeResolveLabel(v, addrCkFault);
            pParse->iSelfTab = 0;
            zErr = sqlite3MPrintf(db, "CHECK constraint failed in %s",
                pTab->zName);
            sqlite3VdbeAddOp4(v, 118, 0, 3, 0, zErr, (-6));
            integrityCheckResultRow(v);
            sqlite3VdbeResolveLabel(v, addrCkOk);
          }
          sqlite3ExprListDelete(db, pCheck);
        }
        if( !isQuick ){

          for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
            int jmp2, jmp3, jmp4, jmp5, label6;
            int kk;
            int ckUniq = sqlite3VdbeMakeLabel(pParse);
            if( pPk==pIdx ) continue;
            r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3,
                                         pPrior, r1);
            pPrior = pIdx;
            sqlite3VdbeAddOp2(v, 87, 8+j, 1);

            jmp2 = sqlite3VdbeAddOp4Int(v, 29, iIdxCur+j, ckUniq, r1,
                                        pIdx->nColumn); ;
            sqlite3VdbeLoadString(v, 3, "row ");
            sqlite3VdbeAddOp3(v, 112, 7, 3, 3);
            sqlite3VdbeLoadString(v, 4, " missing from index ");
            sqlite3VdbeAddOp3(v, 112, 4, 3, 3);
            jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);
            sqlite3VdbeAddOp3(v, 112, 4, 3, 3);
            jmp4 = integrityCheckResultRow(v);
            sqlite3VdbeJumpHere(v, jmp2);





            if( (((pTab)->tabFlags & 0x00000080)==0) ){
              int jmp7;
              sqlite3VdbeAddOp2(v, 143, iIdxCur+j, 3);
              jmp7 = sqlite3VdbeAddOp3(v, 54, 3, 0, r1+pIdx->nColumn-1);
                                      ;
              sqlite3VdbeLoadString(v, 3,
                 "rowid not at end-of-record for row ");
              sqlite3VdbeAddOp3(v, 112, 7, 3, 3);
              sqlite3VdbeLoadString(v, 4, " of index ");
              sqlite3VdbeGoto(v, jmp5-1);
              sqlite3VdbeJumpHere(v, jmp7);
            }



            label6 = 0;
            for(kk=0; kk<pIdx->nKeyCol; kk++){
              if( pIdx->azColl[kk]==sqlite3StrBINARY ) continue;
              if( label6==0 ) label6 = sqlite3VdbeMakeLabel(pParse);
              sqlite3VdbeAddOp3(v, 95, iIdxCur+j, kk, 3);
              sqlite3VdbeAddOp3(v, 53, 3, label6, r1+kk); ;
            }
            if( label6 ){
              int jmp6 = sqlite3VdbeAddOp0(v, 9);
              sqlite3VdbeResolveLabel(v, label6);
              sqlite3VdbeLoadString(v, 3, "row ");
              sqlite3VdbeAddOp3(v, 112, 7, 3, 3);
              sqlite3VdbeLoadString(v, 4, " values differ from index ");
              sqlite3VdbeGoto(v, jmp5-1);
              sqlite3VdbeJumpHere(v, jmp6);
            }




            if( ((pIdx)->onError!=0) ){
              int uniqOk = sqlite3VdbeMakeLabel(pParse);
              int jmp6;
              for(kk=0; kk<pIdx->nKeyCol; kk++){
                int iCol = pIdx->aiColumn[kk];
                ((void) (0));
                if( iCol>=0 && pTab->aCol[iCol].notNull ) continue;
                sqlite3VdbeAddOp2(v, 51, r1+kk, uniqOk);
                               ;
              }
              jmp6 = sqlite3VdbeAddOp1(v, 40, iIdxCur+j); ;
              sqlite3VdbeGoto(v, uniqOk);
              sqlite3VdbeJumpHere(v, jmp6);
              sqlite3VdbeAddOp4Int(v, 42, iIdxCur+j, uniqOk, r1,
                                   pIdx->nKeyCol); ;
              sqlite3VdbeLoadString(v, 3, "non-unique entry in index ");
              sqlite3VdbeGoto(v, jmp5);
              sqlite3VdbeResolveLabel(v, uniqOk);
            }
            sqlite3VdbeJumpHere(v, jmp4);
            sqlite3ResolvePartIdxLabel(pParse, jmp3);
          }
        }
        sqlite3VdbeAddOp2(v, 40, iDataCur, loopTop); ;
        sqlite3VdbeJumpHere(v, loopTop-1);
        if( pPk ){
          ((void) (0));
          sqlite3ReleaseTempRange(pParse, r2, pPk->nKeyCol);
        }
      }





      for(x=((pTbls)->first); x; x=((x)->next)){
        Table *pTab = ((x)->data);
        sqlite3_vtab *pVTab;
        int a1;
        if( tableSkipIntegrityCheck(pTab,pObjTab) ) continue;
        if( ((pTab)->eTabType==0) ) continue;
        if( !((pTab)->eTabType==1) ) continue;
        if( pTab->nCol<=0 ){
          const char *zMod = pTab->u.vtab.azArg[0];
          if( sqlite3HashFind(&db->aModule, zMod)==0 ) continue;
        }
        sqlite3ViewGetColumnNames(pParse, pTab);
        if( pTab->u.vtab.p==0 ) continue;
        pVTab = pTab->u.vtab.p->pVtab;
        if( (pVTab==0) ) continue;
        if( (pVTab->pModule==0) ) continue;
        if( pVTab->pModule->iVersion<4 ) continue;
        if( pVTab->pModule->xIntegrity==0 ) continue;
        sqlite3VdbeAddOp3(v, 175, i, 3, isQuick);
        pTab->nTabRef++;
        sqlite3VdbeAppendP4(v, pTab, (-16));
        a1 = sqlite3VdbeAddOp1(v, 51, 3); ;
        integrityCheckResultRow(v);
        sqlite3VdbeJumpHere(v, a1);
        continue;
      }

    }
    {
      static const int iLn = 0;
      static const VdbeOpList endCode[] = {
        { 87, 1, 0, 0},
        { 61, 1, 4, 0},
        { 118, 0, 3, 0},
        { 85, 3, 1, 0},
        { 71, 0, 0, 0},
        { 118, 0, 3, 0},
        { 9, 0, 3, 0},
      };
      VdbeOp *aOp;

      aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(endCode)/sizeof(endCode[0]))), endCode, iLn);
      if( aOp ){
        aOp[0].p2 = 1-mxErr;
        aOp[2].p4type = (-1);
        aOp[2].p4.z = "ok";
        aOp[5].p4type = (-1);
        aOp[5].p4.z = (char*)sqlite3ErrStr(11);
      }
      sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v)-2);
    }
  }
  break;
# 144797 "c_tests/sqlite3.c"
  case 14: {
    static const struct EncName {
      char *zName;
      u8 enc;
    } encnames[] = {
      { "UTF8", 1 },
      { "UTF-8", 1 },
      { "UTF-16le", 2 },
      { "UTF-16be", 3 },
      { "UTF16le", 2 },
      { "UTF16be", 3 },
      { "UTF-16", 0 },
      { "UTF16", 0 },
      { 0, 0 }
    };
    const struct EncName *pEnc;
    if( !zRight ){
      if( sqlite3ReadSchema(pParse) ) goto pragma_out;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      returnSingleText(v, encnames[((pParse->db)->enc)].zName);
    }else{





      if( (db->mDbFlags & 0x0040)==0 ){
        for(pEnc=&encnames[0]; pEnc->zName; pEnc++){
          if( 0==sqlite3StrICmp(zRight, pEnc->zName) ){
            u8 enc = pEnc->enc ? pEnc->enc : 2;
            ((db)->aDb[0].pSchema->enc) = enc;
            sqlite3SetTextEncoding(db, enc);
            break;
          }
        }
        if( !pEnc->zName ){
          sqlite3ErrorMsg(pParse, "unsupported encoding: %s", zRight);
        }
      }
    }
  }
  break;
# 144876 "c_tests/sqlite3.c"
  case 2: {
    int iCookie = pPragma->iArg;
    sqlite3VdbeUsesBtree(v, iDb);
    if( zRight && (pPragma->mPragFlg & 0x08)==0 ){

      static const VdbeOpList setCookie[] = {
        { 2, 0, 1, 0},
        { 101, 0, 0, 0},
      };
      VdbeOp *aOp;
                                                                ;
      aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(setCookie)/sizeof(setCookie[0]))), setCookie, 0);
      if( (0) ) break;
      aOp[0].p1 = iDb;
      aOp[1].p1 = iDb;
      aOp[1].p2 = iCookie;
      aOp[1].p3 = sqlite3Atoi(zRight);
      aOp[1].p5 = 1;
      if( iCookie==1 && (db->flags & 0x10000000)!=0 ){


        aOp[1].opcode = 188;
      }
    }else{

      static const VdbeOpList readCookie[] = {
        { 2, 0, 0, 0},
        { 100, 0, 1, 0},
        { 85, 1, 1, 0}
      };
      VdbeOp *aOp;
                                                                 ;
      aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(readCookie)/sizeof(readCookie[0]))),readCookie,0);
      if( (0) ) break;
      aOp[0].p1 = iDb;
      aOp[1].p1 = iDb;
      aOp[1].p3 = iCookie;
      sqlite3VdbeReusable(v);
    }
  }
  break;
# 144926 "c_tests/sqlite3.c"
  case 10: {
    int i = 0;
    const char *zOpt;
    pParse->nMem = 1;
    while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){
      sqlite3VdbeLoadString(v, 1, zOpt);
      sqlite3VdbeAddOp2(v, 85, 1, 1);
    }
    sqlite3VdbeReusable(v);
  }
  break;
# 144945 "c_tests/sqlite3.c"
  case 43: {
    int iBt = (pId2->z?iDb:(10 +2));
    int eMode = 0;
    if( zRight ){
      if( sqlite3StrICmp(zRight, "full")==0 ){
        eMode = 1;
      }else if( sqlite3StrICmp(zRight, "restart")==0 ){
        eMode = 2;
      }else if( sqlite3StrICmp(zRight, "truncate")==0 ){
        eMode = 3;
      }else if( sqlite3StrICmp(zRight, "noop")==0 ){
        eMode = -1;
      }
    }
    pParse->nMem = 3;
    sqlite3VdbeAddOp3(v, 3, iBt, eMode, 1);
    sqlite3VdbeAddOp2(v, 85, 1, 3);
  }
  break;
# 144973 "c_tests/sqlite3.c"
  case 42: {
    if( zRight ){
      sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));
    }
    returnSingleInt(v,
       db->xWalCallback==sqlite3WalDefaultHook ?
           ((int)(long int)(db->pWalArg)) : 0);
  }
  break;
# 144991 "c_tests/sqlite3.c"
  case 34: {
    sqlite3_db_release_memory(db);
    break;
  }
# 145069 "c_tests/sqlite3.c"
  case 30: {
    int iDbLast;
    int iTabCur;
    HashElem *k;
    Schema *pSchema;
    Table *pTab;
    Index *pIdx;
    LogEst szThreshold;
    char *zSubSql;
    u32 opMask;
    int nLimit;
    int nCheck = 0;
    int nBtree = 0;
    int nIndex;

    if( zRight ){
      opMask = (u32)sqlite3Atoi(zRight);
      if( (opMask & 0x02)==0 ) break;
    }else{
      opMask = 0xfffe;
    }
    if( (opMask & 0x10)==0 ){
      nLimit = 0;
    }else if( db->nAnalysisLimit>0
           && db->nAnalysisLimit<2000 ){
      nLimit = 0;
    }else{
      nLimit = 2000;
    }
    iTabCur = pParse->nTab++;
    for(iDbLast = zDb?iDb:db->nDb-1; iDb<=iDbLast; iDb++){
      if( iDb==1 ) continue;
      sqlite3CodeVerifySchema(pParse, iDb);
      pSchema = db->aDb[iDb].pSchema;
      for(k=((&pSchema->tblHash)->first); k; k=((k)->next)){
        pTab = (Table*)((k)->data);


        if( !((pTab)->eTabType==0) ) continue;


        if( 0==sqlite3_strnicmp(pTab->zName, "sqlite_", 7) ) continue;





        szThreshold = pTab->nRowLogEst;
        nIndex = 0;
        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
          nIndex++;
          if( !pIdx->hasStat1 ){
            szThreshold = -1;
          }
        }




        if( (pTab->tabFlags & 0x00000100)!=0 ){

        }else if( opMask & 0x10000 ){

        }else if( pTab->pIndex!=0 && szThreshold<0 ){

        }else{

          continue;
        }

        nCheck++;
        if( nCheck==2 ){


          sqlite3BeginWriteOperation(pParse, 0, iDb);
        }
        nBtree += nIndex+1;




        sqlite3OpenTable(pParse, iTabCur, iDb, pTab, 113);
        if( szThreshold>=0 ){
          const LogEst iRange = 33;
          sqlite3VdbeAddOp4Int(v, 33, iTabCur,
                         sqlite3VdbeCurrentAddr(v)+2+(opMask&1),
                         szThreshold>=iRange ? szThreshold-iRange : -1,
                         szThreshold+iRange);
                         ;
        }else{
          sqlite3VdbeAddOp2(v, 36, iTabCur,
                         sqlite3VdbeCurrentAddr(v)+2+(opMask&1));
                         ;
        }
        zSubSql = sqlite3MPrintf(db, "ANALYZE \"%w\".\"%w\"",
                                 db->aDb[iDb].zDbSName, pTab->zName);
        if( opMask & 0x01 ){
          int r1 = sqlite3GetTempReg(pParse);
          sqlite3VdbeAddOp4(v, 118, 0, r1, 0, zSubSql, (-6));
          sqlite3VdbeAddOp2(v, 85, r1, 1);
        }else{
          sqlite3VdbeAddOp4(v, 149, nLimit ? 0x02 : 00, nLimit, 0,
                            zSubSql, (-6));
        }
      }
    }
    sqlite3VdbeAddOp0(v, 167);




    if( !db->mallocFailed && nLimit>0 && nBtree>100 ){
      int iAddr, iEnd;
      VdbeOp *aOp;
      nLimit = 100*nLimit/nBtree;
      if( nLimit<100 ) nLimit = 100;
      aOp = sqlite3VdbeGetOp(v, 0);
      iEnd = sqlite3VdbeCurrentAddr(v);
      for(iAddr=0; iAddr<iEnd; iAddr++){
        if( aOp[iAddr].opcode==149 ) aOp[iAddr].p2 = nLimit;
      }
    }
    break;
  }
# 145203 "c_tests/sqlite3.c"
                                default: {
    ((void) (0));
    if( zRight ){
      sqlite3_busy_timeout(db, sqlite3Atoi(zRight));
    }
    returnSingleInt(v, db->busyTimeout);
    break;
  }
# 145223 "c_tests/sqlite3.c"
  case 35: {
    sqlite3_int64 N;
    if( zRight && sqlite3DecOrHexToI64(zRight, &N)==0 ){
      sqlite3_soft_heap_limit64(N);
    }
    returnSingleInt(v, sqlite3_soft_heap_limit64(-1));
    break;
  }
# 145243 "c_tests/sqlite3.c"
  case 18: {
    sqlite3_int64 N;
    if( zRight && sqlite3DecOrHexToI64(zRight, &N)==0 ){
      sqlite3_int64 iPrior = sqlite3_hard_heap_limit64(-1);
      if( N>0 && (iPrior==0 || iPrior>N) ) sqlite3_hard_heap_limit64(N);
    }
    returnSingleInt(v, sqlite3_hard_heap_limit64(-1));
    break;
  }
# 145260 "c_tests/sqlite3.c"
  case 41: {
    sqlite3_int64 N;
    if( zRight
     && sqlite3DecOrHexToI64(zRight, &N)==0
     && N>=0
    ){
      sqlite3_limit(db, 11, (int)(N&0x7fffffff));
    }
    returnSingleInt(v, sqlite3_limit(db, 11, -1));
    break;
  }
# 145279 "c_tests/sqlite3.c"
  case 1: {
    sqlite3_int64 N;
    if( zRight
     && sqlite3DecOrHexToI64(zRight, &N)==0
     && N>=0
    ){
      db->nAnalysisLimit = (int)(N&0x7fffffff);
    }
    returnSingleInt(v, db->nAnalysisLimit);
    break;
  }
# 145328 "c_tests/sqlite3.c"
  }






  if( (pPragma->mPragFlg & 0x04) && zRight ){
                                   ;
  }

pragma_out:
  sqlite3DbFree(db, zLeft);
  sqlite3DbFree(db, zRight);
}





typedef struct PragmaVtab PragmaVtab;
typedef struct PragmaVtabCursor PragmaVtabCursor;
struct PragmaVtab {
  sqlite3_vtab base;
  sqlite3 *db;
  const PragmaName *pName;
  u8 nHidden;
  u8 iHidden;
};
struct PragmaVtabCursor {
  sqlite3_vtab_cursor base;
  sqlite3_stmt *pPragma;
  sqlite_int64 iRowid;
  char *azArg[2];
};




static int pragmaVtabConnect(
  sqlite3 *db,
  void *pAux,
  int argc, const char *const*argv,
  sqlite3_vtab **ppVtab,
  char **pzErr
){
  const PragmaName *pPragma = (const PragmaName*)pAux;
  PragmaVtab *pTab = 0;
  int rc;
  int i, j;
  char cSep = '(';
  StrAccum acc;
  char zBuf[200];

  (void)(argc);
  (void)(argv);
  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);
  sqlite3_str_appendall(&acc, "CREATE TABLE x");
  for(i=0, j=pPragma->iPragCName; i<pPragma->nPragCName; i++, j++){
    sqlite3_str_appendf(&acc, "%c\"%s\"", cSep, pragCName[j]);
    cSep = ',';
  }
  if( i==0 ){
    sqlite3_str_appendf(&acc, "(\"%s\"", pPragma->zName);
    i++;
  }
  j = 0;
  if( pPragma->mPragFlg & 0x20 ){
    sqlite3_str_appendall(&acc, ",arg HIDDEN");
    j++;
  }
  if( pPragma->mPragFlg & (0x40|0x80) ){
    sqlite3_str_appendall(&acc, ",schema HIDDEN");
    j++;
  }
  sqlite3_str_append(&acc, ")", 1);
  sqlite3StrAccumFinish(&acc);
  ((void) (0));
  rc = sqlite3_declare_vtab(db, zBuf);
  if( rc==0 ){
    pTab = (PragmaVtab*)sqlite3_malloc(sizeof(PragmaVtab));
    if( pTab==0 ){
      rc = 7;
    }else{
      memset(pTab, 0, sizeof(PragmaVtab));
      pTab->pName = pPragma;
      pTab->db = db;
      pTab->iHidden = i;
      pTab->nHidden = j;
    }
  }else{
    *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
  }

  *ppVtab = (sqlite3_vtab*)pTab;
  return rc;
}




static int pragmaVtabDisconnect(sqlite3_vtab *pVtab){
  PragmaVtab *pTab = (PragmaVtab*)pVtab;
  sqlite3_free(pTab);
  return 0;
}
# 145442 "c_tests/sqlite3.c"
static int pragmaVtabBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
  PragmaVtab *pTab = (PragmaVtab*)tab;
  const struct sqlite3_index_constraint *pConstraint;
  int i, j;
  int seen[2];

  pIdxInfo->estimatedCost = (double)1;
  if( pTab->nHidden==0 ){ return 0; }
  pConstraint = pIdxInfo->aConstraint;
  seen[0] = 0;
  seen[1] = 0;
  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
    if( pConstraint->iColumn < pTab->iHidden ) continue;
    if( pConstraint->op!=2 ) continue;
    if( pConstraint->usable==0 ) return 19;
    j = pConstraint->iColumn - pTab->iHidden;
    ((void) (0));
    seen[j] = i+1;
  }
  if( seen[0]==0 ){
    pIdxInfo->estimatedCost = (double)2147483647;
    pIdxInfo->estimatedRows = 2147483647;
    return 0;
  }
  j = seen[0]-1;
  pIdxInfo->aConstraintUsage[j].argvIndex = 1;
  pIdxInfo->aConstraintUsage[j].omit = 1;
  pIdxInfo->estimatedCost = (double)20;
  pIdxInfo->estimatedRows = 20;
  if( seen[1] ){
    j = seen[1]-1;
    pIdxInfo->aConstraintUsage[j].argvIndex = 2;
    pIdxInfo->aConstraintUsage[j].omit = 1;
  }
  return 0;
}


static int pragmaVtabOpen(sqlite3_vtab *pVtab, sqlite3_vtab_cursor **ppCursor){
  PragmaVtabCursor *pCsr;
  pCsr = (PragmaVtabCursor*)sqlite3_malloc(sizeof(*pCsr));
  if( pCsr==0 ) return 7;
  memset(pCsr, 0, sizeof(PragmaVtabCursor));
  pCsr->base.pVtab = pVtab;
  *ppCursor = &pCsr->base;
  return 0;
}


static void pragmaVtabCursorClear(PragmaVtabCursor *pCsr){
  int i;
  sqlite3_finalize(pCsr->pPragma);
  pCsr->pPragma = 0;
  pCsr->iRowid = 0;
  for(i=0; i<((int)(sizeof(pCsr->azArg)/sizeof(pCsr->azArg[0]))); i++){
    sqlite3_free(pCsr->azArg[i]);
    pCsr->azArg[i] = 0;
  }
}


static int pragmaVtabClose(sqlite3_vtab_cursor *cur){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)cur;
  pragmaVtabCursorClear(pCsr);
  sqlite3_free(pCsr);
  return 0;
}


static int pragmaVtabNext(sqlite3_vtab_cursor *pVtabCursor){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;
  int rc = 0;


  pCsr->iRowid++;
  ((void) (0));
  if( 100!=sqlite3_step(pCsr->pPragma) ){
    rc = sqlite3_finalize(pCsr->pPragma);
    pCsr->pPragma = 0;
    pragmaVtabCursorClear(pCsr);
  }
  return rc;
}




static int pragmaVtabFilter(
  sqlite3_vtab_cursor *pVtabCursor,
  int idxNum, const char *idxStr,
  int argc, sqlite3_value **argv
){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;
  PragmaVtab *pTab = (PragmaVtab*)(pVtabCursor->pVtab);
  int rc;
  int i, j;
  StrAccum acc;
  char *zSql;

  (void)(idxNum);
  (void)(idxStr);
  pragmaVtabCursorClear(pCsr);
  j = (pTab->pName->mPragFlg & 0x20)!=0 ? 0 : 1;
  for(i=0; i<argc; i++, j++){
    const char *zText = (const char*)sqlite3_value_text(argv[i]);
    ((void) (0));
    ((void) (0));
    if( zText ){
      pCsr->azArg[j] = sqlite3_mprintf("%s", zText);
      if( pCsr->azArg[j]==0 ){
        return 7;
      }
    }
  }
  sqlite3StrAccumInit(&acc, 0, 0, 0, pTab->db->aLimit[1]);
  sqlite3_str_appendall(&acc, "PRAGMA ");
  if( pCsr->azArg[1] ){
    sqlite3_str_appendf(&acc, "%Q.", pCsr->azArg[1]);
  }
  sqlite3_str_appendall(&acc, pTab->pName->zName);
  if( pCsr->azArg[0] ){
    sqlite3_str_appendf(&acc, "=%Q", pCsr->azArg[0]);
  }
  zSql = sqlite3StrAccumFinish(&acc);
  if( zSql==0 ) return 7;
  rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pCsr->pPragma, 0);
  sqlite3_free(zSql);
  if( rc!=0 ){
    pTab->base.zErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pTab->db));
    return rc;
  }
  return pragmaVtabNext(pVtabCursor);
}




static int pragmaVtabEof(sqlite3_vtab_cursor *pVtabCursor){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;
  return (pCsr->pPragma==0);
}




static int pragmaVtabColumn(
  sqlite3_vtab_cursor *pVtabCursor,
  sqlite3_context *ctx,
  int i
){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;
  PragmaVtab *pTab = (PragmaVtab*)(pVtabCursor->pVtab);
  if( i<pTab->iHidden ){
    sqlite3_result_value(ctx, sqlite3_column_value(pCsr->pPragma, i));
  }else{
    sqlite3_result_text(ctx, pCsr->azArg[i-pTab->iHidden],-1,((sqlite3_destructor_type)-1));
  }
  return 0;
}




static int pragmaVtabRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *p){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;
  *p = pCsr->iRowid;
  return 0;
}


static const sqlite3_module pragmaVtabModule = {
  0,
  0,
  pragmaVtabConnect,
  pragmaVtabBestIndex,
  pragmaVtabDisconnect,
  0,
  pragmaVtabOpen,
  pragmaVtabClose,
  pragmaVtabFilter,
  pragmaVtabNext,
  pragmaVtabEof,
  pragmaVtabColumn,
  pragmaVtabRowid,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
};






static Module *sqlite3PragmaVtabRegister(sqlite3 *db, const char *zName){
  const PragmaName *pName;
  ((void) (0));
  pName = pragmaLocate(zName+7);
  if( pName==0 ) return 0;
  if( (pName->mPragFlg & (0x10|0x20))==0 ) return 0;
  ((void) (0));
  return sqlite3VtabCreateModule(db, zName, &pragmaVtabModule, (void*)pName, 0);
}
# 145682 "c_tests/sqlite3.c"
static void corruptSchema(
  InitData *pData,
  char **azObj,
  const char *zExtra
){
  sqlite3 *db = pData->db;
  if( db->mallocFailed ){
    pData->rc = 7;
  }else if( pData->pzErrMsg[0]!=0 ){

  }else if( pData->mInitFlags & (0x0003) ){
    static const char *azAlterType[] = {
       "rename",
       "drop column",
       "add column"
    };
    *pData->pzErrMsg = sqlite3MPrintf(db,
        "error in %s %s after %s: %s", azObj[0], azObj[1],
        azAlterType[(pData->mInitFlags&0x0003)-1],
        zExtra
    );
    pData->rc = 1;
  }else if( db->flags & 0x00000001 ){
    pData->rc = sqlite3CorruptError(145705);
  }else{
    char *z;
    const char *zObj = azObj[1] ? azObj[1] : "?";
    z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);
    if( zExtra && zExtra[0] ) z = sqlite3MPrintf(db, "%z - %s", z, zExtra);
    *pData->pzErrMsg = z;
    pData->rc = sqlite3CorruptError(145712);
  }
}






static int sqlite3IndexHasDuplicateRootPage(Index *pIndex){
  Index *p;
  for(p=pIndex->pTable->pIndex; p; p=p->pNext){
    if( p->tnum==pIndex->tnum && p!=pIndex ) return 1;
  }
  return 0;
}


static int sqlite3Prepare(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  u32 prepFlags,
  Vdbe *pReprepare,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
# 145755 "c_tests/sqlite3.c"
static int sqlite3InitCallback(void *pInit, int argc, char **argv, char **NotUsed){
  InitData *pData = (InitData*)pInit;
  sqlite3 *db = pData->db;
  int iDb = pData->iDb;

  ((void) (0));
  (void)(NotUsed),(void)(argc);
  ((void) (0));
  db->mDbFlags |= 0x0040;
  if( argv==0 ) return 0;
  pData->nInitRow++;
  if( db->mallocFailed ){
    corruptSchema(pData, argv, 0);
    return 1;
  }

  ((void) (0));
  if( argv[3]==0 ){
    corruptSchema(pData, argv, 0);
  }else if( argv[4]
         && 'c'==sqlite3UpperToLower[(unsigned char)argv[4][0]]
         && 'r'==sqlite3UpperToLower[(unsigned char)argv[4][1]] ){
# 145787 "c_tests/sqlite3.c"
    int rc;
    u8 saved_iDb = db->init.iDb;
    sqlite3_stmt *pStmt;
                     ;

    ((void) (0));
    db->init.iDb = iDb;
    if( sqlite3GetUInt32(argv[3], &db->init.newTnum)==0
     || (db->init.newTnum>pData->mxPage && pData->mxPage>0)
    ){
      if( sqlite3Config.bExtraSchemaChecks ){
        corruptSchema(pData, argv, "invalid rootpage");
      }
    }
    db->init.orphanTrigger = 0;
    db->init.azInit = (const char**)argv;
    pStmt = 0;
                     sqlite3Prepare(db, argv[4], -1, 0, 0, &pStmt, 0);
    rc = db->errCode;
    ((void) (0));
    db->init.iDb = saved_iDb;

    if( 0!=rc ){
      if( db->init.orphanTrigger ){
        ((void) (0));
      }else{
        if( rc > pData->rc ) pData->rc = rc;
        if( rc==7 ){
          sqlite3OomFault(db);
        }else if( rc!=9 && (rc&0xFF)!=6 ){
          corruptSchema(pData, argv, sqlite3_errmsg(db));
        }
      }
    }
    db->init.azInit = sqlite3StdType;
    sqlite3_finalize(pStmt);
  }else if( argv[1]==0 || (argv[4]!=0 && argv[4][0]!=0) ){
    corruptSchema(pData, argv, 0);
  }else{






    Index *pIndex;
    pIndex = sqlite3FindIndex(db, argv[1], db->aDb[iDb].zDbSName);
    if( pIndex==0 ){
      corruptSchema(pData, argv, "orphan index");
    }else
    if( sqlite3GetUInt32(argv[3],&pIndex->tnum)==0
     || pIndex->tnum<2
     || pIndex->tnum>pData->mxPage
     || sqlite3IndexHasDuplicateRootPage(pIndex)
    ){
      if( sqlite3Config.bExtraSchemaChecks ){
        corruptSchema(pData, argv, "invalid rootpage");
      }
    }
  }
  return 0;
}
# 145858 "c_tests/sqlite3.c"
static int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg, u32 mFlags){
  int rc;
  int i;

  int size;

  Db *pDb;
  char const *azArg[6];
  int meta[5];
  InitData initData;
  const char *zSchemaTabName;
  int openedTransaction = 0;
  int mask = ((db->mDbFlags & 0x0040) | ~0x0040);

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  db->init.busy = 1;






  azArg[0] = "table";
  azArg[1] = zSchemaTabName = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");
  azArg[2] = azArg[1];
  azArg[3] = "1";
  azArg[4] = "CREATE TABLE x(type text,name text,tbl_name text,"
                            "rootpage int,sql text)";
  azArg[5] = 0;
  initData.db = db;
  initData.iDb = iDb;
  initData.rc = 0;
  initData.pzErrMsg = pzErrMsg;
  initData.mInitFlags = mFlags;
  initData.nInitRow = 0;
  initData.mxPage = 0;
  sqlite3InitCallback(&initData, 5, (char **)azArg, 0);
  db->mDbFlags &= mask;
  if( initData.rc ){
    rc = initData.rc;
    goto error_out;
  }



  pDb = &db->aDb[iDb];
  if( pDb->pBt==0 ){
    ((void) (0));
    (db)->aDb[1].pSchema->schemaFlags|=(0x0001);
    rc = 0;
    goto error_out;
  }




  sqlite3BtreeEnter(pDb->pBt);
  if( sqlite3BtreeTxnState(pDb->pBt)==0 ){
    rc = sqlite3BtreeBeginTrans(pDb->pBt, 0, 0);
    if( rc!=0 ){
      sqlite3SetString(pzErrMsg, db, sqlite3ErrStr(rc));
      goto initone_error_out;
    }
    openedTransaction = 1;
  }
# 145946 "c_tests/sqlite3.c"
  for(i=0; i<((int)(sizeof(meta)/sizeof(meta[0]))); i++){
    sqlite3BtreeGetMeta(pDb->pBt, i+1, (u32 *)&meta[i]);
  }
  if( (db->flags & 0x02000000)!=0 ){
    memset(meta, 0, sizeof(meta));
  }
  pDb->pSchema->schema_cookie = meta[1 -1];






  if( meta[5 -1] ){
    if( iDb==0 && (db->mDbFlags & 0x0040)==0 ){
      u8 encoding;


      encoding = (u8)meta[5 -1] & 3;
      if( encoding==0 ) encoding = 1;



      sqlite3SetTextEncoding(db, encoding);
    }else{

      if( (meta[5 -1] & 3)!=((db)->enc) ){
        sqlite3SetString(pzErrMsg, db, "attached databases must use the same"
            " text encoding as main database");
        rc = 1;
        goto initone_error_out;
      }
    }
  }
  pDb->pSchema->enc = ((db)->enc);

  if( pDb->pSchema->cache_size==0 ){

    size = sqlite3AbsInt32(meta[3 -1]);
    if( size==0 ){ size = -2000; }
    pDb->pSchema->cache_size = size;



    sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
  }







  pDb->pSchema->file_format = (u8)meta[2 -1];
  if( pDb->pSchema->file_format==0 ){
    pDb->pSchema->file_format = 1;
  }
  if( pDb->pSchema->file_format>4 ){
    sqlite3SetString(pzErrMsg, db, "unsupported file format");
    rc = 1;
    goto initone_error_out;
  }






  if( iDb==0 && meta[2 -1]>=4 ){
    db->flags &= ~(u64)0x00000002;
  }



  ((void) (0));
  initData.mxPage = sqlite3BtreeLastPage(pDb->pBt);
  {
    char *zSql;
    zSql = sqlite3MPrintf(db,
        "SELECT*FROM\"%w\".%s ORDER BY rowid",
        db->aDb[iDb].zDbSName, zSchemaTabName);

    {
      sqlite3_xauth xAuth;
      xAuth = db->xAuth;
      db->xAuth = 0;

      rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);

      db->xAuth = xAuth;
    }

    if( rc==0 ) rc = initData.rc;
    sqlite3DbFree(db, zSql);

    if( rc==0 ){
      sqlite3AnalysisLoad(db, iDb);
    }

  }
  ((void) (0));
  if( db->mallocFailed ){
    rc = 7;
    sqlite3ResetAllSchemasOfConnection(db);
    pDb = &db->aDb[iDb];
  }else
  if( rc==0 || ((db->flags&0x08000000) && rc!=7)){
# 146063 "c_tests/sqlite3.c"
    (db)->aDb[iDb].pSchema->schemaFlags|=(0x0001);
    rc = 0;
  }





initone_error_out:
  if( openedTransaction ){
    sqlite3BtreeCommit(pDb->pBt);
  }
  sqlite3BtreeLeave(pDb->pBt);

error_out:
  if( rc ){
    if( rc==7 || rc==(10 | (12<<8)) ){
      sqlite3OomFault(db);
    }
    sqlite3ResetOneSchema(db, iDb);
  }
  db->init.busy = 0;
  return rc;
}
# 146097 "c_tests/sqlite3.c"
static int sqlite3Init(sqlite3 *db, char **pzErrMsg){
  int i, rc;
  int commit_internal = !(db->mDbFlags&0x0001);

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((db)->enc) = ((db)->aDb[0].pSchema->enc);
  ((void) (0));

  if( !(((db)->aDb[0].pSchema->schemaFlags&(0x0001))==(0x0001)) ){
    rc = sqlite3InitOne(db, 0, pzErrMsg, 0);
    if( rc ) return rc;
  }

  for(i=db->nDb-1; i>0; i--){
    ((void) (0));
    if( !(((db)->aDb[i].pSchema->schemaFlags&(0x0001))==(0x0001)) ){
      rc = sqlite3InitOne(db, i, pzErrMsg, 0);
      if( rc ) return rc;
    }
  }
  if( commit_internal ){
    sqlite3CommitInternalChanges(db);
  }
  return 0;
}





static int sqlite3ReadSchema(Parse *pParse){
  int rc = 0;
  sqlite3 *db = pParse->db;
  ((void) (0));
  if( !db->init.busy ){
    rc = sqlite3Init(db, &pParse->zErrMsg);
    if( rc!=0 ){
      pParse->rc = rc;
      pParse->nErr++;
    }else if( db->noSharedCache ){
      db->mDbFlags |= 0x0010;
    }
  }
  return rc;
}







static void schemaIsValid(Parse *pParse){
  sqlite3 *db = pParse->db;
  int iDb;
  int rc;
  int cookie;

  ((void) (0));
  ((void) (0));
  for(iDb=0; iDb<db->nDb; iDb++){
    int openedTransaction = 0;
    Btree *pBt = db->aDb[iDb].pBt;
    if( pBt==0 ) continue;




    if( sqlite3BtreeTxnState(pBt)==0 ){
      rc = sqlite3BtreeBeginTrans(pBt, 0, 0);
      if( rc==7 || rc==(10 | (12<<8)) ){
        sqlite3OomFault(db);
        pParse->rc = 7;
      }
      if( rc!=0 ) return;
      openedTransaction = 1;
    }




    sqlite3BtreeGetMeta(pBt, 1, (u32 *)&cookie);
    ((void) (0));
    if( cookie!=db->aDb[iDb].pSchema->schema_cookie ){
      if( (((db)->aDb[iDb].pSchema->schemaFlags&(0x0001))==(0x0001)) ) pParse->rc = 17;
      sqlite3ResetOneSchema(db, iDb);
    }


    if( openedTransaction ){
      sqlite3BtreeCommit(pBt);
    }
  }
}
# 146201 "c_tests/sqlite3.c"
static int sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema){
  int i = -32768;
# 146215 "c_tests/sqlite3.c"
  ((void) (0));
  if( pSchema ){
    for(i=0; 1; i++){
      ((void) (0));
      if( db->aDb[i].pSchema==pSchema ){
        break;
      }
    }
    ((void) (0));
  }
  return i;
}




static void sqlite3ParseObjectReset(Parse *pParse){
  sqlite3 *db = pParse->db;
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pParse->aTableLock ) sqlite3DbNNFreeNN(db, pParse->aTableLock);

  while( pParse->pCleanup ){
    ParseCleanup *pCleanup = pParse->pCleanup;
    pParse->pCleanup = pCleanup->pNext;
    pCleanup->xCleanup(db, pCleanup->pPtr);
    sqlite3DbNNFreeNN(db, pCleanup);
  }
  if( pParse->aLabel ) sqlite3DbNNFreeNN(db, pParse->aLabel);
  if( pParse->pConstExpr ){
    sqlite3ExprListDelete(db, pParse->pConstExpr);
  }
  ((void) (0));
  db->lookaside.bDisable -= pParse->disableLookaside;
  db->lookaside.sz = db->lookaside.bDisable ? 0 : db->lookaside.szTrue;
  ((void) (0));
  db->pParse = pParse->pOuterParse;
}
# 146284 "c_tests/sqlite3.c"
static void *sqlite3ParserAddCleanup(
  Parse *pParse,
  void (*xCleanup)(sqlite3*,void*),
  void *pPtr
){
  ParseCleanup *pCleanup;
  if( sqlite3FaultSim(300) ){
    pCleanup = 0;
    sqlite3OomFault(pParse->db);
  }else{
    pCleanup = sqlite3DbMallocRaw(pParse->db, sizeof(*pCleanup));
  }
  if( pCleanup ){
    pCleanup->pNext = pParse->pCleanup;
    pParse->pCleanup = pCleanup;
    pCleanup->pPtr = pPtr;
    pCleanup->xCleanup = xCleanup;
  }else{
    xCleanup(pParse->db, pPtr);
    pPtr = 0;



  }
  return pPtr;
}
# 146320 "c_tests/sqlite3.c"
static void sqlite3ParseObjectInit(Parse *pParse, sqlite3 *db){
  memset((((char*)(pParse))+__builtin_offsetof(Parse, zErrMsg)), 0, (__builtin_offsetof(Parse, aTempReg)-__builtin_offsetof(Parse, zErrMsg)));
  memset((((char*)(pParse))+__builtin_offsetof(Parse, sLastToken)), 0, (sizeof(Parse)-__builtin_offsetof(Parse, sLastToken)));
  ((void) (0));
  pParse->pOuterParse = db->pParse;
  db->pParse = pParse;
  pParse->db = db;
  if( db->mallocFailed ) sqlite3ErrorMsg(pParse, "out of memory");
}
# 146341 "c_tests/sqlite3.c"
static int sqlite3Prepare(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  u32 prepFlags,
  Vdbe *pReprepare,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc = 0;
  int i;
  Parse sParse;


  memset((((char*)(&sParse))+__builtin_offsetof(Parse, zErrMsg)), 0, (__builtin_offsetof(Parse, aTempReg)-__builtin_offsetof(Parse, zErrMsg)));
  memset((((char*)(&sParse))+__builtin_offsetof(Parse, sLastToken)), 0, (sizeof(Parse)-__builtin_offsetof(Parse, sLastToken)));
  sParse.pOuterParse = db->pParse;
  db->pParse = &sParse;
  sParse.db = db;
  if( pReprepare ){
    sParse.pReprepare = pReprepare;
    sParse.explain = sqlite3_stmt_isexplain((sqlite3_stmt*)pReprepare);
  }else{
    ((void) (0));
  }
  ((void) (0));
  if( db->mallocFailed ){
    sqlite3ErrorMsg(&sParse, "out of memory");
    db->errCode = rc = 7;
    goto end_prepare;
  }
  ((void) (0));




  if( prepFlags & 0x01 ){
    sParse.disableLookaside++;
    db->lookaside.bDisable++;db->lookaside.sz=0;
  }
  sParse.prepFlags = prepFlags & 0xff;
# 146406 "c_tests/sqlite3.c"
  if( !db->noSharedCache ){
    for(i=0; i<db->nDb; i++) {
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        ((void) (0));
        rc = sqlite3BtreeSchemaLocked(pBt);
        if( rc ){
          const char *zDb = db->aDb[i].zDbSName;
          sqlite3ErrorWithMsg(db, rc, "database schema is locked: %s", zDb);
                                                     ;
          goto end_prepare;
        }
      }
    }
  }


  if( db->pDisconnect ) sqlite3VtabUnlockList(db);


  if( nBytes>=0 && (nBytes==0 || zSql[nBytes-1]!=0) ){
    char *zSqlCopy;
    int mxLen = db->aLimit[1];
                             ;
                               ;
    if( nBytes>mxLen ){
      sqlite3ErrorWithMsg(db, 18, "statement too long");
      rc = sqlite3ApiExit(db, 18);
      goto end_prepare;
    }
    zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);
    if( zSqlCopy ){
      sqlite3RunParser(&sParse, zSqlCopy);
      sParse.zTail = &zSql[sParse.zTail-zSqlCopy];
      sqlite3DbFree(db, zSqlCopy);
    }else{
      sParse.zTail = &zSql[nBytes];
    }
  }else{
    sqlite3RunParser(&sParse, zSql);
  }
  ((void) (0));

  if( pzTail ){
    *pzTail = sParse.zTail;
  }

  if( db->init.busy==0 ){
    sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail-zSql), prepFlags);
  }
  if( db->mallocFailed ){
    sParse.rc = 7;
    sParse.checkSchema = 0;
  }
  if( sParse.rc!=0 && sParse.rc!=101 ){
    if( sParse.checkSchema && db->init.busy==0 ){
      schemaIsValid(&sParse);
    }
    if( sParse.pVdbe ){
      sqlite3VdbeFinalize(sParse.pVdbe);
    }
    ((void) (0));
    rc = sParse.rc;
    if( sParse.zErrMsg ){
      sqlite3ErrorWithMsg(db, rc, "%s", sParse.zErrMsg);
      sqlite3DbFree(db, sParse.zErrMsg);
    }else{
      sqlite3Error(db, rc);
    }
  }else{
    ((void) (0));
    *ppStmt = (sqlite3_stmt*)sParse.pVdbe;
    rc = 0;
    sqlite3ErrorClear(db);
  }



  while( sParse.pTriggerPrg ){
    TriggerPrg *pT = sParse.pTriggerPrg;
    sParse.pTriggerPrg = pT->pNext;
    sqlite3DbFree(db, pT);
  }

end_prepare:

  sqlite3ParseObjectReset(&sParse);
  return rc;
}
static int sqlite3LockAndPrepare(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  u32 prepFlags,
  Vdbe *pOld,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc;
  int cnt = 0;




  *ppStmt = 0;
  if( !sqlite3SafetyCheckOk(db)||zSql==0 ){
    return sqlite3MisuseError(146512);
  }
  sqlite3_mutex_enter(db->mutex);
  sqlite3BtreeEnterAll(db);
  do{



    rc = sqlite3Prepare(db, zSql, nBytes, prepFlags, pOld, ppStmt, pzTail);
    ((void) (0));
    if( rc==0 || db->mallocFailed ) break;
    cnt++;
  }while( (rc==(1 | (2<<8)) && (cnt<=25))
       || (rc==17 && (sqlite3ResetOneSchema(db,-1), cnt)==1) );
  sqlite3BtreeLeaveAll(db);
  ((void) (0));
  rc = sqlite3ApiExit(db, rc);
  ((void) (0));
  db->busyHandler.nBusy = 0;
  sqlite3_mutex_leave(db->mutex);
  ((void) (0));
  return rc;
}
# 146545 "c_tests/sqlite3.c"
static int sqlite3Reprepare(Vdbe *p){
  int rc;
  sqlite3_stmt *pNew;
  const char *zSql;
  sqlite3 *db;
  u8 prepFlags;

  ((void) (0));
  zSql = sqlite3_sql((sqlite3_stmt *)p);
  ((void) (0));
  db = sqlite3VdbeDb(p);
  ((void) (0));
  prepFlags = sqlite3VdbePrepareFlags(p);
  rc = sqlite3LockAndPrepare(db, zSql, -1, prepFlags, p, &pNew, 0);
  if( rc ){
    if( rc==7 ){
      sqlite3OomFault(db);
    }
    ((void) (0));
    return rc;
  }else{
    ((void) (0));
  }
  sqlite3VdbeSwap((Vdbe*)pNew, p);
  sqlite3TransferBindings(pNew, (sqlite3_stmt*)p);
  sqlite3VdbeResetStepResult((Vdbe*)pNew);
  sqlite3VdbeFinalize((Vdbe*)pNew);
  return 0;
}
# 146584 "c_tests/sqlite3.c"
           int sqlite3_prepare(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc;
  rc = sqlite3LockAndPrepare(db,zSql,nBytes,0,0,ppStmt,pzTail);
  ((void) (0));
  return rc;
}
           int sqlite3_prepare_v2(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc;





  rc = sqlite3LockAndPrepare(db,zSql,nBytes,0x80,0,
                             ppStmt,pzTail);
  ((void) (0));
  return rc;
}
           int sqlite3_prepare_v3(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  unsigned int prepFlags,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc;







  rc = sqlite3LockAndPrepare(db,zSql,nBytes,
                 0x80|(prepFlags&0x1f),
                 0,ppStmt,pzTail);
  ((void) (0));
  return rc;
}






static int sqlite3Prepare16(
  sqlite3 *db,
  const void *zSql,
  int nBytes,
  u32 prepFlags,
  sqlite3_stmt **ppStmt,
  const void **pzTail
){




  char *zSql8;
  const char *zTail8 = 0;
  int rc = 0;




  *ppStmt = 0;
  if( !sqlite3SafetyCheckOk(db)||zSql==0 ){
    return sqlite3MisuseError(146663);
  }






  if( nBytes>=0 ){
    int sz;
    const char *z = (const char*)zSql;
    for(sz=0; sz<nBytes && (z[sz]!=0 || z[sz+1]!=0); sz += 2){}
    nBytes = sz;
  }else{
    int sz;
    const char *z = (const char*)zSql;
    for(sz=0; z[sz]!=0 || z[sz+1]!=0; sz += 2){}
    nBytes = sz;
  }

  sqlite3_mutex_enter(db->mutex);
  zSql8 = sqlite3Utf16to8(db, zSql, nBytes, 2);
  if( zSql8 ){
    rc = sqlite3LockAndPrepare(db, zSql8, -1, prepFlags, 0, ppStmt, &zTail8);
  }

  if( zTail8 && pzTail ){





    int chars_parsed = sqlite3Utf8CharLen(zSql8, (int)(zTail8-zSql8));
    *pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, nBytes, chars_parsed);
  }
  sqlite3DbFree(db, zSql8);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 146712 "c_tests/sqlite3.c"
           int sqlite3_prepare16(
  sqlite3 *db,
  const void *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const void **pzTail
){
  int rc;
  rc = sqlite3Prepare16(db,zSql,nBytes,0,ppStmt,pzTail);
  ((void) (0));
  return rc;
}
           int sqlite3_prepare16_v2(
  sqlite3 *db,
  const void *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const void **pzTail
){
  int rc;
  rc = sqlite3Prepare16(db,zSql,nBytes,0x80,ppStmt,pzTail);
  ((void) (0));
  return rc;
}
           int sqlite3_prepare16_v3(
  sqlite3 *db,
  const void *zSql,
  int nBytes,
  unsigned int prepFlags,
  sqlite3_stmt **ppStmt,
  const void **pzTail
){
  int rc;
  rc = sqlite3Prepare16(db,zSql,nBytes,
         0x80|(prepFlags&0x1f),
         ppStmt,pzTail);
  ((void) (0));
  return rc;
}
# 146777 "c_tests/sqlite3.c"
typedef struct DistinctCtx DistinctCtx;
struct DistinctCtx {
  u8 isTnct;
  u8 eTnctType;
  int tabTnct;
  int addrTnct;
};
# 146803 "c_tests/sqlite3.c"
typedef struct SortCtx SortCtx;
struct SortCtx {
  ExprList *pOrderBy;
  int nOBSat;
  int iECursor;
  int regReturn;
  int labelBkOut;
  int addrSortIndex;
  int labelDone;
  int labelOBLopt;
  u8 sortFlags;
# 146822 "c_tests/sqlite3.c"
  struct RowLoadInfo *pDeferredRowLoad;




};
# 146837 "c_tests/sqlite3.c"
static void clearSelect(sqlite3 *db, Select *p, int bFree){
  ((void) (0));
  while( p ){
    Select *pPrior = p->pPrior;
    sqlite3ExprListDelete(db, p->pEList);
    sqlite3SrcListDelete(db, p->pSrc);
    sqlite3ExprDelete(db, p->pWhere);
    sqlite3ExprListDelete(db, p->pGroupBy);
    sqlite3ExprDelete(db, p->pHaving);
    sqlite3ExprListDelete(db, p->pOrderBy);
    sqlite3ExprDelete(db, p->pLimit);
    if( (p->pWith) ) sqlite3WithDelete(db, p->pWith);

    if( (p->pWinDefn) ){
      sqlite3WindowListDelete(db, p->pWinDefn);
    }
    while( p->pWin ){
      ((void) (0));
      sqlite3WindowUnlinkFromSelect(p->pWin);
    }

    if( bFree ) sqlite3DbNNFreeNN(db, p);
    p = pPrior;
    bFree = 1;
  }
}




static void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){
  pDest->eDest = (u8)eDest;
  pDest->iSDParm = iParm;
  pDest->iSDParm2 = 0;
  pDest->zAffSdst = 0;
  pDest->iSdst = 0;
  pDest->nSdst = 0;
}






static Select *sqlite3SelectNew(
  Parse *pParse,
  ExprList *pEList,
  SrcList *pSrc,
  Expr *pWhere,
  ExprList *pGroupBy,
  Expr *pHaving,
  ExprList *pOrderBy,
  u32 selFlags,
  Expr *pLimit
){
  Select *pNew, *pAllocated;
  Select standin;
  pAllocated = pNew = sqlite3DbMallocRawNN(pParse->db, sizeof(*pNew) );
  if( pNew==0 ){
    ((void) (0));
    pNew = &standin;
  }
  if( pEList==0 ){
    pEList = sqlite3ExprListAppend(pParse, 0,
                                   sqlite3Expr(pParse->db,180,0));
  }
  pNew->pEList = pEList;
  pNew->op = 139;
  pNew->selFlags = selFlags;
  pNew->iLimit = 0;
  pNew->iOffset = 0;
  pNew->selId = ++pParse->nSelect;
  pNew->addrOpenEphm[0] = -1;
  pNew->addrOpenEphm[1] = -1;
  pNew->nSelectRow = 0;
  if( pSrc==0 ) pSrc = sqlite3DbMallocZero(pParse->db, (__builtin_offsetof(SrcList, a)+sizeof(SrcItem)));
  pNew->pSrc = pSrc;
  pNew->pWhere = pWhere;
  pNew->pGroupBy = pGroupBy;
  pNew->pHaving = pHaving;
  pNew->pOrderBy = pOrderBy;
  pNew->pPrior = 0;
  pNew->pNext = 0;
  pNew->pLimit = pLimit;
  pNew->pWith = 0;

  pNew->pWin = 0;
  pNew->pWinDefn = 0;

  if( pParse->db->mallocFailed ) {
    clearSelect(pParse->db, pNew, pNew!=&standin);
    pAllocated = 0;
  }else{
    ((void) (0));
  }
  return pAllocated;
}





static void sqlite3SelectDelete(sqlite3 *db, Select *p){
  if( (p) ) clearSelect(db, p, 1);
}
static void sqlite3SelectDeleteGeneric(sqlite3 *db, void *p){
  if( (p) ) clearSelect(db, (Select*)p, 1);
}




static Select *findRightmost(Select *p){
  while( p->pNext ) p = p->pNext;
  return p;
}
# 147017 "c_tests/sqlite3.c"
static int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){
  int jointype = 0;
  Token *apAll[3];
  Token *p;

  static const char zKeyText[] = "naturaleftouterightfullinnercross";
  static const struct {
    u8 i;
    u8 nChar;
    u8 code;
  } aKeyword[] = {
                      { 0, 7, 0x04 },
                      { 6, 4, 0x08|0x20 },
                      { 10, 5, 0x20 },
                      { 14, 5, 0x10|0x20 },
                      { 19, 4, 0x08|0x10|0x20 },
                      { 23, 5, 0x01 },
                      { 28, 5, 0x01|0x02 },
  };
  int i, j;
  apAll[0] = pA;
  apAll[1] = pB;
  apAll[2] = pC;
  for(i=0; i<3 && apAll[i]; i++){
    p = apAll[i];
    for(j=0; j<((int)(sizeof(aKeyword)/sizeof(aKeyword[0]))); j++){
      if( p->n==aKeyword[j].nChar
          && sqlite3_strnicmp((char*)p->z, &zKeyText[aKeyword[j].i], p->n)==0 ){
        jointype |= aKeyword[j].code;
        break;
      }
    }
                                                                    ;
    if( j>=((int)(sizeof(aKeyword)/sizeof(aKeyword[0]))) ){
      jointype |= 0x80;
      break;
    }
  }
  if(
     (jointype & (0x01|0x20))==(0x01|0x20) ||
     (jointype & 0x80)!=0 ||
     (jointype & (0x20|0x08|0x10))==0x20
  ){
    const char *zSp1 = " ";
    const char *zSp2 = " ";
    if( pB==0 ){ zSp1++; }
    if( pC==0 ){ zSp2++; }
    sqlite3ErrorMsg(pParse, "unknown join type: "
       "%T%s%T%s%T", pA, zSp1, pB, zSp2, pC);
    jointype = 0x01;
  }
  return jointype;
}





static int sqlite3ColumnIndex(Table *pTab, const char *zCol){
  int i;
  u8 h;
  const Column *aCol;
  int nCol;

  h = sqlite3StrIHash(zCol);
  aCol = pTab->aCol;
  nCol = pTab->nCol;


  i = pTab->aHx[h % sizeof(pTab->aHx)];
  ((void) (0));
  if( aCol[i].hName==h
   && sqlite3StrICmp(aCol[i].zCnName, zCol)==0
  ){
    return i;
  }


  i = 0;
  while( 1 ){
    if( aCol[i].hName==h
     && sqlite3StrICmp(aCol[i].zCnName, zCol)==0
    ){
      return i;
    }
    i++;
    if( i>=nCol ) break;
  }
  return -1;
}




static void sqlite3SrcItemColumnUsed(SrcItem *pItem, int iCol){
  ((void) (0));
  ((void) (0));
  if( pItem->fg.isNestedFrom ){
    ExprList *pResults;
    ((void) (0));
    ((void) (0));
    ((void) (0));
    pResults = pItem->u4.pSubq->pSelect->pEList;
    ((void) (0));
    ((void) (0));
    pResults->a[iCol].fg.bUsed = 1;
  }
}
# 147136 "c_tests/sqlite3.c"
static int tableAndColumnIndex(
  SrcList *pSrc,
  int iStart,
  int iEnd,
  const char *zCol,
  int *piTab,
  int *piCol,
  int bIgnoreHidden
){
  int i;
  int iCol;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  for(i=iStart; i<=iEnd; i++){
    iCol = sqlite3ColumnIndex(pSrc->a[i].pSTab, zCol);
    if( iCol>=0
     && (bIgnoreHidden==0 || (((&pSrc->a[i].pSTab->aCol[iCol])->colFlags & 0x0002)!=0)==0)
    ){
      if( piTab ){
        sqlite3SrcItemColumnUsed(&pSrc->a[i], iCol);
        *piTab = i;
        *piCol = iCol;
      }
      return 1;
    }
  }
  return 0;
}
# 147194 "c_tests/sqlite3.c"
static void sqlite3SetJoinExpr(Expr *p, int iTable, u32 joinFlag){
  ((void) (0));
  while( p ){
    (p)->flags|=(u32)(joinFlag);
    ((void) (0));
                                      ;
    p->w.iJoin = iTable;
    if( (((p)->flags&0x001000)==0) ){
      if( p->x.pList ){
        int i;
        for(i=0; i<p->x.pList->nExpr; i++){
          sqlite3SetJoinExpr(p->x.pList->a[i].pExpr, iTable, joinFlag);
        }
      }
    }
    sqlite3SetJoinExpr(p->pLeft, iTable, joinFlag);
    p = p->pRight;
  }
}
# 147228 "c_tests/sqlite3.c"
static void unsetJoinExpr(Expr *p, int iTable, int nullable){
  while( p ){
    if( iTable<0 || ((((p)->flags&(u32)(0x000001))!=0) && p->w.iJoin==iTable) ){
      (p)->flags&=~(u32)(0x000001|0x000002);
      if( iTable>=0 ) (p)->flags|=(u32)(0x000002);
    }
    if( p->op==168 && p->iTable==iTable && !nullable ){
      (p)->flags&=~(u32)(0x200000);
    }
    if( p->op==172 ){
      ((void) (0));
      ((void) (0));
      if( p->x.pList ){
        int i;
        for(i=0; i<p->x.pList->nExpr; i++){
          unsetJoinExpr(p->x.pList->a[i].pExpr, iTable, nullable);
        }
      }
    }
    unsetJoinExpr(p->pLeft, iTable, nullable);
    p = p->pRight;
  }
}
# 147273 "c_tests/sqlite3.c"
static int sqlite3ProcessJoin(Parse *pParse, Select *p){
  SrcList *pSrc;
  int i, j;
  SrcItem *pLeft;
  SrcItem *pRight;

  pSrc = p->pSrc;
  pLeft = &pSrc->a[0];
  pRight = &pLeft[1];
  for(i=0; i<pSrc->nSrc-1; i++, pRight++, pLeft++){
    Table *pRightTab = pRight->pSTab;
    u32 joinType;

    if( (pLeft->pSTab==0 || pRightTab==0) ) continue;
    joinType = (pRight->fg.jointype & 0x20)!=0 ? 0x000001 : 0x000002;




    if( pRight->fg.jointype & 0x04 ){
      IdList *pUsing = 0;
      if( pRight->fg.isUsing || pRight->u3.pOn ){
        sqlite3ErrorMsg(pParse, "a NATURAL join may not have "
           "an ON or USING clause", 0);
        return 1;
      }
      for(j=0; j<pRightTab->nCol; j++){
        char *zName;

        if( (((&pRightTab->aCol[j])->colFlags & 0x0002)!=0) ) continue;
        zName = pRightTab->aCol[j].zCnName;
        if( tableAndColumnIndex(pSrc, 0, i, zName, 0, 0, 1) ){
          pUsing = sqlite3IdListAppend(pParse, pUsing, 0);
          if( pUsing ){
            ((void) (0));
            ((void) (0));
            pUsing->a[pUsing->nId-1].zName = sqlite3DbStrDup(pParse->db, zName);
          }
        }
      }
      if( pUsing ){
        pRight->fg.isUsing = 1;
        pRight->fg.isSynthUsing = 1;
        pRight->u3.pUsing = pUsing;
      }
      if( pParse->nErr ) return 1;
    }
# 147328 "c_tests/sqlite3.c"
    if( pRight->fg.isUsing ){
      IdList *pList = pRight->u3.pUsing;
      sqlite3 *db = pParse->db;
      ((void) (0));
      for(j=0; j<pList->nId; j++){
        char *zName;
        int iLeft;
        int iLeftCol;
        int iRightCol;
        Expr *pE1;
        Expr *pE2;
        Expr *pEq;

        zName = pList->a[j].zName;
        iRightCol = sqlite3ColumnIndex(pRightTab, zName);
        if( iRightCol<0
         || tableAndColumnIndex(pSrc, 0, i, zName, &iLeft, &iLeftCol,
                                pRight->fg.isSynthUsing)==0
        ){
          sqlite3ErrorMsg(pParse, "cannot join using column %s - column "
            "not present in both tables", zName);
          return 1;
        }
        pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iLeftCol);
        sqlite3SrcItemColumnUsed(&pSrc->a[iLeft], iLeftCol);
        if( (pSrc->a[0].fg.jointype & 0x40)!=0 && pParse->nErr==0 ){
# 147367 "c_tests/sqlite3.c"
          ExprList *pFuncArgs = 0;
          static const Token tkCoalesce = { "coalesce", 8 };
          ((void) (0));
          (pE1)->flags|=(u32)(0x200000);
          while( tableAndColumnIndex(pSrc, iLeft+1, i, zName, &iLeft, &iLeftCol,
                                     pRight->fg.isSynthUsing)!=0 ){
            if( pSrc->a[iLeft].fg.isUsing==0
             || sqlite3IdListIndex(pSrc->a[iLeft].u3.pUsing, zName)<0
            ){
              sqlite3ErrorMsg(pParse, "ambiguous reference to %s in USING()",
                              zName);
              break;
            }
            pFuncArgs = sqlite3ExprListAppend(pParse, pFuncArgs, pE1);
            pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iLeftCol);
            sqlite3SrcItemColumnUsed(&pSrc->a[iLeft], iLeftCol);
          }
          if( pFuncArgs ){
            pFuncArgs = sqlite3ExprListAppend(pParse, pFuncArgs, pE1);
            pE1 = sqlite3ExprFunction(pParse, pFuncArgs, &tkCoalesce, 0);
            if( pE1 ){
              pE1->affExpr = 0x58;
            }
          }
        }else if( (pSrc->a[i+1].fg.jointype & 0x08)!=0 && pParse->nErr==0 ){
          ((void) (0));
          (pE1)->flags|=(u32)(0x200000);
        }
        pE2 = sqlite3CreateColumnExpr(db, pSrc, i+1, iRightCol);
        sqlite3SrcItemColumnUsed(pRight, iRightCol);
        pEq = sqlite3PExpr(pParse, 54, pE1, pE2);
        ((void) (0));
        if( pEq ){
          (pEq)->flags|=(u32)(joinType);
          ((void) (0));
                                              ;
          pEq->w.iJoin = pE2->iTable;
        }
        p->pWhere = sqlite3ExprAnd(pParse, p->pWhere, pEq);
      }
    }




    else if( pRight->u3.pOn ){
      sqlite3SetJoinExpr(pRight->u3.pOn, pRight->iCursor, joinType);
      p->pWhere = sqlite3ExprAnd(pParse, p->pWhere, pRight->u3.pOn);
      pRight->u3.pOn = 0;
      pRight->fg.isOn = 1;
      p->selFlags |= 0x40000000;
    }
  }
  return 0;
}





typedef struct RowLoadInfo RowLoadInfo;
struct RowLoadInfo {
  int regResult;
  u8 ecelFlags;




};





static void innerLoopLoadRow(
  Parse *pParse,
  Select *pSelect,
  RowLoadInfo *pInfo
){
  sqlite3ExprCodeExprList(pParse, pSelect->pEList, pInfo->regResult,
                          0, pInfo->ecelFlags);






}







static int makeSorterRecord(
  Parse *pParse,
  SortCtx *pSort,
  Select *pSelect,
  int regBase,
  int nBase
){
  int nOBSat = pSort->nOBSat;
  Vdbe *v = pParse->pVdbe;
  int regOut = ++pParse->nMem;
  if( pSort->pDeferredRowLoad ){
    innerLoopLoadRow(pParse, pSelect, pSort->pDeferredRowLoad);
  }
  sqlite3VdbeAddOp3(v, 98, regBase+nOBSat, nBase-nOBSat, regOut);
  return regOut;
}





static void pushOntoSorter(
  Parse *pParse,
  SortCtx *pSort,
  Select *pSelect,
  int regData,
  int regOrigData,
  int nData,
  int nPrefixReg
){
  Vdbe *v = pParse->pVdbe;
  int bSeq = ((pSort->sortFlags & 0x01)==0);
  int nExpr = pSort->pOrderBy->nExpr;
  int nBase = nExpr + bSeq + nData;
  int regBase;
  int regRecord = 0;
  int nOBSat = pSort->nOBSat;
  int op;
  int iLimit;
  int iSkip = 0;

  ((void) (0));
# 147518 "c_tests/sqlite3.c"
  ((void) (0));





  if( nPrefixReg ){
    ((void) (0));
    regBase = regData - nPrefixReg;
  }else{
    regBase = pParse->nMem + 1;
    pParse->nMem += nBase;
  }
  ((void) (0));
  iLimit = pSelect->iOffset ? pSelect->iOffset+1 : pSelect->iLimit;
  pSort->labelDone = sqlite3VdbeMakeLabel(pParse);
  sqlite3ExprCodeExprList(pParse, pSort->pOrderBy, regBase, regOrigData,
                          0x01 | (regOrigData? 0x04 : 0));
  if( bSeq ){
    sqlite3VdbeAddOp2(v, 127, pSort->iECursor, regBase+nExpr);
  }
  if( nPrefixReg==0 && nData>0 ){
    sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+bSeq, nData);
  }
  if( nOBSat>0 ){
    int regPrevKey;
    int addrFirst;
    int addrJmp;
    VdbeOp *pOp;
    int nKey;
    KeyInfo *pKI;

    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);
    regPrevKey = pParse->nMem+1;
    pParse->nMem += pSort->nOBSat;
    nKey = nExpr - pSort->nOBSat + bSeq;
    if( bSeq ){
      addrFirst = sqlite3VdbeAddOp1(v, 17, regBase+nExpr);
    }else{
      addrFirst = sqlite3VdbeAddOp1(v, 121, pSort->iECursor);
    }
                   ;
    sqlite3VdbeAddOp3(v, 91, regPrevKey, regBase, pSort->nOBSat);
    pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);
    if( pParse->db->mallocFailed ) return;
    pOp->p2 = nKey + nData;
    pKI = pOp->p4.pKeyInfo;
    memset(pKI->aSortFlags, 0, pKI->nKeyField);
    sqlite3VdbeChangeP4(v, -1, (char*)pKI, (-8));
                                                 ;
    pOp->p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pSort->pOrderBy,nOBSat,
                                           pKI->nAllField-pKI->nKeyField-1);
    pOp = 0;
    addrJmp = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp3(v, 14, addrJmp+1, 0, addrJmp+1); ;
    pSort->labelBkOut = sqlite3VdbeMakeLabel(pParse);
    pSort->regReturn = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 10, pSort->regReturn, pSort->labelBkOut);
    sqlite3VdbeAddOp1(v, 147, pSort->iECursor);
    if( iLimit ){
      sqlite3VdbeAddOp2(v, 17, iLimit, pSort->labelDone);
                     ;
    }
    sqlite3VdbeJumpHere(v, addrFirst);
    sqlite3ExprCodeMove(pParse, regBase, regPrevKey, pSort->nOBSat);
    sqlite3VdbeJumpHere(v, addrJmp);
  }
  if( iLimit ){
# 147601 "c_tests/sqlite3.c"
    int iCsr = pSort->iECursor;
    sqlite3VdbeAddOp2(v, 61, iLimit, sqlite3VdbeCurrentAddr(v)+4);
                   ;
    sqlite3VdbeAddOp2(v, 32, iCsr, 0);
    iSkip = sqlite3VdbeAddOp4Int(v, 41,
                                 iCsr, 0, regBase+nOBSat, nExpr-nOBSat);
                   ;
    sqlite3VdbeAddOp1(v, 131, iCsr);
  }
  if( regRecord==0 ){
    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);
  }
  if( pSort->sortFlags & 0x01 ){
    op = 140;
  }else{
    op = 139;
  }
  sqlite3VdbeAddOp4Int(v, op, pSort->iECursor, regRecord,
                       regBase+nOBSat, nBase-nOBSat);
  if( iSkip ){
    sqlite3VdbeChangeP2(v, iSkip,
         pSort->labelOBLopt ? pSort->labelOBLopt : sqlite3VdbeCurrentAddr(v));
  }



}




static void codeOffset(
  Vdbe *v,
  int iOffset,
  int iContinue
){
  if( iOffset>0 ){
    sqlite3VdbeAddOp3(v, 60, iOffset, iContinue, 1); ;
                              ;
  }
}
# 147686 "c_tests/sqlite3.c"
static int codeDistinct(
  Parse *pParse,
  int eTnctType,
  int iTab,
  int addrRepeat,
  ExprList *pEList,
  int regElem
){
  int iRet = 0;
  int nResultCol = pEList->nExpr;
  Vdbe *v = pParse->pVdbe;

  switch( eTnctType ){
    case 2: {
      int i;
      int iJump;
      int regPrev;


      iRet = regPrev = pParse->nMem+1;
      pParse->nMem += nResultCol;

      iJump = sqlite3VdbeCurrentAddr(v) + nResultCol;
      for(i=0; i<nResultCol; i++){
        CollSeq *pColl = sqlite3ExprCollSeq(pParse, pEList->a[i].pExpr);
        if( i<nResultCol-1 ){
          sqlite3VdbeAddOp3(v, 53, regElem+i, iJump, regPrev+i);
                         ;
        }else{
          sqlite3VdbeAddOp3(v, 54, regElem+i, addrRepeat, regPrev+i);
                         ;
         }
        sqlite3VdbeChangeP4(v, -1, (const char *)pColl, (-2));
        sqlite3VdbeChangeP5(v, 0x80);
      }
      ((void) (0));
      sqlite3VdbeAddOp3(v, 81, regElem, regPrev, nResultCol-1);
      break;
    }

    case 1: {

      break;
    }

    default: {
      int r1 = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp4Int(v, 29, iTab, addrRepeat, regElem, nResultCol);
                     ;
      sqlite3VdbeAddOp3(v, 98, regElem, nResultCol, r1);
      sqlite3VdbeAddOp4Int(v, 139, iTab, r1, regElem, nResultCol);
      sqlite3VdbeChangeP5(v, 0x10);
      sqlite3ReleaseTempReg(pParse, r1);
      iRet = iTab;
      break;
    }
  }

  return iRet;
}
# 147770 "c_tests/sqlite3.c"
static void fixDistinctOpenEph(
  Parse *pParse,
  int eTnctType,
  int iVal,
  int iOpenEphAddr
){
  if( pParse->nErr==0
   && (eTnctType==1 || eTnctType==2)
  ){
    Vdbe *v = pParse->pVdbe;
    sqlite3VdbeChangeToNoop(v, iOpenEphAddr);
    if( sqlite3VdbeGetOp(v, iOpenEphAddr+1)->opcode==189 ){
      sqlite3VdbeChangeToNoop(v, iOpenEphAddr+1);
    }
    if( eTnctType==2 ){




      VdbeOp *pOp = sqlite3VdbeGetOp(v, iOpenEphAddr);
      pOp->opcode = 76;
      pOp->p1 = 1;
      pOp->p2 = iVal;
    }
  }
}
# 147892 "c_tests/sqlite3.c"
static void selectInnerLoop(
  Parse *pParse,
  Select *p,
  int srcTab,
  SortCtx *pSort,
  DistinctCtx *pDistinct,
  SelectDest *pDest,
  int iContinue,
  int iBreak
){
  Vdbe *v = pParse->pVdbe;
  int i;
  int hasDistinct;
  int eDest = pDest->eDest;
  int iParm = pDest->iSDParm;
  int nResultCol;
  int nPrefixReg = 0;
  RowLoadInfo sRowLoadInfo;






  int regResult;
  int regOrig;

  ((void) (0));
  ((void) (0));
  hasDistinct = pDistinct ? pDistinct->eTnctType : 0;
  if( pSort && pSort->pOrderBy==0 ) pSort = 0;
  if( pSort==0 && !hasDistinct ){
    ((void) (0));
    codeOffset(v, p->iOffset, iContinue);
  }



  nResultCol = p->pEList->nExpr;

  if( pDest->iSdst==0 ){
    if( pSort ){
      nPrefixReg = pSort->pOrderBy->nExpr;
      if( !(pSort->sortFlags & 0x01) ) nPrefixReg++;
      pParse->nMem += nPrefixReg;
    }
    pDest->iSdst = pParse->nMem+1;
    pParse->nMem += nResultCol;
  }else if( pDest->iSdst+nResultCol > pParse->nMem ){





    pParse->nMem += nResultCol;
  }
  pDest->nSdst = nResultCol;
  regOrig = regResult = pDest->iSdst;
  if( srcTab>=0 ){
    for(i=0; i<nResultCol; i++){
      sqlite3VdbeAddOp3(v, 95, srcTab, i, regResult+i);
                                                    ;
    }
  }else if( eDest!=3 ){






    u8 ecelFlags;
    ExprList *pEList;
    if( eDest==10 || eDest==9 || eDest==13 ){
      ecelFlags = 0x01;
    }else{
      ecelFlags = 0;
    }
    if( pSort && hasDistinct==0 && eDest!=12 && eDest!=14 ){






      ecelFlags |= (0x08|0x04);

      for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++){
        int j;
        if( (j = pSort->pOrderBy->a[i].u.x.iOrderByCol)>0 ){
          p->pEList->a[j-1].u.x.iOrderByCol = i+1-pSort->nOBSat;
        }
      }
# 148001 "c_tests/sqlite3.c"
      pEList = p->pEList;
      for(i=0; i<pEList->nExpr; i++){
        if( pEList->a[i].u.x.iOrderByCol>0



        ){
          nResultCol--;
          regOrig = 0;
        }
      }

                         ;
                                ;
                                ;
                                      ;
                                   ;
      ((void) (0));


    }
    sRowLoadInfo.regResult = regResult;
    sRowLoadInfo.ecelFlags = ecelFlags;





    if( p->iLimit
     && (ecelFlags & 0x08)!=0
     && nPrefixReg>0
    ){
      ((void) (0));
      ((void) (0));
      pSort->pDeferredRowLoad = &sRowLoadInfo;
      regOrig = 0;
    }else{
      innerLoopLoadRow(pParse, p, &sRowLoadInfo);
    }
  }





  if( hasDistinct ){
    int eType = pDistinct->eTnctType;
    int iTab = pDistinct->tabTnct;
    ((void) (0));
    iTab = codeDistinct(pParse, eType, iTab, iContinue, p->pEList, regResult);
    fixDistinctOpenEph(pParse, eType, iTab, pDistinct->addrTnct);
    if( pSort==0 ){
      codeOffset(v, p->iOffset, iContinue);
    }
  }

  switch( eDest ){




    case 1: {
      int r1;
      r1 = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp3(v, 98, regResult, nResultCol, r1);
      sqlite3VdbeAddOp4Int(v, 139, iParm, r1, regResult, nResultCol);
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }





    case 2: {
      sqlite3VdbeAddOp3(v, 141, iParm, regResult, nResultCol);
      break;
    }




    case 8:
    case 5:
    case 14:
    case 12: {
      int r1 = sqlite3GetTempRange(pParse, nPrefixReg+1);
                                  ;
                                     ;
                                 ;
                                     ;
      sqlite3VdbeAddOp3(v, 98, regResult, nResultCol, r1+nPrefixReg);
# 148104 "c_tests/sqlite3.c"
      if( eDest==5 ){





        int addr = sqlite3VdbeCurrentAddr(v) + 4;
        sqlite3VdbeAddOp4Int(v, 29, iParm+1, addr, r1, 0);
                       ;
        sqlite3VdbeAddOp4Int(v, 139, iParm+1, r1,regResult,nResultCol);
        ((void) (0));
      }

      if( pSort ){
        ((void) (0));
        pushOntoSorter(pParse, pSort, p, r1+nPrefixReg, regOrig, 1, nPrefixReg);
      }else{
        int r2 = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp2(v, 128, iParm, r2);
        sqlite3VdbeAddOp3(v, 129, iParm, r1, r2);
        sqlite3VdbeChangeP5(v, 0x08);
        sqlite3ReleaseTempReg(pParse, r2);
      }
      sqlite3ReleaseTempRange(pParse, r1, nPrefixReg+1);
      break;
    }

    case 15: {
      if( pSort ){
        pushOntoSorter(
            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);
      }else{
        int i2 = pDest->iSDParm2;
        int r1 = sqlite3GetTempReg(pParse);




        sqlite3VdbeAddOp2(v, 51, regResult, iBreak); ;

        sqlite3VdbeAddOp3(v, 98,
                          regResult+(i2<0), nResultCol-(i2<0), r1);
        if( i2<0 ){
          sqlite3VdbeAddOp3(v, 129, iParm, r1, regResult);
        }else{
          sqlite3VdbeAddOp4Int(v, 139, iParm, r1, regResult, i2);
        }
      }
      break;
    }






    case 11: {
      if( pSort ){




        pushOntoSorter(
            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);
        pDest->iSDParm2 = 0;
      }else{
        int r1 = sqlite3GetTempReg(pParse);
        ((void) (0));
        sqlite3VdbeAddOp4(v, 98, regResult, nResultCol,
            r1, pDest->zAffSdst, nResultCol);
        sqlite3VdbeAddOp4Int(v, 139, iParm, r1, regResult, nResultCol);
        if( pDest->iSDParm2 ){
          sqlite3VdbeAddOp4Int(v, 184, pDest->iSDParm2, 0,
                               regResult, nResultCol);
          sqlite3VdbeExplain (pParse, 0, "CREATE BLOOM FILTER");
        }
        sqlite3ReleaseTempReg(pParse, r1);
      }
      break;
    }




    case 3: {
      sqlite3VdbeAddOp2(v, 72, 1, iParm);

      break;
    }





    case 10: {
      if( pSort ){
        ((void) (0));
        pushOntoSorter(
            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);
        pDest->iSDParm = regResult;
      }else{
        ((void) (0));
        if( regResult!=iParm ){


          sqlite3VdbeAddOp3(v, 81, regResult, iParm, nResultCol-1);
        }

      }
      break;
    }


    case 13:
    case 9: {
                                      ;
                                   ;
      if( pSort ){
        pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol,
                       nPrefixReg);
      }else if( eDest==13 ){
        sqlite3VdbeAddOp1(v, 12, pDest->iSDParm);
      }else{
        sqlite3VdbeAddOp2(v, 85, regResult, nResultCol);
      }
      break;
    }
# 148239 "c_tests/sqlite3.c"
    case 6:
    case 7: {
      int nKey;
      int r1, r2, r3;
      int addrTest = 0;
      ExprList *pSO;
      pSO = pDest->pOrderBy;
      ((void) (0));
      nKey = pSO->nExpr;
      r1 = sqlite3GetTempReg(pParse);
      r2 = sqlite3GetTempRange(pParse, nKey+2);
      r3 = r2+nKey+1;
      if( eDest==6 ){



        addrTest = sqlite3VdbeAddOp4Int(v, 29, iParm+1, 0,
                                        regResult, nResultCol);
                       ;
      }
      sqlite3VdbeAddOp3(v, 98, regResult, nResultCol, r3);
      if( eDest==6 ){
        sqlite3VdbeAddOp2(v, 139, iParm+1, r3);
        sqlite3VdbeChangeP5(v, 0x10);
      }
      for(i=0; i<nKey; i++){
        sqlite3VdbeAddOp2(v, 82,
                          regResult + pSO->a[i].u.x.iOrderByCol - 1,
                          r2+i);
      }
      sqlite3VdbeAddOp2(v, 127, iParm, r2+nKey);
      sqlite3VdbeAddOp3(v, 98, r2, nKey+2, r1);
      sqlite3VdbeAddOp4Int(v, 139, iParm, r1, r2, nKey+2);
      if( addrTest ) sqlite3VdbeJumpHere(v, addrTest);
      sqlite3ReleaseTempReg(pParse, r1);
      sqlite3ReleaseTempRange(pParse, r2, nKey+2);
      break;
    }
# 148287 "c_tests/sqlite3.c"
    default: {
      ((void) (0));
      break;
    }

  }





  if( pSort==0 && p->iLimit ){
    sqlite3VdbeAddOp2(v, 62, p->iLimit, iBreak); ;
  }
}





static KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){
  int nExtra = (N+X)*(sizeof(CollSeq*)+1);
  KeyInfo *p;
  ((void) (0));
  if( (N+X>0xffff) ) return (KeyInfo*)sqlite3OomFault(db);
  p = sqlite3DbMallocRawNN(db, (__builtin_offsetof(KeyInfo, aColl) + (0)*sizeof(CollSeq*)) + nExtra);
  if( p ){
    p->aSortFlags = (u8*)&p->aColl[N+X];
    p->nKeyField = (u16)N;
    p->nAllField = (u16)(N+X);
    p->enc = ((db)->enc);
    p->db = db;
    p->nRef = 1;
    memset(p->aColl, 0, nExtra);
  }else{
    return (KeyInfo*)sqlite3OomFault(db);
  }
  return p;
}




static void sqlite3KeyInfoUnref(KeyInfo *p){
  if( p ){
    ((void) (0));
    ((void) (0));
    p->nRef--;
    if( p->nRef==0 ) sqlite3DbNNFreeNN(p->db, p);
  }
}




static KeyInfo *sqlite3KeyInfoRef(KeyInfo *p){
  if( p ){
    ((void) (0));
    p->nRef++;
  }
  return p;
}
# 148374 "c_tests/sqlite3.c"
static KeyInfo *sqlite3KeyInfoFromExprList(
  Parse *pParse,
  ExprList *pList,
  int iStart,
  int nExtra
){
  int nExpr;
  KeyInfo *pInfo;
  struct ExprList_item *pItem;
  sqlite3 *db = pParse->db;
  int i;

  nExpr = pList->nExpr;
  pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);
  if( pInfo ){
    ((void) (0));
    for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++){
      pInfo->aColl[i-iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);
      pInfo->aSortFlags[i-iStart] = pItem->fg.sortFlags;
    }
  }
  return pInfo;
}




static const char *sqlite3SelectOpName(int id){
  char *z;
  switch( id ){
    case 136: z = "UNION ALL"; break;
    case 138: z = "INTERSECT"; break;
    case 137: z = "EXCEPT"; break;
    default: z = "UNION"; break;
  }
  return z;
}
# 148423 "c_tests/sqlite3.c"
static void explainTempTable(Parse *pParse, const char *zUsage){
  sqlite3VdbeExplain (pParse, 0, "USE TEMP B-TREE FOR %s", zUsage);
}
# 148449 "c_tests/sqlite3.c"
static void generateSortTail(
  Parse *pParse,
  Select *p,
  SortCtx *pSort,
  int nColumn,
  SelectDest *pDest
){
  Vdbe *v = pParse->pVdbe;
  int addrBreak = pSort->labelDone;
  int addrContinue = sqlite3VdbeMakeLabel(pParse);
  int addr;
  int addrOnce = 0;
  int iTab;
  ExprList *pOrderBy = pSort->pOrderBy;
  int eDest = pDest->eDest;
  int iParm = pDest->iSDParm;
  int regRow;
  int regRowid;
  int iCol;
  int nKey;
  int iSortTab;
  int i;
  int bSeq;
  int nRefKey = 0;
  struct ExprList_item *aOutEx = p->pEList->a;




  nKey = pOrderBy->nExpr - pSort->nOBSat;
  if( pSort->nOBSat==0 || nKey==1 ){
    sqlite3VdbeExplain (pParse, 0, "USE TEMP B-TREE FOR %sORDER BY", pSort->nOBSat?"LAST TERM OF ":"" );


  }else{
    sqlite3VdbeExplain (pParse, 0, "USE TEMP B-TREE FOR LAST %d TERMS OF ORDER BY", nKey );


  }
                                                                               ;
                                                                             ;


  ((void) (0));
  if( pSort->labelBkOut ){
    sqlite3VdbeAddOp2(v, 10, pSort->regReturn, pSort->labelBkOut);
    sqlite3VdbeGoto(v, addrBreak);
    sqlite3VdbeResolveLabel(v, pSort->labelBkOut);
  }
# 148509 "c_tests/sqlite3.c"
  iTab = pSort->iECursor;
  if( eDest==9 || eDest==13 || eDest==10 ){
    if( eDest==10 && p->iOffset ){
      sqlite3VdbeAddOp2(v, 76, 0, pDest->iSdst);
    }
    regRowid = 0;
    regRow = pDest->iSdst;
  }else{
    regRowid = sqlite3GetTempReg(pParse);
    if( eDest==12 || eDest==14 ){
      regRow = sqlite3GetTempReg(pParse);
      nColumn = 0;
    }else{
      regRow = sqlite3GetTempRange(pParse, nColumn);
    }
  }
  if( pSort->sortFlags & 0x01 ){
    int regSortOut = ++pParse->nMem;
    iSortTab = pParse->nTab++;
    if( pSort->labelBkOut ){
      addrOnce = sqlite3VdbeAddOp0(v, 15); ;
    }
    sqlite3VdbeAddOp3(v, 122, iSortTab, regSortOut,
        nKey+1+nColumn+nRefKey);
    if( addrOnce ) sqlite3VdbeJumpHere(v, addrOnce);
    addr = 1 + sqlite3VdbeAddOp2(v, 34, iTab, addrBreak);
                   ;
    ((void) (0));
    sqlite3VdbeAddOp3(v, 134, iTab, regSortOut, iSortTab);
    bSeq = 0;
  }else{
    addr = 1 + sqlite3VdbeAddOp2(v, 35, iTab, addrBreak); ;
    codeOffset(v, p->iOffset, addrContinue);
    iSortTab = iTab;
    bSeq = 1;
    if( p->iOffset>0 ){
      sqlite3VdbeAddOp2(v, 87, p->iLimit, -1);
    }
  }
  for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++){



    if( aOutEx[i].u.x.iOrderByCol==0 ) iCol++;
  }
# 148585 "c_tests/sqlite3.c"
  for(i=nColumn-1; i>=0; i--){





    {
      int iRead;
      if( aOutEx[i].u.x.iOrderByCol ){
        iRead = aOutEx[i].u.x.iOrderByCol-1;
      }else{
        iRead = iCol--;
      }
      sqlite3VdbeAddOp3(v, 95, iSortTab, iRead, regRow+i);
                                              ;
    }
  }
                                                             ;
  switch( eDest ){
    case 14:
    case 12: {
      sqlite3VdbeAddOp3(v, 95, iSortTab, nKey+bSeq, regRow);
      sqlite3VdbeAddOp2(v, 128, iParm, regRowid);
      sqlite3VdbeAddOp3(v, 129, iParm, regRow, regRowid);
      sqlite3VdbeChangeP5(v, 0x08);
      break;
    }

    case 11: {
      ((void) (0));
      sqlite3VdbeAddOp4(v, 98, regRow, nColumn, regRowid,
                        pDest->zAffSdst, nColumn);
      sqlite3VdbeAddOp4Int(v, 139, iParm, regRowid, regRow, nColumn);
      break;
    }
    case 10: {

      break;
    }

    case 15: {
      int i2 = pDest->iSDParm2;
      int r1 = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp3(v, 98,regRow+(i2<0),nColumn-(i2<0),r1);
      if( i2<0 ){
        sqlite3VdbeAddOp3(v, 129, iParm, r1, regRow);
      }else{
        sqlite3VdbeAddOp4Int(v, 139, iParm, r1, regRow, i2);
      }
      break;
    }
    default: {
      ((void) (0));
                                   ;
                                      ;
      if( eDest==9 ){
        sqlite3VdbeAddOp2(v, 85, pDest->iSdst, nColumn);
      }else{
        sqlite3VdbeAddOp1(v, 12, pDest->iSDParm);
      }
      break;
    }
  }
  if( regRowid ){
    if( eDest==11 ){
      sqlite3ReleaseTempRange(pParse, regRow, nColumn);
    }else{
      sqlite3ReleaseTempReg(pParse, regRow);
    }
    sqlite3ReleaseTempReg(pParse, regRowid);
  }


  sqlite3VdbeResolveLabel(v, addrContinue);
  if( pSort->sortFlags & 0x01 ){
    sqlite3VdbeAddOp2(v, 38, iTab, addr); ;
  }else{
    sqlite3VdbeAddOp2(v, 40, iTab, addr); ;
  }
                                                                             ;
  if( pSort->regReturn ) sqlite3VdbeAddOp1(v, 68, pSort->regReturn);
  sqlite3VdbeResolveLabel(v, addrBreak);
}
# 148695 "c_tests/sqlite3.c"
static const char *columnTypeImpl(
  NameContext *pNC,

  Expr *pExpr






){
  char const *zType = 0;
  int j;






  ((void) (0));
  ((void) (0));
  switch( pExpr->op ){
    case 168: {




      Table *pTab = 0;
      Select *pS = 0;
      int iCol = pExpr->iColumn;
      while( pNC && !pTab ){
        SrcList *pTabList = pNC->pSrcList;
        for(j=0;j<pTabList->nSrc && pTabList->a[j].iCursor!=pExpr->iTable;j++);
        if( j<pTabList->nSrc ){
          pTab = pTabList->a[j].pSTab;
          if( pTabList->a[j].fg.isSubquery ){
            pS = pTabList->a[j].u4.pSubq->pSelect;
          }else{
            pS = 0;
          }
        }else{
          pNC = pNC->pNext;
        }
      }

      if( pTab==0 ){
# 148758 "c_tests/sqlite3.c"
        break;
      }

      ((void) (0));
      if( pS ){




        if( iCol<pS->pEList->nExpr
         && (!0 || iCol>=0)
        ){




          NameContext sNC;
          Expr *p = pS->pEList->a[iCol].pExpr;
          sNC.pSrcList = pS->pSrc;
          sNC.pNext = pNC;
          sNC.pParse = pNC->pParse;
          zType = columnTypeImpl(&sNC,p);
        }
      }else{

        ((void) (0));
# 148800 "c_tests/sqlite3.c"
        ((void) (0));
        if( iCol<0 ){
          zType = "INTEGER";
        }else{
          zType = sqlite3ColumnType(&pTab->aCol[iCol],0);
        }

      }
      break;
    }

    case 139: {




      NameContext sNC;
      Select *pS;
      Expr *p;
      ((void) (0));
      pS = pExpr->x.pSelect;
      p = pS->pEList->a[0].pExpr;
      sNC.pSrcList = pS->pSrc;
      sNC.pNext = pNC;
      sNC.pParse = pNC->pParse;
      zType = columnTypeImpl(&sNC,p);
      break;
    }

  }
# 148839 "c_tests/sqlite3.c"
  return zType;
}





static void generateColumnTypes(
  Parse *pParse,
  SrcList *pTabList,
  ExprList *pEList
){

  Vdbe *v = pParse->pVdbe;
  int i;
  NameContext sNC;
  sNC.pSrcList = pTabList;
  sNC.pParse = pParse;
  sNC.pNext = 0;
  for(i=0; i<pEList->nExpr; i++){
    Expr *p = pEList->a[i].pExpr;
    const char *zType;
# 148875 "c_tests/sqlite3.c"
    zType = columnTypeImpl(&sNC,p);

    sqlite3VdbeSetColName(v, i, 1, zType, ((sqlite3_destructor_type)-1));
  }





}
# 148917 "c_tests/sqlite3.c"
static void sqlite3GenerateColumnNames(
  Parse *pParse,
  Select *pSelect
){
  Vdbe *v = pParse->pVdbe;
  int i;
  Table *pTab;
  SrcList *pTabList;
  ExprList *pEList;
  sqlite3 *db = pParse->db;
  int fullName;
  int srcName;

  if( pParse->colNamesSet ) return;

  while( pSelect->pPrior ) pSelect = pSelect->pPrior;
                                                              ;
  pTabList = pSelect->pSrc;
  pEList = pSelect->pEList;
  ((void) (0));
  ((void) (0));
  pParse->colNamesSet = 1;
  fullName = (db->flags & 0x00000004)!=0;
  srcName = (db->flags & 0x00000040)!=0 || fullName;
  sqlite3VdbeSetNumCols(v, pEList->nExpr);
  for(i=0; i<pEList->nExpr; i++){
    Expr *p = pEList->a[i].pExpr;

    ((void) (0));
    ((void) (0));
    ((void) (0));

    if( pEList->a[i].zEName && pEList->a[i].fg.eEName==0 ){

      char *zName = pEList->a[i].zEName;
      sqlite3VdbeSetColName(v, i, 0, zName, ((sqlite3_destructor_type)-1));
    }else if( srcName && p->op==168 ){
      char *zCol;
      int iCol = p->iColumn;
      pTab = p->y.pTab;
      ((void) (0));
      if( iCol<0 ) iCol = pTab->iPKey;
      ((void) (0));
      if( iCol<0 ){
        zCol = "rowid";
      }else{
        zCol = pTab->aCol[iCol].zCnName;
      }
      if( fullName ){
        char *zName = 0;
        zName = sqlite3MPrintf(db, "%s.%s", pTab->zName, zCol);
        sqlite3VdbeSetColName(v, i, 0, zName, ((sqlite3_destructor_type)sqlite3RowSetClear));
      }else{
        sqlite3VdbeSetColName(v, i, 0, zCol, ((sqlite3_destructor_type)-1));
      }
    }else{
      const char *z = pEList->a[i].zEName;
      z = z==0 ? sqlite3MPrintf(db, "column%d", i+1) : sqlite3DbStrDup(db, z);
      sqlite3VdbeSetColName(v, i, 0, z, ((sqlite3_destructor_type)sqlite3RowSetClear));
    }
  }
  generateColumnTypes(pParse, pTabList, pEList);
}
# 149003 "c_tests/sqlite3.c"
static int sqlite3ColumnsFromExprList(
  Parse *pParse,
  ExprList *pEList,
  i16 *pnCol,
  Column **paCol
){
  sqlite3 *db = pParse->db;
  int i, j;
  u32 cnt;
  Column *aCol, *pCol;
  int nCol;
  char *zName;
  int nName;
  Hash ht;
  Table *pTab;

  sqlite3HashInit(&ht);
  if( pEList ){
    nCol = pEList->nExpr;
    aCol = sqlite3DbMallocZero(db, sizeof(aCol[0])*nCol);
                       ;
    if( (nCol>32767) ) nCol = 32767;
  }else{
    nCol = 0;
    aCol = 0;
  }
  ((void) (0));
  *pnCol = nCol;
  *paCol = aCol;

  for(i=0, pCol=aCol; i<nCol && !pParse->nErr; i++, pCol++){
    struct ExprList_item *pX = &pEList->a[i];
    struct ExprList_item *pCollide;


    if( (zName = pX->zEName)!=0 && pX->fg.eEName==0 ){

    }else{
      Expr *pColExpr = sqlite3ExprSkipCollateAndLikely(pX->pExpr);
      while( (pColExpr!=0) && pColExpr->op==142 ){
        pColExpr = pColExpr->pRight;
        ((void) (0));
      }
      if( pColExpr->op==168
       && ((((pColExpr)->flags&(0x1000000|0x2000000))==0))
       && (pColExpr->y.pTab!=0)
      ){

        int iCol = pColExpr->iColumn;
        pTab = pColExpr->y.pTab;
        if( iCol<0 ) iCol = pTab->iPKey;
        zName = iCol>=0 ? pTab->aCol[iCol].zCnName : "rowid";
      }else if( pColExpr->op==60 ){
        ((void) (0));
        zName = pColExpr->u.zToken;
      }else{

        ((void) (0));
      }
    }
    if( zName && !sqlite3IsTrueOrFalse(zName) ){
      zName = sqlite3DbStrDup(db, zName);
    }else{
      zName = sqlite3MPrintf(db,"column%d",i+1);
    }




    cnt = 0;
    while( zName && (pCollide = sqlite3HashFind(&ht, zName))!=0 ){
      if( pCollide->fg.bUsingTerm ){
        pCol->colFlags |= 0x0400;
      }
      nName = sqlite3Strlen30(zName);
      if( nName>0 ){
        for(j=nName-1; j>0 && (sqlite3CtypeMap[(unsigned char)(zName[j])]&0x04); j--){}
        if( zName[j]==':' ) nName = j;
      }
      zName = sqlite3MPrintf(db, "%.*z:%u", nName, zName, ++cnt);
      sqlite3ProgressCheck(pParse);
      if( cnt>3 ){
        sqlite3_randomness(sizeof(cnt), &cnt);
      }
    }
    pCol->zCnName = zName;
    pCol->hName = sqlite3StrIHash(zName);
    if( pX->fg.bNoExpand ){
      pCol->colFlags |= 0x0400;
    }
                                            ;
    if( zName && sqlite3HashInsert(&ht, zName, pX)==pX ){
      sqlite3OomFault(db);
    }
  }
  sqlite3HashClear(&ht);
  if( pParse->nErr ){
    for(j=0; j<i; j++){
      sqlite3DbFree(db, aCol[j].zCnName);
    }
    sqlite3DbFree(db, aCol);
    *paCol = 0;
    *pnCol = 0;
    return pParse->rc;
  }
  return 0;
}
# 149122 "c_tests/sqlite3.c"
static void sqlite3SubqueryColumnTypes(
  Parse *pParse,
  Table *pTab,
  Select *pSelect,
  char aff
){
  sqlite3 *db = pParse->db;
  Column *pCol;
  CollSeq *pColl;
  int i,j;
  Expr *p;
  struct ExprList_item *a;
  NameContext sNC;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( db->mallocFailed || (pParse->eParseMode>=2) ) return;
  while( pSelect->pPrior ) pSelect = pSelect->pPrior;
  a = pSelect->pEList->a;
  memset(&sNC, 0, sizeof(sNC));
  sNC.pSrcList = pSelect->pSrc;
  for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){
    const char *zType;
    i64 n;
    int m = 0;
    Select *pS2 = pSelect;
    pTab->tabFlags |= (pCol->colFlags & 0x0062);
    p = a[i].pExpr;

    pCol->affinity = sqlite3ExprAffinity(p);
    while( pCol->affinity<=0x40 && pS2->pNext!=0 ){
      m |= sqlite3ExprDataType(pS2->pEList->a[i].pExpr);
      pS2 = pS2->pNext;
      pCol->affinity = sqlite3ExprAffinity(pS2->pEList->a[i].pExpr);
    }
    if( pCol->affinity<=0x40 ){
      pCol->affinity = aff;
    }
    if( pCol->affinity>=0x42 && (pS2->pNext || pS2!=pSelect) ){
      for(pS2=pS2->pNext; pS2; pS2=pS2->pNext){
        m |= sqlite3ExprDataType(pS2->pEList->a[i].pExpr);
      }
      if( pCol->affinity==0x42 && (m&0x01)!=0 ){
        pCol->affinity = 0x41;
      }else
      if( pCol->affinity>=0x43 && (m&0x02)!=0 ){
        pCol->affinity = 0x41;
      }
      if( pCol->affinity>=0x43 && p->op==36 ){
        pCol->affinity = 0x46;
      }
    }
    zType = columnTypeImpl(&sNC,p);
    if( zType==0 || pCol->affinity!=sqlite3AffinityType(zType, 0) ){
      if( pCol->affinity==0x43
       || pCol->affinity==0x46
      ){
        zType = "NUM";
      }else{
        zType = 0;
        for(j=1; j<6; j++){
          if( sqlite3StdTypeAffinity[j]==pCol->affinity ){
            zType = sqlite3StdType[j];
            break;
          }
        }
      }
    }
    if( zType ){
      const i64 k = sqlite3Strlen30(zType);
      n = sqlite3Strlen30(pCol->zCnName);
      pCol->zCnName = sqlite3DbReallocOrFree(db, pCol->zCnName, n+k+2);
      pCol->colFlags &= ~(0x0004|0x0200);
      if( pCol->zCnName ){
        memcpy(&pCol->zCnName[n+1], zType, k+1);
        pCol->colFlags |= 0x0004;
      }
    }
    pColl = sqlite3ExprCollSeq(pParse, p);
    if( pColl ){
      ((void) (0));
      sqlite3ColumnSetColl(db, pCol, pColl->zName);
    }
  }
  pTab->szTabRow = 1;
}





static Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect, char aff){
  Table *pTab;
  sqlite3 *db = pParse->db;
  u64 savedFlags;

  savedFlags = db->flags;
  db->flags &= ~(u64)0x00000004;
  db->flags |= 0x00000040;
  sqlite3SelectPrep(pParse, pSelect, 0);
  db->flags = savedFlags;
  if( pParse->nErr ) return 0;
  while( pSelect->pPrior ) pSelect = pSelect->pPrior;
  pTab = sqlite3DbMallocZero(db, sizeof(Table) );
  if( pTab==0 ){
    return 0;
  }
  pTab->nTabRef = 1;
  pTab->zName = 0;
  pTab->nRowLogEst = 200; ((void) (0));
  sqlite3ColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);
  sqlite3SubqueryColumnTypes(pParse, pTab, pSelect, aff);
  pTab->iPKey = -1;
  if( db->mallocFailed ){
    sqlite3DeleteTable(db, pTab);
    return 0;
  }
  return pTab;
}





static Vdbe *sqlite3GetVdbe(Parse *pParse){
  if( pParse->pVdbe ){
    return pParse->pVdbe;
  }
  if( pParse->pToplevel==0
   && (((pParse->db)->dbOptFlags&(0x00000008))==0)
  ){
    pParse->okConstFactor = 1;
  }
  return sqlite3VdbeCreate(pParse);
}
# 149284 "c_tests/sqlite3.c"
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){
  Vdbe *v = 0;
  int iLimit = 0;
  int iOffset;
  int n;
  Expr *pLimit = p->pLimit;

  if( p->iLimit ) return;







  if( pLimit ){
    ((void) (0));
    ((void) (0));
    p->iLimit = iLimit = ++pParse->nMem;
    v = sqlite3GetVdbe(pParse);
    ((void) (0));
    if( sqlite3ExprIsInteger(pLimit->pLeft, &n, pParse) ){
      sqlite3VdbeAddOp2(v, 72, n, iLimit);
                                       ;
      if( n==0 ){
        sqlite3VdbeGoto(v, iBreak);
      }else if( n>=0 && p->nSelectRow>sqlite3LogEst((u64)n) ){
        p->nSelectRow = sqlite3LogEst((u64)n);
        p->selFlags |= 0x0004000;
      }
    }else{
      sqlite3ExprCode(pParse, pLimit->pLeft, iLimit);
      sqlite3VdbeAddOp1(v, 13, iLimit); ;
                                       ;
      sqlite3VdbeAddOp2(v, 17, iLimit, iBreak); ;
    }
    if( pLimit->pRight ){
      p->iOffset = iOffset = ++pParse->nMem;
      pParse->nMem++;
      sqlite3ExprCode(pParse, pLimit->pRight, iOffset);
      sqlite3VdbeAddOp1(v, 13, iOffset); ;
                                        ;
      sqlite3VdbeAddOp3(v, 161, iLimit, iOffset+1, iOffset);
                                      ;
    }
  }
}
# 149341 "c_tests/sqlite3.c"
static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){
  CollSeq *pRet;
  if( p->pPrior ){
    pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);
  }else{
    pRet = 0;
  }
  ((void) (0));



  if( pRet==0 && (iCol<p->pEList->nExpr) ){
    pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr);
  }
  return pRet;
}
# 149367 "c_tests/sqlite3.c"
static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){
  ExprList *pOrderBy = p->pOrderBy;
  int nOrderBy = (pOrderBy!=0) ? pOrderBy->nExpr : 0;
  sqlite3 *db = pParse->db;
  KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);
  if( pRet ){
    int i;
    for(i=0; i<nOrderBy; i++){
      struct ExprList_item *pItem = &pOrderBy->a[i];
      Expr *pTerm = pItem->pExpr;
      CollSeq *pColl;

      if( pTerm->flags & 0x000200 ){
        pColl = sqlite3ExprCollSeq(pParse, pTerm);
      }else{
        pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol-1);
        if( pColl==0 ) pColl = db->pDfltColl;
        pOrderBy->a[i].pExpr =
          sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);
      }
      ((void) (0));
      pRet->aColl[i] = pColl;
      pRet->aSortFlags[i] = pOrderBy->a[i].fg.sortFlags;
    }
  }

  return pRet;
}
# 149433 "c_tests/sqlite3.c"
static void generateWithRecursiveQuery(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  SrcList *pSrc = p->pSrc;
  int nCol = p->pEList->nExpr;
  Vdbe *v = pParse->pVdbe;
  Select *pSetup;
  Select *pFirstRec;
  int addrTop;
  int addrCont, addrBreak;
  int iCurrent = 0;
  int regCurrent;
  int iQueue;
  int iDistinct = 0;
  int eDest = 8;
  SelectDest destQueue;
  int i;
  int rc;
  ExprList *pOrderBy;
  Expr *pLimit;
  int regLimit, regOffset;


  if( p->pWin ){
    sqlite3ErrorMsg(pParse, "cannot use window functions in recursive queries");
    return;
  }



  if( sqlite3AuthCheck(pParse, 33, 0, 0, 0) ) return;


  addrBreak = sqlite3VdbeMakeLabel(pParse);
  p->nSelectRow = 320;
  computeLimitRegisters(pParse, p, addrBreak);
  pLimit = p->pLimit;
  regLimit = p->iLimit;
  regOffset = p->iOffset;
  p->pLimit = 0;
  p->iLimit = p->iOffset = 0;
  pOrderBy = p->pOrderBy;


  for(i=0; (i<pSrc->nSrc); i++){
    if( pSrc->a[i].fg.isRecursive ){
      iCurrent = pSrc->a[i].iCursor;
      break;
    }
  }




  iQueue = pParse->nTab++;
  if( p->op==135 ){
    eDest = pOrderBy ? 6 : 5;
    iDistinct = pParse->nTab++;
  }else{
    eDest = pOrderBy ? 7 : 8;
  }
  sqlite3SelectDestInit(&destQueue, eDest, iQueue);


  regCurrent = ++pParse->nMem;
  sqlite3VdbeAddOp3(v, 122, iCurrent, regCurrent, nCol);
  if( pOrderBy ){
    KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);
    sqlite3VdbeAddOp4(v, 119, iQueue, pOrderBy->nExpr+2, 0,
                      (char*)pKeyInfo, (-8));
    destQueue.pOrderBy = pOrderBy;
  }else{
    sqlite3VdbeAddOp2(v, 119, iQueue, nCol);
  }
                                 ;
  if( iDistinct ){
    p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, 119, iDistinct, 0);
    p->selFlags |= 0x0000020;
  }


  p->pOrderBy = 0;
# 149525 "c_tests/sqlite3.c"
  for(pFirstRec=p; (pFirstRec!=0); pFirstRec=pFirstRec->pPrior){
    if( pFirstRec->selFlags & 0x0000008 ){
      sqlite3ErrorMsg(pParse, "recursive aggregate queries not supported");
      goto end_of_recursive_query;
    }
    pFirstRec->op = 136;
    if( (pFirstRec->pPrior->selFlags & 0x0002000)==0 ) break;
  }


  pSetup = pFirstRec->pPrior;
  pSetup->pNext = 0;
  sqlite3VdbeExplain (pParse, 1, "SETUP");
  rc = sqlite3Select(pParse, pSetup, &destQueue);
  pSetup->pNext = p;
  if( rc ) goto end_of_recursive_query;


  addrTop = sqlite3VdbeAddOp2(v, 36, iQueue, addrBreak); ;


  sqlite3VdbeAddOp1(v, 137, iCurrent);
  if( pOrderBy ){
    sqlite3VdbeAddOp3(v, 95, iQueue, pOrderBy->nExpr+1, regCurrent);
  }else{
    sqlite3VdbeAddOp2(v, 135, iQueue, regCurrent);
  }
  sqlite3VdbeAddOp1(v, 131, iQueue);


  addrCont = sqlite3VdbeMakeLabel(pParse);
  codeOffset(v, regOffset, addrCont);
  selectInnerLoop(pParse, p, iCurrent,
      0, 0, pDest, addrCont, addrBreak);
  if( regLimit ){
    sqlite3VdbeAddOp2(v, 62, regLimit, addrBreak);
                   ;
  }
  sqlite3VdbeResolveLabel(v, addrCont);




  pFirstRec->pPrior = 0;
  sqlite3VdbeExplain (pParse, 1, "RECURSIVE STEP");
  sqlite3Select(pParse, p, &destQueue);
  ((void) (0));
  pFirstRec->pPrior = pSetup;


  sqlite3VdbeGoto(v, addrTop);
  sqlite3VdbeResolveLabel(v, addrBreak);

end_of_recursive_query:
  sqlite3ExprListDelete(pParse->db, p->pOrderBy);
  p->pOrderBy = pOrderBy;
  p->pLimit = pLimit;
  return;
}



static int multiSelectOrderBy(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
);
# 149609 "c_tests/sqlite3.c"
static int multiSelectValues(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  int nRow = 1;
  int rc = 0;
  int bShowAll = p->pLimit==0;
  ((void) (0));
  do{
    ((void) (0));
    ((void) (0));
    ((void) (0));

    if( p->pWin ) return -1;

    if( p->pPrior==0 ) break;
    ((void) (0));
    p = p->pPrior;
    nRow += bShowAll;
  }while(1);
  sqlite3VdbeExplain (pParse, 0, "SCAN %d CONSTANT ROW%s", nRow, nRow==1 ? "" : "S");

  while( p ){
    selectInnerLoop(pParse, p, -1, 0, 0, pDest, 1, 1);
    if( !bShowAll ) break;
    p->nSelectRow = nRow;
    p = p->pNext;
  }
  return rc;
}






static int hasAnchor(Select *p){
  while( p && (p->selFlags & 0x0002000)!=0 ){ p = p->pPrior; }
  return p!=0;
}
# 149682 "c_tests/sqlite3.c"
static int multiSelect(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  int rc = 0;
  Select *pPrior;
  Vdbe *v;
  SelectDest dest;
  Select *pDelete = 0;
  sqlite3 *db;




  ((void) (0));
  ((void) (0));
  ((void) (0));
  db = pParse->db;
  pPrior = p->pPrior;
  dest = *pDest;
  ((void) (0));
  ((void) (0));

  v = sqlite3GetVdbe(pParse);
  ((void) (0));



  if( dest.eDest==12 ){
    ((void) (0));
    sqlite3VdbeAddOp2(v, 119, dest.iSDParm, p->pEList->nExpr);
    dest.eDest = 14;
  }



  if( p->selFlags & 0x0000400 ){
    rc = multiSelectValues(pParse, p, &dest);
    if( rc>=0 ) goto multi_select_end;
    rc = 0;
  }




  ((void) (0));
  ((void) (0));


  if( (p->selFlags & 0x0002000)!=0 && hasAnchor(p) ){
    generateWithRecursiveQuery(pParse, p, &dest);
  }else




  if( p->pOrderBy ){
    return multiSelectOrderBy(pParse, p, pDest);
  }else{


    if( pPrior->pPrior==0 ){
      sqlite3VdbeExplain (pParse, 1, "COMPOUND QUERY");
      sqlite3VdbeExplain (pParse, 1, "LEFT-MOST SUBQUERY");
    }




    switch( p->op ){
      case 136: {
        int addr = 0;
        int nLimit = 0;
        ((void) (0));
        pPrior->iLimit = p->iLimit;
        pPrior->iOffset = p->iOffset;
        pPrior->pLimit = p->pLimit;
                                                                        ;
        rc = sqlite3Select(pParse, pPrior, &dest);
        pPrior->pLimit = 0;
        if( rc ){
          goto multi_select_end;
        }
        p->pPrior = 0;
        p->iLimit = pPrior->iLimit;
        p->iOffset = pPrior->iOffset;
        if( p->iLimit ){
          addr = sqlite3VdbeAddOp1(v, 17, p->iLimit); ;
                                                         ;
          if( p->iOffset ){
            sqlite3VdbeAddOp3(v, 161,
                              p->iLimit, p->iOffset+1, p->iOffset);
          }
        }
        sqlite3VdbeExplain (pParse, 1, "UNION ALL");
                                                                         ;
        rc = sqlite3Select(pParse, p, &dest);
                                 ;
        pDelete = p->pPrior;
        p->pPrior = pPrior;
        p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
        if( p->pLimit
         && sqlite3ExprIsInteger(p->pLimit->pLeft, &nLimit, pParse)
         && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit)
        ){
          p->nSelectRow = sqlite3LogEst((u64)nLimit);
        }
        if( addr ){
          sqlite3VdbeJumpHere(v, addr);
        }
        break;
      }
      case 137:
      case 135: {
        int unionTab;
        u8 op = 0;
        int priorOp;
        Expr *pLimit;
        int addr;
        int emptyBypass = 0;
        SelectDest uniondest;


                                    ;
                                   ;
        priorOp = 1;
        if( dest.eDest==priorOp ){



          ((void) (0));
          unionTab = dest.iSDParm;
        }else{



          unionTab = pParse->nTab++;
          ((void) (0));
          addr = sqlite3VdbeAddOp2(v, 119, unionTab, 0);
          ((void) (0));
          p->addrOpenEphm[0] = addr;
          findRightmost(p)->selFlags |= 0x0000020;
          ((void) (0));
        }




        ((void) (0));
        sqlite3SelectDestInit(&uniondest, priorOp, unionTab);
                                                                           ;
        rc = sqlite3Select(pParse, pPrior, &uniondest);
        if( rc ){
          goto multi_select_end;
        }



        if( p->op==137 ){
          op = 2;
          emptyBypass = sqlite3VdbeAddOp1(v, 37, unionTab);
                         ;
        }else{
          ((void) (0));
          op = 1;
        }
        p->pPrior = 0;
        pLimit = p->pLimit;
        p->pLimit = 0;
        uniondest.eDest = op;
        sqlite3VdbeExplain (pParse, 1, "%s USING TEMP B-TREE", sqlite3SelectOpName(p->op));

                                                                            ;
        rc = sqlite3Select(pParse, p, &uniondest);
                                 ;
        ((void) (0));
        pDelete = p->pPrior;
        p->pPrior = pPrior;
        p->pOrderBy = 0;
        if( p->op==135 ){
          p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
        }
        if( emptyBypass ) sqlite3VdbeJumpHere(v, emptyBypass);
        sqlite3ExprDelete(db, p->pLimit);
        p->pLimit = pLimit;
        p->iLimit = 0;
        p->iOffset = 0;




        ((void) (0));
        ((void) (0));
        if( dest.eDest!=priorOp && db->mallocFailed==0 ){
          int iCont, iBreak, iStart;
          iBreak = sqlite3VdbeMakeLabel(pParse);
          iCont = sqlite3VdbeMakeLabel(pParse);
          computeLimitRegisters(pParse, p, iBreak);
          sqlite3VdbeAddOp2(v, 36, unionTab, iBreak); ;
          iStart = sqlite3VdbeCurrentAddr(v);
          selectInnerLoop(pParse, p, unionTab,
                          0, 0, &dest, iCont, iBreak);
          sqlite3VdbeResolveLabel(v, iCont);
          sqlite3VdbeAddOp2(v, 40, unionTab, iStart); ;
          sqlite3VdbeResolveLabel(v, iBreak);
          sqlite3VdbeAddOp2(v, 123, unionTab, 0);
        }
        break;
      }
      default: ((void) (0)); {
        int tab1, tab2;
        int iCont, iBreak, iStart;
        Expr *pLimit;
        int addr, iLimit, iOffset;
        SelectDest intersectdest;
        int r1;
        int emptyBypass;





        tab1 = pParse->nTab++;
        tab2 = pParse->nTab++;
        ((void) (0));

        addr = sqlite3VdbeAddOp2(v, 119, tab1, 0);
        ((void) (0));
        p->addrOpenEphm[0] = addr;
        findRightmost(p)->selFlags |= 0x0000020;
        ((void) (0));



        sqlite3SelectDestInit(&intersectdest, 1, tab1);
                                                                        ;
        rc = sqlite3Select(pParse, pPrior, &intersectdest);
        if( rc ){
          goto multi_select_end;
        }



        iBreak = sqlite3VdbeMakeLabel(pParse);
        computeLimitRegisters(pParse, p, iBreak);
        emptyBypass = sqlite3VdbeAddOp1(v, 37, tab1); ;



        addr = sqlite3VdbeAddOp2(v, 119, tab2, 0);
        ((void) (0));
        p->addrOpenEphm[1] = addr;



        pLimit = p->pLimit;
        iLimit = p->iLimit;
        iOffset = p->iOffset;
        p->pPrior = 0;
        p->pLimit = 0;
        p->iLimit = 0;
        p->iOffset = 0;

        intersectdest.iSDParm = tab2;
        sqlite3VdbeExplain (pParse, 1, "%s USING TEMP B-TREE", sqlite3SelectOpName(p->op));

                                                                         ;
        rc = sqlite3Select(pParse, p, &intersectdest);
                                 ;
        pDelete = p->pPrior;
        p->pPrior = pPrior;
        if( p->nSelectRow>pPrior->nSelectRow ){
          p->nSelectRow = pPrior->nSelectRow;
        }
        sqlite3ExprDelete(db, p->pLimit);


        p->pLimit = pLimit;
        p->iLimit = iLimit;
        p->iOffset = iOffset;




        if( rc ) break;
        ((void) (0));
        sqlite3VdbeAddOp1(v, 36, tab1);
        r1 = sqlite3GetTempReg(pParse);
        iStart = sqlite3VdbeAddOp2(v, 135, tab1, r1);
        iCont = sqlite3VdbeMakeLabel(pParse);
        sqlite3VdbeAddOp4Int(v, 28, tab2, iCont, r1, 0);
                       ;
        sqlite3ReleaseTempReg(pParse, r1);
        selectInnerLoop(pParse, p, tab1,
                        0, 0, &dest, iCont, iBreak);
        sqlite3VdbeResolveLabel(v, iCont);
        sqlite3VdbeAddOp2(v, 40, tab1, iStart); ;
        sqlite3VdbeResolveLabel(v, iBreak);
        sqlite3VdbeAddOp2(v, 123, tab2, 0);
        sqlite3VdbeJumpHere(v, emptyBypass);
        sqlite3VdbeAddOp2(v, 123, tab1, 0);
        break;
      }
    }


    if( p->pNext==0 ){
      sqlite3VdbeExplainPop(pParse);
    }

  }
  if( pParse->nErr ) goto multi_select_end;
# 150005 "c_tests/sqlite3.c"
  if( p->selFlags & 0x0000020 ){
    int i;
    KeyInfo *pKeyInfo;
    Select *pLoop;
    CollSeq **apColl;
    int nCol;

    ((void) (0));
    ((void) (0));
    nCol = p->pEList->nExpr;
    pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);
    if( !pKeyInfo ){
      rc = 7;
      goto multi_select_end;
    }
    for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){
      *apColl = multiSelectCollSeq(pParse, p, i);
      if( 0==*apColl ){
        *apColl = db->pDfltColl;
      }
    }

    for(pLoop=p; pLoop; pLoop=pLoop->pPrior){
      for(i=0; i<2; i++){
        int addr = pLoop->addrOpenEphm[i];
        if( addr<0 ){


          ((void) (0));
          break;
        }
        sqlite3VdbeChangeP2(v, addr, nCol);
        sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),
                            (-8));
        pLoop->addrOpenEphm[i] = -1;
      }
    }
    sqlite3KeyInfoUnref(pKeyInfo);
  }

multi_select_end:
  pDest->iSdst = dest.iSdst;
  pDest->nSdst = dest.nSdst;
  pDest->iSDParm2 = dest.iSDParm2;
  if( pDelete ){
    sqlite3ParserAddCleanup(pParse, sqlite3SelectDeleteGeneric, pDelete);
  }
  return rc;
}






static void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p){
  if( p->selFlags & 0x0000200 ){
    sqlite3ErrorMsg(pParse, "all VALUES must have the same number of terms");
  }else{
    sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s"
      " do not have the same number of result columns",
      sqlite3SelectOpName(p->op));
  }
}
# 150090 "c_tests/sqlite3.c"
static int generateOutputSubroutine(
  Parse *pParse,
  Select *p,
  SelectDest *pIn,
  SelectDest *pDest,
  int regReturn,
  int regPrev,
  KeyInfo *pKeyInfo,
  int iBreak
){
  Vdbe *v = pParse->pVdbe;
  int iContinue;
  int addr;

  addr = sqlite3VdbeCurrentAddr(v);
  iContinue = sqlite3VdbeMakeLabel(pParse);



  if( regPrev ){
    int addr1, addr2;
    addr1 = sqlite3VdbeAddOp1(v, 17, regPrev); ;
    addr2 = sqlite3VdbeAddOp4(v, 91, pIn->iSdst, regPrev+1, pIn->nSdst,
                              (char*)sqlite3KeyInfoRef(pKeyInfo), (-8));
    sqlite3VdbeAddOp3(v, 14, addr2+2, iContinue, addr2+2); ;
    sqlite3VdbeJumpHere(v, addr1);
    sqlite3VdbeAddOp3(v, 81, pIn->iSdst, regPrev+1, pIn->nSdst-1);
    sqlite3VdbeAddOp2(v, 72, 1, regPrev);
  }
  if( pParse->db->mallocFailed ) return 0;



  codeOffset(v, p->iOffset, iContinue);

  ((void) (0));
  ((void) (0));
  switch( pDest->eDest ){


    case 12: {
      int r1 = sqlite3GetTempReg(pParse);
      int r2 = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp3(v, 98, pIn->iSdst, pIn->nSdst, r1);
      sqlite3VdbeAddOp2(v, 128, pDest->iSDParm, r2);
      sqlite3VdbeAddOp3(v, 129, pDest->iSDParm, r1, r2);
      sqlite3VdbeChangeP5(v, 0x08);
      sqlite3ReleaseTempReg(pParse, r2);
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }




    case 11: {
      int r1;
                              ;
      r1 = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp4(v, 98, pIn->iSdst, pIn->nSdst,
          r1, pDest->zAffSdst, pIn->nSdst);
      sqlite3VdbeAddOp4Int(v, 139, pDest->iSDParm, r1,
                           pIn->iSdst, pIn->nSdst);
      if( pDest->iSDParm2>0 ){
        sqlite3VdbeAddOp4Int(v, 184, pDest->iSDParm2, 0,
                             pIn->iSdst, pIn->nSdst);
        sqlite3VdbeExplain (pParse, 0, "CREATE BLOOM FILTER");
      }
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }






    case 10: {
                              ;
      sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, pIn->nSdst);

      break;
    }





    case 13: {
      if( pDest->iSdst==0 ){
        pDest->iSdst = sqlite3GetTempRange(pParse, pIn->nSdst);
        pDest->nSdst = pIn->nSdst;
      }
      sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pIn->nSdst);
      sqlite3VdbeAddOp1(v, 12, pDest->iSDParm);
      break;
    }
# 150196 "c_tests/sqlite3.c"
    default: {
      ((void) (0));
      sqlite3VdbeAddOp2(v, 85, pIn->iSdst, pIn->nSdst);
      break;
    }
  }



  if( p->iLimit ){
    sqlite3VdbeAddOp2(v, 62, p->iLimit, iBreak); ;
  }



  sqlite3VdbeResolveLabel(v, iContinue);
  sqlite3VdbeAddOp1(v, 68, regReturn);

  return addr;
}
# 150303 "c_tests/sqlite3.c"
static int multiSelectOrderBy(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  int i, j;
  Select *pPrior;
  Select *pSplit;
  int nSelect;
  Vdbe *v;
  SelectDest destA;
  SelectDest destB;
  int regAddrA;
  int regAddrB;
  int addrSelectA;
  int addrSelectB;
  int regOutA;
  int regOutB;
  int addrOutA;
  int addrOutB = 0;
  int addrEofA;
  int addrEofA_noB;
  int addrEofB;
  int addrAltB;
  int addrAeqB;
  int addrAgtB;
  int regLimitA;
  int regLimitB;
  int regPrev;
  int savedLimit;
  int savedOffset;
  int labelCmpr;
  int labelEnd;
  int addr1;
  int op;
  KeyInfo *pKeyDup = 0;
  KeyInfo *pKeyMerge;
  sqlite3 *db;
  ExprList *pOrderBy;
  int nOrderBy;
  u32 *aPermute;

  ((void) (0));
  ((void) (0));
  db = pParse->db;
  v = pParse->pVdbe;
  ((void) (0));
  labelEnd = sqlite3VdbeMakeLabel(pParse);
  labelCmpr = sqlite3VdbeMakeLabel(pParse);




  op = p->op;
  ((void) (0));
  pOrderBy = p->pOrderBy;
  ((void) (0));
  nOrderBy = pOrderBy->nExpr;





  if( op!=136 ){
    for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++){
      struct ExprList_item *pItem;
      for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++){
        ((void) (0));
        ((void) (0));
        if( pItem->u.x.iOrderByCol==i ) break;
      }
      if( j==nOrderBy ){
        Expr *pNew = sqlite3Expr(db, 156, 0);
        if( pNew==0 ) return 7;
        pNew->flags |= 0x000800;
        pNew->u.iValue = i;
        p->pOrderBy = pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);
        if( pOrderBy ) pOrderBy->a[nOrderBy++].u.x.iOrderByCol = (u16)i;
      }
    }
  }
# 150392 "c_tests/sqlite3.c"
  aPermute = sqlite3DbMallocRawNN(db, sizeof(u32)*(nOrderBy + 1));
  if( aPermute ){
    struct ExprList_item *pItem;
    aPermute[0] = nOrderBy;
    for(i=1, pItem=pOrderBy->a; i<=nOrderBy; i++, pItem++){
      ((void) (0));
      ((void) (0));
      ((void) (0));
      aPermute[i] = pItem->u.x.iOrderByCol - 1;
    }
    pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, 1);
  }else{
    pKeyMerge = 0;
  }





  if( op==136 ){
    regPrev = 0;
  }else{
    int nExpr = p->pEList->nExpr;
    ((void) (0));
    regPrev = pParse->nMem+1;
    pParse->nMem += nExpr+1;
    sqlite3VdbeAddOp2(v, 72, 0, regPrev);
    pKeyDup = sqlite3KeyInfoAlloc(db, nExpr, 1);
    if( pKeyDup ){
      ((void) (0));
      for(i=0; i<nExpr; i++){
        pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);
        pKeyDup->aSortFlags[i] = 0;
      }
    }
  }



  nSelect = 1;
  if( (op==136 || op==135)
   && (((db)->dbOptFlags&(0x00200000))==0)
  ){
    for(pSplit=p; pSplit->pPrior!=0 && pSplit->op==op; pSplit=pSplit->pPrior){
      nSelect++;
      ((void) (0));
    }
  }
  if( nSelect<=3 ){
    pSplit = p;
  }else{
    pSplit = p;
    for(i=2; i<nSelect; i+=2){ pSplit = pSplit->pPrior; }
  }
  pPrior = pSplit->pPrior;
  ((void) (0));
  pSplit->pPrior = 0;
  pPrior->pNext = 0;
  ((void) (0));
  ((void) (0));
  pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);
  sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, "ORDER");
  sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, "ORDER");


  computeLimitRegisters(pParse, p, labelEnd);
  if( p->iLimit && op==136 ){
    regLimitA = ++pParse->nMem;
    regLimitB = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 81, p->iOffset ? p->iOffset+1 : p->iLimit,
                                  regLimitA);
    sqlite3VdbeAddOp2(v, 81, regLimitA, regLimitB);
  }else{
    regLimitA = regLimitB = 0;
  }
  sqlite3ExprDelete(db, p->pLimit);
  p->pLimit = 0;

  regAddrA = ++pParse->nMem;
  regAddrB = ++pParse->nMem;
  regOutA = ++pParse->nMem;
  regOutB = ++pParse->nMem;
  sqlite3SelectDestInit(&destA, 13, regAddrA);
  sqlite3SelectDestInit(&destB, 13, regAddrB);

  sqlite3VdbeExplain (pParse, 1, "MERGE (%s)", sqlite3SelectOpName(p->op));




  addrSelectA = sqlite3VdbeCurrentAddr(v) + 1;
  addr1 = sqlite3VdbeAddOp3(v, 11, regAddrA, 0, addrSelectA);
                                 ;
  pPrior->iLimit = regLimitA;
  sqlite3VdbeExplain (pParse, 1, "LEFT");
  sqlite3Select(pParse, pPrior, &destA);
  sqlite3VdbeEndCoroutine(v, regAddrA);
  sqlite3VdbeJumpHere(v, addr1);




  addrSelectB = sqlite3VdbeCurrentAddr(v) + 1;
  addr1 = sqlite3VdbeAddOp3(v, 11, regAddrB, 0, addrSelectB);
                                  ;
  savedLimit = p->iLimit;
  savedOffset = p->iOffset;
  p->iLimit = regLimitB;
  p->iOffset = 0;
  sqlite3VdbeExplain (pParse, 1, "RIGHT");
  sqlite3Select(pParse, p, &destB);
  p->iLimit = savedLimit;
  p->iOffset = savedOffset;
  sqlite3VdbeEndCoroutine(v, regAddrB);




                                              ;
  addrOutA = generateOutputSubroutine(pParse,
                 p, &destA, pDest, regOutA,
                 regPrev, pKeyDup, labelEnd);




  if( op==136 || op==135 ){
                                                ;
    addrOutB = generateOutputSubroutine(pParse,
                 p, &destB, pDest, regOutB,
                 regPrev, pKeyDup, labelEnd);
  }
  sqlite3KeyInfoUnref(pKeyDup);




  if( op==137 || op==138 ){
    addrEofA_noB = addrEofA = labelEnd;
  }else{
                                            ;
    addrEofA = sqlite3VdbeAddOp2(v, 10, regOutB, addrOutB);
    addrEofA_noB = sqlite3VdbeAddOp2(v, 12, regAddrB, labelEnd);
                                                    ;
    sqlite3VdbeGoto(v, addrEofA);
    p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
  }




  if( op==138 ){
    addrEofB = addrEofA;
    if( p->nSelectRow > pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;
  }else{
                                            ;
    addrEofB = sqlite3VdbeAddOp2(v, 10, regOutA, addrOutA);
    sqlite3VdbeAddOp2(v, 12, regAddrA, labelEnd); ;
    sqlite3VdbeGoto(v, addrEofB);
  }



                                           ;
  addrAltB = sqlite3VdbeAddOp2(v, 10, regOutA, addrOutA);
  sqlite3VdbeAddOp2(v, 12, regAddrA, addrEofA); ;
  sqlite3VdbeGoto(v, labelCmpr);



  if( op==136 ){
    addrAeqB = addrAltB;
  }else if( op==138 ){
    addrAeqB = addrAltB;
    addrAltB++;
  }else{
                                             ;
    addrAeqB =
    sqlite3VdbeAddOp2(v, 12, regAddrA, addrEofA); ;
    sqlite3VdbeGoto(v, labelCmpr);
  }



                                           ;
  addrAgtB = sqlite3VdbeCurrentAddr(v);
  if( op==136 || op==135 ){
    sqlite3VdbeAddOp2(v, 10, regOutB, addrOutB);
  }
  sqlite3VdbeAddOp2(v, 12, regAddrB, addrEofB); ;
  sqlite3VdbeGoto(v, labelCmpr);



  sqlite3VdbeJumpHere(v, addr1);
  sqlite3VdbeAddOp2(v, 12, regAddrA, addrEofA_noB); ;
  sqlite3VdbeAddOp2(v, 12, regAddrB, addrEofB); ;



  sqlite3VdbeResolveLabel(v, labelCmpr);
  sqlite3VdbeAddOp4(v, 90, 0, 0, 0, (char*)aPermute, (-14));
  sqlite3VdbeAddOp4(v, 91, destA.iSdst, destB.iSdst, nOrderBy,
                         (char*)pKeyMerge, (-8));
  sqlite3VdbeChangeP5(v, 0x01);
  sqlite3VdbeAddOp3(v, 14, addrAltB, addrAeqB, addrAgtB); ;



  sqlite3VdbeResolveLabel(v, labelEnd);



  if( pSplit->pPrior ){
    sqlite3ParserAddCleanup(pParse, sqlite3SelectDeleteGeneric, pSplit->pPrior);
  }
  pSplit->pPrior = pPrior;
  pPrior->pNext = pSplit;
  sqlite3ExprListDelete(db, pPrior->pOrderBy);
  pPrior->pOrderBy = 0;



  sqlite3VdbeExplainPop(pParse);
  return pParse->nErr!=0;
}
# 150656 "c_tests/sqlite3.c"
typedef struct SubstContext {
  Parse *pParse;
  int iTable;
  int iNewTable;
  int isOuterJoin;
  int nSelDepth;
  ExprList *pEList;
  ExprList *pCList;
} SubstContext;


static void substExprList(SubstContext*, ExprList*);
static void substSelect(SubstContext*, Select*, int);
# 150683 "c_tests/sqlite3.c"
static Expr *substExpr(
  SubstContext *pSubst,
  Expr *pExpr
){
  if( pExpr==0 ) return 0;
  if( (((pExpr)->flags&(u32)(0x000001|0x000002))!=0)
   && pExpr->w.iJoin==pSubst->iTable
  ){
                                                  ;
    pExpr->w.iJoin = pSubst->iNewTable;
  }
  if( pExpr->op==168
   && pExpr->iTable==pSubst->iTable
   && !(((pExpr)->flags&(u32)(0x000020))!=0)
  ){





    {
      Expr *pNew;
      int iColumn;
      Expr *pCopy;
      Expr ifNullRow;
      iColumn = pExpr->iColumn;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      pCopy = pSubst->pEList->a[iColumn].pExpr;
      if( sqlite3ExprIsVector(pCopy) ){
        sqlite3VectorErrorMsg(pSubst->pParse, pCopy);
      }else{
        sqlite3 *db = pSubst->pParse->db;
        if( pSubst->isOuterJoin
         && (pCopy->op!=168 || pCopy->iTable!=pSubst->iNewTable)
        ){
          memset(&ifNullRow, 0, sizeof(ifNullRow));
          ifNullRow.op = 179;
          ifNullRow.pLeft = pCopy;
          ifNullRow.iTable = pSubst->iNewTable;
          ifNullRow.iColumn = -99;
          ifNullRow.flags = 0x040000;
          pCopy = &ifNullRow;
        }
                                                       ;
        pNew = sqlite3ExprDup(db, pCopy, 0);
        if( db->mallocFailed ){
          sqlite3ExprDelete(db, pNew);
          return pExpr;
        }
        if( pSubst->isOuterJoin ){
          (pNew)->flags|=(u32)(0x200000);
        }
        if( pNew->op==171 ){
          pNew->u.iValue = sqlite3ExprTruthValue(pNew);
          pNew->op = 156;
          (pNew)->flags|=(u32)(0x000800);
        }



        {
          CollSeq *pNat = sqlite3ExprCollSeq(pSubst->pParse, pNew);
          CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse,
                pSubst->pCList->a[iColumn].pExpr
          );
          if( pNat!=pColl || (pNew->op!=168 && pNew->op!=114) ){
            pNew = sqlite3ExprAddCollateString(pSubst->pParse, pNew,
                (pColl ? pColl->zName : "BINARY")
            );
          }
        }
        (pNew)->flags&=~(u32)(0x000200);
        if( (((pExpr)->flags&(u32)(0x000001|0x000002))!=0) ){
          sqlite3SetJoinExpr(pNew, pExpr->w.iJoin,
                             pExpr->flags & (0x000001|0x000002));
        }
        sqlite3ExprDelete(db, pExpr);
        pExpr = pNew;
      }
    }
  }else{
    if( pExpr->op==179 && pExpr->iTable==pSubst->iTable ){
      pExpr->iTable = pSubst->iNewTable;
    }
    if( pExpr->op==169 && pExpr->op2>=pSubst->nSelDepth ){
      pExpr->op2--;
    }
    pExpr->pLeft = substExpr(pSubst, pExpr->pLeft);
    pExpr->pRight = substExpr(pSubst, pExpr->pRight);
    if( (((pExpr)->flags&0x001000)!=0) ){
      substSelect(pSubst, pExpr->x.pSelect, 1);
    }else{
      substExprList(pSubst, pExpr->x.pList);
    }

    if( (((pExpr)->flags&(u32)(0x1000000))!=0) ){
      Window *pWin = pExpr->y.pWin;
      pWin->pFilter = substExpr(pSubst, pWin->pFilter);
      substExprList(pSubst, pWin->pPartition);
      substExprList(pSubst, pWin->pOrderBy);
    }

  }
  return pExpr;
}
static void substExprList(
  SubstContext *pSubst,
  ExprList *pList
){
  int i;
  if( pList==0 ) return;
  for(i=0; i<pList->nExpr; i++){
    pList->a[i].pExpr = substExpr(pSubst, pList->a[i].pExpr);
  }
}
static void substSelect(
  SubstContext *pSubst,
  Select *p,
  int doPrior
){
  SrcList *pSrc;
  SrcItem *pItem;
  int i;
  if( !p ) return;
  pSubst->nSelDepth++;
  do{
    substExprList(pSubst, p->pEList);
    substExprList(pSubst, p->pGroupBy);
    substExprList(pSubst, p->pOrderBy);
    p->pHaving = substExpr(pSubst, p->pHaving);
    p->pWhere = substExpr(pSubst, p->pWhere);
    pSrc = p->pSrc;
    ((void) (0));
    for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){
      if( pItem->fg.isSubquery ){
        substSelect(pSubst, pItem->u4.pSubq->pSelect, 1);
      }
      if( pItem->fg.isTabFunc ){
        substExprList(pSubst, pItem->u1.pFuncArg);
      }
    }
  }while( doPrior && (p = p->pPrior)!=0 );
  pSubst->nSelDepth--;
}
# 150839 "c_tests/sqlite3.c"
static int recomputeColumnsUsedExpr(Walker *pWalker, Expr *pExpr){
  SrcItem *pItem;
  if( pExpr->op!=168 ) return 0;
  pItem = pWalker->u.pSrcItem;
  if( pItem->iCursor!=pExpr->iTable ) return 0;
  if( pExpr->iColumn<0 ) return 0;
  pItem->colUsed |= sqlite3ExprColUsed(pExpr);
  return 0;
}
static void recomputeColumnsUsed(
  Select *pSelect,
  SrcItem *pSrcItem
){
  Walker w;
  if( (pSrcItem->pSTab==0) ) return;
  memset(&w, 0, sizeof(w));
  w.xExprCallback = recomputeColumnsUsedExpr;
  w.xSelectCallback = sqlite3SelectWalkNoop;
  w.u.pSrcItem = pSrcItem;
  pSrcItem->colUsed = 0;
  sqlite3WalkSelect(&w, pSelect);
}
# 150877 "c_tests/sqlite3.c"
static void srclistRenumberCursors(
  Parse *pParse,
  int *aCsrMap,
  SrcList *pSrc,
  int iExcept
){
  int i;
  SrcItem *pItem;
  for(i=0, pItem=pSrc->a; i<pSrc->nSrc; i++, pItem++){
    if( i!=iExcept ){
      Select *p;
      ((void) (0));
      if( !pItem->fg.isRecursive || aCsrMap[pItem->iCursor+1]==0 ){
        aCsrMap[pItem->iCursor+1] = pParse->nTab++;
      }
      pItem->iCursor = aCsrMap[pItem->iCursor+1];
      if( pItem->fg.isSubquery ){
        for(p=pItem->u4.pSubq->pSelect; p; p=p->pPrior){
          srclistRenumberCursors(pParse, aCsrMap, p->pSrc, -1);
        }
      }
    }
  }
}




static void renumberCursorDoMapping(Walker *pWalker, int *piCursor){
  int *aCsrMap = pWalker->u.aiCol;
  int iCsr = *piCursor;
  if( iCsr < aCsrMap[0] && aCsrMap[iCsr+1]>0 ){
    *piCursor = aCsrMap[iCsr+1];
  }
}





static int renumberCursorsCb(Walker *pWalker, Expr *pExpr){
  int op = pExpr->op;
  if( op==168 || op==179 ){
    renumberCursorDoMapping(pWalker, &pExpr->iTable);
  }
  if( (((pExpr)->flags&(u32)(0x000001))!=0) ){
    renumberCursorDoMapping(pWalker, &pExpr->w.iJoin);
  }
  return 0;
}
# 150946 "c_tests/sqlite3.c"
static void renumberCursors(
  Parse *pParse,
  Select *p,
  int iExcept,
  int *aCsrMap
){
  Walker w;
  srclistRenumberCursors(pParse, aCsrMap, p->pSrc, iExcept);
  memset(&w, 0, sizeof(w));
  w.u.aiCol = aCsrMap;
  w.xExprCallback = renumberCursorsCb;
  w.xSelectCallback = sqlite3SelectWalkNoop;
  sqlite3WalkSelect(&w, p);
}







static ExprList *findLeftmostExprlist(Select *pSel){
  while( pSel->pPrior ){
    pSel = pSel->pPrior;
  }
  return pSel->pEList;
}





static int compoundHasDifferentAffinities(Select *p){
  int ii;
  ExprList *pList;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pList = p->pEList;
  for(ii=0; ii<pList->nExpr; ii++){
    char aff;
    Select *pSub1;
    ((void) (0));
    aff = sqlite3ExprAffinity(pList->a[ii].pExpr);
    for(pSub1=p->pPrior; pSub1; pSub1=pSub1->pPrior){
      ((void) (0));
      ((void) (0));
      ((void) (0));
      if( sqlite3ExprAffinity(pSub1->pEList->a[ii].pExpr)!=aff ){
        return 1;
      }
    }
  }
  return 0;
}
# 151176 "c_tests/sqlite3.c"
static int flattenSubquery(
  Parse *pParse,
  Select *p,
  int iFrom,
  int isAgg
){
  const char *zSavedAuthContext = pParse->zAuthContext;
  Select *pParent;
  Select *pSub;
  Select *pSub1;
  SrcList *pSrc;
  SrcList *pSubSrc;
  int iParent;
  int iNewParent = -1;
  int isOuterJoin = 0;
  int i;
  Expr *pWhere;
  SrcItem *pSubitem;
  sqlite3 *db = pParse->db;
  Walker w;
  int *aCsrMap = 0;



  ((void) (0));
  ((void) (0));
  if( (((db)->dbOptFlags&(0x00000001))!=0) ) return 0;
  pSrc = p->pSrc;
  ((void) (0));
  pSubitem = &pSrc->a[iFrom];
  iParent = pSubitem->iCursor;
  ((void) (0));
  pSub = pSubitem->u4.pSubq->pSelect;
  ((void) (0));


  if( p->pWin || pSub->pWin ) return 0;


  pSubSrc = pSub->pSrc;
  ((void) (0));





  if( pSub->pLimit && p->pLimit ) return 0;
  if( pSub->pLimit && pSub->pLimit->pRight ) return 0;
  if( (p->selFlags & 0x0000100)!=0 && pSub->pLimit ){
    return 0;
  }
  if( pSubSrc->nSrc==0 ) return 0;
  if( pSub->selFlags & 0x0000001 ) return 0;
  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){
     return 0;
  }
  if( p->pOrderBy && pSub->pOrderBy ){
     return 0;
  }
  if( isAgg && pSub->pOrderBy ) return 0;
  if( pSub->pLimit && p->pWhere ) return 0;
  if( pSub->pLimit && (p->selFlags & 0x0000001)!=0 ){
     return 0;
  }
  if( pSub->selFlags & (0x0002000) ){
    return 0;
  }
# 151259 "c_tests/sqlite3.c"
  if( (pSubitem->fg.jointype & (0x20|0x40))!=0 ){
    if( pSubSrc->nSrc>1

     || (p->selFlags & 0x0000001)!=0
     || (pSubitem->fg.jointype & 0x10)!=0
    ){
      return 0;
    }
    isOuterJoin = 1;
  }

  ((void) (0));
  if( iFrom>0 && (pSubSrc->a[0].fg.jointype & 0x40)!=0 ){
    return 0;
  }


  ((void) (0));






  if( pSub->pPrior ){
    int ii;
    if( pSub->pOrderBy ){
      return 0;
    }
    if( isAgg || (p->selFlags & 0x0000001)!=0 || isOuterJoin>0 ){
      return 0;
    }
    for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){
                                                                             ;
                                                                              ;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      if( (pSub1->selFlags & (0x0000001|0x0000008))!=0
       || (pSub1->pPrior && pSub1->op!=136)
       || pSub1->pSrc->nSrc<1

       || pSub1->pWin

      ){
        return 0;
      }
      if( iFrom>0 && (pSub1->pSrc->a[0].fg.jointype & 0x40)!=0 ){



        return 0;
      }
                                     ;
    }


    if( p->pOrderBy ){
      for(ii=0; ii<p->pOrderBy->nExpr; ii++){
        if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;
      }
    }


    if( (p->selFlags & 0x0002000) ) return 0;


    if( compoundHasDifferentAffinities(pSub) ) return 0;

    if( pSrc->nSrc>1 ){
      if( pParse->nSelect>500 ) return 0;
      if( (((db)->dbOptFlags&(0x00800000))!=0) ) return 0;
      aCsrMap = sqlite3DbMallocZero(db, ((i64)pParse->nTab+1)*sizeof(int));
      if( aCsrMap ) aCsrMap[0] = pParse->nTab;
    }
  }



                                             ;


  pParse->zAuthContext = pSubitem->zName;
                sqlite3AuthCheck(pParse, 21, 0, 0, 0);
                            ;
  pParse->zAuthContext = zSavedAuthContext;



  if( (pSubitem->fg.isSubquery) ){
    pSub1 = sqlite3SubqueryDetach(db, pSubitem);
  }else{
    pSub1 = 0;
  }
  ((void) (0));
  ((void) (0));
  sqlite3DbFree(db, pSubitem->zName);
  sqlite3DbFree(db, pSubitem->zAlias);
  pSubitem->zName = 0;
  pSubitem->zAlias = 0;
  ((void) (0));
# 151394 "c_tests/sqlite3.c"
  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){
    Select *pNew;
    ExprList *pOrderBy = p->pOrderBy;
    Expr *pLimit = p->pLimit;
    Select *pPrior = p->pPrior;
    Table *pItemTab = pSubitem->pSTab;
    pSubitem->pSTab = 0;
    p->pOrderBy = 0;
    p->pPrior = 0;
    p->pLimit = 0;
    pNew = sqlite3SelectDup(db, p, 0);
    p->pLimit = pLimit;
    p->pOrderBy = pOrderBy;
    p->op = 136;
    pSubitem->pSTab = pItemTab;
    if( pNew==0 ){
      p->pPrior = pPrior;
    }else{
      pNew->selId = ++pParse->nSelect;
      if( aCsrMap && (db->mallocFailed==0) ){
        renumberCursors(pParse, pNew, iFrom, aCsrMap);
      }
      pNew->pPrior = pPrior;
      if( pPrior ) pPrior->pNext = pNew;
      pNew->pNext = p;
      p->pPrior = pNew;

                                                                   ;
    }
    ((void) (0));
  }
  sqlite3DbFree(db, aCsrMap);
  if( db->mallocFailed ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    sqlite3SrcItemAttachSubquery(pParse, pSubitem, pSub1, 0);
    return 1;
  }
# 151441 "c_tests/sqlite3.c"
  if( (pSubitem->pSTab!=0) ){
    Table *pTabToDel = pSubitem->pSTab;
    if( pTabToDel->nTabRef==1 ){
      Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
      sqlite3ParserAddCleanup(pToplevel, sqlite3DeleteTableGeneric, pTabToDel);
                                         ;
    }else{
      pTabToDel->nTabRef--;
    }
    pSubitem->pSTab = 0;
  }
# 151466 "c_tests/sqlite3.c"
  pSub = pSub1;
  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){
    int nSubSrc;
    u8 jointype = pSubitem->fg.jointype;
    ((void) (0));
    pSubSrc = pSub->pSrc;
    nSubSrc = pSubSrc->nSrc;
    pSrc = pParent->pSrc;
# 151490 "c_tests/sqlite3.c"
    if( nSubSrc>1 ){
      pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);
      if( pSrc==0 ) break;
      pParent->pSrc = pSrc;
      pSubitem = &pSrc->a[iFrom];
    }




    iNewParent = pSubSrc->a[0].iCursor;
    for(i=0; i<nSubSrc; i++){
      SrcItem *pItem = &pSrc->a[i+iFrom];
      ((void) (0));
      ((void) (0));


      if( pItem->fg.isUsing ) sqlite3IdListDelete(db, pItem->u3.pUsing);
      *pItem = pSubSrc->a[i];
      pItem->fg.jointype |= (jointype & 0x40);
      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
    }
    pSubitem->fg.jointype |= jointype;
# 151526 "c_tests/sqlite3.c"
    if( pSub->pOrderBy && (pParent->selFlags & 0x0400000)==0 ){
# 151537 "c_tests/sqlite3.c"
      ExprList *pOrderBy = pSub->pOrderBy;
      for(i=0; i<pOrderBy->nExpr; i++){
        pOrderBy->a[i].u.x.iOrderByCol = 0;
      }
      ((void) (0));
      pParent->pOrderBy = pOrderBy;
      pSub->pOrderBy = 0;
    }
    pWhere = pSub->pWhere;
    pSub->pWhere = 0;
    if( isOuterJoin>0 ){
      ((void) (0));
      sqlite3SetJoinExpr(pWhere, iNewParent, 0x000001);
    }
    if( pWhere ){
      if( pParent->pWhere ){
        pParent->pWhere = sqlite3PExpr(pParse, 44, pWhere, pParent->pWhere);
      }else{
        pParent->pWhere = pWhere;
      }
    }
    if( db->mallocFailed==0 ){
      SubstContext x;
      x.pParse = pParse;
      x.iTable = iParent;
      x.iNewTable = iNewParent;
      x.isOuterJoin = isOuterJoin;
      x.nSelDepth = 0;
      x.pEList = pSub->pEList;
      x.pCList = findLeftmostExprlist(pSub);
      substSelect(&x, pParent, 0);
    }



    pParent->selFlags |= pSub->selFlags & 0x0000100;
    ((void) (0));







    if( pSub->pLimit ){
      pParent->pLimit = pSub->pLimit;
      pSub->pLimit = 0;
    }



    for(i=0; i<nSubSrc; i++){
      recomputeColumnsUsed(pParent, &pSrc->a[i+iFrom]);
    }
  }



  sqlite3AggInfoPersistWalkerInit(&w, pParse);
  sqlite3WalkSelect(&w,pSub1);
  sqlite3SelectDelete(db, pSub1);
# 151606 "c_tests/sqlite3.c"
  return 1;
}






typedef struct WhereConst WhereConst;
struct WhereConst {
  Parse *pParse;
  u8 *pOomFault;
  int nConst;
  int nChng;
  int bHasAffBlob;
  u32 mExcludeOn;

  Expr **apExpr;
};
# 151634 "c_tests/sqlite3.c"
static void constInsert(
  WhereConst *pConst,
  Expr *pColumn,
  Expr *pValue,
  Expr *pExpr
){
  int i;
  ((void) (0));
  ((void) (0));

  if( (((pColumn)->flags&(u32)(0x000020))!=0) ) return;
  if( sqlite3ExprAffinity(pValue)!=0 ) return;
  if( !sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst->pParse,pExpr)) ){
    return;
  }



  for(i=0; i<pConst->nConst; i++){
    const Expr *pE2 = pConst->apExpr[i*2];
    ((void) (0));
    if( pE2->iTable==pColumn->iTable
     && pE2->iColumn==pColumn->iColumn
    ){
      return;
    }
  }
  ((void) (0));
  if( sqlite3ExprAffinity(pColumn)<=0x41 ){
    pConst->bHasAffBlob = 1;
  }

  pConst->nConst++;
  pConst->apExpr = sqlite3DbReallocOrFree(pConst->pParse->db, pConst->apExpr,
                         pConst->nConst*2*sizeof(Expr*));
  if( pConst->apExpr==0 ){
    pConst->nConst = 0;
  }else{
    pConst->apExpr[pConst->nConst*2-2] = pColumn;
    pConst->apExpr[pConst->nConst*2-1] = pValue;
  }
}







static void findConstInWhere(WhereConst *pConst, Expr *pExpr){
  Expr *pRight, *pLeft;
  if( (pExpr==0) ) return;
  if( (((pExpr)->flags&(u32)(pConst->mExcludeOn))!=0) ){
                                                  ;
                                                  ;
    return;
  }
  if( pExpr->op==44 ){
    findConstInWhere(pConst, pExpr->pRight);
    findConstInWhere(pConst, pExpr->pLeft);
    return;
  }
  if( pExpr->op!=54 ) return;
  pRight = pExpr->pRight;
  pLeft = pExpr->pLeft;
  ((void) (0));
  ((void) (0));
  if( pRight->op==168 && sqlite3ExprIsConstant(pConst->pParse, pLeft) ){
    constInsert(pConst,pRight,pLeft,pExpr);
  }
  if( pLeft->op==168 && sqlite3ExprIsConstant(pConst->pParse, pRight) ){
    constInsert(pConst,pLeft,pRight,pExpr);
  }
}
# 151718 "c_tests/sqlite3.c"
static int propagateConstantExprRewriteOne(
  WhereConst *pConst,
  Expr *pExpr,
  int bIgnoreAffBlob
){
  int i;
  if( pConst->pOomFault[0] ) return 1;
  if( pExpr->op!=168 ) return 0;
  if( (((pExpr)->flags&(u32)(0x000020|pConst->mExcludeOn))!=0) ){
                                                   ;
                                                  ;
                                                  ;
    return 0;
  }
  for(i=0; i<pConst->nConst; i++){
    Expr *pColumn = pConst->apExpr[i*2];
    if( pColumn==pExpr ) continue;
    if( pColumn->iTable!=pExpr->iTable ) continue;
    if( pColumn->iColumn!=pExpr->iColumn ) continue;
    ((void) (0));
    if( bIgnoreAffBlob && sqlite3ExprAffinity(pColumn)<=0x41 ){
      break;
    }

    pConst->nChng++;
    (pExpr)->flags&=~(u32)(0x800000);
    (pExpr)->flags|=(u32)(0x000020);
    ((void) (0));
    pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);
    if( pConst->pParse->db->mallocFailed ) return 1;
    break;
  }
  return 1;
}
# 151769 "c_tests/sqlite3.c"
static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){
  WhereConst *pConst = pWalker->u.pConst;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pConst->bHasAffBlob ){
    if( (pExpr->op>=54 && pExpr->op<=58)
     || pExpr->op==45
    ){
      propagateConstantExprRewriteOne(pConst, pExpr->pLeft, 0);
      if( pConst->pOomFault[0] ) return 1;
      if( sqlite3ExprAffinity(pExpr->pLeft)!=0x42 ){
        propagateConstantExprRewriteOne(pConst, pExpr->pRight, 0);
      }
    }
  }
  return propagateConstantExprRewriteOne(pConst, pExpr, pConst->bHasAffBlob);
}
# 151840 "c_tests/sqlite3.c"
static int propagateConstants(
  Parse *pParse,
  Select *p
){
  WhereConst x;
  Walker w;
  int nChng = 0;
  x.pParse = pParse;
  x.pOomFault = &pParse->db->mallocFailed;
  do{
    x.nConst = 0;
    x.nChng = 0;
    x.apExpr = 0;
    x.bHasAffBlob = 0;
    if( (p->pSrc!=0)
     && p->pSrc->nSrc>0
     && (p->pSrc->a[0].fg.jointype & 0x40)!=0
    ){


      x.mExcludeOn = 0x000002 | 0x000001;
    }else{

      x.mExcludeOn = 0x000001;
    }
    findConstInWhere(&x, p->pWhere);
    if( x.nConst ){
      memset(&w, 0, sizeof(w));
      w.pParse = pParse;
      w.xExprCallback = propagateConstantExprRewrite;
      w.xSelectCallback = sqlite3SelectWalkNoop;
      w.xSelectCallback2 = 0;
      w.walkerDepth = 0;
      w.u.pConst = &x;
      sqlite3WalkExpr(&w, p->pWhere);
      sqlite3DbFree(x.pParse->db, x.apExpr);
      nChng += x.nChng;
    }
  }while( x.nChng );
  return nChng;
}
# 151902 "c_tests/sqlite3.c"
static int pushDownWindowCheck(Parse *pParse, Select *pSubq, Expr *pExpr){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return sqlite3ExprIsConstantOrGroupBy(pParse, pExpr, pSubq->pWin->pPartition);
}
# 152020 "c_tests/sqlite3.c"
static int pushDownWhereTerms(
  Parse *pParse,
  Select *pSubq,
  Expr *pWhere,
  SrcList *pSrcList,
  int iSrc
){
  Expr *pNew;
  SrcItem *pSrc;
  int nChng = 0;
  pSrc = &pSrcList->a[iSrc];
  if( pWhere==0 ) return 0;
  if( pSubq->selFlags & (0x0002000|0x2000000) ){
    return 0;
  }
  if( pSrc->fg.jointype & (0x40|0x10) ){
    return 0;
  }

  if( pSubq->pPrior ){
    Select *pSel;
    int notUnionAll = 0;
    for(pSel=pSubq; pSel; pSel=pSel->pPrior){
      u8 op = pSel->op;
      ((void) (0));

      if( op!=136 && op!=139 ){
        notUnionAll = 1;
      }

      if( pSel->pWin ) return 0;

    }
    if( notUnionAll ){



      for(pSel=pSubq; pSel; pSel=pSel->pPrior){
        int ii;
        const ExprList *pList = pSel->pEList;
        ((void) (0));
        for(ii=0; ii<pList->nExpr; ii++){
          CollSeq *pColl = sqlite3ExprCollSeq(pParse, pList->a[ii].pExpr);
          if( !sqlite3IsBinary(pColl) ){
            return 0;
          }
        }
      }
    }
  }else{

    if( pSubq->pWin && pSubq->pWin->pPartition==0 ) return 0;

  }
# 152088 "c_tests/sqlite3.c"
  if( pSubq->pLimit!=0 ){
    return 0;
  }
  while( pWhere->op==44 ){
    nChng += pushDownWhereTerms(pParse, pSubq, pWhere->pRight, pSrcList, iSrc);
    pWhere = pWhere->pLeft;
  }
# 152139 "c_tests/sqlite3.c"
  if( sqlite3ExprIsSingleTableConstraint(pWhere, pSrcList, iSrc, 1) ){
    nChng++;
    pSubq->selFlags |= 0x1000000;
    while( pSubq ){
      SubstContext x;
      pNew = sqlite3ExprDup(pParse->db, pWhere, 0);
      unsetJoinExpr(pNew, -1, 1);
      x.pParse = pParse;
      x.iTable = pSrc->iCursor;
      x.iNewTable = pSrc->iCursor;
      x.isOuterJoin = 0;
      x.nSelDepth = 0;
      x.pEList = pSubq->pEList;
      x.pCList = findLeftmostExprlist(pSubq);
      pNew = substExpr(&x, pNew);

      if( pSubq->pWin && 0==pushDownWindowCheck(pParse, pSubq, pNew) ){

        sqlite3ExprDelete(pParse->db, pNew);
        nChng--;
        break;
      }

      if( pSubq->selFlags & 0x0000008 ){
        pSubq->pHaving = sqlite3ExprAnd(pParse, pSubq->pHaving, pNew);
      }else{
        pSubq->pWhere = sqlite3ExprAnd(pParse, pSubq->pWhere, pNew);
      }
      pSubq = pSubq->pPrior;
    }
  }
  return nChng;
}
# 152181 "c_tests/sqlite3.c"
static int disableUnusedSubqueryResultColumns(SrcItem *pItem){
  int nCol;
  Select *pSub;
  Select *pX;
  Table *pTab;
  int j;
  int nChng = 0;
  Bitmask colUsed;

  ((void) (0));
  if( pItem->fg.isCorrelated || pItem->fg.isCte ){
    return 0;
  }
  ((void) (0));
  pTab = pItem->pSTab;
  ((void) (0));
  pSub = pItem->u4.pSubq->pSelect;
  ((void) (0));
  for(pX=pSub; pX; pX=pX->pPrior){
    if( (pX->selFlags & (0x0000001|0x0000008))!=0 ){
                                            ;
                                             ;
      return 0;
    }
    if( pX->pPrior && pX->op!=136 ){


      return 0;
    }

    if( pX->pWin ){


      return 0;
    }

  }
  colUsed = pItem->colUsed;
  if( pSub->pOrderBy ){
    ExprList *pList = pSub->pOrderBy;
    for(j=0; j<pList->nExpr; j++){
      u16 iCol = pList->a[j].u.x.iOrderByCol;
      if( iCol>0 ){
        iCol--;
        colUsed |= ((Bitmask)1)<<(iCol>=((int)(sizeof(Bitmask)*8)) ? ((int)(sizeof(Bitmask)*8))-1 : iCol);
      }
    }
  }
  nCol = pTab->nCol;
  for(j=0; j<nCol; j++){
    Bitmask m = j<((int)(sizeof(Bitmask)*8))-1 ? (((Bitmask)1)<<(j)) : (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1));
    if( (m & colUsed)!=0 ) continue;
    for(pX=pSub; pX; pX=pX->pPrior) {
      Expr *pY = pX->pEList->a[j].pExpr;
      if( pY->op==122 ) continue;
      pY->op = 122;
      (pY)->flags&=~(u32)(0x002000|0x080000);
      pX->selFlags |= 0x1000000;
      nChng++;
    }
  }
  return nChng;
}
# 152262 "c_tests/sqlite3.c"
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax){
  int eRet = 0x0000;
  ExprList *pEList;
  const char *zFunc;
  ExprList *pOrderBy;
  u8 sortFlags = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pEList = pFunc->x.pList;
  if( pEList==0
   || pEList->nExpr!=1
   || (((pFunc)->flags&(u32)(0x1000000))!=0)
   || (((db)->dbOptFlags&(0x00010000))!=0)
  ){
    return eRet;
  }
  ((void) (0));
  zFunc = pFunc->u.zToken;
  if( sqlite3StrICmp(zFunc, "min")==0 ){
    eRet = 0x0001;
    if( sqlite3ExprCanBeNull(pEList->a[0].pExpr) ){
      sortFlags = 0x02;
    }
  }else if( sqlite3StrICmp(zFunc, "max")==0 ){
    eRet = 0x0002;
    sortFlags = 0x01;
  }else{
    return eRet;
  }
  *ppMinMax = pOrderBy = sqlite3ExprListDup(db, pEList, 0);
  ((void) (0));
  if( pOrderBy ) pOrderBy->a[0].fg.sortFlags = sortFlags;
  return eRet;
}
# 152317 "c_tests/sqlite3.c"
static Table *isSimpleCount(Select *p, AggInfo *pAggInfo){
  Table *pTab;
  Expr *pExpr;

  ((void) (0));

  if( p->pWhere
   || p->pEList->nExpr!=1
   || p->pSrc->nSrc!=1
   || p->pSrc->a[0].fg.isSubquery
   || pAggInfo->nFunc!=1
   || p->pHaving
  ){
    return 0;
  }
  pTab = p->pSrc->a[0].pSTab;
  ((void) (0));
  ((void) (0));
  if( !((pTab)->eTabType==0) ) return 0;
  pExpr = p->pEList->a[0].pExpr;
  ((void) (0));
  if( pExpr->op!=169 ) return 0;
  if( pExpr->pAggInfo!=pAggInfo ) return 0;
  if( (pAggInfo->aFunc[0].pFunc->funcFlags&0x0100)==0 ) return 0;
  ((void) (0));
                                                 ;
                                                ;
  if( (((pExpr)->flags&(u32)(0x000004|0x1000000))!=0) ) return 0;

  return pTab;
}
# 152356 "c_tests/sqlite3.c"
static int sqlite3IndexedByLookup(Parse *pParse, SrcItem *pFrom){
  Table *pTab = pFrom->pSTab;
  char *zIndexedBy = pFrom->u1.zIndexedBy;
  Index *pIdx;
  ((void) (0));
  ((void) (0));

  for(pIdx=pTab->pIndex;
      pIdx && sqlite3StrICmp(pIdx->zName, zIndexedBy);
      pIdx=pIdx->pNext
  );
  if( !pIdx ){
    sqlite3ErrorMsg(pParse, "no such index: %s", zIndexedBy, 0);
    pParse->checkSchema = 1;
    return 1;
  }
  ((void) (0));
  pFrom->u2.pIBIndex = pIdx;
  return 0;
}
# 152398 "c_tests/sqlite3.c"
static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){
  int i;
  Select *pNew;
  Select *pX;
  sqlite3 *db;
  struct ExprList_item *a;
  SrcList *pNewSrc;
  Parse *pParse;
  Token dummy;

  if( p->pPrior==0 ) return 0;
  if( p->pOrderBy==0 ) return 0;
  for(pX=p; pX && (pX->op==136 || pX->op==139); pX=pX->pPrior){}
  if( pX==0 ) return 0;
  a = p->pOrderBy->a;






  if( a[0].u.x.iOrderByCol ) return 0;

  for(i=p->pOrderBy->nExpr-1; i>=0; i--){
    if( a[i].pExpr->flags & 0x000200 ) break;
  }
  if( i<0 ) return 0;



  pParse = pWalker->pParse;
  db = pParse->db;
  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );
  if( pNew==0 ) return 2;
  memset(&dummy, 0, sizeof(dummy));
  pNewSrc = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&dummy,pNew,0);
  ((void) (0));
  if( pParse->nErr ){
    sqlite3SrcListDelete(db, pNewSrc);
    return 2;
  }
  *pNew = *p;
  p->pSrc = pNewSrc;
  p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, 180, 0));
  p->op = 139;
  p->pWhere = 0;
  pNew->pGroupBy = 0;
  pNew->pHaving = 0;
  pNew->pOrderBy = 0;
  p->pPrior = 0;
  p->pNext = 0;
  p->pWith = 0;

  p->pWinDefn = 0;

  p->selFlags &= ~(u32)0x0000100;
  ((void) (0));
  p->selFlags |= 0x0010000;
  ((void) (0));
  pNew->pPrior->pNext = pNew;
  pNew->pLimit = 0;
  return 0;
}






static int cannotBeFunction(Parse *pParse, SrcItem *pFrom){
  if( pFrom->fg.isTabFunc ){
    sqlite3ErrorMsg(pParse, "'%s' is not a function", pFrom->zName);
    return 1;
  }
  return 0;
}
# 152486 "c_tests/sqlite3.c"
static struct Cte *searchWith(
  With *pWith,
  SrcItem *pItem,
  With **ppContext
){
  const char *zName = pItem->zName;
  With *p;
  ((void) (0));
  ((void) (0));
  for(p=pWith; p; p=p->pOuter){
    int i;
    for(i=0; i<p->nCte; i++){
      if( sqlite3StrICmp(zName, p->a[i].zName)==0 ){
        *ppContext = p;
        return &p->a[i];
      }
    }
    if( p->bView ) break;
  }
  return 0;
}
# 152525 "c_tests/sqlite3.c"
static With *sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){
  if( pWith ){
    if( bFree ){
      pWith = (With*)sqlite3ParserAddCleanup(pParse, sqlite3WithDeleteGeneric,
                      pWith);
      if( pWith==0 ) return 0;
    }
    if( pParse->nErr==0 ){
      ((void) (0));
      pWith->pOuter = pParse->pWith;
      pParse->pWith = pWith;
    }
  }
  return pWith;
}
# 152555 "c_tests/sqlite3.c"
static int resolveFromTermToCte(
  Parse *pParse,
  Walker *pWalker,
  SrcItem *pFrom
){
  Cte *pCte;
  With *pWith;

  ((void) (0));
  if( pParse->pWith==0 ){

    return 0;
  }
  if( pParse->nErr ){


    return 0;
  }
  ((void) (0));
  if( pFrom->fg.fixedSchema==0 && pFrom->u4.zDatabase!=0 ){


    return 0;
  }
  if( pFrom->fg.notCte ){





    return 0;
  }
  pCte = searchWith(pParse->pWith, pFrom, &pWith);
  if( pCte ){
    sqlite3 *db = pParse->db;
    Table *pTab;
    ExprList *pEList;
    Select *pSel;
    Select *pLeft;
    Select *pRecTerm;
    int bMayRecursive;
    With *pSavedWith;
    int iRecTab = -1;
    CteUse *pCteUse;





    if( pCte->zCteErr ){
      sqlite3ErrorMsg(pParse, pCte->zCteErr, pCte->zName);
      return 2;
    }
    if( cannotBeFunction(pParse, pFrom) ) return 2;

    ((void) (0));
    pTab = sqlite3DbMallocZero(db, sizeof(Table));
    if( pTab==0 ) return 2;
    pCteUse = pCte->pUse;
    if( pCteUse==0 ){
      pCte->pUse = pCteUse = sqlite3DbMallocZero(db, sizeof(pCteUse[0]));
      if( pCteUse==0
       || sqlite3ParserAddCleanup(pParse,sqlite3DbFree,pCteUse)==0
      ){
        sqlite3DbFree(db, pTab);
        return 2;
      }
      pCteUse->eM10d = pCte->eM10d;
    }
    pFrom->pSTab = pTab;
    pTab->nTabRef = 1;
    pTab->zName = sqlite3DbStrDup(db, pCte->zName);
    pTab->iPKey = -1;
    pTab->nRowLogEst = 200; ((void) (0));
    pTab->tabFlags |= 0x00004000 | 0x00000200;
    sqlite3SrcItemAttachSubquery(pParse, pFrom, pCte->pSelect, 1);
    if( db->mallocFailed ) return 2;
    ((void) (0));
    pSel = pFrom->u4.pSubq->pSelect;
    ((void) (0));
    pSel->selFlags |= 0x4000000;
    if( pFrom->fg.isIndexedBy ){
      sqlite3ErrorMsg(pParse, "no such index: \"%s\"", pFrom->u1.zIndexedBy);
      return 2;
    }
    ((void) (0));
    pFrom->fg.isCte = 1;
    pFrom->u2.pCteUse = pCteUse;
    pCteUse->nUse++;


    pRecTerm = pSel;
    bMayRecursive = ( pSel->op==136 || pSel->op==135 );
    while( bMayRecursive && pRecTerm->op==pSel->op ){
      int i;
      SrcList *pSrc = pRecTerm->pSrc;
      ((void) (0));
      for(i=0; i<pSrc->nSrc; i++){
        SrcItem *pItem = &pSrc->a[i];
        if( pItem->zName!=0
         && !pItem->fg.hadSchema
         && (!pItem->fg.isSubquery)
         && (pItem->fg.fixedSchema || pItem->u4.zDatabase==0)
         && 0==sqlite3StrICmp(pItem->zName, pCte->zName)
        ){
          pItem->pSTab = pTab;
          pTab->nTabRef++;
          pItem->fg.isRecursive = 1;
          if( pRecTerm->selFlags & 0x0002000 ){
            sqlite3ErrorMsg(pParse,
               "multiple references to recursive table: %s", pCte->zName
            );
            return 2;
          }
          pRecTerm->selFlags |= 0x0002000;
          if( iRecTab<0 ) iRecTab = pParse->nTab++;
          pItem->iCursor = iRecTab;
        }
      }
      if( (pRecTerm->selFlags & 0x0002000)==0 ) break;
      pRecTerm = pRecTerm->pPrior;
    }

    pCte->zCteErr = "circular reference: %s";
    pSavedWith = pParse->pWith;
    pParse->pWith = pWith;
    if( pSel->selFlags & 0x0002000 ){
      int rc;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      pRecTerm->pWith = pSel->pWith;
      rc = sqlite3WalkSelect(pWalker, pRecTerm);
      pRecTerm->pWith = 0;
      if( rc ){
        pParse->pWith = pSavedWith;
        return 2;
      }
    }else{
      if( sqlite3WalkSelect(pWalker, pSel) ){
        pParse->pWith = pSavedWith;
        return 2;
      }
    }
    pParse->pWith = pWith;

    for(pLeft=pSel; pLeft->pPrior; pLeft=pLeft->pPrior);
    pEList = pLeft->pEList;
    if( pCte->pCols ){
      if( pEList && pEList->nExpr!=pCte->pCols->nExpr ){
        sqlite3ErrorMsg(pParse, "table %s has %d values for %d columns",
            pCte->zName, pEList->nExpr, pCte->pCols->nExpr
        );
        pParse->pWith = pSavedWith;
        return 2;
      }
      pEList = pCte->pCols;
    }

    sqlite3ColumnsFromExprList(pParse, pEList, &pTab->nCol, &pTab->aCol);
    if( bMayRecursive ){
      if( pSel->selFlags & 0x0002000 ){
        pCte->zCteErr = "multiple recursive references: %s";
      }else{
        pCte->zCteErr = "recursive reference in a subquery: %s";
      }
      sqlite3WalkSelect(pWalker, pSel);
    }
    pCte->zCteErr = 0;
    pParse->pWith = pSavedWith;
    return 1;
  }
  return 0;
}
# 152742 "c_tests/sqlite3.c"
static void sqlite3SelectPopWith(Walker *pWalker, Select *p){
  Parse *pParse = pWalker->pParse;
  if( (pParse->pWith) && p->pPrior==0 ){
    With *pWith = findRightmost(p)->pWith;
    if( pWith!=0 ){
      ((void) (0));
      pParse->pWith = pWith->pOuter;
    }
  }
}
# 152761 "c_tests/sqlite3.c"
static int sqlite3ExpandSubquery(Parse *pParse, SrcItem *pFrom){
  Select *pSel;
  Table *pTab;

  ((void) (0));
  ((void) (0));
  pSel = pFrom->u4.pSubq->pSelect;
  ((void) (0));
  pFrom->pSTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));
  if( pTab==0 ) return 7;
  pTab->nTabRef = 1;
  if( pFrom->zAlias ){
    pTab->zName = sqlite3DbStrDup(pParse->db, pFrom->zAlias);
  }else{
    pTab->zName = sqlite3MPrintf(pParse->db, "%!S", pFrom);
  }
  while( pSel->pPrior ){ pSel = pSel->pPrior; }
  sqlite3ColumnsFromExprList(pParse, pSel->pEList,&pTab->nCol,&pTab->aCol);
  pTab->iPKey = -1;
  pTab->eTabType = 2;
  pTab->nRowLogEst = 200; ((void) (0));


  pTab->tabFlags |= 0x00004000 | 0x00000200;




  return pParse->nErr ? 1 : 0;
}
# 152802 "c_tests/sqlite3.c"
static int inAnyUsingClause(
  const char *zName,
  SrcItem *pBase,
  int N
){
  while( N>0 ){
    N--;
    pBase++;
    if( pBase->fg.isUsing==0 ) continue;
    if( (pBase->u3.pUsing==0) ) continue;
    if( sqlite3IdListIndex(pBase->u3.pUsing, zName)>=0 ) return 1;
  }
  return 0;
}
# 152842 "c_tests/sqlite3.c"
static int selectExpander(Walker *pWalker, Select *p){
  Parse *pParse = pWalker->pParse;
  int i, j, k, rc;
  SrcList *pTabList;
  ExprList *pEList;
  SrcItem *pFrom;
  sqlite3 *db = pParse->db;
  Expr *pE, *pRight, *pExpr;
  u16 selFlags = p->selFlags;
  u32 elistFlags = 0;

  p->selFlags |= 0x0000040;
  if( db->mallocFailed ){
    return 2;
  }
  ((void) (0));
  if( (selFlags & 0x0000040)!=0 ){
    return 1;
  }
  if( pWalker->eCode ){

    p->selId = ++pParse->nSelect;
  }
  pTabList = p->pSrc;
  pEList = p->pEList;
  if( pParse->pWith && (p->selFlags & 0x0200000) ){
    if( p->pWith==0 ){
      p->pWith = (With*)sqlite3DbMallocZero(db, (__builtin_offsetof(With, a) + (1)*sizeof(Cte)) );
      if( p->pWith==0 ){
        return 2;
      }
    }
    p->pWith->bView = 1;
  }
  sqlite3WithPush(pParse, p->pWith, 0);




  sqlite3SrcListAssignCursors(pParse, pTabList);





  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
    Table *pTab;
    ((void) (0));
    if( pFrom->pSTab ) continue;
    ((void) (0));
    if( pFrom->zName==0 ){

      Select *pSel;
      ((void) (0));
      pSel = pFrom->u4.pSubq->pSelect;

      ((void) (0));
      ((void) (0));
      if( sqlite3WalkSelect(pWalker, pSel) ) return 2;
      if( sqlite3ExpandSubquery(pParse, pFrom) ) return 2;


    }else if( (rc = resolveFromTermToCte(pParse, pWalker, pFrom))!=0 ){
      if( rc>1 ) return 2;
      pTab = pFrom->pSTab;
      ((void) (0));

    }else{

      ((void) (0));
      pFrom->pSTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);
      if( pTab==0 ) return 2;
      if( pTab->nTabRef>=0xffff ){
        sqlite3ErrorMsg(pParse, "too many references to \"%s\": max 65535",
           pTab->zName);
        pFrom->pSTab = 0;
        return 2;
      }
      pTab->nTabRef++;
      if( !((pTab)->eTabType==1) && cannotBeFunction(pParse, pFrom) ){
        return 2;
      }

      if( !((pTab)->eTabType==0) ){
        i16 nCol;
        u8 eCodeOrig = pWalker->eCode;
        if( sqlite3ViewGetColumnNames(pParse, pTab) ) return 2;
        ((void) (0));
        if( ((pTab)->eTabType==2) ){
          if( (db->flags & 0x80000000)==0
           && pTab->pSchema!=db->aDb[1].pSchema
          ){
            sqlite3ErrorMsg(pParse, "access to view \"%s\" prohibited",
              pTab->zName);
          }
          sqlite3SrcItemAttachSubquery(pParse, pFrom, pTab->u.view.pSelect, 1);
        }

        else if( (((pTab)->eTabType==1))
         && pFrom->fg.fromDDL
         && (pTab->u.vtab.p!=0)
         && pTab->u.vtab.p->eVtabRisk > ((db->flags & 0x00000080)!=0)
        ){
          sqlite3ErrorMsg(pParse, "unsafe use of virtual table \"%s\"",
                                  pTab->zName);
        }
        ((void) (0));

        nCol = pTab->nCol;
        pTab->nCol = -1;
        pWalker->eCode = 1;
        if( pFrom->fg.isSubquery ){
          sqlite3WalkSelect(pWalker, pFrom->u4.pSubq->pSelect);
        }
        pWalker->eCode = eCodeOrig;
        pTab->nCol = nCol;
      }

    }


    if( pFrom->fg.isIndexedBy && sqlite3IndexedByLookup(pParse, pFrom) ){
      return 2;
    }
  }



  ((void) (0));
  if( pParse->nErr || sqlite3ProcessJoin(pParse, p) ){
    return 2;
  }
# 152986 "c_tests/sqlite3.c"
  for(k=0; k<pEList->nExpr; k++){
    pE = pEList->a[k].pExpr;
    if( pE->op==180 ) break;
    ((void) (0));
    ((void) (0));
    if( pE->op==142 && pE->pRight->op==180 ) break;
    elistFlags |= pE->flags;
  }
  if( k<pEList->nExpr ){





    struct ExprList_item *a = pEList->a;
    ExprList *pNew = 0;
    int flags = pParse->db->flags;
    int longNames = (flags & 0x00000004)!=0
                      && (flags & 0x00000040)==0;

    for(k=0; k<pEList->nExpr; k++){
      pE = a[k].pExpr;
      elistFlags |= pE->flags;
      pRight = pE->pRight;
      ((void) (0));
      if( pE->op!=180
       && (pE->op!=142 || pRight->op!=180)
      ){


        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);
        if( pNew ){
          pNew->a[pNew->nExpr-1].zEName = a[k].zEName;
          pNew->a[pNew->nExpr-1].fg.eEName = a[k].fg.eEName;
          a[k].zEName = 0;
        }
        a[k].pExpr = 0;
      }else{


        int tableSeen = 0;
        char *zTName = 0;
        int iErrOfst;
        if( pE->op==142 ){
          ((void) (0));
          ((void) (0));
          ((void) (0));
          zTName = pE->pLeft->u.zToken;
          ((void) (0));
          iErrOfst = pE->pRight->w.iOfst;
        }else{
          ((void) (0));
          iErrOfst = pE->w.iOfst;
        }
        for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
          int nAdd;
          Table *pTab = pFrom->pSTab;
          ExprList *pNestedFrom;
          char *zTabName;
          const char *zSchemaName = 0;
          int iDb;
          IdList *pUsing;

          if( (zTabName = pFrom->zAlias)==0 ){
            zTabName = pTab->zName;
          }
          if( db->mallocFailed ) break;
          ((void) (0));
          if( pFrom->fg.isNestedFrom ){
            ((void) (0));
            ((void) (0));
            pNestedFrom = pFrom->u4.pSubq->pSelect->pEList;
            ((void) (0));
            ((void) (0));
            ((void) (0));
          }else{
            if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){
              continue;
            }
            pNestedFrom = 0;
            iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
            zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : "*";
          }
          if( i+1<pTabList->nSrc
           && pFrom[1].fg.isUsing
           && (selFlags & 0x0000800)!=0
          ){
            int ii;
            pUsing = pFrom[1].u3.pUsing;
            for(ii=0; ii<pUsing->nId; ii++){
              const char *zUName = pUsing->a[ii].zName;
              pRight = sqlite3Expr(db, 60, zUName);
              sqlite3ExprSetErrorOffset(pRight, iErrOfst);
              pNew = sqlite3ExprListAppend(pParse, pNew, pRight);
              if( pNew ){
                struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];
                ((void) (0));
                pX->zEName = sqlite3MPrintf(db,"..%s", zUName);
                pX->fg.eEName = 2;
                pX->fg.bUsingTerm = 1;
              }
            }
          }else{
            pUsing = 0;
          }

          nAdd = pTab->nCol;
          if( (((pTab)->tabFlags & 0x00000200)==0) && (selFlags & 0x0000800)!=0 ) nAdd++;
          for(j=0; j<nAdd; j++){
            const char *zName;
            struct ExprList_item *pX;

            if( j==pTab->nCol ){
              zName = sqlite3RowidAlias(pTab);
              if( zName==0 ) continue;
            }else{
              zName = pTab->aCol[j].zCnName;



              if( pNestedFrom && pNestedFrom->a[j].fg.eEName==3 ){
                continue;
              }

              if( zTName
               && pNestedFrom
               && sqlite3MatchEName(&pNestedFrom->a[j], 0, zTName, 0, 0)==0
              ){
                continue;
              }





              if( (p->selFlags & 0x0020000)==0
                && (((&pTab->aCol[j])->colFlags & 0x0002)!=0)
              ){
                continue;
              }
              if( (pTab->aCol[j].colFlags & 0x0400)!=0
               && zTName==0
               && (selFlags & (0x0000800))==0
              ){
                continue;
              }
            }
            ((void) (0));
            tableSeen = 1;

            if( i>0 && zTName==0 && (selFlags & 0x0000800)==0 ){
              if( pFrom->fg.isUsing
               && sqlite3IdListIndex(pFrom->u3.pUsing, zName)>=0
              ){


                continue;
              }
            }
            pRight = sqlite3Expr(db, 60, zName);
            if( (pTabList->nSrc>1
                 && ( (pFrom->fg.jointype & 0x40)==0
                     || (selFlags & 0x0000800)!=0
                     || !inAnyUsingClause(zName,pFrom,pTabList->nSrc-i-1)
                    )
                )
             || (pParse->eParseMode>=2)
            ){
              Expr *pLeft;
              pLeft = sqlite3Expr(db, 60, zTabName);
              pExpr = sqlite3PExpr(pParse, 142, pLeft, pRight);
              if( (pParse->eParseMode>=2) && pE->pLeft ){
                sqlite3RenameTokenRemap(pParse, pLeft, pE->pLeft);
              }
              if( zSchemaName ){
                pLeft = sqlite3Expr(db, 60, zSchemaName);
                pExpr = sqlite3PExpr(pParse, 142, pLeft, pExpr);
              }
            }else{
              pExpr = pRight;
            }
            sqlite3ExprSetErrorOffset(pExpr, iErrOfst);
            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);
            if( pNew==0 ){
              break;
            }
            pX = &pNew->a[pNew->nExpr-1];
            ((void) (0));
            if( (selFlags & 0x0000800)!=0 && !(pParse->eParseMode>=2) ){
              if( pNestedFrom && (!0 || j<pNestedFrom->nExpr) ){
                ((void) (0));
                pX->zEName = sqlite3DbStrDup(db, pNestedFrom->a[j].zEName);
                                         ;
              }else{
                pX->zEName = sqlite3MPrintf(db, "%s.%s.%s",
                                           zSchemaName, zTabName, zName);
                                         ;
              }
              pX->fg.eEName = (j==pTab->nCol ? 3 : 2);
              if( (pFrom->fg.isUsing
                   && sqlite3IdListIndex(pFrom->u3.pUsing, zName)>=0)
               || (pUsing && sqlite3IdListIndex(pUsing, zName)>=0)
               || (j<pTab->nCol && (pTab->aCol[j].colFlags & 0x0400))
              ){
                pX->fg.bNoExpand = 1;
              }
            }else if( longNames ){
              pX->zEName = sqlite3MPrintf(db, "%s.%s", zTabName, zName);
              pX->fg.eEName = 0;
            }else{
              pX->zEName = sqlite3DbStrDup(db, zName);
              pX->fg.eEName = 0;
            }
          }
        }
        if( !tableSeen ){
          if( zTName ){
            sqlite3ErrorMsg(pParse, "no such table: %s", zTName);
          }else{
            sqlite3ErrorMsg(pParse, "no tables specified");
          }
        }
      }
    }
    sqlite3ExprListDelete(db, pEList);
    p->pEList = pNew;
  }
  if( p->pEList ){
    if( p->pEList->nExpr>db->aLimit[2] ){
      sqlite3ErrorMsg(pParse, "too many columns in result set");
      return 2;
    }
    if( (elistFlags & (0x000008|0x400000))!=0 ){
      p->selFlags |= 0x0040000;
    }
  }






  return 0;
}
# 153254 "c_tests/sqlite3.c"
static void sqlite3SelectExpand(Parse *pParse, Select *pSelect){
  Walker w;
  w.xExprCallback = sqlite3ExprWalkNoop;
  w.pParse = pParse;
  if( (pParse->hasCompound) ){
    w.xSelectCallback = convertCompoundSelectToSubquery;
    w.xSelectCallback2 = 0;
    sqlite3WalkSelect(&w, pSelect);
  }
  w.xSelectCallback = selectExpander;
  w.xSelectCallback2 = sqlite3SelectPopWith;
  w.eCode = 0;
  sqlite3WalkSelect(&w, pSelect);
}
# 153284 "c_tests/sqlite3.c"
static void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){
  Parse *pParse;
  int i;
  SrcList *pTabList;
  SrcItem *pFrom;

  if( p->selFlags & 0x0000080 ) return;
  p->selFlags |= 0x0000080;
  pParse = pWalker->pParse;
  ((void) (0));
  pTabList = p->pSrc;
  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
    Table *pTab = pFrom->pSTab;
    ((void) (0));
    if( (pTab->tabFlags & 0x00004000)!=0 && pFrom->fg.isSubquery ){

      Select *pSel = pFrom->u4.pSubq->pSelect;
      sqlite3SubqueryColumnTypes(pParse, pTab, pSel, 0x40);
    }
  }
}
# 153315 "c_tests/sqlite3.c"
static void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){

  Walker w;
  w.xSelectCallback = sqlite3SelectWalkNoop;
  w.xSelectCallback2 = selectAddSubqueryTypeInfo;
  w.xExprCallback = sqlite3ExprWalkNoop;
  w.pParse = pParse;
  sqlite3WalkSelect(&w, pSelect);

}
# 153339 "c_tests/sqlite3.c"
static void sqlite3SelectPrep(
  Parse *pParse,
  Select *p,
  NameContext *pOuterNC
){
  ((void) (0));
  ((void) (0));
  if( pParse->db->mallocFailed ) return;
  if( p->selFlags & 0x0000080 ) return;
  sqlite3SelectExpand(pParse, p);
  if( pParse->nErr ) return;
  sqlite3ResolveSelectNames(pParse, p, pOuterNC);
  if( pParse->nErr ) return;
  sqlite3SelectAddTypeInfo(pParse, p);
}
# 153399 "c_tests/sqlite3.c"
static void analyzeAggFuncArgs(
  AggInfo *pAggInfo,
  NameContext *pNC
){
  int i;
  ((void) (0));
  ((void) (0));
  pNC->ncFlags |= 0x020000;
  for(i=0; i<pAggInfo->nFunc; i++){
    Expr *pExpr = pAggInfo->aFunc[i].pFExpr;
    ((void) (0));
    ((void) (0));
    sqlite3ExprAnalyzeAggList(pNC, pExpr->x.pList);
    if( pExpr->pLeft ){
      ((void) (0));
      ((void) (0));
      sqlite3ExprAnalyzeAggList(pNC, pExpr->pLeft->x.pList);
    }

    ((void) (0));
    if( (((pExpr)->flags&(u32)(0x1000000))!=0) ){
      sqlite3ExprAnalyzeAggregates(pNC, pExpr->y.pWin->pFilter);
    }

  }
  pNC->ncFlags &= ~0x020000;
}
# 153434 "c_tests/sqlite3.c"
static void optimizeAggregateUseOfIndexedExpr(
  Parse *pParse,
  Select *pSelect,
  AggInfo *pAggInfo,
  NameContext *pNC
){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pAggInfo->nColumn = pAggInfo->nAccumulator;
  if( (pAggInfo->nSortingColumn>0) ){
    int mx = pSelect->pGroupBy->nExpr - 1;
    int j, k;
    for(j=0; j<pAggInfo->nColumn; j++){
      k = pAggInfo->aCol[j].iSorterColumn;
      if( k>mx ) mx = k;
    }
    pAggInfo->nSortingColumn = mx+1;
  }
  analyzeAggFuncArgs(pAggInfo, pNC);
# 153468 "c_tests/sqlite3.c"
  (void)(pSelect);
  (void)(pParse);

}




static int aggregateIdxEprRefToColCallback(Walker *pWalker, Expr *pExpr){
  AggInfo *pAggInfo;
  struct AggInfo_col *pCol;
  (void)(pWalker);
  if( pExpr->pAggInfo==0 ) return 0;
  if( pExpr->op==170 ) return 0;
  if( pExpr->op==169 ) return 0;
  if( pExpr->op==179 ) return 0;
  pAggInfo = pExpr->pAggInfo;
  if( (pExpr->iAgg>=pAggInfo->nColumn) ) return 0;
  ((void) (0));
  pCol = &pAggInfo->aCol[pExpr->iAgg];
  pExpr->op = 170;
  pExpr->iTable = pCol->iTable;
  pExpr->iColumn = pCol->iColumn;
  (pExpr)->flags&=~(u32)(0x002000|0x000200|0x080000);
  return 1;
}






static void aggregateConvertIndexedExprRefToColumn(AggInfo *pAggInfo){
  int i;
  Walker w;
  memset(&w, 0, sizeof(w));
  w.xExprCallback = aggregateIdxEprRefToColCallback;
  for(i=0; i<pAggInfo->nFunc; i++){
    sqlite3WalkExpr(&w, pAggInfo->aFunc[i].pFExpr);
  }
}
# 153528 "c_tests/sqlite3.c"
static void assignAggregateRegisters(Parse *pParse, AggInfo *pAggInfo){
  ((void) (0));
  ((void) (0));
  pAggInfo->iFirstReg = pParse->nMem + 1;
  pParse->nMem += pAggInfo->nColumn + pAggInfo->nFunc;
}
# 153543 "c_tests/sqlite3.c"
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){
  Vdbe *v = pParse->pVdbe;
  int i;
  struct AggInfo_func *pFunc;
  int nReg = pAggInfo->nFunc + pAggInfo->nColumn;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( nReg==0 ) return;
  if( pParse->nErr ) return;
  sqlite3VdbeAddOp3(v, 76, 0, pAggInfo->iFirstReg,
                    pAggInfo->iFirstReg+nReg-1);
  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){
    if( pFunc->iDistinct>=0 ){
      Expr *pE = pFunc->pFExpr;
      ((void) (0));
      if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){
        sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one "
           "argument");
        pFunc->iDistinct = -1;
      }else{
        KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE->x.pList,0,0);
        pFunc->iDistAddr = sqlite3VdbeAddOp4(v, 119,
            pFunc->iDistinct, 0, 0, (char*)pKeyInfo, (-8));
        sqlite3VdbeExplain (pParse, 0, "USE TEMP B-TREE FOR %s(DISTINCT)", pFunc->pFunc->zName);

      }
    }
    if( pFunc->iOBTab>=0 ){
      ExprList *pOBList;
      KeyInfo *pKeyInfo;
      int nExtra = 0;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      pOBList = pFunc->pFExpr->pLeft->x.pList;
      if( !pFunc->bOBUnique ){
        nExtra++;
      }
      if( pFunc->bOBPayload ){

        ((void) (0));
        ((void) (0));
        nExtra += pFunc->pFExpr->x.pList->nExpr;
      }
      if( pFunc->bUseSubtype ){
        nExtra += pFunc->pFExpr->x.pList->nExpr;
      }
      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOBList, 0, nExtra);
      if( !pFunc->bOBUnique && pParse->nErr==0 ){
        pKeyInfo->nKeyField++;
      }
      sqlite3VdbeAddOp4(v, 119,
            pFunc->iOBTab, pOBList->nExpr+nExtra, 0,
            (char*)pKeyInfo, (-8));
      sqlite3VdbeExplain (pParse, 0, "USE TEMP B-TREE FOR %s(ORDER BY)", pFunc->pFunc->zName);

    }
  }
}





static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){
  Vdbe *v = pParse->pVdbe;
  int i;
  struct AggInfo_func *pF;
  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){
    ExprList *pList;
    ((void) (0));
    if( pParse->nErr ) return;
    pList = pF->pFExpr->x.pList;
    if( pF->iOBTab>=0 ){




      int iTop;
      int nArg;
      int nKey;
      int regAgg;
      int j;

      ((void) (0));
      nArg = pList->nExpr;
      regAgg = sqlite3GetTempRange(pParse, nArg);

      if( pF->bOBPayload==0 ){
        nKey = 0;
      }else{
        ((void) (0));
        ((void) (0));
        ((void) (0));
        nKey = pF->pFExpr->pLeft->x.pList->nExpr;
        if( (!pF->bOBUnique) ) nKey++;
      }
      iTop = sqlite3VdbeAddOp1(v, 36, pF->iOBTab); ;
      for(j=nArg-1; j>=0; j--){
        sqlite3VdbeAddOp3(v, 95, pF->iOBTab, nKey+j, regAgg+j);
      }
      if( pF->bUseSubtype ){
        int regSubtype = sqlite3GetTempReg(pParse);
        int iBaseCol = nKey + nArg + (pF->bOBPayload==0 && pF->bOBUnique==0);
        for(j=nArg-1; j>=0; j--){
          sqlite3VdbeAddOp3(v, 95, pF->iOBTab, iBaseCol+j, regSubtype);
          sqlite3VdbeAddOp2(v, 183, regSubtype, regAgg+j);
        }
        sqlite3ReleaseTempReg(pParse, regSubtype);
      }
      sqlite3VdbeAddOp3(v, 163, 0, regAgg, ((pAggInfo)->iFirstReg+(pAggInfo)->nColumn+(i)));
      sqlite3VdbeAppendP4(v, pF->pFunc, (-7));
      sqlite3VdbeChangeP5(v, (u16)nArg);
      sqlite3VdbeAddOp2(v, 40, pF->iOBTab, iTop+1); ;
      sqlite3VdbeJumpHere(v, iTop);
      sqlite3ReleaseTempRange(pParse, regAgg, nArg);
    }
    sqlite3VdbeAddOp2(v, 166, ((pAggInfo)->iFirstReg+(pAggInfo)->nColumn+(i)),
                      pList ? pList->nExpr : 0);
    sqlite3VdbeAppendP4(v, pF->pFunc, (-7));
  }
}
# 153684 "c_tests/sqlite3.c"
static void updateAccumulator(
  Parse *pParse,
  int regAcc,
  AggInfo *pAggInfo,
  int eDistinctType
){
  Vdbe *v = pParse->pVdbe;
  int i;
  int regHit = 0;
  int addrHitTest = 0;
  struct AggInfo_func *pF;
  struct AggInfo_col *pC;

  ((void) (0));
  if( pParse->nErr ) return;
  pAggInfo->directMode = 1;
  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){
    int nArg;
    int addrNext = 0;
    int regAgg;
    int regAggSz = 0;
    int regDistinct = 0;
    ExprList *pList;
    ((void) (0));
    ((void) (0));
    ((void) (0));
    pList = pF->pFExpr->x.pList;
    if( (((pF->pFExpr)->flags&(u32)(0x1000000))!=0) ){
      Expr *pFilter = pF->pFExpr->y.pWin->pFilter;
      if( pAggInfo->nAccumulator
       && (pF->pFunc->funcFlags & 0x0020)
       && regAcc
      ){



        if( regHit==0 ) regHit = ++pParse->nMem;







        sqlite3VdbeAddOp2(v, 81, regAcc, regHit);
      }
      addrNext = sqlite3VdbeMakeLabel(pParse);
      sqlite3ExprIfFalse(pParse, pFilter, addrNext, 0x10);
    }
    if( pF->iOBTab>=0 ){


      int jj;
      ExprList *pOBList;
      ((void) (0));
      nArg = pList->nExpr;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      pOBList = pF->pFExpr->pLeft->x.pList;
      ((void) (0));
      ((void) (0));
      regAggSz = pOBList->nExpr;
      if( !pF->bOBUnique ){
        regAggSz++;
      }
      if( pF->bOBPayload ){
        regAggSz += nArg;
      }
      if( pF->bUseSubtype ){
        regAggSz += nArg;
      }
      regAggSz++;
      regAgg = sqlite3GetTempRange(pParse, regAggSz);
      regDistinct = regAgg;
      sqlite3ExprCodeExprList(pParse, pOBList, regAgg, 0, 0x01);
      jj = pOBList->nExpr;
      if( !pF->bOBUnique ){
        sqlite3VdbeAddOp2(v, 127, pF->iOBTab, regAgg+jj);
        jj++;
      }
      if( pF->bOBPayload ){
        regDistinct = regAgg+jj;
        sqlite3ExprCodeExprList(pParse, pList, regDistinct, 0, 0x01);
        jj += nArg;
      }
      if( pF->bUseSubtype ){
        int kk;
        int regBase = pF->bOBPayload ? regDistinct : regAgg;
        for(kk=0; kk<nArg; kk++, jj++){
          sqlite3VdbeAddOp2(v, 182, regBase+kk, regAgg+jj);
        }
      }
    }else if( pList ){
      nArg = pList->nExpr;
      regAgg = sqlite3GetTempRange(pParse, nArg);
      regDistinct = regAgg;
      sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, 0x01);
    }else{
      nArg = 0;
      regAgg = 0;
    }
    if( pF->iDistinct>=0 && pList ){
      if( addrNext==0 ){
        addrNext = sqlite3VdbeMakeLabel(pParse);
      }
      pF->iDistinct = codeDistinct(pParse, eDistinctType,
          pF->iDistinct, addrNext, pList, regDistinct);
    }
    if( pF->iOBTab>=0 ){

      sqlite3VdbeAddOp3(v, 98, regAgg, regAggSz-1,
                        regAgg+regAggSz-1);
      sqlite3VdbeAddOp4Int(v, 139, pF->iOBTab, regAgg+regAggSz-1,
                           regAgg, regAggSz-1);
      sqlite3ReleaseTempRange(pParse, regAgg, regAggSz);
    }else{

      if( pF->pFunc->funcFlags & 0x0020 ){
        CollSeq *pColl = 0;
        struct ExprList_item *pItem;
        int j;
        ((void) (0));
        for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){
          pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);
        }
        if( !pColl ){
          pColl = pParse->db->pDfltColl;
        }
        if( regHit==0 && pAggInfo->nAccumulator ) regHit = ++pParse->nMem;
        sqlite3VdbeAddOp4(v, 86, regHit, 0, 0,
                         (char *)pColl, (-2));
      }
      sqlite3VdbeAddOp3(v, 163, 0, regAgg, ((pAggInfo)->iFirstReg+(pAggInfo)->nColumn+(i)));
      sqlite3VdbeAppendP4(v, pF->pFunc, (-7));
      sqlite3VdbeChangeP5(v, (u16)nArg);
      sqlite3ReleaseTempRange(pParse, regAgg, nArg);
    }
    if( addrNext ){
      sqlite3VdbeResolveLabel(v, addrNext);
    }
    if( pParse->nErr ) return;
  }
  if( regHit==0 && pAggInfo->nAccumulator ){
    regHit = regAcc;
  }
  if( regHit ){
    addrHitTest = sqlite3VdbeAddOp1(v, 16, regHit); ;
  }
  for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){
    sqlite3ExprCode(pParse, pC->pCExpr, ((pAggInfo)->iFirstReg+(i)));
    if( pParse->nErr ) return;
  }

  pAggInfo->directMode = 0;
  if( addrHitTest ){
    sqlite3VdbeJumpHereOrPopInst(v, addrHitTest);
  }
}






static void explainSimpleCount(
  Parse *pParse,
  Table *pTab,
  Index *pIdx
){
  if( pParse->explain==2 ){
    int bCover = (pIdx!=0 && ((((pTab)->tabFlags & 0x00000080)==0) || !((pIdx)->idxType==2)));
    sqlite3VdbeExplain(pParse, 0, "SCAN %s%s%s",
        pTab->zName,
        bCover ? " USING COVERING INDEX " : "",
        bCover ? pIdx->zName : ""
    );
  }
}
# 153879 "c_tests/sqlite3.c"
static int havingToWhereExprCb(Walker *pWalker, Expr *pExpr){
  if( pExpr->op!=44 ){
    Select *pS = pWalker->u.pSelect;







    if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy)
     && (((pExpr)->flags&(0x000001|0x20000000))==0x20000000)==0
     && pExpr->pAggInfo==0
    ){
      sqlite3 *db = pWalker->pParse->db;
      Expr *pNew = sqlite3Expr(db, 156, "1");
      if( pNew ){
        Expr *pWhere = pS->pWhere;
        {Expr t=*pNew; *pNew=*pExpr; *pExpr=t;};
        pNew = sqlite3ExprAnd(pWalker->pParse, pWhere, pNew);
        pS->pWhere = pNew;
        pWalker->eCode = 1;
      }
    }
    return 1;
  }
  return 0;
}
# 153923 "c_tests/sqlite3.c"
static void havingToWhere(Parse *pParse, Select *p){
  Walker sWalker;
  memset(&sWalker, 0, sizeof(sWalker));
  sWalker.pParse = pParse;
  sWalker.xExprCallback = havingToWhereExprCb;
  sWalker.u.pSelect = p;
  sqlite3WalkExpr(&sWalker, p->pHaving);






}
# 153946 "c_tests/sqlite3.c"
static SrcItem *isSelfJoinView(
  SrcList *pTabList,
  SrcItem *pThis,
  int iFirst, int iEnd
){
  SrcItem *pItem;
  Select *pSel;
  ((void) (0));
  pSel = pThis->u4.pSubq->pSelect;
  ((void) (0));
  if( pSel->selFlags & 0x1000000 ) return 0;
  while( iFirst<iEnd ){
    Select *pS1;
    pItem = &pTabList->a[iFirst++];
    if( !pItem->fg.isSubquery ) continue;
    if( pItem->fg.viaCoroutine ) continue;
    if( pItem->zName==0 ) continue;
    ((void) (0));
    ((void) (0));
    if( pItem->pSTab->pSchema!=pThis->pSTab->pSchema ) continue;
    if( sqlite3_stricmp(pItem->zName, pThis->zName)!=0 ) continue;
    pS1 = pItem->u4.pSubq->pSelect;
    if( pItem->pSTab->pSchema==0 && pSel->selId!=pS1->selId ){


      continue;
    }
    if( pS1->selFlags & 0x1000000 ){


      continue;
    }
    return pItem;
  }
  return 0;
}




static void agginfoFree(sqlite3 *db, void *pArg){
  AggInfo *p = (AggInfo*)pArg;
  sqlite3DbFree(db, p->aCol);
  sqlite3DbFree(db, p->aFunc);
  sqlite3DbFreeNN(db, p);
}
# 154013 "c_tests/sqlite3.c"
static int countOfViewOptimization(Parse *pParse, Select *p){
  Select *pSub, *pPrior;
  Expr *pExpr;
  Expr *pCount;
  sqlite3 *db;
  SrcItem *pFrom;
  if( (p->selFlags & 0x0000008)==0 ) return 0;
  if( p->pEList->nExpr!=1 ) return 0;
  if( p->pWhere ) return 0;
  if( p->pHaving ) return 0;
  if( p->pGroupBy ) return 0;
  if( p->pOrderBy ) return 0;
  pExpr = p->pEList->a[0].pExpr;
  if( pExpr->op!=169 ) return 0;
  ((void) (0));
  if( sqlite3_stricmp(pExpr->u.zToken,"count") ) return 0;
  ((void) (0));
  if( pExpr->x.pList!=0 ) return 0;
  if( p->pSrc->nSrc!=1 ) return 0;
  if( (((pExpr)->flags&(u32)(0x1000000))!=0) ) return 0;
  pFrom = p->pSrc->a;
  if( pFrom->fg.isSubquery==0 ) return 0;
  pSub = pFrom->u4.pSubq->pSelect;
  if( pSub->pPrior==0 ) return 0;
  if( pSub->selFlags & 0x4000000 ) return 0;
  do{
    if( pSub->op!=136 && pSub->pPrior ) return 0;
    if( pSub->pWhere ) return 0;
    if( pSub->pLimit ) return 0;
    if( pSub->selFlags & (0x0000008|0x0000001) ){
                                                ;
                                               ;
       return 0;
    }
    ((void) (0));
    pSub = pSub->pPrior;
  }while( pSub );



  db = pParse->db;
  pCount = pExpr;
  pExpr = 0;
  pSub = sqlite3SubqueryDetach(db, pFrom);
  sqlite3SrcListDelete(db, p->pSrc);
  p->pSrc = sqlite3DbMallocZero(pParse->db, (__builtin_offsetof(SrcList, a)+sizeof(SrcItem)));
  while( pSub ){
    Expr *pTerm;
    pPrior = pSub->pPrior;
    pSub->pPrior = 0;
    pSub->pNext = 0;
    pSub->selFlags |= 0x0000008;
    pSub->selFlags &= ~(u32)0x0000100;
    pSub->nSelectRow = 0;
    sqlite3ParserAddCleanup(pParse, sqlite3ExprListDeleteGeneric, pSub->pEList);
    pTerm = pPrior ? sqlite3ExprDup(db, pCount, 0) : pCount;
    pSub->pEList = sqlite3ExprListAppend(pParse, 0, pTerm);
    pTerm = sqlite3PExpr(pParse, 139, 0, 0);
    sqlite3PExprAddSelect(pParse, pTerm, pSub);
    if( pExpr==0 ){
      pExpr = pTerm;
    }else{
      pExpr = sqlite3PExpr(pParse, 107, pTerm, pExpr);
    }
    pSub = pPrior;
  }
  p->pEList->a[0].pExpr = pExpr;
  p->selFlags &= ~(u32)0x0000008;







  return 1;
}






static int sameSrcAlias(SrcItem *p0, SrcList *pSrc){
  int i;
  for(i=0; i<pSrc->nSrc; i++){
    SrcItem *p1 = &pSrc->a[i];
    if( p1==p0 ) continue;
    if( p0->pSTab==p1->pSTab && 0==sqlite3_stricmp(p0->zAlias, p1->zAlias) ){
      return 1;
    }
    if( p1->fg.isSubquery
     && (p1->u4.pSubq->pSelect->selFlags & 0x0000800)!=0
     && sameSrcAlias(p0, p1->u4.pSubq->pSelect->pSrc)
    ){
      return 1;
    }
  }
  return 0;
}
# 154142 "c_tests/sqlite3.c"
static int fromClauseTermCanBeCoroutine(
  Parse *pParse,
  SrcList *pTabList,
  int i,
  int selFlags
){
  SrcItem *pItem = &pTabList->a[i];
  if( pItem->fg.isCte ){
    const CteUse *pCteUse = pItem->u2.pCteUse;
    if( pCteUse->eM10d==0 ) return 0;
    if( pCteUse->nUse>=2 && pCteUse->eM10d!=2 ) return 0;
  }
  if( pTabList->a[0].fg.jointype & 0x40 ) return 0;
  if( (((pParse->db)->dbOptFlags&(0x02000000))!=0) ) return 0;
  if( isSelfJoinView(pTabList, pItem, i+1, pTabList->nSrc)!=0 ){
    return 0;
  }
  if( i==0 ){
    if( pTabList->nSrc==1 ) return 1;
    if( pTabList->a[1].fg.jointype & 0x02 ) return 1;
    if( selFlags & 0x10000000 ) return 0;
    return 1;
  }
  if( selFlags & 0x10000000 ) return 0;
  while( 1 ){
    if( pItem->fg.jointype & (0x20|0x02) ) return 0;
    if( i==0 ) break;
    i--;
    pItem--;
    if( pItem->fg.isSubquery ) return 0;
  }
  return 1;
}
# 154202 "c_tests/sqlite3.c"
static __attribute__((noinline)) void existsToJoin(
  Parse *pParse,
  Select *p,
  Expr *pWhere
){
  if( pParse->nErr==0
   && pWhere!=0
   && !(((pWhere)->flags&(u32)(0x000001|0x000002))!=0)
   && (p->pSrc!=0)
   && p->pSrc->nSrc<((int)(sizeof(Bitmask)*8))
  ){
    if( pWhere->op==44 ){
      Expr *pRight = pWhere->pRight;
      existsToJoin(pParse, p, pWhere->pLeft);
      existsToJoin(pParse, p, pRight);
    }
    else if( pWhere->op==20 ){
      Select *pSub = pWhere->x.pSelect;
      Expr *pSubWhere = pSub->pWhere;
      if( pSub->pSrc->nSrc==1
       && (pSub->selFlags & 0x0000008)==0
       && !pSub->pSrc->a[0].fg.isSubquery
       && pSub->pLimit==0
       && pSub->pPrior==0
      ){





        sqlite3 *db = pParse->db;
        int *aCsrMap = sqlite3DbMallocZero(db, (pParse->nTab+2)*sizeof(int));
        if( aCsrMap==0 ) return;
        aCsrMap[0] = (pParse->nTab+1);
        renumberCursors(pParse, pSub, -1, aCsrMap);
        sqlite3DbFree(db, aCsrMap);

        memset(pWhere, 0, sizeof(*pWhere));
        pWhere->op = 156;
        pWhere->u.iValue = 1;
        (pWhere)->flags|=(u32)(0x000800);
        ((void) (0));
        pSub->pSrc->a[0].fg.fromExists = 1;
        pSub->pSrc->a[0].fg.jointype |= 0x02;
        p->pSrc = sqlite3SrcListAppendList(pParse, p->pSrc, pSub->pSrc);
        if( pSubWhere ){
          p->pWhere = sqlite3PExpr(pParse, 44, p->pWhere, pSubWhere);
          pSub->pWhere = 0;
        }
        pSub->pSrc = 0;
        sqlite3ParserAddCleanup(pParse, sqlite3SelectDeleteGeneric, pSub);







        existsToJoin(pParse, p, pSubWhere);
      }
    }
  }
}




typedef struct CheckOnCtx CheckOnCtx;
struct CheckOnCtx {
  SrcList *pSrc;
  int iJoin;
  CheckOnCtx *pParent;
};
# 154285 "c_tests/sqlite3.c"
static int selectCheckOnClausesExpr(Walker *pWalker, Expr *pExpr){
  CheckOnCtx *pCtx = pWalker->u.pCheckOnCtx;
# 154296 "c_tests/sqlite3.c"
  if( ((((pExpr)->flags&(u32)(0x000001))!=0))
   || ((((pExpr)->flags&(u32)(0x000002))!=0) && (((pCtx->pSrc)->a[0].fg.jointype & 0x40)!=0))
  ){





    ((void) (0));
    if( pCtx->iJoin==0 ){
      pCtx->iJoin = pExpr->w.iJoin;
      sqlite3WalkExprNN(pWalker, pExpr);
      pCtx->iJoin = 0;
      return 1;
    }
  }

  if( pExpr->op==168 ){




    do {
      SrcList *pSrc = pCtx->pSrc;
      int iTab = pExpr->iTable;
      if( iTab>=pSrc->a[0].iCursor && iTab<=pSrc->a[pSrc->nSrc-1].iCursor ){
        if( pCtx->iJoin && iTab>pCtx->iJoin ){
          sqlite3ErrorMsg(pWalker->pParse,
              "ON clause references tables to its right");
          return 2;
        }
        break;
      }
      pCtx = pCtx->pParent;
    }while( pCtx );
  }
  return 0;
}




static int selectCheckOnClausesSelect(Walker *pWalker, Select *pSelect){
  CheckOnCtx *pCtx = pWalker->u.pCheckOnCtx;
  if( pSelect->pSrc==pCtx->pSrc || pSelect->pSrc->nSrc==0 ){
    return 0;
  }else{
    CheckOnCtx sCtx;
    memset(&sCtx, 0, sizeof(sCtx));
    sCtx.pSrc = pSelect->pSrc;
    sCtx.pParent = pCtx;
    pWalker->u.pCheckOnCtx = &sCtx;
    sqlite3WalkSelect(pWalker, pSelect);
    pWalker->u.pCheckOnCtx = pCtx;
    pSelect->selFlags &= ~0x40000000;
    return 1;
  }
}





static void selectCheckOnClauses(Parse *pParse, Select *pSelect){
  Walker w;
  CheckOnCtx sCtx;
  ((void) (0));
  ((void) (0));
  memset(&w, 0, sizeof(w));
  w.pParse = pParse;
  w.xExprCallback = selectCheckOnClausesExpr;
  w.xSelectCallback = selectCheckOnClausesSelect;
  w.u.pCheckOnCtx = &sCtx;
  memset(&sCtx, 0, sizeof(sCtx));
  sCtx.pSrc = pSelect->pSrc;
  sqlite3WalkExprNN(&w, pSelect->pWhere);
  pSelect->selFlags &= ~0x40000000;
}
# 154422 "c_tests/sqlite3.c"
static int sqlite3Select(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  int i, j;
  WhereInfo *pWInfo;
  Vdbe *v;
  int isAgg;
  ExprList *pEList = 0;
  SrcList *pTabList;
  Expr *pWhere;
  ExprList *pGroupBy;
  Expr *pHaving;
  AggInfo *pAggInfo = 0;
  int rc = 1;
  DistinctCtx sDistinct;
  SortCtx sSort;
  int iEnd;
  sqlite3 *db;
  ExprList *pMinMaxOrderBy = 0;
  u8 minMaxFlag;

  db = pParse->db;
  ((void) (0));
  v = sqlite3GetVdbe(pParse);
  if( p==0 || pParse->nErr ){
    return 1;
  }
  ((void) (0));
  if( sqlite3AuthCheck(pParse, 21, 0, 0, 0) ) return 1;
# 154465 "c_tests/sqlite3.c"
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( ((pDest->eDest)<=6) ){
    ((void) (0));



    if( p->pOrderBy ){






      sqlite3ParserAddCleanup(pParse, sqlite3ExprListDeleteGeneric,
                              p->pOrderBy);
                                      ;
      p->pOrderBy = 0;
    }
    p->selFlags &= ~(u32)0x0000001;
    p->selFlags |= 0x0400000;
  }
  sqlite3SelectPrep(pParse, p, 0);
  if( pParse->nErr ){
    goto select_end;
  }
  ((void) (0));
  ((void) (0));
# 154507 "c_tests/sqlite3.c"
  if( p->selFlags & 0x40000000 ){
    selectCheckOnClauses(pParse, p);
    if( pParse->nErr ){
      goto select_end;
    }
  }
# 154523 "c_tests/sqlite3.c"
  if( p->selFlags & 0x0800000 ){
    SrcItem *p0 = &p->pSrc->a[0];
    if( sameSrcAlias(p0, p->pSrc) ){
      sqlite3ErrorMsg(pParse,
          "target object/alias may not appear in FROM clause: %s",
          p0->zAlias ? p0->zAlias : p0->pSTab->zName
      );
      goto select_end;
    }





    p->selFlags &= ~(u32)0x0800000;
  }

  if( pDest->eDest==9 ){
    sqlite3GenerateColumnNames(pParse, p);
  }


  if( sqlite3WindowRewrite(pParse, p) ){
    ((void) (0));
    goto select_end;
  }







  pTabList = p->pSrc;
  isAgg = (p->selFlags & 0x0000008)!=0;
  memset(&sSort, 0, sizeof(sSort));
  sSort.pOrderBy = p->pOrderBy;






  for(i=0; !p->pPrior && i<pTabList->nSrc; i++){
    SrcItem *pItem = &pTabList->a[i];
    Select *pSub = pItem->fg.isSubquery ? pItem->u4.pSubq->pSelect : 0;
    Table *pTab = pItem->pSTab;




    ((void) (0));
# 154588 "c_tests/sqlite3.c"
    if( (pItem->fg.jointype & (0x08|0x40))!=0
     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor,
                                     pItem->fg.jointype & 0x40)
     && (((db)->dbOptFlags&(0x00002000))==0)
    ){
      if( pItem->fg.jointype & 0x08 ){
        if( pItem->fg.jointype & 0x10 ){

                                                                          ;
          pItem->fg.jointype &= ~0x08;
        }else{

                                                                    ;
          pItem->fg.jointype &= ~(0x08|0x20);
          unsetJoinExpr(p->pWhere, pItem->iCursor, 0);
        }
      }
      if( pItem->fg.jointype & 0x40 ){
        for(j=i+1; j<pTabList->nSrc; j++){
          SrcItem *pI2 = &pTabList->a[j];
          if( pI2->fg.jointype & 0x10 ){
            if( pI2->fg.jointype & 0x08 ){

                                                                             ;
              pI2->fg.jointype &= ~0x10;
            }else{

                                                                         ;
              pI2->fg.jointype &= ~(0x10|0x20);
              unsetJoinExpr(p->pWhere, pI2->iCursor, 1);
            }
          }
        }
        for(j=pTabList->nSrc-1; j>=0; j--){
          pTabList->a[j].fg.jointype &= ~0x40;
          if( pTabList->a[j].fg.jointype & 0x10 ) break;
        }
      }
    }


    if( pSub==0 ) continue;



    if( pTab->nCol!=pSub->pEList->nExpr ){
      sqlite3ErrorMsg(pParse, "expected %d columns for '%s' but got %d",
                      pTab->nCol, pTab->zName, pSub->pEList->nExpr);
      goto select_end;
    }





    if( pItem->fg.isCte && pItem->u2.pCteUse->eM10d==0 ){
      continue;
    }
# 154654 "c_tests/sqlite3.c"
    if( (pSub->selFlags & 0x0000008)!=0 ) continue;
    ((void) (0));
# 154683 "c_tests/sqlite3.c"
    if( pSub->pOrderBy!=0
     && (p->pOrderBy!=0 || pTabList->nSrc>1)
     && pSub->pLimit==0
     && (pSub->selFlags & (0x8000000|0x0002000))==0
     && (p->selFlags & 0x8000000)==0
     && (((db)->dbOptFlags&(0x00040000))==0)
    ){

                                                                               ;
      sqlite3ParserAddCleanup(pParse, sqlite3ExprListDeleteGeneric,
                              pSub->pOrderBy);
      pSub->pOrderBy = 0;
    }
# 154715 "c_tests/sqlite3.c"
    if( pSub->pOrderBy!=0
     && i==0
     && (p->selFlags & 0x0040000)!=0
     && (pTabList->nSrc==1
         || (pTabList->a[1].fg.jointype&(0x20|0x02))!=0)
    ){
      continue;
    }


    if( flattenSubquery(pParse, p, i, isAgg) ){
      if( pParse->nErr ) goto select_end;

      i = -1;
    }
    pTabList = p->pSrc;
    if( db->mallocFailed ) goto select_end;
    if( !((pDest->eDest)<=8) ){
      sSort.pOrderBy = p->pOrderBy;
    }
  }






  if( p->pPrior ){
    rc = multiSelect(pParse, p, pDest);






    if( p->pNext==0 ) sqlite3VdbeExplainPop(pParse);
    return rc;
  }




  if( pParse->bHasExists && (((db)->dbOptFlags&(0x40000000))==0) ){
    existsToJoin(pParse, p, p->pWhere);
    pTabList = p->pSrc;
  }






  if( p->pWhere!=0
   && p->pWhere->op==44
   && (((db)->dbOptFlags&(0x00008000))==0)
   && propagateConstants(pParse, p)
  ){






  }else{
                                                                     ;
  }


  if( (((db)->dbOptFlags&(0x00000001|0x00000200))==0)
   && countOfViewOptimization(pParse, p)
  ){
    if( db->mallocFailed ) goto select_end;
    pTabList = p->pSrc;
  }
# 154797 "c_tests/sqlite3.c"
  for(i=0; i<pTabList->nSrc; i++){
    SrcItem *pItem = &pTabList->a[i];
    SrcItem *pPrior;
    SelectDest dest;
    Subquery *pSubq;
    Select *pSub;

    const char *zSavedAuthContext;
# 154825 "c_tests/sqlite3.c"
    if( pItem->colUsed==0 && pItem->zName!=0 ){
      const char *zDb;
      if( pItem->fg.fixedSchema ){
        int iDb = sqlite3SchemaToIndex(pParse->db, pItem->u4.pSchema);
        zDb = db->aDb[iDb].zDbSName;
      }else if( pItem->fg.isSubquery ){
        zDb = 0;
      }else{
        zDb = pItem->u4.zDatabase;
      }
      sqlite3AuthCheck(pParse, 20, pItem->zName, "", zDb);
    }




    if( pItem->fg.isSubquery==0 ) continue;
    pSubq = pItem->u4.pSubq;
    ((void) (0));
    pSub = pSubq->pSelect;


    if( pSubq->addrFillSub!=0 ) continue;
# 154856 "c_tests/sqlite3.c"
    pParse->nHeight += sqlite3SelectExprHeight(p);





    if( (((db)->dbOptFlags&(0x00001000))==0)
     && (pItem->fg.isCte==0
         || (pItem->u2.pCteUse->eM10d!=0 && pItem->u2.pCteUse->nUse<2))
     && pushDownWhereTerms(pParse, pSub, p->pWhere, pTabList, i)
    ){







      ((void) (0));
    }else{
                                                                          ;
    }





    if( (((db)->dbOptFlags&(0x04000000))==0)
     && disableUnusedSubqueryResultColumns(pItem)
    ){
# 154894 "c_tests/sqlite3.c"
    }

    zSavedAuthContext = pParse->zAuthContext;
    pParse->zAuthContext = pItem->zName;



    if( fromClauseTermCanBeCoroutine(pParse, pTabList, i, p->selFlags) ){



      int addrTop = sqlite3VdbeCurrentAddr(v)+1;

      pSubq->regReturn = ++pParse->nMem;
      sqlite3VdbeAddOp3(v, 11, pSubq->regReturn, 0, addrTop);
                                    ;
      pSubq->addrFillSub = addrTop;
      sqlite3SelectDestInit(&dest, 13, pSubq->regReturn);
      sqlite3VdbeExplain (pParse, 1, "CO-ROUTINE %!S", pItem);
      sqlite3Select(pParse, pSub, &dest);
      pItem->pSTab->nRowLogEst = pSub->nSelectRow;
      pItem->fg.viaCoroutine = 1;
      pSubq->regResult = dest.iSdst;
      sqlite3VdbeEndCoroutine(v, pSubq->regReturn);
                                        ;
      sqlite3VdbeJumpHere(v, addrTop-1);
      sqlite3ClearTempRegCache(pParse);
    }else if( pItem->fg.isCte && pItem->u2.pCteUse->addrM9e>0 ){




      CteUse *pCteUse = pItem->u2.pCteUse;
      sqlite3VdbeAddOp2(v, 10, pCteUse->regRtn, pCteUse->addrM9e);
      if( pItem->iCursor!=pCteUse->iCur ){
        sqlite3VdbeAddOp2(v, 116, pItem->iCursor, pCteUse->iCur);
                                      ;
      }
      pSub->nSelectRow = pCteUse->nRowEst;
    }else if( (pPrior = isSelfJoinView(pTabList, pItem, 0, i))!=0 ){


      Subquery *pPriorSubq;
      ((void) (0));
      pPriorSubq = pPrior->u4.pSubq;
      ((void) (0));
      if( pPriorSubq->addrFillSub ){
        sqlite3VdbeAddOp2(v, 10, pPriorSubq->regReturn,
                                       pPriorSubq->addrFillSub);
      }
      sqlite3VdbeAddOp2(v, 116, pItem->iCursor, pPrior->iCursor);
      pSub->nSelectRow = pPriorSubq->pSelect->nSelectRow;
    }else{



      int topAddr;
      int onceAddr = 0;




      pSubq->regReturn = ++pParse->nMem;
      topAddr = sqlite3VdbeAddOp0(v, 9);
      pSubq->addrFillSub = topAddr+1;
      pItem->fg.isMaterialized = 1;
      if( pItem->fg.isCorrelated==0 ){



        onceAddr = sqlite3VdbeAddOp0(v, 15); ;
                                                  ;
      }else{
                                                      ;
      }
      sqlite3SelectDestInit(&dest, 12, pItem->iCursor);

      sqlite3VdbeExplain (pParse, 1, "MATERIALIZE %!S", pItem);
      sqlite3Select(pParse, pSub, &dest);
      pItem->pSTab->nRowLogEst = pSub->nSelectRow;
      if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);
      sqlite3VdbeAddOp2(v, 68, pSubq->regReturn, topAddr+1);
                                        ;
                                                                 ;
      sqlite3VdbeJumpHere(v, topAddr);
      sqlite3ClearTempRegCache(pParse);
      if( pItem->fg.isCte && pItem->fg.isCorrelated==0 ){
        CteUse *pCteUse = pItem->u2.pCteUse;
        pCteUse->addrM9e = pSubq->addrFillSub;
        pCteUse->regRtn = pSubq->regReturn;
        pCteUse->iCur = pItem->iCursor;
        pCteUse->nRowEst = pSub->nSelectRow;
      }
    }
    if( db->mallocFailed ) goto select_end;
    pParse->nHeight -= sqlite3SelectExprHeight(p);
    pParse->zAuthContext = zSavedAuthContext;

  }



  pEList = p->pEList;
  pWhere = p->pWhere;
  pGroupBy = p->pGroupBy;
  pHaving = p->pHaving;
  sDistinct.isTnct = (p->selFlags & 0x0000001)!=0;
# 155026 "c_tests/sqlite3.c"
  if( (p->selFlags & (0x0000001|0x0000008))==0x0000001
   && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0
   && (((db)->dbOptFlags&(0x00000004))==0)

   && p->pWin==0

  ){
    p->selFlags &= ~(u32)0x0000001;
    pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);
    if( pGroupBy ){
      for(i=0; i<pGroupBy->nExpr; i++){
        pGroupBy->a[i].u.x.iOrderByCol = i+1;
      }
    }
    p->selFlags |= 0x0000008;



    ((void) (0));
    sDistinct.isTnct = 2;







  }
# 155063 "c_tests/sqlite3.c"
  if( sSort.pOrderBy ){
    KeyInfo *pKeyInfo;
    pKeyInfo = sqlite3KeyInfoFromExprList(
        pParse, sSort.pOrderBy, 0, pEList->nExpr);
    sSort.iECursor = pParse->nTab++;
    sSort.addrSortIndex =
      sqlite3VdbeAddOp4(v, 119,
          sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,
          (char*)pKeyInfo, (-8)
      );
  }else{
    sSort.addrSortIndex = -1;
  }




  if( pDest->eDest==12 ){
    sqlite3VdbeAddOp2(v, 119, pDest->iSDParm, pEList->nExpr);
    if( p->selFlags & 0x0000800 ){

      int ii;
      for(ii=pEList->nExpr-1; ii>0 && pEList->a[ii].fg.bUsed==0; ii--){
        sqlite3ExprDelete(db, pEList->a[ii].pExpr);
        sqlite3DbFree(db, pEList->a[ii].zEName);
        pEList->nExpr--;
      }
      for(ii=0; ii<pEList->nExpr; ii++){
        if( pEList->a[ii].fg.bUsed==0 ) pEList->a[ii].pExpr->op = 122;
      }
    }
  }



  iEnd = sqlite3VdbeMakeLabel(pParse);
  if( (p->selFlags & 0x0004000)==0 ){
    p->nSelectRow = 320;
  }
  if( p->pLimit ) computeLimitRegisters(pParse, p, iEnd);
  if( p->iLimit==0 && sSort.addrSortIndex>=0 ){
    sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, 120);
    sSort.sortFlags |= 0x01;
  }



  if( p->selFlags & 0x0000001 ){
    sDistinct.tabTnct = pParse->nTab++;
    sDistinct.addrTnct = sqlite3VdbeAddOp4(v, 119,
                       sDistinct.tabTnct, 0, 0,
                       (char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),
                       (-8));
    sqlite3VdbeChangeP5(v, 8);
    sDistinct.eTnctType = 3;
  }else{
    sDistinct.eTnctType = 0;
  }

  if( !isAgg && pGroupBy==0 ){

    u16 wctrlFlags = (sDistinct.isTnct ? 0x0100 : 0)
                   | (p->selFlags & 0x0004000);

    Window *pWin = p->pWin;
    if( pWin ){
      sqlite3WindowCodeInit(pParse, p);
    }

    ((void) (0));



                                            ;
    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,
                               p->pEList, p, wctrlFlags, p->nSelectRow);
    if( pWInfo==0 ) goto select_end;
    if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){
      p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);
      if( pDest->eDest<=6 && pDest->eDest>=5 ){



        p->nSelectRow -= 30;
      }
    }
    if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){
      sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);
    }
    if( sSort.pOrderBy ){
      sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);
      sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);
      if( sSort.nOBSat==sSort.pOrderBy->nExpr ){
        sSort.pOrderBy = 0;
      }
    }
                                                    ;





    if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){
      sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
    }

    ((void) (0));

    if( pWin ){
      int addrGosub = sqlite3VdbeMakeLabel(pParse);
      int iCont = sqlite3VdbeMakeLabel(pParse);
      int iBreak = sqlite3VdbeMakeLabel(pParse);
      int regGosub = ++pParse->nMem;

      sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);

      sqlite3VdbeAddOp2(v, 9, 0, iBreak);
      sqlite3VdbeResolveLabel(v, addrGosub);
                                                   ;
      sSort.labelOBLopt = 0;
      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);
      sqlite3VdbeResolveLabel(v, iCont);
      sqlite3VdbeAddOp1(v, 68, regGosub);
                                                   ;
      sqlite3VdbeResolveLabel(v, iBreak);
    }else

    {

      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,
          sqlite3WhereContinueLabel(pWInfo),
          sqlite3WhereBreakLabel(pWInfo));



                                            ;
      sqlite3WhereEnd(pWInfo);
    }
  }else{


    NameContext sNC;
    int iAMem;
    int iBMem;
    int iUseFlag;


    int iAbortFlag;
    int groupBySort;
    int addrEnd;
    int sortPTab = 0;
    int sortOut = 0;
    int orderByGrp = 0;




    if( pGroupBy ){
      int k;
      struct ExprList_item *pItem;

      for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){
        pItem->u.x.iAlias = 0;
      }
      for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){
        pItem->u.x.iAlias = 0;
      }
      ((void) (0));
      if( p->nSelectRow>66 ) p->nSelectRow = 66;
# 155241 "c_tests/sqlite3.c"
      if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){
        int ii;





        for(ii=0; ii<pGroupBy->nExpr; ii++){
          u8 sortFlags;
          sortFlags = sSort.pOrderBy->a[ii].fg.sortFlags & 0x01;
          pGroupBy->a[ii].fg.sortFlags = sortFlags;
        }
        if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){
          orderByGrp = 1;
        }
      }
    }else{
      ((void) (0));
      p->nSelectRow = 0;
    }


    addrEnd = sqlite3VdbeMakeLabel(pParse);





    pAggInfo = sqlite3DbMallocZero(db, sizeof(*pAggInfo) );
    if( pAggInfo ){
      sqlite3ParserAddCleanup(pParse, agginfoFree, pAggInfo);
                                      ;
    }
    if( db->mallocFailed ){
      goto select_end;
    }
    pAggInfo->selId = p->selId;



    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    sNC.pSrcList = pTabList;
    sNC.uNC.pAggInfo = pAggInfo;

    pAggInfo->nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;
    pAggInfo->pGroupBy = pGroupBy;
    sqlite3ExprAnalyzeAggList(&sNC, pEList);
    sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);
    if( pHaving ){
      if( pGroupBy ){
        ((void) (0));
        ((void) (0));
        ((void) (0));
        havingToWhere(pParse, p);
        pWhere = p->pWhere;
      }
      sqlite3ExprAnalyzeAggregates(&sNC, pHaving);
    }
    pAggInfo->nAccumulator = pAggInfo->nColumn;
    if( p->pGroupBy==0 && p->pHaving==0 && pAggInfo->nFunc==1 ){
      minMaxFlag = minMaxQuery(db, pAggInfo->aFunc[0].pFExpr, &pMinMaxOrderBy);
    }else{
      minMaxFlag = 0x0000;
    }
    analyzeAggFuncArgs(pAggInfo, &sNC);
    if( db->mallocFailed ) goto select_end;
# 155324 "c_tests/sqlite3.c"
    if( pGroupBy ){
      KeyInfo *pKeyInfo;
      int addr1;
      int addrOutputRow;
      int regOutputRow;
      int addrSetAbort;
      int addrTopOfLoop;
      int addrSortingIdx;
      int addrReset;
      int regReset;
      ExprList *pDistinct = 0;
      u16 distFlag = 0;
      int eDist = 0;

      if( pAggInfo->nFunc==1
       && pAggInfo->aFunc[0].iDistinct>=0
       && (pAggInfo->aFunc[0].pFExpr!=0)
       && ((((pAggInfo->aFunc[0].pFExpr)->flags&0x001000)==0))
       && pAggInfo->aFunc[0].pFExpr->x.pList!=0
      ){
        Expr *pExpr = pAggInfo->aFunc[0].pFExpr->x.pList->a[0].pExpr;
        pExpr = sqlite3ExprDup(db, pExpr, 0);
        pDistinct = sqlite3ExprListDup(db, pGroupBy, 0);
        pDistinct = sqlite3ExprListAppend(pParse, pDistinct, pExpr);
        distFlag = pDistinct ? (0x0100|0x0400) : 0;
      }






      pAggInfo->sortingIdx = pParse->nTab++;
      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pGroupBy,
                                            0, pAggInfo->nColumn);
      addrSortingIdx = sqlite3VdbeAddOp4(v, 120,
          pAggInfo->sortingIdx, pAggInfo->nSortingColumn,
          0, (char*)pKeyInfo, (-8));



      iUseFlag = ++pParse->nMem;
      iAbortFlag = ++pParse->nMem;
      regOutputRow = ++pParse->nMem;
      addrOutputRow = sqlite3VdbeMakeLabel(pParse);
      regReset = ++pParse->nMem;
      addrReset = sqlite3VdbeMakeLabel(pParse);
      iAMem = pParse->nMem + 1;
      pParse->nMem += pGroupBy->nExpr;
      iBMem = pParse->nMem + 1;
      pParse->nMem += pGroupBy->nExpr;
      sqlite3VdbeAddOp2(v, 72, 0, iAbortFlag);
                                          ;
      sqlite3VdbeAddOp3(v, 76, 0, iAMem, iAMem+pGroupBy->nExpr-1);
      sqlite3ExprNullRegisterRange(pParse, iAMem, pGroupBy->nExpr);






      sqlite3VdbeAddOp2(v, 10, regReset, addrReset);
                                              ;
      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, pDistinct,
          p, (sDistinct.isTnct==2 ? 0x0080 : 0x0040)
          | (orderByGrp ? 0x0200 : 0) | distFlag, 0
      );
      if( pWInfo==0 ){
        sqlite3ExprListDelete(db, pDistinct);
        goto select_end;
      }
      if( pParse->pIdxEpr ){
        optimizeAggregateUseOfIndexedExpr(pParse, p, pAggInfo, &sNC);
      }
      assignAggregateRegisters(pParse, pAggInfo);
      eDist = sqlite3WhereIsDistinct(pWInfo);
                                                      ;
      if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){




        groupBySort = 0;
      }else{





        int regBase;
        int regRecord;
        int nCol;
        int nGroupBy;




        sqlite3VdbeExplain (pParse, 0, "USE TEMP B-TREE FOR %s", (sDistinct.isTnct && (p->selFlags&0x0000001)==0) ? "DISTINCT" : "GROUP BY" );




        groupBySort = 1;
        nGroupBy = pGroupBy->nExpr;
        nCol = nGroupBy;
        j = nGroupBy;
        for(i=0; i<pAggInfo->nColumn; i++){
          if( pAggInfo->aCol[i].iSorterColumn>=j ){
            nCol++;
            j++;
          }
        }
        regBase = sqlite3GetTempRange(pParse, nCol);
        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);
        j = nGroupBy;
        pAggInfo->directMode = 1;
        for(i=0; i<pAggInfo->nColumn; i++){
          struct AggInfo_col *pCol = &pAggInfo->aCol[i];
          if( pCol->iSorterColumn>=j ){
            sqlite3ExprCode(pParse, pCol->pCExpr, j + regBase);
            j++;
          }
        }
        pAggInfo->directMode = 0;
        regRecord = sqlite3GetTempReg(pParse);
                                                                               ;
        sqlite3VdbeAddOp3(v, 98, regBase, nCol, regRecord);
        sqlite3VdbeAddOp2(v, 140, pAggInfo->sortingIdx, regRecord);
                                                                               ;
        sqlite3ReleaseTempReg(pParse, regRecord);
        sqlite3ReleaseTempRange(pParse, regBase, nCol);
                                              ;
        sqlite3WhereEnd(pWInfo);
        pAggInfo->sortingIdxPTab = sortPTab = pParse->nTab++;
        sortOut = sqlite3GetTempReg(pParse);
                                                                               ;
        sqlite3VdbeAddOp3(v, 122, sortPTab, sortOut, nCol);
        sqlite3VdbeAddOp2(v, 34, pAggInfo->sortingIdx, addrEnd);
                                         ; ;
        pAggInfo->useSortingIdx = 1;
                                                            ;
                                                                        ;
      }






      if( pParse->pIdxEpr ){
        aggregateConvertIndexedExprRefToColumn(pAggInfo);
# 155483 "c_tests/sqlite3.c"
      }
# 155492 "c_tests/sqlite3.c"
      if( orderByGrp && (((db)->dbOptFlags&(0x00000004))==0)
       && (groupBySort || sqlite3WhereIsSorted(pWInfo))
      ){
        sSort.pOrderBy = 0;
        sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
      }






      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);
      if( groupBySort ){
        sqlite3VdbeAddOp3(v, 134, pAggInfo->sortingIdx,
                          sortOut, sortPTab);
      }
      for(j=0; j<pGroupBy->nExpr; j++){
        int iOrderByCol = pGroupBy->a[j].u.x.iOrderByCol;

        if( groupBySort ){
          sqlite3VdbeAddOp3(v, 95, sortPTab, j, iBMem+j);
        }else{
          pAggInfo->directMode = 1;
          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);
        }

        if( iOrderByCol ){
          Expr *pX = p->pEList->a[iOrderByCol-1].pExpr;
          Expr *pBase = sqlite3ExprSkipCollateAndLikely(pX);
          while( (pBase!=0) && pBase->op==179 ){
            pX = pBase->pLeft;
            pBase = sqlite3ExprSkipCollateAndLikely(pX);
          }
          if( (pBase!=0)
           && pBase->op!=170
           && pBase->op!=176
          ){
            sqlite3ExprToRegister(pX, iAMem+j);
          }
        }
      }
      sqlite3VdbeAddOp4(v, 91, iAMem, iBMem, pGroupBy->nExpr,
                          (char*)sqlite3KeyInfoRef(pKeyInfo), (-8));
      addr1 = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp3(v, 14, addr1+1, 0, addr1+1); ;
# 155548 "c_tests/sqlite3.c"
      sqlite3VdbeAddOp2(v, 10, regOutputRow, addrOutputRow);
                                                        ;
      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);
      sqlite3VdbeAddOp2(v, 60, iAbortFlag, addrEnd); ;
                                          ;
      sqlite3VdbeAddOp2(v, 10, regReset, addrReset);
                                                        ;




      sqlite3VdbeJumpHere(v, addr1);
      updateAccumulator(pParse, iUseFlag, pAggInfo, eDist);
      sqlite3VdbeAddOp2(v, 72, 1, iUseFlag);
                                                                   ;



      if( groupBySort ){
        sqlite3VdbeAddOp2(v, 38, pAggInfo->sortingIdx,addrTopOfLoop);
                       ;
      }else{
                                              ;
        sqlite3WhereEnd(pWInfo);
        sqlite3VdbeChangeToNoop(v, addrSortingIdx);
      }
      sqlite3ExprListDelete(db, pDistinct);



      sqlite3VdbeAddOp2(v, 10, regOutputRow, addrOutputRow);
                                                          ;



      sqlite3VdbeGoto(v, addrEnd);
# 155592 "c_tests/sqlite3.c"
      addrSetAbort = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp2(v, 72, 1, iAbortFlag);
                                        ;
      sqlite3VdbeAddOp1(v, 68, regOutputRow);
      sqlite3VdbeResolveLabel(v, addrOutputRow);
      addrOutputRow = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp2(v, 60, iUseFlag, addrOutputRow+2);
                     ;
                                                                           ;
      sqlite3VdbeAddOp1(v, 68, regOutputRow);
      finalizeAggFunctions(pParse, pAggInfo);
      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, 0x10);
      selectInnerLoop(pParse, p, -1, &sSort,
                      &sDistinct, pDest,
                      addrOutputRow+1, addrSetAbort);
      sqlite3VdbeAddOp1(v, 68, regOutputRow);
                                                                   ;



      sqlite3VdbeResolveLabel(v, addrReset);
      resetAccumulator(pParse, pAggInfo);
      sqlite3VdbeAddOp2(v, 72, 0, iUseFlag);
                                                                 ;
      sqlite3VdbeAddOp1(v, 68, regReset);

      if( distFlag!=0 && eDist!=0 ){
        struct AggInfo_func *pF = &pAggInfo->aFunc[0];
        fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);
      }
    }
    else {

      Table *pTab;
      if( (pTab = isSimpleCount(p, pAggInfo))!=0 ){
# 155642 "c_tests/sqlite3.c"
        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
        const int iCsr = pParse->nTab++;
        Index *pIdx;
        KeyInfo *pKeyInfo = 0;
        Index *pBest = 0;
        Pgno iRoot = pTab->tnum;

        sqlite3CodeVerifySchema(pParse, iDb);
        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
# 155661 "c_tests/sqlite3.c"
        if( !(((pTab)->tabFlags & 0x00000080)==0) ) pBest = sqlite3PrimaryKeyIndex(pTab);
        if( !p->pSrc->a[0].fg.notIndexed ){
          for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
            if( pIdx->bUnordered==0
             && pIdx->szIdxRow<pTab->szTabRow
             && pIdx->pPartIdxWhere==0
             && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)
            ){
              pBest = pIdx;
            }
          }
        }
        if( pBest ){
          iRoot = pBest->tnum;
          pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);
        }


        sqlite3VdbeAddOp4Int(v, 113, iCsr, (int)iRoot, iDb, 1);
        if( pKeyInfo ){
          sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, (-8));
        }
        assignAggregateRegisters(pParse, pAggInfo);
        sqlite3VdbeAddOp2(v, 99, iCsr, ((pAggInfo)->iFirstReg+(pAggInfo)->nColumn+(0)));
        sqlite3VdbeAddOp1(v, 123, iCsr);
        explainSimpleCount(pParse, pTab, pBest);
      }else{


        int regAcc = 0;
        ExprList *pDistinct = 0;
        u16 distFlag = 0;
        int eDist;
# 155704 "c_tests/sqlite3.c"
        if( pAggInfo->nAccumulator ){
          for(i=0; i<pAggInfo->nFunc; i++){
            if( (((pAggInfo->aFunc[i].pFExpr)->flags&(u32)(0x1000000))!=0) ){
              continue;
            }
            if( pAggInfo->aFunc[i].pFunc->funcFlags&0x0020 ){
              break;
            }
          }
          if( i==pAggInfo->nFunc ){
            regAcc = ++pParse->nMem;
            sqlite3VdbeAddOp2(v, 72, 0, regAcc);
          }
        }else if( pAggInfo->nFunc==1 && pAggInfo->aFunc[0].iDistinct>=0 ){
          ((void) (0));
          pDistinct = pAggInfo->aFunc[0].pFExpr->x.pList;
          distFlag = pDistinct ? (0x0100|0x0400) : 0;
        }
        assignAggregateRegisters(pParse, pAggInfo);





        ((void) (0));
        resetAccumulator(pParse, pAggInfo);






        ((void) (0));
        ((void) (0));

                                                ;
        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,
                                   pDistinct, p, minMaxFlag|distFlag, 0);
        if( pWInfo==0 ){
          goto select_end;
        }
                                                        ;
        eDist = sqlite3WhereIsDistinct(pWInfo);
        updateAccumulator(pParse, regAcc, pAggInfo, eDist);
        if( eDist!=0 ){
          struct AggInfo_func *pF = pAggInfo->aFunc;
          if( pF ){
            fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);
          }
        }

        if( regAcc ) sqlite3VdbeAddOp2(v, 72, 1, regAcc);
        if( minMaxFlag ){
          sqlite3WhereMinMaxOptEarlyOut(v, pWInfo);
        }
                                              ;
        sqlite3WhereEnd(pWInfo);
        finalizeAggFunctions(pParse, pAggInfo);
      }

      sSort.pOrderBy = 0;
      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, 0x10);
      selectInnerLoop(pParse, p, -1, 0, 0,
                      pDest, addrEnd, addrEnd);
    }
    sqlite3VdbeResolveLabel(v, addrEnd);

  }

  if( sDistinct.eTnctType==3 ){
    explainTempTable(pParse, "DISTINCT");
  }




  if( sSort.pOrderBy ){
    ((void) (0));
    generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);
  }



  sqlite3VdbeResolveLabel(v, iEnd);



  rc = (pParse->nErr>0);




select_end:
  ((void) (0));
  ((void) (0));
  sqlite3ExprListDelete(db, pMinMaxOrderBy);
# 155830 "c_tests/sqlite3.c"
  sqlite3VdbeExplainPop(pParse);
  return rc;
}
# 155862 "c_tests/sqlite3.c"
typedef struct TabResult {
  char **azResult;
  char *zErrMsg;
  u32 nAlloc;
  u32 nRow;
  u32 nColumn;
  u32 nData;
  int rc;
} TabResult;






static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){
  TabResult *p = (TabResult*)pArg;
  int need;
  int i;
  char *z;




  if( p->nRow==0 && argv!=0 ){
    need = nCol*2;
  }else{
    need = nCol;
  }
  if( p->nData + need > p->nAlloc ){
    char **azNew;
    p->nAlloc = p->nAlloc*2 + need;
    azNew = sqlite3Realloc( p->azResult, sizeof(char*)*p->nAlloc );
    if( azNew==0 ) goto malloc_failed;
    p->azResult = azNew;
  }




  if( p->nRow==0 ){
    p->nColumn = nCol;
    for(i=0; i<nCol; i++){
      z = sqlite3_mprintf("%s", colv[i]);
      if( z==0 ) goto malloc_failed;
      p->azResult[p->nData++] = z;
    }
  }else if( (int)p->nColumn!=nCol ){
    sqlite3_free(p->zErrMsg);
    p->zErrMsg = sqlite3_mprintf(
       "sqlite3_get_table() called with two or more incompatible queries"
    );
    p->rc = 1;
    return 1;
  }



  if( argv!=0 ){
    for(i=0; i<nCol; i++){
      if( argv[i]==0 ){
        z = 0;
      }else{
        int n = sqlite3Strlen30(argv[i])+1;
        z = sqlite3_malloc64( n );
        if( z==0 ) goto malloc_failed;
        memcpy(z, argv[i], n);
      }
      p->azResult[p->nData++] = z;
    }
    p->nRow++;
  }
  return 0;

malloc_failed:
  p->rc = 7;
  return 1;
}
# 155951 "c_tests/sqlite3.c"
           int sqlite3_get_table(
  sqlite3 *db,
  const char *zSql,
  char ***pazResult,
  int *pnRow,
  int *pnColumn,
  char **pzErrMsg
){
  int rc;
  TabResult res;




  *pazResult = 0;
  if( pnColumn ) *pnColumn = 0;
  if( pnRow ) *pnRow = 0;
  if( pzErrMsg ) *pzErrMsg = 0;
  res.zErrMsg = 0;
  res.nRow = 0;
  res.nColumn = 0;
  res.nData = 1;
  res.nAlloc = 20;
  res.rc = 0;
  res.azResult = sqlite3_malloc64(sizeof(char*)*res.nAlloc );
  if( res.azResult==0 ){
     db->errCode = 7;
     return 7;
  }
  res.azResult[0] = 0;
  rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);
  ((void) (0));
  res.azResult[0] = ((void*)(long int)(res.nData));
  if( (rc&0xff)==4 ){
    sqlite3_free_table(&res.azResult[1]);
    if( res.zErrMsg ){
      if( pzErrMsg ){
        sqlite3_free(*pzErrMsg);
        *pzErrMsg = sqlite3_mprintf("%s",res.zErrMsg);
      }
      sqlite3_free(res.zErrMsg);
    }
    db->errCode = res.rc;
    return res.rc;
  }
  sqlite3_free(res.zErrMsg);
  if( rc!=0 ){
    sqlite3_free_table(&res.azResult[1]);
    return rc;
  }
  if( res.nAlloc>res.nData ){
    char **azNew;
    azNew = sqlite3Realloc( res.azResult, sizeof(char*)*res.nData );
    if( azNew==0 ){
      sqlite3_free_table(&res.azResult[1]);
      db->errCode = 7;
      return 7;
    }
    res.azResult = azNew;
  }
  *pazResult = &res.azResult[1];
  if( pnColumn ) *pnColumn = res.nColumn;
  if( pnRow ) *pnRow = res.nRow;
  return rc;
}




           void sqlite3_free_table(
  char **azResult
){
  if( azResult ){
    int i, n;
    azResult--;
    ((void) (0));
    n = ((int)(long int)(azResult[0]));
    for(i=1; i<n; i++){ if( azResult[i] ) sqlite3_free(azResult[i]); }
    sqlite3_free(azResult);
  }
}
# 156055 "c_tests/sqlite3.c"
static void sqlite3DeleteTriggerStep(sqlite3 *db, TriggerStep *pTriggerStep){
  while( pTriggerStep ){
    TriggerStep * pTmp = pTriggerStep;
    pTriggerStep = pTriggerStep->pNext;

    sqlite3ExprDelete(db, pTmp->pWhere);
    sqlite3ExprListDelete(db, pTmp->pExprList);
    sqlite3SelectDelete(db, pTmp->pSelect);
    sqlite3IdListDelete(db, pTmp->pIdList);
    sqlite3UpsertDelete(db, pTmp->pUpsert);
    sqlite3SrcListDelete(db, pTmp->pFrom);
    sqlite3DbFree(db, pTmp->zSpan);

    sqlite3DbFree(db, pTmp);
  }
}
# 156086 "c_tests/sqlite3.c"
static Trigger *sqlite3TriggerList(Parse *pParse, Table *pTab){
  Schema *pTmpSchema;
  Trigger *pList;
  HashElem *p;

  ((void) (0));
  pTmpSchema = pParse->db->aDb[1].pSchema;
  p = ((&pTmpSchema->trigHash)->first);
  pList = pTab->pTrigger;
  while( p ){
    Trigger *pTrig = (Trigger *)((p)->data);
    if( pTrig->pTabSchema==pTab->pSchema
     && pTrig->table
     && 0==sqlite3StrICmp(pTrig->table, pTab->zName)
     && (pTrig->pTabSchema!=pTmpSchema || pTrig->bReturning)
    ){
      pTrig->pNext = pList;
      pList = pTrig;
    }else if( pTrig->op==151 ){

      ((void) (0));

      ((void) (0));
      ((void) (0));
      ((void) (0));
      pTrig->table = pTab->zName;
      pTrig->pTabSchema = pTab->pSchema;
      pTrig->pNext = pList;
      pList = pTrig;
    }
    p = ((p)->next);
  }
# 156129 "c_tests/sqlite3.c"
  return pList;
}
# 156140 "c_tests/sqlite3.c"
static void sqlite3BeginTrigger(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  int tr_tm,
  int op,
  IdList *pColumns,
  SrcList *pTableName,
  Expr *pWhen,
  int isTemp,
  int noErr
){
  Trigger *pTrigger = 0;
  Table *pTab;
  char *zName = 0;
  sqlite3 *db = pParse->db;
  int iDb;
  Token *pName;
  DbFixer sFix;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( isTemp ){

    if( pName2->n>0 ){
      sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name");
      goto trigger_cleanup;
    }
    iDb = 1;
    pName = pName1;
  }else{

    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
    if( iDb<0 ){
      goto trigger_cleanup;
    }
  }
  if( !pTableName || db->mallocFailed ){
    goto trigger_cleanup;
  }
# 156191 "c_tests/sqlite3.c"
  if( db->init.busy && iDb!=1 ){
    ((void) (0));
    ((void) (0));
    sqlite3DbFree(db, pTableName->a[0].u4.zDatabase);
    pTableName->a[0].u4.zDatabase = 0;
  }






  pTab = sqlite3SrcListLookup(pParse, pTableName);
  if( db->init.busy==0 && pName2->n==0 && pTab
        && pTab->pSchema==db->aDb[1].pSchema ){
    iDb = 1;
  }


  if( db->mallocFailed ) goto trigger_cleanup;
  ((void) (0));
  sqlite3FixInit(&sFix, pParse, iDb, "trigger", pName);
  if( sqlite3FixSrcList(&sFix, pTableName) ){
    goto trigger_cleanup;
  }
  pTab = sqlite3SrcListLookup(pParse, pTableName);
  if( !pTab ){

    goto trigger_orphan_error;
  }
  if( ((pTab)->eTabType==1) ){
    sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables");
    goto trigger_orphan_error;
  }
  if( (pTab->tabFlags & 0x00001000)!=0 && sqlite3ReadOnlyShadowTables(db) ){
    sqlite3ErrorMsg(pParse, "cannot create triggers on shadow tables");
    goto trigger_orphan_error;
  }



  zName = sqlite3NameFromToken(db, pName);
  if( zName==0 ){
    ((void) (0));
    goto trigger_cleanup;
  }
  if( sqlite3CheckObjectName(pParse, zName, "trigger", pTab->zName) ){
    goto trigger_cleanup;
  }
  ((void) (0));
  if( !(pParse->eParseMode>=2) ){
    if( sqlite3HashFind(&(db->aDb[iDb].pSchema->trigHash),zName) ){
      if( !noErr ){
        sqlite3ErrorMsg(pParse, "trigger %T already exists", pName);
      }else{
        ((void) (0));
        sqlite3CodeVerifySchema(pParse, iDb);

      }
      goto trigger_cleanup;
    }
  }


  if( sqlite3_strnicmp(pTab->zName, "sqlite_", 7)==0 ){
    sqlite3ErrorMsg(pParse, "cannot create trigger on system table");
    goto trigger_cleanup;
  }




  if( ((pTab)->eTabType==2) && tr_tm!=66 ){
    sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S",
        (tr_tm == 33)?"BEFORE":"AFTER", pTableName->a);
    goto trigger_orphan_error;
  }
  if( !((pTab)->eTabType==2) && tr_tm==66 ){
    sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF"
        " trigger on table: %S", pTableName->a);
    goto trigger_orphan_error;
  }


  if( !(pParse->eParseMode>=2) ){
    int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    int code = 7;
    const char *zDb = db->aDb[iTabDb].zDbSName;
    const char *zDbTrig = isTemp ? db->aDb[1].zDbSName : zDb;
    if( iTabDb==1 || isTemp ) code = 5;
    if( sqlite3AuthCheck(pParse, code, zName, pTab->zName, zDbTrig) ){
      goto trigger_cleanup;
    }
    if( sqlite3AuthCheck(pParse, 18, ((!0)&&(iTabDb==1)?"sqlite_temp_master":"sqlite_master"),0,zDb)){
      goto trigger_cleanup;
    }
  }







  if (tr_tm == 66){
    tr_tm = 33;
  }


  pTrigger = (Trigger*)sqlite3DbMallocZero(db, sizeof(Trigger));
  if( pTrigger==0 ) goto trigger_cleanup;
  pTrigger->zName = zName;
  zName = 0;
  pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName);
  pTrigger->pSchema = db->aDb[iDb].pSchema;
  pTrigger->pTabSchema = pTab->pSchema;
  pTrigger->op = (u8)op;
  pTrigger->tr_tm = tr_tm==33 ? 1 : 2;
  if( (pParse->eParseMode>=2) ){
    sqlite3RenameTokenRemap(pParse, pTrigger->table, pTableName->a[0].zName);
    pTrigger->pWhen = pWhen;
    pWhen = 0;
  }else{
    pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 0x0001);
  }
  pTrigger->pColumns = pColumns;
  pColumns = 0;
  ((void) (0));
  pParse->pNewTrigger = pTrigger;

trigger_cleanup:
  sqlite3DbFree(db, zName);
  sqlite3SrcListDelete(db, pTableName);
  sqlite3IdListDelete(db, pColumns);
  sqlite3ExprDelete(db, pWhen);
  if( !pParse->pNewTrigger ){
    sqlite3DeleteTrigger(db, pTrigger);
  }else{
    ((void) (0));
  }
  return;

trigger_orphan_error:
  if( db->init.iDb==1 ){
# 156345 "c_tests/sqlite3.c"
    db->init.orphanTrigger = 1;
  }
  goto trigger_cleanup;
}





static void sqlite3FinishTrigger(
  Parse *pParse,
  TriggerStep *pStepList,
  Token *pAll
){
  Trigger *pTrig = pParse->pNewTrigger;
  char *zName;
  sqlite3 *db = pParse->db;
  DbFixer sFix;
  int iDb;
  Token nameToken;

  pParse->pNewTrigger = 0;
  if( (pParse->nErr) || !pTrig ) goto triggerfinish_cleanup;
  zName = pTrig->zName;
  iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);
  pTrig->step_list = pStepList;
  while( pStepList ){
    pStepList->pTrig = pTrig;
    pStepList = pStepList->pNext;
  }
  sqlite3TokenInit(&nameToken, pTrig->zName);
  sqlite3FixInit(&sFix, pParse, iDb, "trigger", &nameToken);
  if( sqlite3FixTriggerStep(&sFix, pTrig->step_list)
   || sqlite3FixExpr(&sFix, pTrig->pWhen)
  ){
    goto triggerfinish_cleanup;
  }


  if( (pParse->eParseMode>=2) ){
    ((void) (0));
    pParse->pNewTrigger = pTrig;
    pTrig = 0;
  }else





  if( !db->init.busy ){
    Vdbe *v;
    char *z;




    if( sqlite3ReadOnlyShadowTables(db) ){
      TriggerStep *pStep;
      for(pStep=pTrig->step_list; pStep; pStep=pStep->pNext){
        if( pStep->zTarget!=0
         && sqlite3ShadowTableName(db, pStep->zTarget)
        ){
          sqlite3ErrorMsg(pParse,
            "trigger \"%s\" may not write to shadow table \"%s\"",
            pTrig->zName, pStep->zTarget);
          goto triggerfinish_cleanup;
        }
      }
    }


    v = sqlite3GetVdbe(pParse);
    if( v==0 ) goto triggerfinish_cleanup;
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    z = sqlite3DbStrNDup(db, (char*)pAll->z, pAll->n);
                    ;
    sqlite3NestedParse(pParse,
       "INSERT INTO %Q." "sqlite_master"
       " VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')",
       db->aDb[iDb].zDbSName, zName,
       pTrig->table, z);
    sqlite3DbFree(db, z);
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddParseSchemaOp(v, iDb,
        sqlite3MPrintf(db, "type='trigger' AND name='%q'", zName), 0);
  }

  if( db->init.busy ){
    Trigger *pLink = pTrig;
    Hash *pHash = &db->aDb[iDb].pSchema->trigHash;
    ((void) (0));
    ((void) (0));
    pTrig = sqlite3HashInsert(pHash, zName, pTrig);
    if( pTrig ){
      sqlite3OomFault(db);
    }else if( pLink->pSchema==pLink->pTabSchema ){
      Table *pTab;
      pTab = sqlite3HashFind(&pLink->pTabSchema->tblHash, pLink->table);
      ((void) (0));
      pLink->pNext = pTab->pTrigger;
      pTab->pTrigger = pLink;
    }
  }

triggerfinish_cleanup:
  sqlite3DeleteTrigger(db, pTrig);
  ((void) (0));
  sqlite3DeleteTriggerStep(db, pStepList);
}





static char *triggerSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){
  char *z = sqlite3DbSpanDup(db, zStart, zEnd);
  int i;
  if( z ) for(i=0; z[i]; i++) if( (sqlite3CtypeMap[(unsigned char)(z[i])]&0x01) ) z[i] = ' ';
  return z;
}
# 156473 "c_tests/sqlite3.c"
static TriggerStep *sqlite3TriggerSelectStep(
  sqlite3 *db,
  Select *pSelect,
  const char *zStart,
  const char *zEnd
){
  TriggerStep *pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep));
  if( pTriggerStep==0 ) {
    sqlite3SelectDelete(db, pSelect);
    return 0;
  }
  pTriggerStep->op = 139;
  pTriggerStep->pSelect = pSelect;
  pTriggerStep->orconf = 11;
  pTriggerStep->zSpan = triggerSpanDup(db, zStart, zEnd);
  return pTriggerStep;
}







static TriggerStep *triggerStepAllocate(
  Parse *pParse,
  u8 op,
  Token *pName,
  const char *zStart,
  const char *zEnd
){
  sqlite3 *db = pParse->db;
  TriggerStep *pTriggerStep;

  if( pParse->nErr ) return 0;
  pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep) + pName->n + 1);
  if( pTriggerStep ){
    char *z = (char*)&pTriggerStep[1];
    memcpy(z, pName->z, pName->n);
    sqlite3Dequote(z);
    pTriggerStep->zTarget = z;
    pTriggerStep->op = op;
    pTriggerStep->zSpan = triggerSpanDup(db, zStart, zEnd);
    if( (pParse->eParseMode>=2) ){
      sqlite3RenameTokenMap(pParse, pTriggerStep->zTarget, pName);
    }
  }
  return pTriggerStep;
}
# 156530 "c_tests/sqlite3.c"
static TriggerStep *sqlite3TriggerInsertStep(
  Parse *pParse,
  Token *pTableName,
  IdList *pColumn,
  Select *pSelect,
  u8 orconf,
  Upsert *pUpsert,
  const char *zStart,
  const char *zEnd
){
  sqlite3 *db = pParse->db;
  TriggerStep *pTriggerStep;

  ((void) (0));

  pTriggerStep = triggerStepAllocate(pParse, 128, pTableName,zStart,zEnd);
  if( pTriggerStep ){
    if( (pParse->eParseMode>=2) ){
      pTriggerStep->pSelect = pSelect;
      pSelect = 0;
    }else{
      pTriggerStep->pSelect = sqlite3SelectDup(db, pSelect, 0x0001);
    }
    pTriggerStep->pIdList = pColumn;
    pTriggerStep->pUpsert = pUpsert;
    pTriggerStep->orconf = orconf;
    if( pUpsert ){
      sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget);
    }
  }else{
                       ;
    sqlite3IdListDelete(db, pColumn);
                       ;
    sqlite3UpsertDelete(db, pUpsert);
  }
  sqlite3SelectDelete(db, pSelect);

  return pTriggerStep;
}






static TriggerStep *sqlite3TriggerUpdateStep(
  Parse *pParse,
  Token *pTableName,
  SrcList *pFrom,
  ExprList *pEList,
  Expr *pWhere,
  u8 orconf,
  const char *zStart,
  const char *zEnd
){
  sqlite3 *db = pParse->db;
  TriggerStep *pTriggerStep;

  pTriggerStep = triggerStepAllocate(pParse, 130, pTableName,zStart,zEnd);
  if( pTriggerStep ){
    if( (pParse->eParseMode>=2) ){
      pTriggerStep->pExprList = pEList;
      pTriggerStep->pWhere = pWhere;
      pTriggerStep->pFrom = pFrom;
      pEList = 0;
      pWhere = 0;
      pFrom = 0;
    }else{
      pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, 0x0001);
      pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001);
      pTriggerStep->pFrom = sqlite3SrcListDup(db, pFrom, 0x0001);
    }
    pTriggerStep->orconf = orconf;
  }
  sqlite3ExprListDelete(db, pEList);
  sqlite3ExprDelete(db, pWhere);
  sqlite3SrcListDelete(db, pFrom);
  return pTriggerStep;
}






static TriggerStep *sqlite3TriggerDeleteStep(
  Parse *pParse,
  Token *pTableName,
  Expr *pWhere,
  const char *zStart,
  const char *zEnd
){
  sqlite3 *db = pParse->db;
  TriggerStep *pTriggerStep;

  pTriggerStep = triggerStepAllocate(pParse, 129, pTableName,zStart,zEnd);
  if( pTriggerStep ){
    if( (pParse->eParseMode>=2) ){
      pTriggerStep->pWhere = pWhere;
      pWhere = 0;
    }else{
      pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001);
    }
    pTriggerStep->orconf = 11;
  }
  sqlite3ExprDelete(db, pWhere);
  return pTriggerStep;
}




static void sqlite3DeleteTrigger(sqlite3 *db, Trigger *pTrigger){
  if( pTrigger==0 || pTrigger->bReturning ) return;
  sqlite3DeleteTriggerStep(db, pTrigger->step_list);
  sqlite3DbFree(db, pTrigger->zName);
  sqlite3DbFree(db, pTrigger->table);
  sqlite3ExprDelete(db, pTrigger->pWhen);
  sqlite3IdListDelete(db, pTrigger->pColumns);
  sqlite3DbFree(db, pTrigger);
}
# 156660 "c_tests/sqlite3.c"
static void sqlite3DropTrigger(Parse *pParse, SrcList *pName, int noErr){
  Trigger *pTrigger = 0;
  int i;
  const char *zDb;
  const char *zName;
  sqlite3 *db = pParse->db;

  if( db->mallocFailed ) goto drop_trigger_cleanup;
  if( 0!=sqlite3ReadSchema(pParse) ){
    goto drop_trigger_cleanup;
  }

  ((void) (0));
  ((void) (0));
  zDb = pName->a[0].u4.zDatabase;
  zName = pName->a[0].zName;
  ((void) (0));
  for(i=0; i<db->nDb; i++){
    int j = (i<2) ? i^1 : i;
    if( zDb && sqlite3DbIsNamed(db, j, zDb)==0 ) continue;
    ((void) (0));
    pTrigger = sqlite3HashFind(&(db->aDb[j].pSchema->trigHash), zName);
    if( pTrigger ) break;
  }
  if( !pTrigger ){
    if( !noErr ){
      sqlite3ErrorMsg(pParse, "no such trigger: %S", pName->a);
    }else{
      sqlite3CodeVerifyNamedSchema(pParse, zDb);
    }
    pParse->checkSchema = 1;
    goto drop_trigger_cleanup;
  }
  sqlite3DropTriggerPtr(pParse, pTrigger);

drop_trigger_cleanup:
  sqlite3SrcListDelete(db, pName);
}





static Table *tableOfTrigger(Trigger *pTrigger){
  return sqlite3HashFind(&pTrigger->pTabSchema->tblHash, pTrigger->table);
}





static void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger){
  Table *pTable;
  Vdbe *v;
  sqlite3 *db = pParse->db;
  int iDb;

  iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema);
  ((void) (0));
  pTable = tableOfTrigger(pTrigger);
  ((void) (0));

  if( pTable ){
    int code = 16;
    const char *zDb = db->aDb[iDb].zDbSName;
    const char *zTab = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");
    if( iDb==1 ) code = 14;
    if( sqlite3AuthCheck(pParse, code, pTrigger->zName, pTable->zName, zDb) ||
      sqlite3AuthCheck(pParse, 9, zTab, 0, zDb) ){
      return;
    }
  }




  if( (v = sqlite3GetVdbe(pParse))!=0 ){
    sqlite3NestedParse(pParse,
       "DELETE FROM %Q." "sqlite_master" " WHERE name=%Q AND type='trigger'",
       db->aDb[iDb].zDbSName, pTrigger->zName
    );
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddOp4(v, 155, iDb, 0, 0, pTrigger->zName, 0);
  }
}




static void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName){
  Trigger *pTrigger;
  Hash *pHash;

  ((void) (0));
  pHash = &(db->aDb[iDb].pSchema->trigHash);
  pTrigger = sqlite3HashInsert(pHash, zName, 0);
  if( (pTrigger) ){
    if( pTrigger->pSchema==pTrigger->pTabSchema ){
      Table *pTab = tableOfTrigger(pTrigger);
      if( pTab ){
        Trigger **pp;
        for(pp=&pTab->pTrigger; *pp; pp=&((*pp)->pNext)){
          if( *pp==pTrigger ){
            *pp = (*pp)->pNext;
            break;
          }
        }
      }
    }
    sqlite3DeleteTrigger(db, pTrigger);
    db->mDbFlags |= 0x0001;
  }
}
# 156783 "c_tests/sqlite3.c"
static int checkColumnOverlap(IdList *pIdList, ExprList *pEList){
  int e;
  if( pIdList==0 || (pEList==0) ) return 1;
  for(e=0; e<pEList->nExpr; e++){
    if( sqlite3IdListIndex(pIdList, pEList->a[e].zEName)>=0 ) return 1;
  }
  return 0;
}




static int tempTriggersExist(sqlite3 *db){
  if( (db->aDb[1].pSchema==0) ) return 0;
  if( ((&db->aDb[1].pSchema->trigHash)->first)==0 ) return 0;
  return 1;
}







static __attribute__((noinline)) Trigger *triggersReallyExist(
  Parse *pParse,
  Table *pTab,
  int op,
  ExprList *pChanges,
  int *pMask
){
  int mask = 0;
  Trigger *pList = 0;
  Trigger *p;

  pList = sqlite3TriggerList(pParse, pTab);
  ((void) (0));

  if( pList!=0 ){
    p = pList;
    if( (pParse->db->flags & 0x00040000)==0
     && pTab->pTrigger!=0
    ){



      if( pList==pTab->pTrigger ){
        pList = 0;
        goto exit_triggers_exist;
      }
      while( (p->pNext) && p->pNext!=pTab->pTrigger ) p = p->pNext;
      p->pNext = 0;
      p = pList;
    }
    do{
      if( p->op==op && checkColumnOverlap(p->pColumns, pChanges) ){
        mask |= p->tr_tm;
      }else if( p->op==151 ){


        ((void) (0));
        p->op = op;
        if( ((pTab)->eTabType==1) ){
          if( op!=128 ){
            sqlite3ErrorMsg(pParse,
              "%s RETURNING is not available on virtual tables",
              op==129 ? "DELETE" : "UPDATE");
          }
          p->tr_tm = 1;
        }else{
          p->tr_tm = 2;
        }
        mask |= p->tr_tm;
      }else if( p->bReturning && p->op==128 && op==130
                && ((pParse)->pToplevel==0) ){

        mask |= p->tr_tm;
      }
      p = p->pNext;
    }while( p );
  }
exit_triggers_exist:
  if( pMask ){
    *pMask = mask;
  }
  return (mask ? pList : 0);
}
static Trigger *sqlite3TriggersExist(
  Parse *pParse,
  Table *pTab,
  int op,
  ExprList *pChanges,
  int *pMask
){
  ((void) (0));
  if( (pTab->pTrigger==0 && !tempTriggersExist(pParse->db))
   || pParse->disableTriggers
  ){
    if( pMask ) *pMask = 0;
    return 0;
  }
  return triggersReallyExist(pParse,pTab,op,pChanges,pMask);
}
# 156897 "c_tests/sqlite3.c"
static SrcList *sqlite3TriggerStepSrc(
  Parse *pParse,
  TriggerStep *pStep
){
  sqlite3 *db = pParse->db;
  SrcList *pSrc;
  char *zName = sqlite3DbStrDup(db, pStep->zTarget);
  pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
  ((void) (0));
  ((void) (0));
  if( pSrc ){
    Schema *pSchema = pStep->pTrig->pSchema;
    pSrc->a[0].zName = zName;
    if( pSchema!=db->aDb[1].pSchema ){
      ((void) (0));
      pSrc->a[0].u4.pSchema = pSchema;
      pSrc->a[0].fg.fixedSchema = 1;
    }
    if( pStep->pFrom ){
      SrcList *pDup = sqlite3SrcListDup(db, pStep->pFrom, 0);
      if( pDup && pDup->nSrc>1 && !(pParse->eParseMode>=2) ){
        Select *pSubquery;
        Token as;
        pSubquery = sqlite3SelectNew(pParse,0,pDup,0,0,0,0,0x0000800,0);
        as.n = 0;
        as.z = 0;
        pDup = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&as,pSubquery,0);
      }
      pSrc = sqlite3SrcListAppendList(pParse, pSrc, pDup);
    }
  }else{
    sqlite3DbFree(db, zName);
  }
  return pSrc;
}






static int isAsteriskTerm(
  Parse *pParse,
  Expr *pTerm
){
  ((void) (0));
  if( pTerm->op==180 ) return 1;
  if( pTerm->op!=142 ) return 0;
  ((void) (0));
  ((void) (0));
  if( pTerm->pRight->op!=180 ) return 0;
  sqlite3ErrorMsg(pParse, "RETURNING may not use \"TABLE.*\" wildcards");
  return 1;
}







static ExprList *sqlite3ExpandReturning(
  Parse *pParse,
  ExprList *pList,
  Table *pTab
){
  ExprList *pNew = 0;
  sqlite3 *db = pParse->db;
  int i;

  for(i=0; i<pList->nExpr; i++){
    Expr *pOldExpr = pList->a[i].pExpr;
    if( (pOldExpr==0) ) continue;
    if( isAsteriskTerm(pParse, pOldExpr) ){
      int jj;
      for(jj=0; jj<pTab->nCol; jj++){
        Expr *pNewExpr;
        if( (((pTab->aCol+jj)->colFlags & 0x0002)!=0) ) continue;
        pNewExpr = sqlite3Expr(db, 60, pTab->aCol[jj].zCnName);
        pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);
        if( !db->mallocFailed ){
          struct ExprList_item *pItem = &pNew->a[pNew->nExpr-1];
          pItem->zEName = sqlite3DbStrDup(db, pTab->aCol[jj].zCnName);
          pItem->fg.eEName = 0;
        }
      }
    }else{
      Expr *pNewExpr = sqlite3ExprDup(db, pOldExpr, 0);
      pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);
      if( !db->mallocFailed && (pList->a[i].zEName!=0) ){
        struct ExprList_item *pItem = &pNew->a[pNew->nExpr-1];
        pItem->zEName = sqlite3DbStrDup(db, pList->a[i].zEName);
        pItem->fg.eEName = pList->a[i].fg.eEName;
      }
    }
  }
  return pNew;
}





static int sqlite3ReturningSubqueryVarSelect(Walker *NotUsed, Expr *pExpr){
  (void)(NotUsed);
  if( (((pExpr)->flags&0x001000)!=0)
   && (pExpr->x.pSelect->selFlags & 0x20000000)!=0
  ){
                                                    ;
    (pExpr)->flags|=(u32)(0x000040);
  }
  return 0;
}
# 157019 "c_tests/sqlite3.c"
static int sqlite3ReturningSubqueryCorrelated(Walker *pWalker, Select *pSelect){
  int i;
  SrcList *pSrc;
  ((void) (0));
  pSrc = pSelect->pSrc;
  ((void) (0));
  for(i=0; i<pSrc->nSrc; i++){
    if( pSrc->a[i].pSTab==pWalker->u.pTab ){
                                                   ;
      pSelect->selFlags |= 0x20000000;
      pWalker->eCode = 1;
      break;
    }
  }
  return 0;
}
# 157045 "c_tests/sqlite3.c"
static void sqlite3ProcessReturningSubqueries(
  ExprList *pEList,
  Table *pTab
){
  Walker w;
  memset(&w, 0, sizeof(w));
  w.xExprCallback = sqlite3ExprWalkNoop;
  w.xSelectCallback = sqlite3ReturningSubqueryCorrelated;
  w.u.pTab = pTab;
  sqlite3WalkExprList(&w, pEList);
  if( w.eCode ){
    w.xExprCallback = sqlite3ReturningSubqueryVarSelect;
    w.xSelectCallback = sqlite3SelectWalkNoop;
    sqlite3WalkExprList(&w, pEList);
  }
}






static void codeReturningTrigger(
  Parse *pParse,
  Trigger *pTrigger,
  Table *pTab,
  int regIn
){
  Vdbe *v = pParse->pVdbe;
  sqlite3 *db = pParse->db;
  ExprList *pNew;
  Returning *pReturning;
  Select sSelect;
  SrcList *pFrom;
  union {
    SrcList sSrc;
    u8 fromSpace[(__builtin_offsetof(SrcList, a)+sizeof(SrcItem))];
  } uSrc;

  ((void) (0));
  if( !pParse->bReturning ){


    return;
  }
  ((void) (0));
  ((void) (0));
  pReturning = pParse->u1.d.pReturning;
  if( pTrigger != &(pReturning->retTrig) ){

    return;
  }
  memset(&sSelect, 0, sizeof(sSelect));
  memset(&uSrc, 0, sizeof(uSrc));
  pFrom = &uSrc.sSrc;
  sSelect.pEList = sqlite3ExprListDup(db, pReturning->pReturnEL, 0);
  sSelect.pSrc = pFrom;
  pFrom->nSrc = 1;
  pFrom->a[0].pSTab = pTab;
  pFrom->a[0].zName = pTab->zName;
  pFrom->a[0].iCursor = -1;
  sqlite3SelectPrep(pParse, &sSelect, 0);
  if( pParse->nErr==0 ){
    ((void) (0));
    sqlite3GenerateColumnNames(pParse, &sSelect);
  }
  sqlite3ExprListDelete(db, sSelect.pEList);
  pNew = sqlite3ExpandReturning(pParse, pReturning->pReturnEL, pTab);
  if( pParse->nErr==0 ){
    NameContext sNC;
    memset(&sNC, 0, sizeof(sNC));
    if( pReturning->nRetCol==0 ){
      pReturning->nRetCol = pNew->nExpr;
      pReturning->iRetCur = pParse->nTab++;
    }
    sNC.pParse = pParse;
    sNC.uNC.iBaseReg = regIn;
    sNC.ncFlags = 0x000400;
    pParse->eTriggerOp = pTrigger->op;
    pParse->pTriggerTab = pTab;
    if( sqlite3ResolveExprListNames(&sNC, pNew)==0
     && (!db->mallocFailed)
    ){
      int i;
      int nCol = pNew->nExpr;
      int reg = pParse->nMem+1;
      sqlite3ProcessReturningSubqueries(pNew, pTab);
      pParse->nMem += nCol+2;
      pReturning->iRetReg = reg;
      for(i=0; i<nCol; i++){
        Expr *pCol = pNew->a[i].pExpr;
        ((void) (0));
        sqlite3ExprCodeFactorable(pParse, pCol, reg+i);
        if( sqlite3ExprAffinity(pCol)==0x45 ){
          sqlite3VdbeAddOp1(v, 88, reg+i);
        }
      }
      sqlite3VdbeAddOp3(v, 98, reg, i, reg+i);
      sqlite3VdbeAddOp2(v, 128, pReturning->iRetCur, reg+i+1);
      sqlite3VdbeAddOp3(v, 129, pReturning->iRetCur, reg+i, reg+i+1);
    }
  }
  sqlite3ExprListDelete(db, pNew);
  pParse->eTriggerOp = 0;
  pParse->pTriggerTab = 0;
}







static int codeTriggerProgram(
  Parse *pParse,
  TriggerStep *pStepList,
  int orconf
){
  TriggerStep *pStep;
  Vdbe *v = pParse->pVdbe;
  sqlite3 *db = pParse->db;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  for(pStep=pStepList; pStep; pStep=pStep->pNext){
# 157184 "c_tests/sqlite3.c"
    pParse->eOrconf = (orconf==11)?pStep->orconf:(u8)orconf;
    ((void) (0));


    if( pStep->zSpan ){
      sqlite3VdbeAddOp4(v, 185, 0x7fffffff, 1, 0,
                        sqlite3MPrintf(db, "-- %s", pStep->zSpan),
                        (-6));
    }


    switch( pStep->op ){
      case 130: {
        sqlite3Update(pParse,
          sqlite3TriggerStepSrc(pParse, pStep),
          sqlite3ExprListDup(db, pStep->pExprList, 0),
          sqlite3ExprDup(db, pStep->pWhere, 0),
          pParse->eOrconf, 0, 0, 0
        );
        sqlite3VdbeAddOp0(v, 132);
        break;
      }
      case 128: {
        sqlite3Insert(pParse,
          sqlite3TriggerStepSrc(pParse, pStep),
          sqlite3SelectDup(db, pStep->pSelect, 0),
          sqlite3IdListDup(db, pStep->pIdList),
          pParse->eOrconf,
          sqlite3UpsertDup(db, pStep->pUpsert)
        );
        sqlite3VdbeAddOp0(v, 132);
        break;
      }
      case 129: {
        sqlite3DeleteFrom(pParse,
          sqlite3TriggerStepSrc(pParse, pStep),
          sqlite3ExprDup(db, pStep->pWhere, 0), 0, 0
        );
        sqlite3VdbeAddOp0(v, 132);
        break;
      }
      default: ((void) (0)); {
        SelectDest sDest;
        Select *pSelect = sqlite3SelectDup(db, pStep->pSelect, 0);
        sqlite3SelectDestInit(&sDest, 4, 0);
        sqlite3Select(pParse, pSelect, &sDest);
        sqlite3SelectDelete(db, pSelect);
        break;
      }
    }
  }

  return 0;
}
# 157262 "c_tests/sqlite3.c"
static void transferParseError(Parse *pTo, Parse *pFrom){
  ((void) (0));
  ((void) (0));
  if( pTo->nErr==0 ){
    pTo->zErrMsg = pFrom->zErrMsg;
    pTo->nErr = pFrom->nErr;
    pTo->rc = pFrom->rc;
  }else{
    sqlite3DbFree(pFrom->db, pFrom->zErrMsg);
  }
}





static TriggerPrg *codeRowTrigger(
  Parse *pParse,
  Trigger *pTrigger,
  Table *pTab,
  int orconf
){
  Parse *pTop = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  sqlite3 *db = pParse->db;
  TriggerPrg *pPrg;
  Expr *pWhen = 0;
  Vdbe *v;
  NameContext sNC;
  SubProgram *pProgram = 0;
  int iEndTrigger = 0;
  Parse sSubParse;

  ((void) (0));
  ((void) (0));




  pPrg = sqlite3DbMallocZero(db, sizeof(TriggerPrg));
  if( !pPrg ) return 0;
  pPrg->pNext = pTop->pTriggerPrg;
  pTop->pTriggerPrg = pPrg;
  pPrg->pProgram = pProgram = sqlite3DbMallocZero(db, sizeof(SubProgram));
  if( !pProgram ) return 0;
  sqlite3VdbeLinkSubProgram(pTop->pVdbe, pProgram);
  pPrg->pTrigger = pTrigger;
  pPrg->orconf = orconf;
  pPrg->aColmask[0] = 0xffffffff;
  pPrg->aColmask[1] = 0xffffffff;



  sqlite3ParseObjectInit(&sSubParse, db);
  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = &sSubParse;
  sSubParse.pTriggerTab = pTab;
  sSubParse.pToplevel = pTop;
  sSubParse.zAuthContext = pTrigger->zName;
  sSubParse.eTriggerOp = pTrigger->op;
  sSubParse.nQueryLoop = pParse->nQueryLoop;
  sSubParse.prepFlags = pParse->prepFlags;
  sSubParse.oldmask = 0;
  sSubParse.newmask = 0;

  v = sqlite3GetVdbe(&sSubParse);
  if( v ){







      ;

    if( pTrigger->zName ){
      sqlite3VdbeChangeP4(v, -1,
        sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger->zName), (-6)
      );
    }





    if( pTrigger->pWhen ){
      pWhen = sqlite3ExprDup(db, pTrigger->pWhen, 0);
      if( db->mallocFailed==0
       && 0==sqlite3ResolveExprNames(&sNC, pWhen)
      ){
        iEndTrigger = sqlite3VdbeMakeLabel(&sSubParse);
        sqlite3ExprIfFalse(&sSubParse, pWhen, iEndTrigger, 0x10);
      }
      sqlite3ExprDelete(db, pWhen);
    }


    codeTriggerProgram(&sSubParse, pTrigger->step_list, orconf);


    if( iEndTrigger ){
      sqlite3VdbeResolveLabel(v, iEndTrigger);
    }
    sqlite3VdbeAddOp0(v, 71);
                                                                        ;
    transferParseError(pParse, &sSubParse);

    if( pParse->nErr==0 ){
      ((void) (0));
      pProgram->aOp = sqlite3VdbeTakeOpArray(v, &pProgram->nOp, &pTop->nMaxArg);
    }
    pProgram->nMem = sSubParse.nMem;
    pProgram->nCsr = sSubParse.nTab;
    pProgram->token = (void *)pTrigger;
    pPrg->aColmask[0] = sSubParse.oldmask;
    pPrg->aColmask[1] = sSubParse.newmask;
    sqlite3VdbeDelete(v);
  }else{
    transferParseError(pParse, &sSubParse);
  }

  ((void) (0));
  sqlite3ParseObjectReset(&sSubParse);
  return pPrg;
}







static TriggerPrg *getRowTrigger(
  Parse *pParse,
  Trigger *pTrigger,
  Table *pTab,
  int orconf
){
  Parse *pRoot = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  TriggerPrg *pPrg;

  ((void) (0));





  for(pPrg=pRoot->pTriggerPrg;
      pPrg && (pPrg->pTrigger!=pTrigger || pPrg->orconf!=orconf);
      pPrg=pPrg->pNext
  );


  if( !pPrg ){
    pPrg = codeRowTrigger(pParse, pTrigger, pTab, orconf);
    pParse->db->errByteOffset = -1;
  }

  return pPrg;
}







static void sqlite3CodeRowTriggerDirect(
  Parse *pParse,
  Trigger *p,
  Table *pTab,
  int reg,
  int orconf,
  int ignoreJump
){
  Vdbe *v = sqlite3GetVdbe(pParse);
  TriggerPrg *pPrg;
  pPrg = getRowTrigger(pParse, p, pTab, orconf);
  ((void) (0));



  if( pPrg ){
    int bRecursive = (p->zName && 0==(pParse->db->flags&0x00002000));

    sqlite3VdbeAddOp4(v, 49, reg, ignoreJump, ++pParse->nMem,
                      (const char *)pPrg->pProgram, (-4));

                                                                            ;






    sqlite3VdbeChangeP5(v, (u16)bRecursive);
  }
}
# 157501 "c_tests/sqlite3.c"
static void sqlite3CodeRowTrigger(
  Parse *pParse,
  Trigger *pTrigger,
  int op,
  ExprList *pChanges,
  int tr_tm,
  Table *pTab,
  int reg,
  int orconf,
  int ignoreJump
){
  Trigger *p;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  for(p=pTrigger; p; p=p->pNext){




    ((void) (0));
    ((void) (0));
    ((void) (0));







    if( (p->op==op || (p->bReturning && p->op==128 && op==130))
     && p->tr_tm==tr_tm
     && checkColumnOverlap(p->pColumns, pChanges)
    ){
      if( !p->bReturning ){
        sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump);
      }else if( ((pParse)->pToplevel==0) ){
        codeReturningTrigger(pParse, p, pTab, reg);
      }
    }
  }
}
# 157571 "c_tests/sqlite3.c"
static u32 sqlite3TriggerColmask(
  Parse *pParse,
  Trigger *pTrigger,
  ExprList *pChanges,
  int isNew,
  int tr_tm,
  Table *pTab,
  int orconf
){
  const int op = pChanges ? 130 : 129;
  u32 mask = 0;
  Trigger *p;

  ((void) (0));
  if( ((pTab)->eTabType==2) ){
    return 0xffffffff;
  }
  for(p=pTrigger; p; p=p->pNext){
    if( p->op==op
     && (tr_tm&p->tr_tm)
     && checkColumnOverlap(p->pColumns,pChanges)
    ){
      if( p->bReturning ){
        mask = 0xffffffff;
      }else{
        TriggerPrg *pPrg;
        pPrg = getRowTrigger(pParse, p, pTab, orconf);
        if( pPrg ){
          mask |= pPrg->aColmask[isNew];
        }
      }
    }
  }

  return mask;
}
# 157630 "c_tests/sqlite3.c"
static void updateVirtualTable(
  Parse *pParse,
  SrcList *pSrc,
  Table *pTab,
  ExprList *pChanges,
  Expr *pRowidExpr,
  int *aXRef,
  Expr *pWhere,
  int onError
);
# 157672 "c_tests/sqlite3.c"
static void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i, int iReg){
  Column *pCol;
  ((void) (0));
  ((void) (0));
  pCol = &pTab->aCol[i];
  if( pCol->iDflt ){
    sqlite3_value *pValue = 0;
    u8 enc = ((sqlite3VdbeDb(v))->enc);
    ((void) (0));
                                                         ;
    ((void) (0));
    sqlite3ValueFromExpr(sqlite3VdbeDb(v),
                         sqlite3ColumnExpr(pTab,pCol), enc,
                         pCol->affinity, &pValue);
    if( pValue ){
      sqlite3VdbeAppendP4(v, pValue, (-10));
    }
  }

  if( pCol->affinity==0x45 && !((pTab)->eTabType==1) ){
    sqlite3VdbeAddOp1(v, 88, iReg);
  }

}
# 157708 "c_tests/sqlite3.c"
static int indexColumnIsBeingUpdated(
  Index *pIdx,
  int iCol,
  int *aXRef,
  int chngRowid
){
  i16 iIdxCol = pIdx->aiColumn[iCol];
  ((void) (0));
  if( iIdxCol>=0 ){
    return aXRef[iIdxCol]>=0;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return sqlite3ExprReferencesUpdatedColumn(pIdx->aColExpr->a[iCol].pExpr,
                                            aXRef,chngRowid);
}
# 157738 "c_tests/sqlite3.c"
static int indexWhereClauseMightChange(
  Index *pIdx,
  int *aXRef,
  int chngRowid
){
  if( pIdx->pPartIdxWhere==0 ) return 0;
  return sqlite3ExprReferencesUpdatedColumn(pIdx->pPartIdxWhere,
                                            aXRef, chngRowid);
}







static Expr *exprRowColumn(Parse *pParse, int iCol){
  Expr *pRet = sqlite3PExpr(pParse, 76, 0, 0);
  if( pRet ) pRet->iColumn = iCol+1;
  return pRet;
}
# 157798 "c_tests/sqlite3.c"
static void updateFromSelect(
  Parse *pParse,
  int iEph,
  Index *pPk,
  ExprList *pChanges,
  SrcList *pTabList,
  Expr *pWhere,
  ExprList *pOrderBy,
  Expr *pLimit
){
  int i;
  SelectDest dest;
  Select *pSelect = 0;
  ExprList *pList = 0;
  ExprList *pGrp = 0;
  Expr *pLimit2 = 0;
  ExprList *pOrderBy2 = 0;
  sqlite3 *db = pParse->db;
  Table *pTab = pTabList->a[0].pSTab;
  SrcList *pSrc;
  Expr *pWhere2;
  int eDest;
# 157829 "c_tests/sqlite3.c"
  (void)(pOrderBy);
  (void)(pLimit);


  pSrc = sqlite3SrcListDup(db, pTabList, 0);
  pWhere2 = sqlite3ExprDup(db, pWhere, 0);

  ((void) (0));
  if( pSrc ){
    ((void) (0));
    pSrc->a[0].iCursor = -1;
    pSrc->a[0].pSTab->nTabRef--;
    pSrc->a[0].pSTab = 0;
  }
  if( pPk ){
    for(i=0; i<pPk->nKeyCol; i++){
      Expr *pNew = exprRowColumn(pParse, pPk->aiColumn[i]);





      pList = sqlite3ExprListAppend(pParse, pList, pNew);
    }
    eDest = ((pTab)->eTabType==1) ? 14 : 15;
  }else if( ((pTab)->eTabType==2) ){
    for(i=0; i<pTab->nCol; i++){
      pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));
    }
    eDest = 14;
  }else{
    eDest = ((pTab)->eTabType==1) ? 14 : 15;
    pList = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,76,0,0));





  }
  ((void) (0));
  if( pChanges ){
    for(i=0; i<pChanges->nExpr; i++){
      pList = sqlite3ExprListAppend(pParse, pList,
          sqlite3ExprDup(db, pChanges->a[i].pExpr, 0)
      );
    }
  }
  pSelect = sqlite3SelectNew(pParse, pList,
      pSrc, pWhere2, pGrp, 0, pOrderBy2,
      0x0800000|0x0020000|0x10000000, pLimit2
  );
  if( pSelect ) pSelect->selFlags |= 0x8000000;
  sqlite3SelectDestInit(&dest, eDest, iEph);
  dest.iSDParm2 = (pPk ? pPk->nKeyCol : -1);
  sqlite3Select(pParse, pSelect, &dest);
  sqlite3SelectDelete(db, pSelect);
}
# 157896 "c_tests/sqlite3.c"
static void sqlite3Update(
  Parse *pParse,
  SrcList *pTabList,
  ExprList *pChanges,
  Expr *pWhere,
  int onError,
  ExprList *pOrderBy,
  Expr *pLimit,
  Upsert *pUpsert
){
  int i, j, k;
  Table *pTab;
  int addrTop = 0;
  WhereInfo *pWInfo = 0;
  Vdbe *v;
  Index *pIdx;
  Index *pPk;
  int nIdx;
  int nAllIdx;
  int iBaseCur;
  int iDataCur;
  int iIdxCur;
  sqlite3 *db;
  int *aRegIdx = 0;
  int *aXRef = 0;


  u8 *aToOpen;
  u8 chngPk;
  u8 chngRowid;
  u8 chngKey;
  Expr *pRowidExpr = 0;
  int iRowidExpr = -1;
  AuthContext sContext;
  NameContext sNC;
  int iDb;
  int eOnePass;
  int hasFK;
  int labelBreak;
  int labelContinue;
  int flags;


  int isView;
  Trigger *pTrigger;
  int tmask;

  int newmask;
  int iEph = 0;
  int nKey = 0;
  int aiCurOnePass[2];
  int addrOpen = 0;
  int iPk = 0;
  i16 nPk = 0;
  int bReplace = 0;
  int bFinishSeek = 1;
  int nChangeFrom = 0;


  int regRowCount = 0;
  int regOldRowid = 0;
  int regNewRowid = 0;
  int regNew = 0;
  int regOld = 0;
  int regRowSet = 0;
  int regKey = 0;

  memset(&sContext, 0, sizeof(sContext));
  db = pParse->db;
  ((void) (0));
  if( pParse->nErr ){
    goto update_cleanup;
  }
  ((void) (0));



  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if( pTab==0 ) goto update_cleanup;
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);





  pTrigger = sqlite3TriggersExist(pParse, pTab, 130, pChanges, &tmask);
  isView = ((pTab)->eTabType==2);
  ((void) (0));
# 158006 "c_tests/sqlite3.c"
  nChangeFrom = (pTabList->nSrc>1) ? pChanges->nExpr : 0;
  ((void) (0));
# 158019 "c_tests/sqlite3.c"
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto update_cleanup;
  }
  if( sqlite3IsReadOnly(pParse, pTab, pTrigger) ){
    goto update_cleanup;
  }






  iBaseCur = iDataCur = pParse->nTab++;
  iIdxCur = iDataCur+1;
  pPk = (((pTab)->tabFlags & 0x00000080)==0) ? 0 : sqlite3PrimaryKeyIndex(pTab);
                                         ;
  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){
    if( pPk==pIdx ){
      iDataCur = pParse->nTab;
    }
    pParse->nTab++;
  }
  if( pUpsert ){

    iDataCur = pUpsert->iDataCur;
    iIdxCur = pUpsert->iIdxCur;
    pParse->nTab = iBaseCur;
  }
  pTabList->a[0].iCursor = iDataCur;




  aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx+1) + nIdx+2 );
  if( aXRef==0 ) goto update_cleanup;
  aRegIdx = aXRef+pTab->nCol;
  aToOpen = (u8*)(aRegIdx+nIdx+1);
  memset(aToOpen, 1, nIdx+1);
  aToOpen[nIdx+1] = 0;
  for(i=0; i<pTab->nCol; i++) aXRef[i] = -1;


  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  sNC.uNC.pUpsert = pUpsert;
  sNC.ncFlags = 0x000200;


  v = sqlite3GetVdbe(pParse);
  if( v==0 ) goto update_cleanup;







  chngRowid = chngPk = 0;
  for(i=0; i<pChanges->nExpr; i++){


    if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){
      goto update_cleanup;
    }
    j = sqlite3ColumnIndex(pTab, pChanges->a[i].zEName);
    if( j>=0 ){
      if( j==pTab->iPKey ){
        chngRowid = 1;
        pRowidExpr = pChanges->a[i].pExpr;
        iRowidExpr = i;
      }else if( pPk && (pTab->aCol[j].colFlags & 0x0001)!=0 ){
        chngPk = 1;
      }

      else if( pTab->aCol[j].colFlags & 0x0060 ){
                                                            ;
                                                           ;
        sqlite3ErrorMsg(pParse,
           "cannot UPDATE generated column \"%s\"",
           pTab->aCol[j].zCnName);
        goto update_cleanup;
      }

      aXRef[j] = i;
    }else{
      if( pPk==0 && sqlite3IsRowid(pChanges->a[i].zEName) ){
        j = -1;
        chngRowid = 1;
        pRowidExpr = pChanges->a[i].pExpr;
        iRowidExpr = i;
      }else{
        sqlite3ErrorMsg(pParse, "no such column: %s", pChanges->a[i].zEName);
        pParse->checkSchema = 1;
        goto update_cleanup;
      }
    }

    {
      int rc;
      rc = sqlite3AuthCheck(pParse, 23, pTab->zName,
                            j<0 ? "ROWID" : pTab->aCol[j].zCnName,
                            db->aDb[iDb].zDbSName);
      if( rc==1 ){
        goto update_cleanup;
      }else if( rc==2 ){
        aXRef[j] = -1;
      }
    }

  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  chngKey = chngRowid + chngPk;
# 158143 "c_tests/sqlite3.c"
  if( pTab->tabFlags & 0x00000060 ){
    int bProgress;
                                              ;
                                             ;
    do{
      bProgress = 0;
      for(i=0; i<pTab->nCol; i++){
        if( aXRef[i]>=0 ) continue;
        if( (pTab->aCol[i].colFlags & 0x0060)==0 ) continue;
        if( sqlite3ExprReferencesUpdatedColumn(
                sqlite3ColumnExpr(pTab, &pTab->aCol[i]),
                 aXRef, chngRowid)
        ){
          aXRef[i] = 99999;
          bProgress = 1;
        }
      }
    }while( bProgress );
  }







  pTabList->a[0].colUsed = ((pTab)->eTabType==1) ? ((Bitmask)-1) : 0;

  hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngKey);





  if( onError==5 ) bReplace = 1;
  for(nAllIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nAllIdx++){
    int reg;
    if( chngKey || hasFK>1 || pIdx==pPk
     || indexWhereClauseMightChange(pIdx,aXRef,chngRowid)
    ){
      reg = ++pParse->nMem;
      pParse->nMem += pIdx->nColumn;
    }else{
      reg = 0;
      for(i=0; i<pIdx->nKeyCol; i++){
        if( indexColumnIsBeingUpdated(pIdx, i, aXRef, chngRowid) ){
          reg = ++pParse->nMem;
          pParse->nMem += pIdx->nColumn;
          if( onError==11 && pIdx->onError==5 ){
            bReplace = 1;
          }
          break;
        }
      }
    }
    if( reg==0 ) aToOpen[nAllIdx+1] = 0;
    aRegIdx[nAllIdx] = reg;
  }
  aRegIdx[nAllIdx] = ++pParse->nMem;
  if( bReplace ){


    memset(aToOpen, 1, nIdx+1);
  }

  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
  sqlite3BeginWriteOperation(pParse, pTrigger || hasFK, iDb);


  if( !((pTab)->eTabType==1) ){





    ((void) (0));
    regRowSet = aRegIdx[nAllIdx];
    regOldRowid = regNewRowid = ++pParse->nMem;
    if( chngPk || pTrigger || hasFK ){
      regOld = pParse->nMem + 1;
      pParse->nMem += pTab->nCol;
    }
    if( chngKey || pTrigger || hasFK ){
      regNewRowid = ++pParse->nMem;
    }
    regNew = pParse->nMem + 1;
    pParse->nMem += pTab->nCol;
  }


  if( isView ){
    sqlite3AuthContextPush(pParse, &sContext, pTab->zName);
  }





  if( nChangeFrom==0 && isView ){
    sqlite3MaterializeView(pParse, pTab,
        pWhere, pOrderBy, pLimit, iDataCur
    );
    pOrderBy = 0;
    pLimit = 0;
  }





  if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pWhere) ){
    goto update_cleanup;
  }



  if( ((pTab)->eTabType==1) ){
    updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef,
                       pWhere, onError);
    goto update_cleanup;
  }



  labelContinue = labelBreak = sqlite3VdbeMakeLabel(pParse);



  if( (db->flags&((u64)(0x00001)<<32))!=0
   && !pParse->pTriggerTab
   && !pParse->nested
   && !pParse->bReturning
   && pUpsert==0
  ){
    regRowCount = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 72, 0, regRowCount);
  }

  if( nChangeFrom==0 && (((pTab)->tabFlags & 0x00000080)==0) ){
    sqlite3VdbeAddOp3(v, 76, 0, regRowSet, regOldRowid);
    iEph = pParse->nTab++;
    addrOpen = sqlite3VdbeAddOp3(v, 119, iEph, 0, regRowSet);
  }else{
    ((void) (0));
    nPk = pPk ? pPk->nKeyCol : 0;
    iPk = pParse->nMem+1;
    pParse->nMem += nPk;
    pParse->nMem += nChangeFrom;
    regKey = ++pParse->nMem;
    if( pUpsert==0 ){
      int nEphCol = nPk + nChangeFrom + (isView ? pTab->nCol : 0);
      iEph = pParse->nTab++;
      if( pPk ) sqlite3VdbeAddOp3(v, 76, 0, iPk, iPk+nPk-1);
      addrOpen = sqlite3VdbeAddOp2(v, 119, iEph, nEphCol);
      if( pPk ){
        KeyInfo *pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);
        if( pKeyInfo ){
          pKeyInfo->nAllField = nEphCol;
          sqlite3VdbeAppendP4(v, pKeyInfo, (-8));
        }
      }
      if( nChangeFrom ){
        updateFromSelect(
            pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit
        );

        if( isView ) iDataCur = iEph;

      }
    }
  }

  if( nChangeFrom ){
    sqlite3MultiWrite(pParse);
    eOnePass = 0;
    nKey = nPk;
    regKey = iPk;
  }else{
    if( pUpsert ){





      pWInfo = 0;
      eOnePass = 1;
      sqlite3ExprIfFalse(pParse, pWhere, labelBreak, 0x10);
      bFinishSeek = 0;
    }else{
# 158343 "c_tests/sqlite3.c"
      flags = 0x0004;
      if( !pParse->nested
       && !pTrigger
       && !hasFK
       && !chngKey
       && !bReplace
       && (pWhere==0 || !(((pWhere)->flags&(u32)(0x400000))!=0))
      ){
        flags |= 0x0008;
      }
      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere,0,0,0,flags,iIdxCur);
      if( pWInfo==0 ) goto update_cleanup;
# 158366 "c_tests/sqlite3.c"
      eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
      bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);
      if( eOnePass!=1 ){
        sqlite3MultiWrite(pParse);
        if( eOnePass==2 ){
          int iCur = aiCurOnePass[1];
          if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){
            eOnePass = 0;
          }
          ((void) (0));
        }
      }
    }

    if( (((pTab)->tabFlags & 0x00000080)==0) ){



      sqlite3VdbeAddOp2(v, 136, iDataCur, regOldRowid);
      if( eOnePass==0 ){
        aRegIdx[nAllIdx] = ++pParse->nMem;
        sqlite3VdbeAddOp3(v, 129, iEph, regRowSet, regOldRowid);
      }else{
        if( (addrOpen) ) sqlite3VdbeChangeToNoop(v, addrOpen);
      }
    }else{





      for(i=0; i<nPk; i++){
        ((void) (0));
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,
                                        pPk->aiColumn[i], iPk+i);
      }
      if( eOnePass ){
        if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);
        nKey = nPk;
        regKey = iPk;
      }else{
        sqlite3VdbeAddOp4(v, 98, iPk, nPk, regKey,
                          sqlite3IndexAffinityStr(db, pPk), nPk);
        sqlite3VdbeAddOp4Int(v, 139, iEph, regKey, iPk, nPk);
      }
    }
  }

  if( pUpsert==0 ){
    if( nChangeFrom==0 && eOnePass!=2 ){
      sqlite3WhereEnd(pWInfo);
    }

    if( !isView ){
      int addrOnce = 0;
      int iNotUsed1 = 0;
      int iNotUsed2 = 0;


      if( eOnePass!=0 ){
        if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iBaseCur] = 0;
        if( aiCurOnePass[1]>=0 ) aToOpen[aiCurOnePass[1]-iBaseCur] = 0;
      }

      if( eOnePass==2 && (nIdx-(aiCurOnePass[1]>=0))>0 ){
        addrOnce = sqlite3VdbeAddOp0(v, 15); ;
      }
      sqlite3OpenTableAndIndices(pParse, pTab, 114, 0, iBaseCur,
                                 aToOpen, &iNotUsed1, &iNotUsed2);
      if( addrOnce ){
        sqlite3VdbeJumpHereOrPopInst(v, addrOnce);
      }
    }


    if( eOnePass!=0 ){
      if( aiCurOnePass[0]!=iDataCur
       && aiCurOnePass[1]!=iDataCur



      ){
        ((void) (0));
        sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelBreak, regKey,nKey);
                       ;
      }
      if( eOnePass!=1 ){
        labelContinue = sqlite3VdbeMakeLabel(pParse);
      }
      sqlite3VdbeAddOp2(v, 51, pPk ? regKey : regOldRowid, labelBreak);
                               ;
                               ;
    }else if( pPk || nChangeFrom ){
      labelContinue = sqlite3VdbeMakeLabel(pParse);
      sqlite3VdbeAddOp2(v, 36, iEph, labelBreak); ;
      addrTop = sqlite3VdbeCurrentAddr(v);
      if( nChangeFrom ){
        if( !isView ){
          if( pPk ){
            for(i=0; i<nPk; i++){
              sqlite3VdbeAddOp3(v, 95, iEph, i, iPk+i);
            }
            sqlite3VdbeAddOp4Int(
                v, 28, iDataCur, labelContinue, iPk, nPk
            ); ;
          }else{
            sqlite3VdbeAddOp2(v, 136, iEph, regOldRowid);
            sqlite3VdbeAddOp3(
                v, 31, iDataCur, labelContinue, regOldRowid
            ); ;
          }
        }
      }else{
        sqlite3VdbeAddOp2(v, 135, iEph, regKey);
        sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey,0);
                       ;
      }
    }else{
      sqlite3VdbeAddOp2(v, 36, iEph, labelBreak); ;
      labelContinue = sqlite3VdbeMakeLabel(pParse);
      addrTop = sqlite3VdbeAddOp2(v, 136, iEph, regOldRowid);
                     ;
      sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);
                     ;
    }
  }





  ((void) (0));
  if( chngRowid ){
    ((void) (0));
    if( nChangeFrom==0 ){
      sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);
    }else{
      sqlite3VdbeAddOp3(v, 95, iEph, iRowidExpr, regNewRowid);
    }
    sqlite3VdbeAddOp1(v, 13, regNewRowid); ;
  }



  if( chngPk || hasFK || pTrigger ){
    u32 oldmask = (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);
    oldmask |= sqlite3TriggerColmask(pParse,
        pTrigger, pChanges, 0, 1|2, pTab, onError
    );
    for(i=0; i<pTab->nCol; i++){
      u32 colFlags = pTab->aCol[i].colFlags;
      k = sqlite3TableColumnToStorage(pTab, i) + regOld;
      if( oldmask==0xffffffff
       || (i<32 && (oldmask & (((unsigned int)1)<<(i)))!=0)
       || (colFlags & 0x0001)!=0
      ){
                                                 ;
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);
      }else{
        sqlite3VdbeAddOp2(v, 76, 0, k);
      }
    }
    if( chngRowid==0 && pPk==0 ){



      sqlite3VdbeAddOp2(v, 81, regOldRowid, regNewRowid);
    }
  }
# 158549 "c_tests/sqlite3.c"
  newmask = sqlite3TriggerColmask(
      pParse, pTrigger, pChanges, 1, 1, pTab, onError
  );
  for(i=0, k=regNew; i<pTab->nCol; i++, k++){
    if( i==pTab->iPKey ){
      sqlite3VdbeAddOp2(v, 76, 0, k);
    }else if( (pTab->aCol[i].colFlags & 0x0060)!=0 ){
      if( pTab->aCol[i].colFlags & 0x0020 ) k--;
    }else{
      j = aXRef[i];
      if( j>=0 ){
        if( nChangeFrom ){
          int nOff = (isView ? pTab->nCol : nPk);
          ((void) (0));
          sqlite3VdbeAddOp3(v, 95, iEph, nOff+j, k);
        }else{
          sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);
        }
      }else if( 0==(tmask&1) || i>31 || (newmask & (((unsigned int)1)<<(i))) ){





                         ;
                         ;
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);
        bFinishSeek = 0;
      }else{
        sqlite3VdbeAddOp2(v, 76, 0, k);
      }
    }
  }

  if( pTab->tabFlags & 0x00000060 ){
                                              ;
                                             ;
    sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);
  }





  if( tmask&1 ){
    sqlite3TableAffinity(v, pTab, regNew);
    sqlite3CodeRowTrigger(pParse, pTrigger, 130, pChanges,
        1, pTab, regOldRowid, onError, labelContinue);

    if( !isView ){






      if( pPk ){
        sqlite3VdbeAddOp4Int(v, 28,iDataCur,labelContinue,regKey,nKey);
                       ;
      }else{
        sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue,regOldRowid);
                       ;
      }
# 158622 "c_tests/sqlite3.c"
      for(i=0, k=regNew; i<pTab->nCol; i++, k++){
        if( pTab->aCol[i].colFlags & 0x0060 ){
          if( pTab->aCol[i].colFlags & 0x0020 ) k--;
        }else if( aXRef[i]<0 && i!=pTab->iPKey ){
          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);
        }
      }

      if( pTab->tabFlags & 0x00000060 ){
                                                  ;
                                                 ;
        sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);
      }

    }
  }

  if( !isView ){

    ((void) (0));
    sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,
        regNewRowid, regOldRowid, chngKey, onError, labelContinue, &bReplace,
        aXRef, 0);




    if( bReplace || chngKey ){
      if( pPk ){
        sqlite3VdbeAddOp4Int(v, 28,iDataCur,labelContinue,regKey,nKey);
      }else{
        sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue,regOldRowid);
      }
                     ;
    }


    if( hasFK ){
      sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngKey);
    }


    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);






    if( bFinishSeek ){
      sqlite3VdbeAddOp1(v, 144, iDataCur);
    }
# 158684 "c_tests/sqlite3.c"
    ((void) (0));
# 158698 "c_tests/sqlite3.c"
    if( hasFK>1 || chngKey ){
      sqlite3VdbeAddOp2(v, 131, iDataCur, 0);
    }


    if( hasFK ){
      sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngKey);
    }


    sqlite3CompleteInsertion(
        pParse, pTab, iDataCur, iIdxCur, regNewRowid, aRegIdx,
        0x04 | (eOnePass==2 ? 0x02 : 0),
        0, 0
    );




    if( hasFK ){
      sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, chngKey);
    }
  }



  if( regRowCount ){
    sqlite3VdbeAddOp2(v, 87, regRowCount, 1);
  }

  if( pTrigger ){
    sqlite3CodeRowTrigger(pParse, pTrigger, 130, pChanges,
        2, pTab, regOldRowid, onError, labelContinue);
  }




  if( eOnePass==1 ){

  }else if( eOnePass==2 ){
    sqlite3VdbeResolveLabel(v, labelContinue);
    sqlite3WhereEnd(pWInfo);
  }else{
    sqlite3VdbeResolveLabel(v, labelContinue);
    sqlite3VdbeAddOp2(v, 40, iEph, addrTop); ;
  }
  sqlite3VdbeResolveLabel(v, labelBreak);





  if( pParse->nested==0 && pParse->pTriggerTab==0 && pUpsert==0 ){
    sqlite3AutoincrementEnd(pParse);
  }





  if( regRowCount ){
    sqlite3CodeChangeCount(v, regRowCount, "rows updated");
  }

update_cleanup:
  sqlite3AuthContextPop(&sContext);
  sqlite3DbFree(db, aXRef);
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprListDelete(db, pChanges);
  sqlite3ExprDelete(db, pWhere);




  return;
}
# 158807 "c_tests/sqlite3.c"
static void updateVirtualTable(
  Parse *pParse,
  SrcList *pSrc,
  Table *pTab,
  ExprList *pChanges,
  Expr *pRowid,
  int *aXRef,
  Expr *pWhere,
  int onError
){
  Vdbe *v = pParse->pVdbe;
  int ephemTab;
  int i;
  sqlite3 *db = pParse->db;
  const char *pVTab = (const char*)sqlite3GetVTable(db, pTab);
  WhereInfo *pWInfo = 0;
  int nArg = 2 + pTab->nCol;
  int regArg;
  int regRec;
  int regRowid;
  int iCsr = pSrc->a[0].iCursor;
  int aDummy[2];
  int eOnePass;
  int addr;




  ((void) (0));
  ephemTab = pParse->nTab++;
  addr= sqlite3VdbeAddOp2(v, 119, ephemTab, nArg);
  regArg = pParse->nMem + 1;
  pParse->nMem += nArg;
  if( pSrc->nSrc>1 ){
    Index *pPk = 0;
    Expr *pRow;
    ExprList *pList;
    if( (((pTab)->tabFlags & 0x00000080)==0) ){
      if( pRowid ){
        pRow = sqlite3ExprDup(db, pRowid, 0);
      }else{
        pRow = sqlite3PExpr(pParse, 76, 0, 0);
      }
    }else{
      i16 iPk;
      pPk = sqlite3PrimaryKeyIndex(pTab);
      ((void) (0));
      ((void) (0));
      iPk = pPk->aiColumn[0];
      if( aXRef[iPk]>=0 ){
        pRow = sqlite3ExprDup(db, pChanges->a[aXRef[iPk]].pExpr, 0);
      }else{
        pRow = exprRowColumn(pParse, iPk);
      }
    }
    pList = sqlite3ExprListAppend(pParse, 0, pRow);

    for(i=0; i<pTab->nCol; i++){
      if( aXRef[i]>=0 ){
        pList = sqlite3ExprListAppend(pParse, pList,
          sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0)
        );
      }else{
        Expr *pRowExpr = exprRowColumn(pParse, i);
        if( pRowExpr ) pRowExpr->op2 = 0x01;
        pList = sqlite3ExprListAppend(pParse, pList, pRowExpr);
      }
    }

    updateFromSelect(pParse, ephemTab, pPk, pList, pSrc, pWhere, 0, 0);
    sqlite3ExprListDelete(db, pList);
    eOnePass = 0;
  }else{
    regRec = ++pParse->nMem;
    regRowid = ++pParse->nMem;


    pWInfo = sqlite3WhereBegin(
        pParse, pSrc, pWhere, 0, 0, 0, 0x0004, 0
    );
    if( pWInfo==0 ) return;


    for(i=0; i<pTab->nCol; i++){
      ((void) (0));
      if( aXRef[i]>=0 ){
        sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);
      }else{
        sqlite3VdbeAddOp3(v, 177, iCsr, i, regArg+2+i);
        sqlite3VdbeChangeP5(v, 0x01);
      }
    }
    if( (((pTab)->tabFlags & 0x00000080)==0) ){
      sqlite3VdbeAddOp2(v, 136, iCsr, regArg);
      if( pRowid ){
        sqlite3ExprCode(pParse, pRowid, regArg+1);
      }else{
        sqlite3VdbeAddOp2(v, 136, iCsr, regArg+1);
      }
    }else{
      Index *pPk;
      i16 iPk;
      pPk = sqlite3PrimaryKeyIndex(pTab);
      ((void) (0));
      ((void) (0));
      iPk = pPk->aiColumn[0];
      sqlite3VdbeAddOp3(v, 177, iCsr, iPk, regArg);
      sqlite3VdbeAddOp2(v, 82, regArg+2+iPk, regArg+1);
    }

    eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);


    ((void) (0));

    if( eOnePass ){


      sqlite3VdbeChangeToNoop(v, addr);
      sqlite3VdbeAddOp1(v, 123, iCsr);
    }else{


      sqlite3MultiWrite(pParse);
      sqlite3VdbeAddOp3(v, 98, regArg, nArg, regRec);





      sqlite3VdbeAddOp2(v, 128, ephemTab, regRowid);
      sqlite3VdbeAddOp3(v, 129, ephemTab, regRec, regRowid);
    }
  }


  if( eOnePass==0 ){

    if( pSrc->nSrc==1 ){
      sqlite3WhereEnd(pWInfo);
    }


    addr = sqlite3VdbeAddOp1(v, 36, ephemTab); ;



    for(i=0; i<nArg; i++){
      sqlite3VdbeAddOp3(v, 95, ephemTab, i, regArg+i);
    }
  }
  sqlite3VtabMakeWritable(pParse, pTab);
  sqlite3VdbeAddOp4(v, 7, 0, nArg, regArg, pVTab, (-11));
  sqlite3VdbeChangeP5(v, onError==11 ? 2 : onError);
  sqlite3MayAbort(pParse);



  if( eOnePass==0 ){
    sqlite3VdbeAddOp2(v, 40, ephemTab, addr+1); ;
    sqlite3VdbeJumpHere(v, addr);
    sqlite3VdbeAddOp2(v, 123, ephemTab, 0);
  }else{
    sqlite3WhereEnd(pWInfo);
  }
}
# 158997 "c_tests/sqlite3.c"
static void __attribute__((noinline)) upsertDelete(sqlite3 *db, Upsert *p){
  do{
    Upsert *pNext = p->pNextUpsert;
    sqlite3ExprListDelete(db, p->pUpsertTarget);
    sqlite3ExprDelete(db, p->pUpsertTargetWhere);
    sqlite3ExprListDelete(db, p->pUpsertSet);
    sqlite3ExprDelete(db, p->pUpsertWhere);
    sqlite3DbFree(db, p->pToFree);
    sqlite3DbFree(db, p);
    p = pNext;
  }while( p );
}
static void sqlite3UpsertDelete(sqlite3 *db, Upsert *p){
  if( p ) upsertDelete(db, p);
}





static Upsert *sqlite3UpsertDup(sqlite3 *db, Upsert *p){
  if( p==0 ) return 0;
  return sqlite3UpsertNew(db,
           sqlite3ExprListDup(db, p->pUpsertTarget, 0),
           sqlite3ExprDup(db, p->pUpsertTargetWhere, 0),
           sqlite3ExprListDup(db, p->pUpsertSet, 0),
           sqlite3ExprDup(db, p->pUpsertWhere, 0),
           sqlite3UpsertDup(db, p->pNextUpsert)
         );
}




static Upsert *sqlite3UpsertNew(
  sqlite3 *db,
  ExprList *pTarget,
  Expr *pTargetWhere,
  ExprList *pSet,
  Expr *pWhere,
  Upsert *pNext
){
  Upsert *pNew;
  pNew = sqlite3DbMallocZero(db, sizeof(Upsert));
  if( pNew==0 ){
    sqlite3ExprListDelete(db, pTarget);
    sqlite3ExprDelete(db, pTargetWhere);
    sqlite3ExprListDelete(db, pSet);
    sqlite3ExprDelete(db, pWhere);
    sqlite3UpsertDelete(db, pNext);
    return 0;
  }else{
    pNew->pUpsertTarget = pTarget;
    pNew->pUpsertTargetWhere = pTargetWhere;
    pNew->pUpsertSet = pSet;
    pNew->pUpsertWhere = pWhere;
    pNew->isDoUpdate = pSet!=0;
    pNew->pNextUpsert = pNext;
  }
  return pNew;
}
# 159066 "c_tests/sqlite3.c"
static int sqlite3UpsertAnalyzeTarget(
  Parse *pParse,
  SrcList *pTabList,
  Upsert *pUpsert,
  Upsert *pAll
){
  Table *pTab;
  int rc;
  int iCursor;
  Index *pIdx;
  ExprList *pTarget;
  Expr *pTerm;
  NameContext sNC;
  Expr sCol[2];
  int nClause = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  for(; pUpsert && pUpsert->pUpsertTarget;
        pUpsert=pUpsert->pNextUpsert, nClause++){
    rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);
    if( rc ) return rc;
    rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);
    if( rc ) return rc;


    pTab = pTabList->a[0].pSTab;
    pTarget = pUpsert->pUpsertTarget;
    iCursor = pTabList->a[0].iCursor;
    if( (((pTab)->tabFlags & 0x00000080)==0)
     && pTarget->nExpr==1
     && (pTerm = pTarget->a[0].pExpr)->op==168
     && pTerm->iColumn==(-1)
    ){

      ((void) (0));
      continue;
    }







    memset(sCol, 0, sizeof(sCol));
    sCol[0].op = 114;
    sCol[0].pLeft = &sCol[1];
    sCol[1].op = 168;
    sCol[1].iTable = pTabList->a[0].iCursor;


    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      int ii, jj, nn;
      if( !((pIdx)->onError!=0) ) continue;
      if( pTarget->nExpr!=pIdx->nKeyCol ) continue;
      if( pIdx->pPartIdxWhere ){
        if( pUpsert->pUpsertTargetWhere==0 ) continue;
        if( sqlite3ExprCompare(pParse, pUpsert->pUpsertTargetWhere,
                               pIdx->pPartIdxWhere, iCursor)!=0 ){
          continue;
        }
      }
      nn = pIdx->nKeyCol;
      for(ii=0; ii<nn; ii++){
        Expr *pExpr;
        sCol[0].u.zToken = (char*)pIdx->azColl[ii];
        if( pIdx->aiColumn[ii]==(-2) ){
          ((void) (0));
          ((void) (0));
          ((void) (0));
          pExpr = pIdx->aColExpr->a[ii].pExpr;
          if( pExpr->op!=114 ){
            sCol[0].pLeft = pExpr;
            pExpr = &sCol[0];
          }
        }else{
          sCol[0].pLeft = &sCol[1];
          sCol[1].iColumn = pIdx->aiColumn[ii];
          pExpr = &sCol[0];
        }
        for(jj=0; jj<nn; jj++){
          if( sqlite3ExprCompare(0,pTarget->a[jj].pExpr,pExpr,iCursor)<2 ){
            break;
          }
        }
        if( jj>=nn ){

          break;
        }
      }
      if( ii<nn ){


        continue;
      }
      pUpsert->pUpsertIdx = pIdx;
      if( sqlite3UpsertOfIndex(pAll,pIdx)!=pUpsert ){





        pUpsert->isDup = 1;
      }
      break;
    }
    if( pUpsert->pUpsertIdx==0 ){
      char zWhich[16];
      if( nClause==0 && pUpsert->pNextUpsert==0 ){
        zWhich[0] = 0;
      }else{
        sqlite3_snprintf(sizeof(zWhich),zWhich,"%r ", nClause+1);
      }
      sqlite3ErrorMsg(pParse, "%sON CONFLICT clause does not match any "
                              "PRIMARY KEY or UNIQUE constraint", zWhich);
      return 1;
    }
  }
  return 0;
}






static int sqlite3UpsertNextIsIPK(Upsert *pUpsert){
  Upsert *pNext;
  if( (pUpsert==0) ) return 0;
  pNext = pUpsert->pNextUpsert;
  while( 1 ){
    if( pNext==0 ) return 1;
    if( pNext->pUpsertTarget==0 ) return 1;
    if( pNext->pUpsertIdx==0 ) return 1;
    if( !pNext->isDup ) return 0;
    pNext = pNext->pNextUpsert;
  }
  return 0;
}







static Upsert *sqlite3UpsertOfIndex(Upsert *pUpsert, Index *pIdx){
  while(
      pUpsert
   && pUpsert->pUpsertTarget!=0
   && pUpsert->pUpsertIdx!=pIdx
  ){
     pUpsert = pUpsert->pNextUpsert;
  }
  return pUpsert;
}
# 159243 "c_tests/sqlite3.c"
static void sqlite3UpsertDoUpdate(
  Parse *pParse,
  Upsert *pUpsert,
  Table *pTab,
  Index *pIdx,
  int iCur
){
  Vdbe *v = pParse->pVdbe;
  sqlite3 *db = pParse->db;
  SrcList *pSrc;
  int iDataCur;
  int i;
  Upsert *pTop = pUpsert;

  ((void) (0));
  ((void) (0));
  iDataCur = pUpsert->iDataCur;
  pUpsert = sqlite3UpsertOfIndex(pTop, pIdx);
                                                   ;
  if( pIdx && iCur!=iDataCur ){
    if( (((pTab)->tabFlags & 0x00000080)==0) ){
      int regRowid = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp2(v, 143, iCur, regRowid);
      sqlite3VdbeAddOp3(v, 30, iDataCur, 0, regRowid);
                     ;
      sqlite3ReleaseTempReg(pParse, regRowid);
    }else{
      Index *pPk = sqlite3PrimaryKeyIndex(pTab);
      int nPk = pPk->nKeyCol;
      int iPk = pParse->nMem+1;
      pParse->nMem += nPk;
      for(i=0; i<nPk; i++){
        int k;
        ((void) (0));
        k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);
        sqlite3VdbeAddOp3(v, 95, iCur, k, iPk+i);

                                                          ;
      }
                                             ;
      i = sqlite3VdbeAddOp4Int(v, 29, iDataCur, 0, iPk, nPk);
                     ;
      sqlite3VdbeAddOp4(v, 71, 11, 2, 0,
            "corrupt database", (-1));
      sqlite3MayAbort(pParse);
      sqlite3VdbeJumpHere(v, i);
    }
  }


  pSrc = sqlite3SrcListDup(db, pTop->pUpsertSrc, 0);

  for(i=0; i<pTab->nCol; i++){
    if( pTab->aCol[i].affinity==0x45 ){
      sqlite3VdbeAddOp1(v, 88, pTop->regData+i);
    }
  }
  sqlite3Update(pParse, pSrc, sqlite3ExprListDup(db,pUpsert->pUpsertSet,0),
      sqlite3ExprDup(db,pUpsert->pUpsertWhere,0), 2, 0, 0, pUpsert);
                                                 ;
}
# 159340 "c_tests/sqlite3.c"
static int execSql(sqlite3 *db, char **pzErrMsg, const char *zSql){
  sqlite3_stmt *pStmt;
  int rc;


  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
  if( rc!=0 ) return rc;
  while( 100==(rc = sqlite3_step(pStmt)) ){
    const char *zSubSql = (const char*)sqlite3_column_text(pStmt,0);
    ((void) (0));





    if( zSubSql
     && (strncmp(zSubSql,"CRE",3)==0 || strncmp(zSubSql,"INS",3)==0)
    ){
      rc = execSql(db, pzErrMsg, zSubSql);
      if( rc!=0 ) break;
    }
  }
  ((void) (0));
  if( rc==101 ) rc = 0;
  if( rc ){
    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
  }
  (void)sqlite3_finalize(pStmt);
  return rc;
}
static int execSqlF(sqlite3 *db, char **pzErrMsg, const char *zSql, ...){
  char *z;
  va_list ap;
  int rc;
  __builtin_va_start(ap, zSql);
  z = sqlite3VMPrintf(db, zSql, ap);
  __builtin_va_end(ap);
  if( z==0 ) return 7;
  rc = execSql(db, pzErrMsg, z);
  sqlite3DbFree(db, z);
  return rc;
}
# 159413 "c_tests/sqlite3.c"
static void sqlite3Vacuum(Parse *pParse, Token *pNm, Expr *pInto){
  Vdbe *v = sqlite3GetVdbe(pParse);
  int iDb = 0;
  if( v==0 ) goto build_vacuum_end;
  if( pParse->nErr ) goto build_vacuum_end;
  if( pNm ){



    iDb = sqlite3TwoPartName(pParse, pNm, pNm, &pNm);
    if( iDb<0 ) goto build_vacuum_end;
# 159433 "c_tests/sqlite3.c"
  }
  if( iDb!=1 ){
    int iIntoReg = 0;
    if( pInto && sqlite3ResolveSelfReference(pParse,0,0,pInto,0)==0 ){
      iIntoReg = ++pParse->nMem;
      sqlite3ExprCode(pParse, pInto, iIntoReg);
    }
    sqlite3VdbeAddOp2(v, 5, iDb, iIntoReg);
    sqlite3VdbeUsesBtree(v, iDb);
  }
build_vacuum_end:
  sqlite3ExprDelete(pParse->db, pInto);
  return;
}




static __attribute__((noinline)) int sqlite3RunVacuum(
  char **pzErrMsg,
  sqlite3 *db,
  int iDb,
  sqlite3_value *pOut
){
  int rc = 0;
  Btree *pMain;
  Btree *pTemp;
  u32 saved_mDbFlags;
  u64 saved_flags;
  i64 saved_nChange;
  i64 saved_nTotalChange;
  u32 saved_openFlags;
  u8 saved_mTrace;
  Db *pDb = 0;
  int isMemDb;
  int nRes;
  int nDb;
  const char *zDbMain;
  const char *zOut;
  u32 pgflags = 0x01;
  u64 iRandom;
  char zDbVacuum[42];


  if( !db->autoCommit ){
    sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction");
    return 1;
  }
  if( db->nVdbeActive>1 ){
    sqlite3SetString(pzErrMsg, db,"cannot VACUUM - SQL statements in progress");
    return 1;
  }
  saved_openFlags = db->openFlags;
  if( pOut ){
    if( sqlite3_value_type(pOut)!=3 ){
      sqlite3SetString(pzErrMsg, db, "non-text filename");
      return 1;
    }
    zOut = (const char*)sqlite3_value_text(pOut);
    db->openFlags &= ~0x00000001;
    db->openFlags |= 0x00000004|0x00000002;
  }else{
    zOut = "";
  }




  saved_flags = db->flags;
  saved_mDbFlags = db->mDbFlags;
  saved_nChange = db->nChange;
  saved_nTotalChange = db->nTotalChange;
  saved_mTrace = db->mTrace;
  db->flags |= 0x00000001 | 0x00000200 | ((u64)(0x00040)<<32)
               | ((u64)(0x00010)<<32) | ((u64)(0x00020)<<32);
  db->mDbFlags |= 0x0002 | 0x0004;
  db->flags &= ~(u64)(0x00004000 | 0x00001000
                   | 0x10000000 | ((u64)(0x00001)<<32));
  db->mTrace = 0;

  zDbMain = db->aDb[iDb].zDbSName;
  pMain = db->aDb[iDb].pBt;
  isMemDb = sqlite3PagerIsMemdb(sqlite3BtreePager(pMain));
# 159531 "c_tests/sqlite3.c"
  sqlite3_randomness(sizeof(iRandom),&iRandom);
  sqlite3_snprintf(sizeof(zDbVacuum), zDbVacuum, "vacuum_%016llx", iRandom);
  nDb = db->nDb;
  rc = execSqlF(db, pzErrMsg, "ATTACH %Q AS %s", zOut, zDbVacuum);
  db->openFlags = saved_openFlags;
  if( rc!=0 ) goto end_of_vacuum;
  ((void) (0));
  pDb = &db->aDb[nDb];
  ((void) (0));
  pTemp = pDb->pBt;
  if( pOut ){
    sqlite3_file *id = sqlite3PagerFile(sqlite3BtreePager(pTemp));
    i64 sz = 0;
    if( id->pMethods!=0 && (sqlite3OsFileSize(id, &sz)!=0 || sz>0) ){
      rc = 1;
      sqlite3SetString(pzErrMsg, db, "output file already exists");
      goto end_of_vacuum;
    }
    db->mDbFlags |= 0x0008;




    pgflags = db->aDb[iDb].safety_level | (db->flags & 0x38);
  }
  nRes = sqlite3BtreeGetRequestedReserve(pMain);

  sqlite3BtreeSetCacheSize(pTemp, db->aDb[iDb].pSchema->cache_size);
  sqlite3BtreeSetSpillSize(pTemp, sqlite3BtreeSetSpillSize(pMain,0));
  sqlite3BtreeSetPagerFlags(pTemp, pgflags|0x20);





  rc = execSql(db, pzErrMsg, "BEGIN");
  if( rc!=0 ) goto end_of_vacuum;
  rc = sqlite3BtreeBeginTrans(pMain, pOut==0 ? 2 : 0, 0);
  if( rc!=0 ) goto end_of_vacuum;


  if( sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain))
                                               ==5
   && pOut==0
  ){
    db->nextPagesize = 0;
  }

  if( sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0)
   || (!isMemDb && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0))
   || (db->mallocFailed)
  ){
    rc = 7;
    goto end_of_vacuum;
  }


  sqlite3BtreeSetAutoVacuum(pTemp, db->nextAutovac>=0 ? db->nextAutovac :
                                           sqlite3BtreeGetAutoVacuum(pMain));





  db->init.iDb = nDb;
  rc = execSqlF(db, pzErrMsg,
      "SELECT sql FROM \"%w\".sqlite_schema"
      " WHERE type='table'AND name<>'sqlite_sequence'"
      " AND coalesce(rootpage,1)>0",
      zDbMain
  );
  if( rc!=0 ) goto end_of_vacuum;
  rc = execSqlF(db, pzErrMsg,
      "SELECT sql FROM \"%w\".sqlite_schema"
      " WHERE type='index'",
      zDbMain
  );
  if( rc!=0 ) goto end_of_vacuum;
  db->init.iDb = 0;





  rc = execSqlF(db, pzErrMsg,
      "SELECT'INSERT INTO %s.'||quote(name)"
      "||' SELECT*FROM\"%w\".'||quote(name)"
      "FROM %s.sqlite_schema "
      "WHERE type='table'AND coalesce(rootpage,1)>0",
      zDbVacuum, zDbMain, zDbVacuum
  );
  ((void) (0));
  db->mDbFlags &= ~0x0004;
  if( rc!=0 ) goto end_of_vacuum;






  rc = execSqlF(db, pzErrMsg,
      "INSERT INTO %s.sqlite_schema"
      " SELECT*FROM \"%w\".sqlite_schema"
      " WHERE type IN('view','trigger')"
      " OR(type='table'AND rootpage=0)",
      zDbVacuum, zDbMain
  );
  if( rc ) goto end_of_vacuum;







  {
    u32 meta;
    int i;







    static const unsigned char aCopy[] = {
       1, 1,
       3, 0,
       5, 0,
       6, 0,
       8, 0,
    };

    ((void) (0));
    ((void) (0));


    for(i=0; i<((int)(sizeof(aCopy)/sizeof(aCopy[0]))); i+=2){


      sqlite3BtreeGetMeta(pMain, aCopy[i], &meta);
      rc = sqlite3BtreeUpdateMeta(pTemp, aCopy[i], meta+aCopy[i+1]);
      if( (rc!=0) ) goto end_of_vacuum;
    }

    if( pOut==0 ){
      rc = sqlite3BtreeCopyFile(pMain, pTemp);
    }
    if( rc!=0 ) goto end_of_vacuum;
    rc = sqlite3BtreeCommit(pTemp);
    if( rc!=0 ) goto end_of_vacuum;

    if( pOut==0 ){
      sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));
    }

  }

  ((void) (0));
  if( pOut==0 ){
    nRes = sqlite3BtreeGetRequestedReserve(pTemp);
    rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes,1);
  }

end_of_vacuum:

  db->init.iDb = 0;
  db->mDbFlags = saved_mDbFlags;
  db->flags = saved_flags;
  db->nChange = saved_nChange;
  db->nTotalChange = saved_nTotalChange;
  db->mTrace = saved_mTrace;
  sqlite3BtreeSetPageSize(pMain, -1, 0, 1);
# 159712 "c_tests/sqlite3.c"
  db->autoCommit = 1;

  if( pDb ){
    sqlite3BtreeClose(pDb->pBt);
    pDb->pBt = 0;
    pDb->pSchema = 0;
  }



  sqlite3ResetAllSchemasOfConnection(db);

  return rc;
}
# 159754 "c_tests/sqlite3.c"
struct VtabCtx {
  VTable *pVTable;
  Table *pTab;
  VtabCtx *pPrior;
  int bDeclared;
};
# 159769 "c_tests/sqlite3.c"
static Module *sqlite3VtabCreateModule(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *pModule,
  void *pAux,
  void (*xDestroy)(void *)
){
  Module *pMod;
  Module *pDel;
  char *zCopy;
  if( pModule==0 ){
    zCopy = (char*)zName;
    pMod = 0;
  }else{
    int nName = sqlite3Strlen30(zName);
    pMod = (Module *)sqlite3Malloc(sizeof(Module) + nName + 1);
    if( pMod==0 ){
      sqlite3OomFault(db);
      return 0;
    }
    zCopy = (char *)(&pMod[1]);
    memcpy(zCopy, zName, nName+1);
    pMod->zName = zCopy;
    pMod->pModule = pModule;
    pMod->pAux = pAux;
    pMod->xDestroy = xDestroy;
    pMod->pEpoTab = 0;
    pMod->nRefModule = 1;
  }
  pDel = (Module *)sqlite3HashInsert(&db->aModule,zCopy,(void*)pMod);
  if( pDel ){
    if( pDel==pMod ){
      sqlite3OomFault(db);
      sqlite3DbFree(db, pDel);
      pMod = 0;
    }else{
      sqlite3VtabEponymousTableClear(db, pDel);
      sqlite3VtabModuleUnref(db, pDel);
    }
  }
  return pMod;
}






static int createModule(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *pModule,
  void *pAux,
  void (*xDestroy)(void *)
){
  int rc = 0;

  sqlite3_mutex_enter(db->mutex);
  (void)sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy);
  rc = sqlite3ApiExit(db, rc);
  if( rc!=0 && xDestroy ) xDestroy(pAux);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}





           int sqlite3_create_module(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *pModule,
  void *pAux
){



  return createModule(db, zName, pModule, pAux, 0);
}




           int sqlite3_create_module_v2(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *pModule,
  void *pAux,
  void (*xDestroy)(void *)
){



  return createModule(db, zName, pModule, pAux, xDestroy);
}





           int sqlite3_drop_modules(sqlite3 *db, const char** azNames){
  HashElem *pThis, *pNext;



  for(pThis=((&db->aModule)->first); pThis; pThis=pNext){
    Module *pMod = (Module*)((pThis)->data);
    pNext = ((pThis)->next);
    if( azNames ){
      int ii;
      for(ii=0; azNames[ii]!=0 && strcmp(azNames[ii],pMod->zName)!=0; ii++){}
      if( azNames[ii]!=0 ) continue;
    }
    createModule(db, pMod->zName, 0, 0, 0);
  }
  return 0;
}





static void sqlite3VtabModuleUnref(sqlite3 *db, Module *pMod){
  ((void) (0));
  pMod->nRefModule--;
  if( pMod->nRefModule==0 ){
    if( pMod->xDestroy ){
      pMod->xDestroy(pMod->pAux);
    }
    ((void) (0));
    sqlite3DbFree(db, pMod);
  }
}
# 159912 "c_tests/sqlite3.c"
static void sqlite3VtabLock(VTable *pVTab){
  pVTab->nRef++;
}







static VTable *sqlite3GetVTable(sqlite3 *db, Table *pTab){
  VTable *pVtab;
  ((void) (0));
  for(pVtab=pTab->u.vtab.p; pVtab && pVtab->db!=db; pVtab=pVtab->pNext);
  return pVtab;
}





static void sqlite3VtabUnlock(VTable *pVTab){
  sqlite3 *db = pVTab->db;

  ((void) (0));
  ((void) (0));
  ((void) (0));


  pVTab->nRef--;
  if( pVTab->nRef==0 ){
    sqlite3_vtab *p = pVTab->pVtab;
    if( p ){
      p->pModule->xDisconnect(p);
    }
    sqlite3VtabModuleUnref(pVTab->db, pVTab->pMod);
    sqlite3DbFree(db, pVTab);
  }
}
# 159959 "c_tests/sqlite3.c"
static VTable *vtabDisconnectAll(sqlite3 *db, Table *p){
  VTable *pRet = 0;
  VTable *pVTable;

  ((void) (0));
  pVTable = p->u.vtab.p;
  p->u.vtab.p = 0;







  ((void) (0));

  while( pVTable ){
    sqlite3 *db2 = pVTable->db;
    VTable *pNext = pVTable->pNext;
    ((void) (0));
    if( db2==db ){
      pRet = pVTable;
      p->u.vtab.p = pRet;
      pRet->pNext = 0;
    }else{
      pVTable->pNext = db2->pDisconnect;
      db2->pDisconnect = pVTable;
    }
    pVTable = pNext;
  }

  ((void) (0));
  return pRet;
}
# 160002 "c_tests/sqlite3.c"
static void sqlite3VtabDisconnect(sqlite3 *db, Table *p){
  VTable **ppVTab;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  for(ppVTab=&p->u.vtab.p; *ppVTab; ppVTab=&(*ppVTab)->pNext){
    if( (*ppVTab)->db==db ){
      VTable *pVTab = *ppVTab;
      *ppVTab = pVTab->pNext;
      sqlite3VtabUnlock(pVTab);
      break;
    }
  }
}
# 160040 "c_tests/sqlite3.c"
static void sqlite3VtabUnlockList(sqlite3 *db){
  VTable *p = db->pDisconnect;

  ((void) (0));
  ((void) (0));

  if( p ){
    db->pDisconnect = 0;
    do {
      VTable *pNext = p->pNext;
      sqlite3VtabUnlock(p);
      p = pNext;
    }while( p );
  }
}
# 160070 "c_tests/sqlite3.c"
static void sqlite3VtabClear(sqlite3 *db, Table *p){
  ((void) (0));
  ((void) (0));
  if( db->pnBytesFreed==0 ) vtabDisconnectAll(0, p);
  if( p->u.vtab.azArg ){
    int i;
    for(i=0; i<p->u.vtab.nArg; i++){
      if( i!=1 ) sqlite3DbFree(db, p->u.vtab.azArg[i]);
    }
    sqlite3DbFree(db, p->u.vtab.azArg);
  }
}







static void addModuleArgument(Parse *pParse, Table *pTable, char *zArg){
  sqlite3_int64 nBytes;
  char **azModuleArg;
  sqlite3 *db = pParse->db;

  ((void) (0));
  nBytes = sizeof(char *)*(2+pTable->u.vtab.nArg);
  if( pTable->u.vtab.nArg+3>=db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many columns on %s", pTable->zName);
  }
  azModuleArg = sqlite3DbRealloc(db, pTable->u.vtab.azArg, nBytes);
  if( azModuleArg==0 ){
    sqlite3DbFree(db, zArg);
  }else{
    int i = pTable->u.vtab.nArg++;
    azModuleArg[i] = zArg;
    azModuleArg[i+1] = 0;
    pTable->u.vtab.azArg = azModuleArg;
  }
}






static void sqlite3VtabBeginParse(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  Token *pModuleName,
  int ifNotExists
){
  Table *pTable;
  sqlite3 *db;

  sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, ifNotExists);
  pTable = pParse->pNewTable;
  if( pTable==0 ) return;
  ((void) (0));
  pTable->eTabType = 1;

  db = pParse->db;

  ((void) (0));
  addModuleArgument(pParse, pTable, sqlite3NameFromToken(db, pModuleName));
  addModuleArgument(pParse, pTable, 0);
  addModuleArgument(pParse, pTable, sqlite3DbStrDup(db, pTable->zName));
  ((void) (0));


  pParse->sNameToken.n = (int)(
      &pModuleName->z[pModuleName->n] - pParse->sNameToken.z
  );







  if( pTable->u.vtab.azArg ){
    int iDb = sqlite3SchemaToIndex(db, pTable->pSchema);
    ((void) (0));
    sqlite3AuthCheck(pParse, 29, pTable->zName,
            pTable->u.vtab.azArg[0], pParse->db->aDb[iDb].zDbSName);
  }

}






static void addArgumentToVtab(Parse *pParse){
  if( pParse->sArg.z && pParse->pNewTable ){
    const char *z = (const char*)pParse->sArg.z;
    int n = pParse->sArg.n;
    sqlite3 *db = pParse->db;
    addModuleArgument(pParse, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));
  }
}





static void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){
  Table *pTab = pParse->pNewTable;
  sqlite3 *db = pParse->db;

  if( pTab==0 ) return;
  ((void) (0));
  addArgumentToVtab(pParse);
  pParse->sArg.z = 0;
  if( pTab->u.vtab.nArg<1 ) return;







  if( !db->init.busy ){
    char *zStmt;
    char *zWhere;
    int iDb;
    int iReg;
    Vdbe *v;

    sqlite3MayAbort(pParse);


    if( pEnd ){
      pParse->sNameToken.n = (int)(pEnd->z - pParse->sNameToken.z) + pEnd->n;
    }
    zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", &pParse->sNameToken);
# 160216 "c_tests/sqlite3.c"
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    ((void) (0));
    sqlite3NestedParse(pParse,
      "UPDATE %Q." "sqlite_master" " "
         "SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q "
       "WHERE rowid=#%d",
      db->aDb[iDb].zDbSName,
      pTab->zName,
      pTab->zName,
      zStmt,
      pParse->u1.cr.regRowid
    );
    v = sqlite3GetVdbe(pParse);
    sqlite3ChangeCookie(pParse, iDb);

    sqlite3VdbeAddOp0(v, 167);
    zWhere = sqlite3MPrintf(db, "name=%Q AND sql=%Q", pTab->zName, zStmt);
    sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere, 0);
    sqlite3DbFree(db, zStmt);

    iReg = ++pParse->nMem;
    sqlite3VdbeLoadString(v, iReg, pTab->zName);
    sqlite3VdbeAddOp2(v, 172, iDb, iReg);
  }else{


    Table *pOld;
    Schema *pSchema = pTab->pSchema;
    const char *zName = pTab->zName;
    ((void) (0));
    sqlite3MarkAllShadowTablesOf(db, pTab);
    pOld = sqlite3HashInsert(&pSchema->tblHash, zName, pTab);
    if( pOld ){
      sqlite3OomFault(db);
      ((void) (0));
      return;
    }
    pParse->pNewTable = 0;
  }
}





static void sqlite3VtabArgInit(Parse *pParse){
  addArgumentToVtab(pParse);
  pParse->sArg.z = 0;
  pParse->sArg.n = 0;
}





static void sqlite3VtabArgExtend(Parse *pParse, Token *p){
  Token *pArg = &pParse->sArg;
  if( pArg->z==0 ){
    pArg->z = p->z;
    pArg->n = p->n;
  }else{
    ((void) (0));
    pArg->n = (int)(&p->z[p->n] - pArg->z);
  }
}






static int vtabCallConstructor(
  sqlite3 *db,
  Table *pTab,
  Module *pMod,
  int (*xConstruct)(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**),
  char **pzErr
){
  VtabCtx sCtx;
  VTable *pVTable;
  int rc;
  const char *const*azArg;
  int nArg = pTab->u.vtab.nArg;
  char *zErr = 0;
  char *zModuleName;
  int iDb;
  VtabCtx *pCtx;

  ((void) (0));
  azArg = (const char *const*)pTab->u.vtab.azArg;


  for(pCtx=db->pVtabCtx; pCtx; pCtx=pCtx->pPrior){
    if( pCtx->pTab==pTab ){
      *pzErr = sqlite3MPrintf(db,
          "vtable constructor called recursively: %s", pTab->zName
      );
      return 6;
    }
  }

  zModuleName = sqlite3DbStrDup(db, pTab->zName);
  if( !zModuleName ){
    return 7;
  }

  pVTable = sqlite3MallocZero(sizeof(VTable));
  if( !pVTable ){
    sqlite3OomFault(db);
    sqlite3DbFree(db, zModuleName);
    return 7;
  }
  pVTable->db = db;
  pVTable->pMod = pMod;
  pVTable->eVtabRisk = 1;

  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  pTab->u.vtab.azArg[1] = db->aDb[iDb].zDbSName;


  ((void) (0));
  ((void) (0));
  sCtx.pTab = pTab;
  sCtx.pVTable = pVTable;
  sCtx.pPrior = db->pVtabCtx;
  sCtx.bDeclared = 0;
  db->pVtabCtx = &sCtx;
  pTab->nTabRef++;
  rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr);
  ((void) (0));
  ((void) (0));
  sqlite3DeleteTable(db, pTab);
  db->pVtabCtx = sCtx.pPrior;
  if( rc==7 ) sqlite3OomFault(db);
  ((void) (0));

  if( 0!=rc ){
    if( zErr==0 ){
      *pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName);
    }else {
      *pzErr = sqlite3MPrintf(db, "%s", zErr);
      sqlite3_free(zErr);
    }
    sqlite3DbFree(db, pVTable);
  }else if( (pVTable->pVtab) ){


    memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));
    pVTable->pVtab->pModule = pMod->pModule;
    pMod->nRefModule++;
    pVTable->nRef = 1;
    if( sCtx.bDeclared==0 ){
      const char *zFormat = "vtable constructor did not declare schema: %s";
      *pzErr = sqlite3MPrintf(db, zFormat, zModuleName);
      sqlite3VtabUnlock(pVTable);
      rc = 1;
    }else{
      int iCol;
      u16 oooHidden = 0;





      pVTable->pNext = pTab->u.vtab.p;
      pTab->u.vtab.p = pVTable;

      for(iCol=0; iCol<pTab->nCol; iCol++){
        char *zType = sqlite3ColumnType(&pTab->aCol[iCol], "");
        int nType;
        int i = 0;
        nType = sqlite3Strlen30(zType);
        for(i=0; i<nType; i++){
          if( 0==sqlite3_strnicmp("hidden", &zType[i], 6)
           && (i==0 || zType[i-1]==' ')
           && (zType[i+6]=='\0' || zType[i+6]==' ')
          ){
            break;
          }
        }
        if( i<nType ){
          int j;
          int nDel = 6 + (zType[i+6] ? 1 : 0);
          for(j=i; (j+nDel)<=nType; j++){
            zType[j] = zType[j+nDel];
          }
          if( zType[i]=='\0' && i>0 ){
            ((void) (0));
            zType[i-1] = '\0';
          }
          pTab->aCol[iCol].colFlags |= 0x0002;
          pTab->tabFlags |= 0x00000002;
          oooHidden = 0x00000400;
        }else{
          pTab->tabFlags |= oooHidden;
        }
      }
    }
  }

  sqlite3DbFree(db, zModuleName);
  return rc;
}
# 160427 "c_tests/sqlite3.c"
static int sqlite3VtabCallConnect(Parse *pParse, Table *pTab){
  sqlite3 *db = pParse->db;
  const char *zMod;
  Module *pMod;
  int rc;

  ((void) (0));
  ((void) (0));
  if( sqlite3GetVTable(db, pTab) ){
    return 0;
  }


  zMod = pTab->u.vtab.azArg[0];
  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);

  if( !pMod ){
    const char *zModule = pTab->u.vtab.azArg[0];
    sqlite3ErrorMsg(pParse, "no such module: %s", zModule);
    rc = 1;
  }else{
    char *zErr = 0;
    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, &zErr);
    if( rc!=0 ){
      sqlite3ErrorMsg(pParse, "%s", zErr);
      pParse->rc = rc;
    }
    sqlite3DbFree(db, zErr);
  }

  return rc;
}




static int growVTrans(sqlite3 *db){
  const int ARRAY_INCR = 5;


  if( (db->nVTrans%ARRAY_INCR)==0 ){
    VTable **aVTrans;
    sqlite3_int64 nBytes = sizeof(sqlite3_vtab*)*
                                 ((sqlite3_int64)db->nVTrans + ARRAY_INCR);
    aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);
    if( !aVTrans ){
      return 7;
    }
    memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);
    db->aVTrans = aVTrans;
  }

  return 0;
}





static void addToVTrans(sqlite3 *db, VTable *pVTab){

  db->aVTrans[db->nVTrans++] = pVTab;
  sqlite3VtabLock(pVTab);
}
# 160500 "c_tests/sqlite3.c"
static int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){
  int rc = 0;
  Table *pTab;
  Module *pMod;
  const char *zMod;

  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);
  ((void) (0));


  zMod = pTab->u.vtab.azArg[0];
  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);





  if( pMod==0 || pMod->pModule->xCreate==0 || pMod->pModule->xDestroy==0 ){
    *pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);
    rc = 1;
  }else{
    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr);
  }



  if( rc==0 && (sqlite3GetVTable(db, pTab)) ){
    rc = growVTrans(db);
    if( rc==0 ){
      addToVTrans(db, sqlite3GetVTable(db, pTab));
    }
  }

  return rc;
}






           int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){
  VtabCtx *pCtx;
  int rc = 0;
  Table *pTab;
  Parse sParse;
  int initBusy;
  int i;
  const unsigned char *z;
  static const u8 aKeyword[] = { 17, 16, 0 };
# 160561 "c_tests/sqlite3.c"
  z = (const unsigned char*)zCreateTable;
  for(i=0; aKeyword[i]; i++){
    int tokenType = 0;
    do{
      z += sqlite3GetToken(z, &tokenType);
    }while( tokenType==184 || tokenType==185 );
    if( tokenType!=aKeyword[i] ){
      sqlite3ErrorWithMsg(db, 1, "syntax error");
      return 1;
    }
  }

  sqlite3_mutex_enter(db->mutex);
  pCtx = db->pVtabCtx;
  if( !pCtx || pCtx->bDeclared ){
    sqlite3Error(db, sqlite3MisuseError(160576));
    sqlite3_mutex_leave(db->mutex);
    return sqlite3MisuseError(160578);
  }

  pTab = pCtx->pTab;
  ((void) (0));

  sqlite3ParseObjectInit(&sParse, db);
  sParse.eParseMode = 1;
  sParse.disableTriggers = 1;



  ((void) (0));
  initBusy = db->init.busy;
  db->init.busy = 0;
  sParse.nQueryLoop = 1;
  if( 0==sqlite3RunParser(&sParse, zCreateTable) ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    if( !pTab->aCol ){
      Table *pNew = sParse.pNewTable;
      Index *pIdx;
      pTab->aCol = pNew->aCol;
      ((void) (0));
      sqlite3ExprListDelete(db, pNew->u.tab.pDfltList);
      pTab->nNVCol = pTab->nCol = pNew->nCol;
      pTab->tabFlags |= pNew->tabFlags & (0x00000080|0x00000200);
      pNew->nCol = 0;
      pNew->aCol = 0;
      ((void) (0));
      ((void) (0));
      if( !(((pNew)->tabFlags & 0x00000080)==0)
       && pCtx->pVTable->pMod->pModule->xUpdate!=0
       && sqlite3PrimaryKeyIndex(pNew)->nKeyCol!=1
      ){


        rc = 1;
      }
      pIdx = pNew->pIndex;
      if( pIdx ){
        ((void) (0));
        pTab->pIndex = pIdx;
        pNew->pIndex = 0;
        pIdx->pTable = pTab;
      }
    }
    pCtx->bDeclared = 1;
  }else{
    sqlite3ErrorWithMsg(db, 1,
          (sParse.zErrMsg ? "%s" : 0), sParse.zErrMsg);
    sqlite3DbFree(db, sParse.zErrMsg);
    rc = 1;
  }
  sParse.eParseMode = 0;

  if( sParse.pVdbe ){
    sqlite3VdbeFinalize(sParse.pVdbe);
  }
  sqlite3DeleteTable(db, sParse.pNewTable);
  sqlite3ParseObjectReset(&sParse);
  db->init.busy = initBusy;

  ((void) (0));
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 160656 "c_tests/sqlite3.c"
static int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab){
  int rc = 0;
  Table *pTab;

  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);
  if( (pTab!=0)
   && (((pTab)->eTabType==1))
   && (pTab->u.vtab.p!=0)
  ){
    VTable *p;
    int (*xDestroy)(sqlite3_vtab *);
    for(p=pTab->u.vtab.p; p; p=p->pNext){
      ((void) (0));
      if( p->pVtab->nRef>0 ){
        return 6;
      }
    }
    p = vtabDisconnectAll(db, pTab);
    xDestroy = p->pMod->pModule->xDestroy;
    if( xDestroy==0 ) xDestroy = p->pMod->pModule->xDisconnect;
    ((void) (0));
    pTab->nTabRef++;
    rc = xDestroy(p->pVtab);

    if( rc==0 ){
      ((void) (0));
      p->pVtab = 0;
      pTab->u.vtab.p = 0;
      sqlite3VtabUnlock(p);
    }
    sqlite3DeleteTable(db, pTab);
  }

  return rc;
}
# 160700 "c_tests/sqlite3.c"
static void callFinaliser(sqlite3 *db, int offset){
  int i;
  if( db->aVTrans ){
    VTable **aVTrans = db->aVTrans;
    db->aVTrans = 0;
    for(i=0; i<db->nVTrans; i++){
      VTable *pVTab = aVTrans[i];
      sqlite3_vtab *p = pVTab->pVtab;
      if( p ){
        int (*x)(sqlite3_vtab *);
        x = *(int (**)(sqlite3_vtab *))((char *)p->pModule + offset);
        if( x ) x(p);
      }
      pVTab->iSavepoint = 0;
      sqlite3VtabUnlock(pVTab);
    }
    sqlite3DbFree(db, aVTrans);
    db->nVTrans = 0;
  }
}
# 160728 "c_tests/sqlite3.c"
static int sqlite3VtabSync(sqlite3 *db, Vdbe *p){
  int i;
  int rc = 0;
  VTable **aVTrans = db->aVTrans;

  db->aVTrans = 0;
  for(i=0; rc==0 && i<db->nVTrans; i++){
    int (*x)(sqlite3_vtab *);
    sqlite3_vtab *pVtab = aVTrans[i]->pVtab;
    if( pVtab && (x = pVtab->pModule->xSync)!=0 ){
      rc = x(pVtab);
      sqlite3VtabImportErrmsg(p, pVtab);
    }
  }
  db->aVTrans = aVTrans;
  return rc;
}





static int sqlite3VtabRollback(sqlite3 *db){
  callFinaliser(db, __builtin_offsetof(sqlite3_module, xRollback));
  return 0;
}





static int sqlite3VtabCommit(sqlite3 *db){
  callFinaliser(db, __builtin_offsetof(sqlite3_module, xCommit));
  return 0;
}
# 160772 "c_tests/sqlite3.c"
static int sqlite3VtabBegin(sqlite3 *db, VTable *pVTab){
  int rc = 0;
  const sqlite3_module *pModule;






  if( ((db)->nVTrans>0 && (db)->aVTrans==0) ){
    return 6;
  }
  if( !pVTab ){
    return 0;
  }
  pModule = pVTab->pVtab->pModule;

  if( pModule->xBegin ){
    int i;


    for(i=0; i<db->nVTrans; i++){
      if( db->aVTrans[i]==pVTab ){
        return 0;
      }
    }



    rc = growVTrans(db);
    if( rc==0 ){
      rc = pModule->xBegin(pVTab->pVtab);
      if( rc==0 ){
        int iSvpt = db->nStatement + db->nSavepoint;
        addToVTrans(db, pVTab);
        if( iSvpt && pModule->xSavepoint ){
          pVTab->iSavepoint = iSvpt;
          rc = pModule->xSavepoint(pVTab->pVtab, iSvpt-1);
        }
      }
    }
  }
  return rc;
}
# 160832 "c_tests/sqlite3.c"
static int sqlite3VtabSavepoint(sqlite3 *db, int op, int iSavepoint){
  int rc = 0;

  ((void) (0));
  ((void) (0));
  if( db->aVTrans ){
    int i;
    for(i=0; rc==0 && i<db->nVTrans; i++){
      VTable *pVTab = db->aVTrans[i];
      const sqlite3_module *pMod = pVTab->pMod->pModule;
      if( pVTab->pVtab && pMod->iVersion>=2 ){
        int (*xMethod)(sqlite3_vtab *, int);
        sqlite3VtabLock(pVTab);
        switch( op ){
          case 0:
            xMethod = pMod->xSavepoint;
            pVTab->iSavepoint = iSavepoint+1;
            break;
          case 2:
            xMethod = pMod->xRollbackTo;
            break;
          default:
            xMethod = pMod->xRelease;
            break;
        }
        if( xMethod && pVTab->iSavepoint>iSavepoint ){
          u64 savedFlags = (db->flags & 0x10000000);
          db->flags &= ~(u64)0x10000000;
          rc = xMethod(pVTab->pVtab, iSavepoint);
          db->flags |= savedFlags;
        }
        sqlite3VtabUnlock(pVTab);
      }
    }
  }
  return rc;
}
# 160883 "c_tests/sqlite3.c"
static FuncDef *sqlite3VtabOverloadFunction(
  sqlite3 *db,
  FuncDef *pDef,
  int nArg,
  Expr *pExpr
){
  Table *pTab;
  sqlite3_vtab *pVtab;
  sqlite3_module *pMod;
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**) = 0;
  void *pArg = 0;
  FuncDef *pNew;
  int rc = 0;


  if( (pExpr==0) ) return pDef;
  if( pExpr->op!=168 ) return pDef;
  ((void) (0));
  pTab = pExpr->y.pTab;
  if( (pTab==0) ) return pDef;
  if( !((pTab)->eTabType==1) ) return pDef;
  pVtab = sqlite3GetVTable(db, pTab)->pVtab;
  ((void) (0));
  ((void) (0));
  pMod = (sqlite3_module *)pVtab->pModule;
  if( pMod->xFindFunction==0 ) return pDef;
# 160926 "c_tests/sqlite3.c"
  rc = pMod->xFindFunction(pVtab, nArg, pDef->zName, &xSFunc, &pArg);
  if( rc==0 ){
    return pDef;
  }



  pNew = sqlite3DbMallocZero(db, sizeof(*pNew)
                             + sqlite3Strlen30(pDef->zName) + 1);
  if( pNew==0 ){
    return pDef;
  }
  *pNew = *pDef;
  pNew->zName = (const char*)&pNew[1];
  memcpy((char*)&pNew[1], pDef->zName, sqlite3Strlen30(pDef->zName)+1);
  pNew->xSFunc = xSFunc;
  pNew->pUserData = pArg;
  pNew->funcFlags |= 0x0010;
  return pNew;
}







static void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  int i, n;
  Table **apVtabLock;

  ((void) (0));
  for(i=0; i<pToplevel->nVtabLock; i++){
    if( pTab==pToplevel->apVtabLock[i] ) return;
  }
  n = (pToplevel->nVtabLock+1)*sizeof(pToplevel->apVtabLock[0]);
  apVtabLock = sqlite3Realloc(pToplevel->apVtabLock, n);
  if( apVtabLock ){
    pToplevel->apVtabLock = apVtabLock;
    pToplevel->apVtabLock[pToplevel->nVtabLock++] = pTab;
  }else{
    sqlite3OomFault(pToplevel->db);
  }
}
# 160987 "c_tests/sqlite3.c"
static int sqlite3VtabEponymousTableInit(Parse *pParse, Module *pMod){
  const sqlite3_module *pModule = pMod->pModule;
  Table *pTab;
  char *zErr = 0;
  int rc;
  sqlite3 *db = pParse->db;
  if( pMod->pEpoTab ) return 1;
  if( pModule->xCreate!=0 && pModule->xCreate!=pModule->xConnect ) return 0;
  pTab = sqlite3DbMallocZero(db, sizeof(Table));
  if( pTab==0 ) return 0;
  pTab->zName = sqlite3DbStrDup(db, pMod->zName);
  if( pTab->zName==0 ){
    sqlite3DbFree(db, pTab);
    return 0;
  }
  pMod->pEpoTab = pTab;
  pTab->nTabRef = 1;
  pTab->eTabType = 1;
  pTab->pSchema = db->aDb[0].pSchema;
  ((void) (0));
  pTab->iPKey = -1;
  pTab->tabFlags |= 0x00008000;
  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));
  addModuleArgument(pParse, pTab, 0);
  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));
  db->nSchemaLock++;
  rc = vtabCallConstructor(db, pTab, pMod, pModule->xConnect, &zErr);
  db->nSchemaLock--;
  if( rc ){
    sqlite3ErrorMsg(pParse, "%s", zErr);
    pParse->rc = rc;
    sqlite3DbFree(db, zErr);
    sqlite3VtabEponymousTableClear(db, pMod);
  }
  return 1;
}





static void sqlite3VtabEponymousTableClear(sqlite3 *db, Module *pMod){
  Table *pTab = pMod->pEpoTab;
  if( pTab!=0 ){



    pTab->tabFlags |= 0x00004000;
    sqlite3DeleteTable(db, pTab);
    pMod->pEpoTab = 0;
  }
}
# 161047 "c_tests/sqlite3.c"
           int sqlite3_vtab_on_conflict(sqlite3 *db){
  static const unsigned char aMap[] = {
    1, 4, 3, 2, 5
  };



  ((void) (0));
  ((void) (0));
  ((void) (0));
  return (int)aMap[db->vtabOnConflict-1];
}






           int sqlite3_vtab_config(sqlite3 *db, int op, ...){
  va_list ap;
  int rc = 0;
  VtabCtx *p;




  sqlite3_mutex_enter(db->mutex);
  p = db->pVtabCtx;
  if( !p ){
    rc = sqlite3MisuseError(161076);
  }else{
    ((void) (0));
    __builtin_va_start(ap, op);
    switch( op ){
      case 1: {
        p->pVTable->bConstraint = (u8)__builtin_va_arg(ap, int);
        break;
      }
      case 2: {
        p->pVTable->eVtabRisk = 0;
        break;
      }
      case 3: {
        p->pVTable->eVtabRisk = 2;
        break;
      }
      case 4: {
        p->pVTable->bAllSchemas = 1;
        break;
      }
      default: {
        rc = sqlite3MisuseError(161098);
        break;
      }
    }
    __builtin_va_end(ap);
  }

  if( rc!=0 ) sqlite3Error(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 161158 "c_tests/sqlite3.c"
typedef struct WhereClause WhereClause;
typedef struct WhereMaskSet WhereMaskSet;
typedef struct WhereOrInfo WhereOrInfo;
typedef struct WhereAndInfo WhereAndInfo;
typedef struct WhereLevel WhereLevel;
typedef struct WhereLoop WhereLoop;
typedef struct WherePath WherePath;
typedef struct WhereTerm WhereTerm;
typedef struct WhereLoopBuilder WhereLoopBuilder;
typedef struct WhereScan WhereScan;
typedef struct WhereOrCost WhereOrCost;
typedef struct WhereOrSet WhereOrSet;
typedef struct WhereMemBlock WhereMemBlock;
typedef struct WhereRightJoin WhereRightJoin;





struct WhereMemBlock {
  WhereMemBlock *pNext;
  u64 sz;
};




struct WhereRightJoin {
  int iMatch;
  int regBloom;
  int regReturn;
  int addrSubrtn;
  int endSubrtn;
};
# 161208 "c_tests/sqlite3.c"
struct WhereLevel {
  int iLeftJoin;
  int iTabCur;
  int iIdxCur;
  int addrBrk;
  int addrHalt;
  int addrNxt;
  int addrSkip;
  int addrCont;
  int addrFirst;
  int addrBody;
  int regBignull;
  int addrBignull;

  u32 iLikeRepCntr;
  int addrLikeRep;

  int regFilter;
  WhereRightJoin *pRJ;
  u8 iFrom;
  u8 op, p3, p5;
  int p1, p2;
  union {
    struct {
      int nIn;
      struct InLoop {
        int iCur;
        int addrInTop;
        int iBase;
        int nPrefix;
        u8 eEndLoopOp;
      } *aInLoop;
    } in;
    Index *pCoveringIdx;
  } u;
  struct WhereLoop *pWLoop;
  Bitmask notReady;



};
# 161264 "c_tests/sqlite3.c"
struct WhereLoop {
  Bitmask prereq;
  Bitmask maskSelf;



  u8 iTab;
  u8 iSortIdx;
  LogEst rSetup;
  LogEst rRun;
  LogEst nOut;
  union {
    struct {
      u16 nEq;
      u16 nBtm;
      u16 nTop;
      u16 nDistinctCol;
      Index *pIndex;
      ExprList *pOrderBy;
    } btree;
    struct {
      int idxNum;
      u32 needFree : 1;
      u32 bOmitOffset : 1;
      u32 bIdxNumHex : 1;
      i8 isOrdered;
      u16 omitMask;
      char *idxStr;
      u32 mHandleIn;
    } vtab;
  } u;
  u32 wsFlags;
  u16 nLTerm;
  u16 nSkip;


  u16 nLSlot;




  WhereTerm **aLTerm;
  WhereLoop *pNextLoop;
  WhereTerm *aLTermSpace[3];
};





struct WhereOrCost {
  Bitmask prereq;
  LogEst rRun;
  LogEst nOut;
};






struct WhereOrSet {
  u16 n;
  WhereOrCost a[3];
};
# 161348 "c_tests/sqlite3.c"
struct WherePath {
  Bitmask maskLoop;
  Bitmask revLoop;
  LogEst nRow;
  LogEst rCost;
  LogEst rUnsort;
  i8 isOrdered;
  WhereLoop **aLoop;
};
# 161409 "c_tests/sqlite3.c"
struct WhereTerm {
  Expr *pExpr;
  WhereClause *pWC;
  LogEst truthProb;
  u16 wtFlags;
  u16 eOperator;
  u8 nChild;
  u8 eMatchOp;
  int iParent;
  int leftCursor;



  union {
    struct {
      int leftColumn;
      int iField;
    } x;
    WhereOrInfo *pOrInfo;
    WhereAndInfo *pAndInfo;
  } u;
  Bitmask prereqRight;
  Bitmask prereqAll;
};
# 161462 "c_tests/sqlite3.c"
struct WhereScan {
  WhereClause *pOrigWC;
  WhereClause *pWC;
  const char *zCollName;
  Expr *pIdxExpr;
  int k;
  u32 opMask;
  char idxaff;
  unsigned char iEquiv;
  unsigned char nEquiv;
  int aiCur[11];
  i16 aiColumn[11];
};
# 161488 "c_tests/sqlite3.c"
struct WhereClause {
  WhereInfo *pWInfo;
  WhereClause *pOuter;
  u8 op;
  u8 hasOr;
  int nTerm;
  int nSlot;
  int nBase;
  WhereTerm *a;



  WhereTerm aStatic[8];

};





struct WhereOrInfo {
  WhereClause wc;
  Bitmask indexable;
};





struct WhereAndInfo {
  WhereClause wc;
};
# 161547 "c_tests/sqlite3.c"
struct WhereMaskSet {
  int bVarSelect;
  int n;
  int ix[((int)(sizeof(Bitmask)*8))];
};





struct WhereLoopBuilder {
  WhereInfo *pWInfo;
  WhereClause *pWC;
  WhereLoop *pNew;
  WhereOrSet *pOrSet;




  unsigned char bldFlags1;
  unsigned char bldFlags2;
  unsigned int iPlanLimit;
};
# 161607 "c_tests/sqlite3.c"
struct WhereInfo {
  Parse *pParse;
  SrcList *pTabList;
  ExprList *pOrderBy;
  ExprList *pResultSet;



  Select *pSelect;
  int aiCurOnePass[2];
  int iContinue;
  int iBreak;
  int savedNQueryLoop;
  u16 wctrlFlags;
  LogEst iLimit;
  u8 nLevel;
  i8 nOBSat;
  u8 eOnePass;
  u8 eDistinct;
  unsigned bDeferredSeek :1;
  unsigned untestedTerms :1;
  unsigned bOrderedInnerLoop:1;
  unsigned sorted :1;
  unsigned bStarDone :1;
  unsigned bStarUsed :1;
  LogEst nRowOut;



  int iTop;
  int iEndWhere;
  WhereLoop *pLoops;
  WhereMemBlock *pMemToFree;
  Bitmask revMask;
  WhereClause sWC;
  WhereMaskSet sMaskSet;
  WhereLevel a[];
};
# 161656 "c_tests/sqlite3.c"
static Bitmask sqlite3WhereGetMask(WhereMaskSet*,int);





static WhereTerm *sqlite3WhereFindTerm(
  WhereClause *pWC,
  int iCur,
  int iColumn,
  Bitmask notReady,
  u32 op,
  Index *pIdx
);
static void *sqlite3WhereMalloc(WhereInfo *pWInfo, u64 nByte);
static void *sqlite3WhereRealloc(WhereInfo *pWInfo, void *pOld, u64 nByte);



static int sqlite3WhereExplainOneScan(
  Parse *pParse,
  SrcList *pTabList,
  WhereLevel *pLevel,
  u16 wctrlFlags
);
static int sqlite3WhereExplainBloomFilter(
  const Parse *pParse,
  const WhereInfo *pWInfo,
  const WhereLevel *pLevel
);
static void sqlite3WhereAddExplainText(
  Parse *pParse,
  int addr,
  SrcList *pTabList,
  WhereLevel *pLevel,
  u16 wctrlFlags
);
# 161708 "c_tests/sqlite3.c"
static Bitmask sqlite3WhereCodeOneLoopStart(
  Parse *pParse,
  Vdbe *v,
  WhereInfo *pWInfo,
  int iLevel,
  WhereLevel *pLevel,
  Bitmask notReady
);
static __attribute__((noinline)) void sqlite3WhereRightJoinLoop(
  WhereInfo *pWInfo,
  int iLevel,
  WhereLevel *pLevel
);


static void sqlite3WhereClauseInit(WhereClause*,WhereInfo*);
static void sqlite3WhereClauseClear(WhereClause*);
static void sqlite3WhereSplit(WhereClause*,Expr*,u8);
static void sqlite3WhereAddLimit(WhereClause*, Select*);
static Bitmask sqlite3WhereExprUsage(WhereMaskSet*, Expr*);
static Bitmask sqlite3WhereExprUsageNN(WhereMaskSet*, Expr*);
static Bitmask sqlite3WhereExprListUsage(WhereMaskSet*, ExprList*);
static void sqlite3WhereExprAnalyze(SrcList*, WhereClause*);
static void sqlite3WhereTabFuncArgs(Parse*, SrcItem*, WhereClause*);
# 161813 "c_tests/sqlite3.c"
static const char *explainIndexColumnName(Index *pIdx, int i){
  i = pIdx->aiColumn[i];
  if( i==(-2) ) return "<expr>";
  if( i==(-1) ) return "rowid";
  return pIdx->pTable->aCol[i].zCnName;
}
# 161828 "c_tests/sqlite3.c"
static void explainAppendTerm(
  StrAccum *pStr,
  Index *pIdx,
  int nTerm,
  int iTerm,
  int bAnd,
  const char *zOp
){
  int i;

  ((void) (0));
  if( bAnd ) sqlite3_str_append(pStr, " AND ", 5);

  if( nTerm>1 ) sqlite3_str_append(pStr, "(", 1);
  for(i=0; i<nTerm; i++){
    if( i ) sqlite3_str_append(pStr, ",", 1);
    sqlite3_str_appendall(pStr, explainIndexColumnName(pIdx, iTerm+i));
  }
  if( nTerm>1 ) sqlite3_str_append(pStr, ")", 1);

  sqlite3_str_append(pStr, zOp, 1);

  if( nTerm>1 ) sqlite3_str_append(pStr, "(", 1);
  for(i=0; i<nTerm; i++){
    if( i ) sqlite3_str_append(pStr, ",", 1);
    sqlite3_str_append(pStr, "?", 1);
  }
  if( nTerm>1 ) sqlite3_str_append(pStr, ")", 1);
}
# 161872 "c_tests/sqlite3.c"
static void explainIndexRange(StrAccum *pStr, WhereLoop *pLoop){
  Index *pIndex = pLoop->u.btree.pIndex;
  u16 nEq = pLoop->u.btree.nEq;
  u16 nSkip = pLoop->nSkip;
  int i, j;

  if( nEq==0 && (pLoop->wsFlags&(0x00000020|0x00000010))==0 ) return;
  sqlite3_str_append(pStr, " (", 2);
  for(i=0; i<nEq; i++){
    const char *z = explainIndexColumnName(pIndex, i);
    if( i ) sqlite3_str_append(pStr, " AND ", 5);
    sqlite3_str_appendf(pStr, i>=nSkip ? "%s=?" : "ANY(%s)", z);
  }

  j = i;
  if( pLoop->wsFlags&0x00000020 ){
    explainAppendTerm(pStr, pIndex, pLoop->u.btree.nBtm, j, i, ">");
    i = 1;
  }
  if( pLoop->wsFlags&0x00000010 ){
    explainAppendTerm(pStr, pIndex, pLoop->u.btree.nTop, j, i, "<");
  }
  sqlite3_str_append(pStr, ")", 1);
}






static void sqlite3WhereAddExplainText(
  Parse *pParse,
  int addr,
  SrcList *pTabList,
  WhereLevel *pLevel,
  u16 wctrlFlags
){

  if( ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->explain==2 || 0 )

  {
    VdbeOp *pOp = sqlite3VdbeGetOp(pParse->pVdbe, addr);
    SrcItem *pItem = &pTabList->a[pLevel->iFrom];
    sqlite3 *db = pParse->db;
    int isSearch;
    WhereLoop *pLoop;
    u32 flags;



    StrAccum str;
    char zBuf[100];

    if( db->mallocFailed ) return;

    pLoop = pLevel->pWLoop;
    flags = pLoop->wsFlags;

    isSearch = (flags&(0x00000020|0x00000010))!=0
            || ((flags&0x00000400)==0 && (pLoop->u.btree.nEq>0))
            || (wctrlFlags&(0x0001|0x0002));

    sqlite3StrAccumInit(&str, db, zBuf, sizeof(zBuf), 1000000000);
    str.printfFlags = 0x01;
    sqlite3_str_appendf(&str, "%s %S%s",
       isSearch ? "SEARCH" : "SCAN",
       pItem,
       pItem->fg.fromExists ? " EXISTS" : "");
    if( (flags & (0x00000100|0x00000400))==0 ){
      const char *zFmt = 0;
      Index *pIdx;

      ((void) (0));
      pIdx = pLoop->u.btree.pIndex;
      ((void) (0));
      if( !(((pItem->pSTab)->tabFlags & 0x00000080)==0) && ((pIdx)->idxType==2) ){
        if( isSearch ){
          zFmt = "PRIMARY KEY";
        }
      }else if( flags & 0x00020000 ){
        zFmt = "AUTOMATIC PARTIAL COVERING INDEX";
      }else if( flags & 0x00004000 ){
        zFmt = "AUTOMATIC COVERING INDEX";
      }else if( flags & (0x00000040|0x04000000) ){
        zFmt = "COVERING INDEX %s";
      }else{
        zFmt = "INDEX %s";
      }
      if( zFmt ){
        sqlite3_str_append(&str, " USING ", 7);
        sqlite3_str_appendf(&str, zFmt, pIdx->zName);
        explainIndexRange(&str, pLoop);
      }
    }else if( (flags & 0x00000100)!=0 && (flags & 0x0000000f)!=0 ){
      char cRangeOp;





      const char *zRowid = "rowid";

      sqlite3_str_appendf(&str, " USING INTEGER PRIMARY KEY (%s", zRowid);
      if( flags&(0x00000001|0x00000004) ){
        cRangeOp = '=';
      }else if( (flags&0x00000030)==0x00000030 ){
        sqlite3_str_appendf(&str, ">? AND %s", zRowid);
        cRangeOp = '<';
      }else if( flags&0x00000020 ){
        cRangeOp = '>';
      }else{
        ((void) (0));
        cRangeOp = '<';
      }
      sqlite3_str_appendf(&str, "%c?)", cRangeOp);
    }

    else if( (flags & 0x00000400)!=0 ){
      sqlite3_str_appendall(&str, " VIRTUAL TABLE INDEX ");
      sqlite3_str_appendf(&str,
                  pLoop->u.vtab.bIdxNumHex ? "0x%x:%s" : "%d:%s",
                  pLoop->u.vtab.idxNum, pLoop->u.vtab.idxStr);
    }

    if( pItem->fg.jointype & 0x08 ){
      sqlite3_str_appendf(&str, " LEFT-JOIN");
    }
# 162012 "c_tests/sqlite3.c"
    ((void) (0));
    ((void) (0));
    sqlite3DbFree(db, pOp->p4.z);
    pOp->p4type = (-6);
    pOp->p4.z = sqlite3StrAccumFinish(&str);
  }
}
# 162030 "c_tests/sqlite3.c"
static int sqlite3WhereExplainOneScan(
  Parse *pParse,
  SrcList *pTabList,
  WhereLevel *pLevel,
  u16 wctrlFlags
){
  int ret = 0;

  if( ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->explain==2 || 0 )

  {
    if( (pLevel->pWLoop->wsFlags & 0x00002000)==0
     && (wctrlFlags & 0x0020)==0
    ){
      Vdbe *v = pParse->pVdbe;
      int addr = sqlite3VdbeCurrentAddr(v);
      ret = sqlite3VdbeAddOp3(
          v, 189, addr, pParse->addrExplain, pLevel->pWLoop->rRun
      );
      sqlite3WhereAddExplainText(pParse, addr, pTabList, pLevel, wctrlFlags);
    }
  }
  return ret;
}
# 162065 "c_tests/sqlite3.c"
static int sqlite3WhereExplainBloomFilter(
  const Parse *pParse,
  const WhereInfo *pWInfo,
  const WhereLevel *pLevel
){
  int ret = 0;
  SrcItem *pItem = &pWInfo->pTabList->a[pLevel->iFrom];
  Vdbe *v = pParse->pVdbe;
  sqlite3 *db = pParse->db;
  char *zMsg;
  int i;
  WhereLoop *pLoop;
  StrAccum str;
  char zBuf[100];

  sqlite3StrAccumInit(&str, db, zBuf, sizeof(zBuf), 1000000000);
  str.printfFlags = 0x01;
  sqlite3_str_appendf(&str, "BLOOM FILTER ON %S (", pItem);
  pLoop = pLevel->pWLoop;
  if( pLoop->wsFlags & 0x00000100 ){
    const Table *pTab = pItem->pSTab;
    if( pTab->iPKey>=0 ){
      sqlite3_str_appendf(&str, "%s=?", pTab->aCol[pTab->iPKey].zCnName);
    }else{
      sqlite3_str_appendf(&str, "rowid=?");
    }
  }else{
    for(i=pLoop->nSkip; i<pLoop->u.btree.nEq; i++){
      const char *z = explainIndexColumnName(pLoop->u.btree.pIndex, i);
      if( i>pLoop->nSkip ) sqlite3_str_append(&str, " AND ", 5);
      sqlite3_str_appendf(&str, "%s=?", z);
    }
  }
  sqlite3_str_append(&str, ")", 1);
  zMsg = sqlite3StrAccumFinish(&str);
  ret = sqlite3VdbeAddOp4(v, 189, sqlite3VdbeCurrentAddr(v),
                          pParse->addrExplain, 0, zMsg,(-6));

                                                                   ;
  return ret;
}
# 162204 "c_tests/sqlite3.c"
static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){
  int nLoop = 0;
  ((void) (0));
  while( (pTerm->wtFlags & 0x0004)==0
      && (pLevel->iLeftJoin==0 || (((pTerm->pExpr)->flags&(u32)(0x000001))!=0))
      && (pLevel->notReady & pTerm->prereqAll)==0
  ){
    if( nLoop && (pTerm->wtFlags & 0x0400)!=0 ){
      pTerm->wtFlags |= 0x0200;
    }else{
      pTerm->wtFlags |= 0x0004;
    }






    if( pTerm->iParent<0 ) break;
    pTerm = &pTerm->pWC->a[pTerm->iParent];
    ((void) (0));
    pTerm->nChild--;
    if( pTerm->nChild!=0 ) break;
    nLoop++;
  }
}
# 162242 "c_tests/sqlite3.c"
static void codeApplyAffinity(Parse *pParse, int base, int n, char *zAff){
  Vdbe *v = pParse->pVdbe;
  if( zAff==0 ){
    ((void) (0));
    return;
  }
  ((void) (0));




  ((void) (0));
  while( n>0 && zAff[0]<=0x41 ){
    n--;
    base++;
    zAff++;
  }
  while( n>1 && zAff[n-1]<=0x41 ){
    n--;
  }


  if( n>0 ){
    sqlite3VdbeAddOp4(v, 97, base, n, 0, zAff, n);
  }
}
# 162279 "c_tests/sqlite3.c"
static void updateRangeAffinityStr(
  Expr *pRight,
  int n,
  char *zAff
){
  int i;
  for(i=0; i<n; i++){
    Expr *p = sqlite3VectorFieldSubexpr(pRight, i);
    if( sqlite3CompareAffinity(p, zAff[i])==0x41
     || sqlite3ExprNeedsNoAffinityChange(p, zAff[i])
    ){
      zAff[i] = 0x41;
    }
  }
}
# 162310 "c_tests/sqlite3.c"
static void adjustOrderByCol(ExprList *pOrderBy, ExprList *pEList){
  int i, j;
  if( pOrderBy==0 ) return;
  for(i=0; i<pOrderBy->nExpr; i++){
    int t = pOrderBy->a[i].u.x.iOrderByCol;
    if( t==0 ) continue;
    for(j=0; j<pEList->nExpr; j++){
      if( pEList->a[j].u.x.iOrderByCol==t ){
        pOrderBy->a[i].u.x.iOrderByCol = j+1;
        break;
      }
    }
    if( j>=pEList->nExpr ){
      pOrderBy->a[i].u.x.iOrderByCol = 0;
    }
  }
}
# 162358 "c_tests/sqlite3.c"
static Expr *removeUnindexableInClauseTerms(
  Parse *pParse,
  int iEq,
  WhereLoop *pLoop,
  Expr *pX
){
  sqlite3 *db = pParse->db;
  Select *pSelect;
  Expr *pNew;
  pNew = sqlite3ExprDup(db, pX, 0);
  if( db->mallocFailed==0 ){
    for(pSelect=pNew->x.pSelect; pSelect; pSelect=pSelect->pPrior){
      ExprList *pOrigRhs;
      ExprList *pOrigLhs = 0;
      ExprList *pRhs = 0;
      ExprList *pLhs = 0;
      int i;

      ((void) (0));
      pOrigRhs = pSelect->pEList;
      ((void) (0));
      ((void) (0));
      if( pSelect==pNew->x.pSelect ){
        pOrigLhs = pNew->pLeft->x.pList;
      }
      for(i=iEq; i<pLoop->nLTerm; i++){
        if( pLoop->aLTerm[i]->pExpr==pX ){
          int iField;
          ((void) (0));
          iField = pLoop->aLTerm[i]->u.x.iField - 1;
          if( (pOrigRhs->a[iField].pExpr==0) ){
            continue;
          }
          pRhs = sqlite3ExprListAppend(pParse, pRhs, pOrigRhs->a[iField].pExpr);
          pOrigRhs->a[iField].pExpr = 0;
          if( pRhs ) pRhs->a[pRhs->nExpr-1].u.x.iOrderByCol = iField+1;
          if( pOrigLhs ){
            ((void) (0));
            pLhs = sqlite3ExprListAppend(pParse,pLhs,pOrigLhs->a[iField].pExpr);
            pOrigLhs->a[iField].pExpr = 0;
          }
        }
      }
      sqlite3ExprListDelete(db, pOrigRhs);
      if( pOrigLhs ){
        sqlite3ExprListDelete(db, pOrigLhs);
        pNew->pLeft->x.pList = pLhs;
      }
      pSelect->pEList = pRhs;
      pSelect->selId = ++pParse->nSelect;
      if( pLhs && pLhs->nExpr==1 ){



        Expr *p = pLhs->a[0].pExpr;
        pLhs->a[0].pExpr = 0;
        sqlite3ExprDelete(db, pNew->pLeft);
        pNew->pLeft = p;
      }





      ((void) (0));
      if( pRhs ){
        adjustOrderByCol(pSelect->pOrderBy, pRhs);
        adjustOrderByCol(pSelect->pGroupBy, pRhs);
        for(i=0; i<pRhs->nExpr; i++) pRhs->a[i].u.x.iOrderByCol = 0;
      }







    }
  }
  return pNew;
}
# 162453 "c_tests/sqlite3.c"
static __attribute__((noinline)) void codeINTerm(
  Parse *pParse,
  WhereTerm *pTerm,
  WhereLevel *pLevel,
  int iEq,
  int bRev,
  int iTarget
){
  Expr *pX = pTerm->pExpr;
  int eType = 5;
  int iTab;
  struct InLoop *pIn;
  WhereLoop *pLoop = pLevel->pWLoop;
  Vdbe *v = pParse->pVdbe;
  int i;
  int nEq = 0;
  int *aiMap = 0;

  if( (pLoop->wsFlags & 0x00000400)==0
    && pLoop->u.btree.pIndex!=0
    && pLoop->u.btree.pIndex->aSortOrder[iEq]
  ){
                      ;
                    ;
    bRev = !bRev;
  }
  ((void) (0));

  for(i=0; i<iEq; i++){
    if( pLoop->aLTerm[i] && pLoop->aLTerm[i]->pExpr==pX ){
      disableTerm(pLevel, pTerm);
      return;
    }
  }
  for(i=iEq; i<pLoop->nLTerm; i++){
    ((void) (0));
    if( pLoop->aLTerm[i]->pExpr==pX ) nEq++;
  }

  iTab = 0;
  if( !(((pX)->flags&0x001000)!=0) || pX->x.pSelect->pEList->nExpr==1 ){
    eType = sqlite3FindInIndex(pParse, pX, 0x0004, 0, 0, &iTab);
  }else{
    sqlite3 *db = pParse->db;
    Expr *pXMod = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);
    if( !db->mallocFailed ){
      aiMap = (int*)sqlite3DbMallocZero(db, sizeof(int)*nEq);
      eType = sqlite3FindInIndex(pParse, pXMod, 0x0004, 0, aiMap, &iTab);
    }
    sqlite3ExprDelete(db, pXMod);
  }

  if( eType==4 ){
                    ;
    bRev = !bRev;
  }
  sqlite3VdbeAddOp2(v, bRev ? 32 : 36, iTab, 0);
                         ;
                          ;

  ((void) (0));
  pLoop->wsFlags |= 0x00000800;
  if( pLevel->u.in.nIn==0 ){
    pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);
  }
  if( iEq>0 && (pLoop->wsFlags & 0x00100000)==0 ){
    pLoop->wsFlags |= 0x00040000;
  }

  i = pLevel->u.in.nIn;
  pLevel->u.in.nIn += nEq;
  pLevel->u.in.aInLoop =
     sqlite3WhereRealloc(pTerm->pWC->pWInfo,
                         pLevel->u.in.aInLoop,
                         sizeof(pLevel->u.in.aInLoop[0])*pLevel->u.in.nIn);
  pIn = pLevel->u.in.aInLoop;
  if( pIn ){
    int iMap = 0;
    pIn += i;
    for(i=iEq; i<pLoop->nLTerm; i++){
      if( pLoop->aLTerm[i]->pExpr==pX ){
        int iOut = iTarget + i - iEq;
        if( eType==1 ){
          pIn->addrInTop = sqlite3VdbeAddOp2(v, 136, iTab, iOut);
        }else{
          int iCol = aiMap ? aiMap[iMap++] : 0;
          pIn->addrInTop = sqlite3VdbeAddOp3(v,95,iTab, iCol, iOut);
        }
        sqlite3VdbeAddOp1(v, 51, iOut); ;
        if( i==iEq ){
          pIn->iCur = iTab;
          pIn->eEndLoopOp = bRev ? 39 : 40;
          if( iEq>0 ){
            pIn->iBase = iTarget - i;
            pIn->nPrefix = i;
          }else{
            pIn->nPrefix = 0;
          }
        }else{
          pIn->eEndLoopOp = 188;
        }
        pIn++;
      }
    }


                                                           ;
    if( iEq>0
     && (pLoop->wsFlags & (0x00100000|0x00000400))==0
    ){
      sqlite3VdbeAddOp3(v, 126, pLevel->iIdxCur, 0, iEq);
    }
  }else{
    pLevel->u.in.nIn = 0;
  }
  sqlite3DbFree(pParse->db, aiMap);
}
# 162588 "c_tests/sqlite3.c"
static int codeEqualityTerm(
  Parse *pParse,
  WhereTerm *pTerm,
  WhereLevel *pLevel,
  int iEq,
  int bRev,
  int iTarget
){
  Expr *pX = pTerm->pExpr;
  int iReg;

  ((void) (0));
  ((void) (0));
  if( pX->op==54 || pX->op==45 ){
    iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget);
  }else if( pX->op==51 ){
    iReg = iTarget;
    sqlite3VdbeAddOp2(pParse->pVdbe, 76, 0, iReg);

  }else{
    ((void) (0));
    iReg = iTarget;
    codeINTerm(pParse, pTerm, pLevel, iEq, bRev, iTarget);

  }
# 162623 "c_tests/sqlite3.c"
  if( (pLevel->pWLoop->wsFlags & 0x00200000)==0
   || (pTerm->eOperator & 0x0800)==0
  ){
    disableTerm(pLevel, pTerm);
  }

  return iReg;
}
# 162677 "c_tests/sqlite3.c"
static int codeAllEqualityTerms(
  Parse *pParse,
  WhereLevel *pLevel,
  int bRev,
  int nExtraReg,
  char **pzAff
){
  u16 nEq;
  u16 nSkip;
  Vdbe *v = pParse->pVdbe;
  Index *pIdx;
  WhereTerm *pTerm;
  WhereLoop *pLoop;
  int j;
  int regBase;
  int nReg;
  char *zAff;


  pLoop = pLevel->pWLoop;
  ((void) (0));
  nEq = pLoop->u.btree.nEq;
  nSkip = pLoop->nSkip;
  pIdx = pLoop->u.btree.pIndex;
  ((void) (0));



  regBase = pParse->nMem + 1;
  nReg = nEq + nExtraReg;
  pParse->nMem += nReg;

  zAff = sqlite3DbStrDup(pParse->db,sqlite3IndexAffinityStr(pParse->db,pIdx));
  ((void) (0));

  if( nSkip ){
    int iIdxCur = pLevel->iIdxCur;
    sqlite3VdbeAddOp3(v, 76, 0, regBase, regBase+nSkip-1);
    sqlite3VdbeAddOp1(v, (bRev?32:36), iIdxCur);
                              ;
                              ;
                                                          ;
    j = sqlite3VdbeAddOp0(v, 9);
    ((void) (0));
    pLevel->addrSkip = sqlite3VdbeAddOp4Int(v, (bRev?21:24),
                            iIdxCur, 0, regBase, nSkip);
                              ;
                              ;
    sqlite3VdbeJumpHere(v, j);
    for(j=0; j<nSkip; j++){
      sqlite3VdbeAddOp3(v, 95, iIdxCur, j, regBase+j);
                                            ;
                                                             ;
    }
  }



  ((void) (0));
  for(j=nSkip; j<nEq; j++){
    int r1;
    pTerm = pLoop->aLTerm[j];
    ((void) (0));


                                                ;
                                             ;
    r1 = codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, regBase+j);
    if( r1!=regBase+j ){
      if( nReg==1 ){
        sqlite3ReleaseTempReg(pParse, regBase);
        regBase = r1;
      }else{
        sqlite3VdbeAddOp2(v, 81, r1, regBase+j);
      }
    }
    if( pTerm->eOperator & 0x0001 ){
      if( pTerm->pExpr->flags & 0x001000 ){




        if( zAff ) zAff[j] = 0x41;
      }
    }else if( (pTerm->eOperator & 0x0100)==0 ){
      Expr *pRight = pTerm->pExpr->pRight;
      if( (pTerm->wtFlags & 0x0800)==0 && sqlite3ExprCanBeNull(pRight) ){
        sqlite3VdbeAddOp2(v, 51, regBase+j, pLevel->addrBrk);
                       ;
      }
      if( pParse->nErr==0 ){
        ((void) (0));
        if( sqlite3CompareAffinity(pRight, zAff[j])==0x41 ){
          zAff[j] = 0x41;
        }
        if( sqlite3ExprNeedsNoAffinityChange(pRight, zAff[j]) ){
          zAff[j] = 0x41;
        }
      }
    }
  }
  *pzAff = zAff;
  return regBase;
}
# 162800 "c_tests/sqlite3.c"
static void whereLikeOptimizationStringFixup(
  Vdbe *v,
  WhereLevel *pLevel,
  WhereTerm *pTerm
){
  if( pTerm->wtFlags & 0x0100 ){
    VdbeOp *pOp;
    ((void) (0));
    pOp = sqlite3VdbeGetLastOp(v);
    ((void) (0));
    ((void) (0));

    pOp->p3 = (int)(pLevel->iLikeRepCntr>>1);
    pOp->p5 = (u8)(pLevel->iLikeRepCntr&1);
  }
}
# 163061 "c_tests/sqlite3.c"
static void codeDeferredSeek(
  WhereInfo *pWInfo,
  Index *pIdx,
  int iCur,
  int iIdxCur
){
  Parse *pParse = pWInfo->pParse;
  Vdbe *v = pParse->pVdbe;

  ((void) (0));
  ((void) (0));

  pWInfo->bDeferredSeek = 1;
  sqlite3VdbeAddOp3(v, 142, iIdxCur, 0, iCur);
  if( (pWInfo->wctrlFlags & (0x0020|0x1000))
   && ((((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->writeMask)==0)
  ){
    int i;
    Table *pTab = pIdx->pTable;
    u32 *ai = (u32*)sqlite3DbMallocZero(pParse->db, sizeof(u32)*(pTab->nCol+1));
    if( ai ){
      ai[0] = pTab->nCol;
      for(i=0; i<pIdx->nColumn-1; i++){
        int x1, x2;
        ((void) (0));
        x1 = pIdx->aiColumn[i];
        x2 = sqlite3TableColumnToStorage(pTab, x1);
                          ;
        if( x1>=0 ) ai[x2+1] = i+1;
      }
      sqlite3VdbeChangeP4(v, -1, (char*)ai, (-14));
    }
  }
}
# 163105 "c_tests/sqlite3.c"
static void codeExprOrVector(Parse *pParse, Expr *p, int iReg, int nReg){
  ((void) (0));
  if( p && sqlite3ExprIsVector(p) ){

    if( (((p)->flags&0x001000)!=0) ){
      Vdbe *v = pParse->pVdbe;
      int iSelect;
      ((void) (0));
      iSelect = sqlite3CodeSubselect(pParse, p);
      sqlite3VdbeAddOp3(v, 81, iSelect, iReg, nReg-1);
    }else

    {
      int i;
      const ExprList *pList;
      ((void) (0));
      pList = p->x.pList;
      ((void) (0));
      for(i=0; i<nReg; i++){
        sqlite3ExprCode(pParse, pList->a[i].pExpr, iReg+i);
      }
    }
  }else{
    ((void) (0));
    sqlite3ExprCode(pParse, p, iReg);
  }
}
# 163140 "c_tests/sqlite3.c"
static void whereApplyPartialIndexConstraints(
  Expr *pTruth,
  int iTabCur,
  WhereClause *pWC
){
  int i;
  WhereTerm *pTerm;
  while( pTruth->op==44 ){
    whereApplyPartialIndexConstraints(pTruth->pLeft, iTabCur, pWC);
    pTruth = pTruth->pRight;
  }
  for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
    Expr *pExpr;
    if( pTerm->wtFlags & 0x0004 ) continue;
    pExpr = pTerm->pExpr;
    if( sqlite3ExprCompare(0, pExpr, pTruth, iTabCur)==0 ){
      pTerm->wtFlags |= 0x0004;
    }
  }
}
# 163176 "c_tests/sqlite3.c"
static __attribute__((noinline)) void filterPullDown(
  Parse *pParse,
  WhereInfo *pWInfo,
  int iLevel,
  int addrNxt,
  Bitmask notReady
){
  int saved_addrBrk;
  while( ++iLevel < pWInfo->nLevel ){
    WhereLevel *pLevel = &pWInfo->a[iLevel];
    WhereLoop *pLoop = pLevel->pWLoop;
    if( pLevel->regFilter==0 ) continue;
    if( pLevel->pWLoop->nSkip ) continue;


    if( (pLoop->prereq & notReady) ) continue;
    saved_addrBrk = pLevel->addrBrk;
    pLevel->addrBrk = addrNxt;
    if( pLoop->wsFlags & 0x00000100 ){
      WhereTerm *pTerm = pLoop->aLTerm[0];
      int regRowid;
      ((void) (0));
      ((void) (0));
                                               ;
      regRowid = sqlite3GetTempReg(pParse);
      regRowid = codeEqualityTerm(pParse, pTerm, pLevel, 0, 0, regRowid);
      sqlite3VdbeAddOp2(pParse->pVdbe, 13, regRowid, addrNxt);
                                 ;
      sqlite3VdbeAddOp4Int(pParse->pVdbe, 65, pLevel->regFilter,
                           addrNxt, regRowid, 1);
                                 ;
    }else{
      u16 nEq = pLoop->u.btree.nEq;
      int r1;
      char *zStartAff;

      ((void) (0));
      ((void) (0));
      r1 = codeAllEqualityTerms(pParse,pLevel,0,0,&zStartAff);
      codeApplyAffinity(pParse, r1, nEq, zStartAff);
      sqlite3DbFree(pParse->db, zStartAff);
      sqlite3VdbeAddOp4Int(pParse->pVdbe, 65, pLevel->regFilter,
                           addrNxt, r1, nEq);
                                 ;
    }
    pLevel->regFilter = 0;
    pLevel->addrBrk = saved_addrBrk;
  }
}






static int whereLoopIsOneRow(WhereLoop *pLoop){
  if( pLoop->u.btree.pIndex->onError
   && pLoop->nSkip==0
   && pLoop->u.btree.nEq==pLoop->u.btree.pIndex->nKeyCol
  ){
    int ii;
    for(ii=0; ii<pLoop->u.btree.nEq; ii++){
      if( pLoop->aLTerm[ii]->eOperator & (0x0080|0x0100) ){
        return 0;
      }
    }
    return 1;
  }
  return 0;
}





static Bitmask sqlite3WhereCodeOneLoopStart(
  Parse *pParse,
  Vdbe *v,
  WhereInfo *pWInfo,
  int iLevel,
  WhereLevel *pLevel,
  Bitmask notReady
){
  int j, k;
  int iCur;
  int addrNxt;
  int bRev;
  WhereLoop *pLoop;
  WhereClause *pWC;
  WhereTerm *pTerm;
  sqlite3 *db;
  SrcItem *pTabItem;
  int addrBrk;
  int addrCont;
  int iRowidReg = 0;
  int iReleaseReg = 0;
  Index *pIdx = 0;
  int iLoop;

  pWC = &pWInfo->sWC;
  db = pParse->db;
  pLoop = pLevel->pWLoop;
  pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];
  iCur = pTabItem->iCursor;
  pLevel->notReady = notReady & ~sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur);
  bRev = (pWInfo->revMask>>iLevel)&1;

                                                     ;
# 163312 "c_tests/sqlite3.c"
  addrBrk = pLevel->addrNxt = pLevel->addrBrk;
  addrCont = pLevel->addrCont = sqlite3VdbeMakeLabel(pParse);





  ((void) (0));


  if( pLevel->iFrom>0 && (pTabItem[0].fg.jointype & 0x08)!=0 ){
    pLevel->iLeftJoin = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 72, 0, pLevel->iLeftJoin);
                                                 ;
  }


  if( pTabItem->fg.viaCoroutine ){
    int regYield;
    Subquery *pSubq;
    ((void) (0));
    pSubq = pTabItem->u4.pSubq;
    regYield = pSubq->regReturn;
    sqlite3VdbeAddOp3(v, 11, regYield, 0, pSubq->addrFillSub);
    pLevel->p2 = sqlite3VdbeAddOp2(v, 12, regYield, addrBrk);
                   ;
                                                              ;
    pLevel->op = 9;
  }else


  if( (pLoop->wsFlags & 0x00000400)!=0 ){



    int iReg;
    int addrNotFound;
    int nConstraint = pLoop->nLTerm;

    iReg = sqlite3GetTempRange(pParse, nConstraint+2);
    addrNotFound = pLevel->addrBrk;
    for(j=0; j<nConstraint; j++){
      int iTarget = iReg+j+2;
      pTerm = pLoop->aLTerm[j];
      if( (pTerm==0) ) continue;
      if( pTerm->eOperator & 0x0001 ){
        if( ((j)<=31?((unsigned int)1)<<(j):0) & pLoop->u.vtab.mHandleIn ){
          int iTab = pParse->nTab++;
          int iCache = ++pParse->nMem;
          sqlite3CodeRhsOfIN(pParse, pTerm->pExpr, iTab);
          sqlite3VdbeAddOp3(v, 176, iTab, iTarget, iCache);
        }else{
          codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget);
          addrNotFound = pLevel->addrNxt;
        }
      }else{
        Expr *pRight = pTerm->pExpr->pRight;
        codeExprOrVector(pParse, pRight, iTarget, 1);
        if( pTerm->eMatchOp==74
         && pLoop->u.vtab.bOmitOffset
        ){
          ((void) (0));
          ((void) (0));
          ((void) (0));
          sqlite3VdbeAddOp2(v, 72, 0, pWInfo->pSelect->iOffset);
                                                ;
        }
      }
    }
    sqlite3VdbeAddOp2(v, 72, pLoop->u.vtab.idxNum, iReg);
    sqlite3VdbeAddOp2(v, 72, nConstraint, iReg+1);



    sqlite3VdbeAddOp4(v, 6, iCur, addrNotFound, iReg,
                      pLoop->u.vtab.idxStr,
                      pLoop->u.vtab.needFree ? (-6) : (-1));
                   ;
    pLoop->u.vtab.needFree = 0;


    if( db->mallocFailed ) pLoop->u.vtab.idxStr = 0;
    pLevel->p1 = iCur;
    pLevel->op = pWInfo->eOnePass ? 188 : 64;
    pLevel->p2 = sqlite3VdbeCurrentAddr(v);
    ((void) (0));

    for(j=0; j<nConstraint; j++){
      pTerm = pLoop->aLTerm[j];
      if( j<16 && (pLoop->u.vtab.omitMask>>j)&1 ){
        disableTerm(pLevel, pTerm);
        continue;
      }
      if( (pTerm->eOperator & 0x0001)!=0
       && (((j)<=31?((unsigned int)1)<<(j):0) & pLoop->u.vtab.mHandleIn)==0
       && !db->mallocFailed
      ){
        Expr *pCompare;
        Expr *pRight;
        VdbeOp *pOp;
        int iIn;






        for(iIn=0; (iIn<pLevel->u.in.nIn); iIn++){
          pOp = sqlite3VdbeGetOp(v, pLevel->u.in.aInLoop[iIn].addrInTop);
          if( (pOp->opcode==95 && pOp->p3==iReg+j+2)
           || (pOp->opcode==136 && pOp->p2==iReg+j+2)
          ){
                                             ;
            sqlite3VdbeAddOp3(v, pOp->opcode, pOp->p1, pOp->p2, pOp->p3);
            break;
          }
        }




        pCompare = sqlite3PExpr(pParse, 54, 0, 0);
        if( !db->mallocFailed ){
          int iFld = pTerm->u.x.iField;
          Expr *pLeft = pTerm->pExpr->pLeft;
          ((void) (0));
          if( iFld>0 ){
            ((void) (0));
            ((void) (0));
            ((void) (0));
            pCompare->pLeft = pLeft->x.pList->a[iFld-1].pExpr;
          }else{
            pCompare->pLeft = pLeft;
          }
          pCompare->pRight = pRight = sqlite3Expr(db, 176, 0);
          if( pRight ){
            pRight->iTable = iReg+j+2;
            sqlite3ExprIfFalse(
                pParse, pCompare, pLevel->addrCont, 0x10
            );
          }
          pCompare->pLeft = 0;
        }
        sqlite3ExprDelete(db, pCompare);
      }
    }
# 163466 "c_tests/sqlite3.c"
  }else


  if( (pLoop->wsFlags & 0x00000100)!=0
   && (pLoop->wsFlags & (0x00000004|0x00000001))!=0
  ){





    ((void) (0));
    pTerm = pLoop->aLTerm[0];
    ((void) (0));
    ((void) (0));
                                             ;
    iReleaseReg = ++pParse->nMem;
    iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);
    if( iRowidReg!=iReleaseReg ) sqlite3ReleaseTempReg(pParse, iReleaseReg);
    addrNxt = pLevel->addrNxt;
    if( pLevel->regFilter ){
      sqlite3VdbeAddOp2(v, 13, iRowidReg, addrNxt);
                     ;
      sqlite3VdbeAddOp4Int(v, 65, pLevel->regFilter, addrNxt,
                           iRowidReg, 1);
                     ;
      filterPullDown(pParse, pWInfo, iLevel, addrNxt, notReady);
    }
    sqlite3VdbeAddOp3(v, 30, iCur, addrNxt, iRowidReg);
                   ;
    pLevel->op = 188;
  }else if( (pLoop->wsFlags & 0x00000100)!=0
         && (pLoop->wsFlags & 0x00000002)!=0
  ){


    int testOp = 188;
    int start;
    int memEndValue = 0;
    WhereTerm *pStart, *pEnd;

    j = 0;
    pStart = pEnd = 0;
    if( pLoop->wsFlags & 0x00000020 ) pStart = pLoop->aLTerm[j++];
    if( pLoop->wsFlags & 0x00000010 ) pEnd = pLoop->aLTerm[j++];
    ((void) (0));
    if( bRev ){
      pTerm = pStart;
      pStart = pEnd;
      pEnd = pTerm;
    }
                                                  ;
    if( pStart ){
      Expr *pX;
      int r1, rTemp;
      int op;




      const u8 aMoveOp[] = {
                        24,
                        22,
                        21,
                        23
      };
      ((void) (0));
      ((void) (0));
      ((void) (0));

      ((void) (0));
                                                ;
      pX = pStart->pExpr;
      ((void) (0));
                                          ;
      if( sqlite3ExprIsVector(pX->pRight) ){
        r1 = rTemp = sqlite3GetTempReg(pParse);
        codeExprOrVector(pParse, pX->pRight, r1, 1);
                                 ;
                                 ;
                                 ;
                                 ;
        op = aMoveOp[((pX->op - 55 - 1) & 0x3) | 0x1];
        ((void) (0));
        ((void) (0));
        ((void) (0));
        ((void) (0));
      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, &rTemp);
        disableTerm(pLevel, pStart);
        op = aMoveOp[(pX->op - 55)];
      }
      sqlite3VdbeAddOp3(v, op, iCur, addrBrk, r1);
                            ;
                                      ;
                                      ;
                                      ;
                                      ;
      sqlite3ReleaseTempReg(pParse, rTemp);
    }else{
      sqlite3VdbeAddOp2(v, bRev ? 32 : 36, iCur, pLevel->addrHalt);
                                ;
                                ;
    }
    if( pEnd ){
      Expr *pX;
      pX = pEnd->pExpr;
      ((void) (0));
      ((void) (0));
                                        ;
                                              ;
      memEndValue = ++pParse->nMem;
      codeExprOrVector(pParse, pX->pRight, memEndValue, 1);
      if( 0==sqlite3ExprIsVector(pX->pRight)
       && (pX->op==57 || pX->op==55)
      ){
        testOp = bRev ? 56 : 58;
      }else{
        testOp = bRev ? 57 : 55;
      }
      if( 0==sqlite3ExprIsVector(pX->pRight) ){
        disableTerm(pLevel, pEnd);
      }
    }
    start = sqlite3VdbeCurrentAddr(v);
    pLevel->op = bRev ? 39 : 40;
    pLevel->p1 = iCur;
    pLevel->p2 = start;
    ((void) (0));
    if( testOp!=188 ){
      iRowidReg = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, 136, iCur, iRowidReg);
      sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);
                                      ;
                                      ;
                                      ;
                                      ;
      sqlite3VdbeChangeP5(v, 0x43 | 0x10);
    }
  }else if( pLoop->wsFlags & 0x00000200 ){
# 163637 "c_tests/sqlite3.c"
    static const u8 aStartOp[] = {
      0,
      0,
      36,
      32,
      24,
      21,
      23,
      22
    };
    static const u8 aEndOp[] = {
      46,
      42,
      41,
      45,
    };
    u16 nEq = pLoop->u.btree.nEq;
    u16 nBtm = pLoop->u.btree.nBtm;
    u16 nTop = pLoop->u.btree.nTop;
    int regBase;
    WhereTerm *pRangeStart = 0;
    WhereTerm *pRangeEnd = 0;
    int startEq;
    int endEq;
    int start_constraints;
    int nConstraint;
    int iIdxCur;
    int nExtraReg = 0;
    int op;
    char *zStartAff;
    char *zEndAff = 0;
    u8 bSeekPastNull = 0;
    u8 bStopAtNull = 0;
    int omitTable;
    int regBignull = 0;
    int addrSeekScan = 0;

    pIdx = pLoop->u.btree.pIndex;
    iIdxCur = pLevel->iIdxCur;
    ((void) (0));




    j = nEq;
    if( pLoop->wsFlags & 0x00000020 ){
      pRangeStart = pLoop->aLTerm[j++];
      nExtraReg = ((nExtraReg)>(pLoop->u.btree.nBtm)?(nExtraReg):(pLoop->u.btree.nBtm));

      ((void) (0));

    }
    if( pLoop->wsFlags & 0x00000010 ){
      pRangeEnd = pLoop->aLTerm[j++];
      nExtraReg = ((nExtraReg)>(pLoop->u.btree.nTop)?(nExtraReg):(pLoop->u.btree.nTop));

      if( (pRangeEnd->wtFlags & 0x0100)!=0 ){
        ((void) (0));
        ((void) (0));
        pLevel->iLikeRepCntr = (u32)++pParse->nMem;
        sqlite3VdbeAddOp2(v, 72, 1, (int)pLevel->iLikeRepCntr);
                                             ;
        pLevel->addrLikeRep = sqlite3VdbeCurrentAddr(v);


                        ;
                                                         ;
        ((void) (0));
        pLevel->iLikeRepCntr <<=1;
        pLevel->iLikeRepCntr |= bRev ^ (pIdx->aSortOrder[nEq]==1);
      }

      if( pRangeStart==0 ){
        j = pIdx->aiColumn[nEq];
        if( (j>=0 && pIdx->pTable->aCol[j].notNull==0) || j==(-2) ){
          bSeekPastNull = 1;
        }
      }
    }
    ((void) (0));
# 163725 "c_tests/sqlite3.c"
    if( (pLoop->wsFlags & (0x00000010|0x00000020))==0
     && (pLoop->wsFlags & 0x00080000)!=0
    ){
      ((void) (0));
      ((void) (0));
                                ;
      nExtraReg = 1;
      bSeekPastNull = 1;
      pLevel->regBignull = regBignull = ++pParse->nMem;
      if( pLevel->iLeftJoin ){
        sqlite3VdbeAddOp2(v, 72, 0, regBignull);
      }
      pLevel->addrBignull = sqlite3VdbeMakeLabel(pParse);
    }





    if( (nEq<pIdx->nColumn && bRev==(pIdx->aSortOrder[nEq]==0)) ){
      {WhereTerm * t=pRangeEnd; pRangeEnd=pRangeStart; pRangeStart=t;};
      {u8 t=bSeekPastNull; bSeekPastNull=bStopAtNull; bStopAtNull=t;};
      {u8 t=nBtm; nBtm=nTop; nTop=t;};
    }

    if( iLevel>0 && (pLoop->wsFlags & 0x00100000)!=0 ){


      sqlite3VdbeAddOp1(v, 137, iIdxCur);
    }





                                                       ;
    regBase = codeAllEqualityTerms(pParse,pLevel,bRev,nExtraReg,&zStartAff);
    ((void) (0));
    if( zStartAff && nTop ){
      zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);
    }
    addrNxt = (regBignull ? pLevel->addrBignull : pLevel->addrNxt);

                                                                  ;
                                                                  ;
                                                              ;
                                                              ;
    startEq = !pRangeStart || pRangeStart->eOperator & ((0x0002<<(56 -54))|(0x0002<<(58 -54)));
    endEq = !pRangeEnd || pRangeEnd->eOperator & ((0x0002<<(56 -54))|(0x0002<<(58 -54)));
    start_constraints = pRangeStart || nEq>0;


    nConstraint = nEq;
    if( pRangeStart ){
      Expr *pRight = pRangeStart->pExpr->pRight;
      codeExprOrVector(pParse, pRight, regBase+nEq, nBtm);
      whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);
      if( (pRangeStart->wtFlags & 0x0080)==0
       && sqlite3ExprCanBeNull(pRight)
      ){
        sqlite3VdbeAddOp2(v, 51, regBase+nEq, addrNxt);
                       ;
      }
      if( zStartAff ){
        updateRangeAffinityStr(pRight, nBtm, &zStartAff[nEq]);
      }
      nConstraint += nBtm;
                                                     ;
      if( sqlite3ExprIsVector(pRight)==0 ){
        disableTerm(pLevel, pRangeStart);
      }else{
        startEq = 1;
      }
      bSeekPastNull = 0;
    }else if( bSeekPastNull ){
      startEq = 0;
      sqlite3VdbeAddOp2(v, 76, 0, regBase+nEq);
      start_constraints = 1;
      nConstraint++;
    }else if( regBignull ){
      sqlite3VdbeAddOp2(v, 76, 0, regBase+nEq);
      start_constraints = 1;
      nConstraint++;
    }
    codeApplyAffinity(pParse, regBase, nConstraint - bSeekPastNull, zStartAff);
    if( pLoop->nSkip>0 && nConstraint==pLoop->nSkip ){



    }else{
      if( regBignull ){
        sqlite3VdbeAddOp2(v, 72, 1, regBignull);
                                              ;
      }
      if( pLevel->regFilter ){
        sqlite3VdbeAddOp4Int(v, 65, pLevel->regFilter, addrNxt,
                             regBase, nEq);
                       ;
        filterPullDown(pParse, pWInfo, iLevel, addrNxt, notReady);
      }

      op = aStartOp[(start_constraints<<2) + (startEq<<1) + bRev];
      ((void) (0));
      if( (pLoop->wsFlags & 0x00100000)!=0 && op==23 ){
        ((void) (0));
# 163838 "c_tests/sqlite3.c"
        addrSeekScan = sqlite3VdbeAddOp1(v, 125,
                                         (pIdx->aiRowLogEst[0]+9)/10);
        if( pRangeStart || pRangeEnd ){
          sqlite3VdbeChangeP5(v, 1);
          sqlite3VdbeChangeP2(v, addrSeekScan, sqlite3VdbeCurrentAddr(v)+1);
          addrSeekScan = 0;
        }
                       ;
      }
      sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
                     ;
                                      ; ;
                                    ; ;
                                      ; ;
                                      ; ;
                                      ; ;
                                      ; ;

      ((void) (0));
      if( regBignull ){
        ((void) (0));
        ((void) (0));
        ((void) (0));
        sqlite3VdbeAddOp2(v, 9, 0, sqlite3VdbeCurrentAddr(v)+2);
        op = aStartOp[(nConstraint>1)*4 + 2 + bRev];
        sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase,
                             nConstraint-startEq);
                       ;
                                        ; ;
                                      ; ;
                                        ; ;
                                        ; ;
        ((void) (0));
      }
    }




    nConstraint = nEq;
    ((void) (0));
    if( pRangeEnd ){
      Expr *pRight = pRangeEnd->pExpr->pRight;
      ((void) (0));
      codeExprOrVector(pParse, pRight, regBase+nEq, nTop);
      whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);
      if( (pRangeEnd->wtFlags & 0x0080)==0
       && sqlite3ExprCanBeNull(pRight)
      ){
        sqlite3VdbeAddOp2(v, 51, regBase+nEq, addrNxt);
                       ;
      }
      if( zEndAff ){
        updateRangeAffinityStr(pRight, nTop, zEndAff);
        codeApplyAffinity(pParse, regBase+nEq, nTop, zEndAff);
      }else{
        ((void) (0));
      }
      nConstraint += nTop;
                                                   ;

      if( sqlite3ExprIsVector(pRight)==0 ){
        disableTerm(pLevel, pRangeEnd);
      }else{
        endEq = 1;
      }
    }else if( bStopAtNull ){
      if( regBignull==0 ){
        sqlite3VdbeAddOp2(v, 76, 0, regBase+nEq);
        endEq = 0;
      }
      nConstraint++;
    }
    if( zStartAff ) sqlite3DbNNFreeNN(db, zStartAff);
    if( zEndAff ) sqlite3DbNNFreeNN(db, zEndAff);


    pLevel->p2 = sqlite3VdbeCurrentAddr(v);


    if( nConstraint ){
      if( regBignull ){

        sqlite3VdbeAddOp2(v, 17, regBignull, sqlite3VdbeCurrentAddr(v)+3);
                                                 ;
                       ;
      }
      op = aEndOp[bRev*2 + endEq];
      sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
                              ; ;
                              ; ;
                              ; ;
                              ; ;
      if( addrSeekScan ) sqlite3VdbeJumpHere(v, addrSeekScan);
    }
    if( regBignull ){


      ((void) (0));
      ((void) (0));
      ((void) (0));
      sqlite3VdbeAddOp2(v, 16, regBignull, sqlite3VdbeCurrentAddr(v)+2);
                                               ;
                     ;
      op = aEndOp[bRev*2 + bSeekPastNull];
      sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase,
                           nConstraint+bSeekPastNull);
                              ; ;
                              ; ;
                              ; ;
                              ; ;
    }

    if( (pLoop->wsFlags & 0x00040000)!=0 ){
      sqlite3VdbeAddOp3(v, 126, iIdxCur, nEq, nEq);
    }


    omitTable = (pLoop->wsFlags & 0x00000040)!=0
           && (pWInfo->wctrlFlags & (0x0020|0x1000))==0;
    if( omitTable ){

    }else if( (((pIdx->pTable)->tabFlags & 0x00000080)==0) ){
      codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);
    }else if( iCur!=iIdxCur ){
      Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);
      iRowidReg = sqlite3GetTempRange(pParse, pPk->nKeyCol);
      for(j=0; j<pPk->nKeyCol; j++){
        k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);
        sqlite3VdbeAddOp3(v, 95, iIdxCur, k, iRowidReg+j);
      }
      sqlite3VdbeAddOp4Int(v, 28, iCur, addrCont,
                           iRowidReg, pPk->nKeyCol); ;
    }

    if( pLevel->iLeftJoin==0 ){
# 163982 "c_tests/sqlite3.c"
      if( pIdx->pPartIdxWhere && pLevel->pRJ==0 ){
        whereApplyPartialIndexConstraints(pIdx->pPartIdxWhere, iCur, pWC);
      }
    }else{
                                     ;



      ((void) (0));
    }


    if( (pLoop->wsFlags & 0x00001000)
     || (pLevel->u.in.nIn && regBignull==0 && whereLoopIsOneRow(pLoop))
    ){
      pLevel->op = 188;
    }else if( bRev ){
      pLevel->op = 39;
    }else{
      pLevel->op = 40;
    }
    pLevel->p1 = iIdxCur;
    pLevel->p3 = (pLoop->wsFlags&0x00010000)!=0 ? 1:0;
    if( (pLoop->wsFlags & 0x0000000f)==0 ){
      pLevel->p5 = 1;
    }else{
      ((void) (0));
    }
    if( omitTable ) pIdx = 0;
  }else


  if( pLoop->wsFlags & 0x00002000 ){
# 164058 "c_tests/sqlite3.c"
    WhereClause *pOrWc;
    SrcList *pOrTab;
    Index *pCov = 0;
    int iCovCur = pParse->nTab++;

    int regReturn = ++pParse->nMem;
    int regRowset = 0;
    int regRowid = 0;
    int iLoopBody = sqlite3VdbeMakeLabel(pParse);
    int iRetInit;
    int untestedTerms = 0;
    int ii;
    Expr *pAndExpr = 0;
    Table *pTab = pTabItem->pSTab;

    pTerm = pLoop->aLTerm[0];
    ((void) (0));
    ((void) (0));
    ((void) (0));
    pOrWc = &pTerm->u.pOrInfo->wc;
    pLevel->op = 68;
    pLevel->p1 = regReturn;





    if( pWInfo->nLevel>1 ){
      int nNotReady;
      SrcItem *origSrc;
      nNotReady = pWInfo->nLevel - iLevel - 1;
      pOrTab = sqlite3DbMallocRawNN(db, (__builtin_offsetof(SrcList, a)+(nNotReady+1)*sizeof(SrcItem)));
      if( pOrTab==0 ) return notReady;
      pOrTab->nAlloc = (u8)(nNotReady + 1);
      pOrTab->nSrc = pOrTab->nAlloc;
      memcpy(pOrTab->a, pTabItem, sizeof(*pTabItem));
      origSrc = pWInfo->pTabList->a;
      for(k=1; k<=nNotReady; k++){
        memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof(pOrTab->a[k]));
      }
    }else{
      pOrTab = pWInfo->pTabList;
    }
# 164114 "c_tests/sqlite3.c"
    if( (pWInfo->wctrlFlags & 0x0010)==0 ){
      if( (((pTab)->tabFlags & 0x00000080)==0) ){
        regRowset = ++pParse->nMem;
        sqlite3VdbeAddOp2(v, 76, 0, regRowset);
      }else{
        Index *pPk = sqlite3PrimaryKeyIndex(pTab);
        regRowset = pParse->nTab++;
        sqlite3VdbeAddOp2(v, 119, regRowset, pPk->nKeyCol);
        sqlite3VdbeSetP4KeyInfo(pParse, pPk);
      }
      regRowid = ++pParse->nMem;
    }
    iRetInit = sqlite3VdbeAddOp2(v, 72, 0, regReturn);
# 164156 "c_tests/sqlite3.c"
    if( pWC->nTerm>1 ){
      int iTerm;
      for(iTerm=0; iTerm<pWC->nTerm; iTerm++){
        Expr *pExpr = pWC->a[iTerm].pExpr;
        if( &pWC->a[iTerm] == pTerm ) continue;
                                                        ;
                                                      ;
                                                      ;
        if( (pWC->a[iTerm].wtFlags & (0x0002|0x0004|0x8000))!=0 ){
          continue;
        }
        if( (pWC->a[iTerm].eOperator & 0x3fff)==0 ) continue;
        if( (((pExpr)->flags&(u32)(0x400000))!=0) ) continue;
        pExpr = sqlite3ExprDup(db, pExpr, 0);
        pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);
      }
      if( pAndExpr ){





        pAndExpr = sqlite3PExpr(pParse, 44|0x10000, 0, pAndExpr);
      }
    }





    sqlite3VdbeExplain (pParse, 1, "MULTI-INDEX OR");
    for(ii=0; ii<pOrWc->nTerm; ii++){
      WhereTerm *pOrTerm = &pOrWc->a[ii];
      if( pOrTerm->leftCursor==iCur || (pOrTerm->eOperator & 0x0400)!=0 ){
        WhereInfo *pSubWInfo;
        Expr *pOrExpr = pOrTerm->pExpr;
        Expr *pDelete;
        int jmp1 = 0;


         ;
        pDelete = pOrExpr = sqlite3ExprDup(db, pOrExpr, 0);
        if( db->mallocFailed ){
          sqlite3ExprDelete(db, pDelete);
          continue;
        }
        if( pAndExpr ){
          pAndExpr->pLeft = pOrExpr;
          pOrExpr = pAndExpr;
        }

        sqlite3VdbeExplain (pParse, 1, "INDEX %d", ii+1);
                                                            ;
        pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, 0, 0, 0,
                                      0x0020, iCovCur);
        ((void) (0));
        if( pSubWInfo ){
          WhereLoop *pSubLoop;
          int addrExplain = sqlite3WhereExplainOneScan(
              pParse, pOrTab, &pSubWInfo->a[0], 0
          );
          ((void)addrExplain);






          if( (pWInfo->wctrlFlags & 0x0010)==0 ){
            int iSet = ((ii==pOrWc->nTerm-1)?-1:ii);
            if( (((pTab)->tabFlags & 0x00000080)==0) ){
              sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, -1, regRowid);
              jmp1 = sqlite3VdbeAddOp4Int(v, 48, regRowset, 0,
                                          regRowid, iSet);
                             ;
            }else{
              Index *pPk = sqlite3PrimaryKeyIndex(pTab);
              int nPk = pPk->nKeyCol;
              int iPk;
              int r;


              r = sqlite3GetTempRange(pParse, nPk);
              for(iPk=0; iPk<nPk; iPk++){
                int iCol = pPk->aiColumn[iPk];
                sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol,r+iPk);
              }
# 164255 "c_tests/sqlite3.c"
              if( iSet ){
                jmp1 = sqlite3VdbeAddOp4Int(v, 29, regRowset, 0, r, nPk);
                               ;
              }
              if( iSet>=0 ){
                sqlite3VdbeAddOp3(v, 98, r, nPk, regRowid);
                sqlite3VdbeAddOp4Int(v, 139, regRowset, regRowid,
                                     r, nPk);
                if( iSet ) sqlite3VdbeChangeP5(v, 0x10);
              }


              sqlite3ReleaseTempRange(pParse, r, nPk);
            }
          }


          sqlite3VdbeAddOp2(v, 10, regReturn, iLoopBody);



          if( jmp1 ) sqlite3VdbeJumpHere(v, jmp1);






          if( pSubWInfo->untestedTerms ) untestedTerms = 1;
# 164297 "c_tests/sqlite3.c"
          pSubLoop = pSubWInfo->a[0].pWLoop;
          ((void) (0));
          if( (pSubLoop->wsFlags & 0x00000200)!=0
           && (ii==0 || pSubLoop->u.btree.pIndex==pCov)
           && ((((pTab)->tabFlags & 0x00000080)==0) || !((pSubLoop->u.btree.pIndex)->idxType==2))
          ){
            ((void) (0));
            pCov = pSubLoop->u.btree.pIndex;
          }else{
            pCov = 0;
          }
          if( sqlite3WhereUsesDeferredSeek(pSubWInfo) ){
            pWInfo->bDeferredSeek = 1;
          }


          sqlite3WhereEnd(pSubWInfo);
          sqlite3VdbeExplainPop(pParse);
        }
        sqlite3ExprDelete(db, pDelete);
      }
    }
    sqlite3VdbeExplainPop(pParse);
    ((void) (0));
    ((void) (0));
    ((void) (0));
    pLevel->u.pCoveringIdx = pCov;
    if( pCov ) pLevel->iIdxCur = iCovCur;
    if( pAndExpr ){
      pAndExpr->pLeft = 0;
      sqlite3ExprDelete(db, pAndExpr);
    }
    sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));
    sqlite3VdbeGoto(v, pLevel->addrBrk);
    sqlite3VdbeResolveLabel(v, iLoopBody);






    ((void) (0));
    pLevel->p2 = sqlite3VdbeCurrentAddr(v);

    if( pWInfo->nLevel>1 ){ sqlite3DbFreeNN(db, pOrTab); }
    if( !untestedTerms ) disableTerm(pLevel, pTerm);
  }else


  {



    static const u8 aStep[] = { 40, 39 };
    static const u8 aStart[] = { 36, 32 };
    ((void) (0));
    if( pTabItem->fg.isRecursive ){


      pLevel->op = 188;
    }else{
                                                 ;
      pLevel->op = aStep[bRev];
      pLevel->p1 = iCur;
      pLevel->p2 = 1 + sqlite3VdbeAddOp2(v, aStart[bRev],iCur,pLevel->addrHalt);
                                ;
                                ;
      pLevel->p5 = 1;
    }
  }
# 164392 "c_tests/sqlite3.c"
  iLoop = (pIdx ? 1 : 2);
  do{
    int iNext = 0;
    for(pTerm=pWC->a, j=pWC->nTerm; j>0; j--, pTerm++){
      Expr *pE;
      int skipLikeAddr = 0;
                                               ;
                                             ;
      if( pTerm->wtFlags & (0x0002|0x0004) ) continue;
      if( (pTerm->prereqAll & pLevel->notReady)!=0 ){

                                                             ;
        pWInfo->untestedTerms = 1;
        continue;
      }
      pE = pTerm->pExpr;
      ((void) (0));
      if( pTabItem->fg.jointype & (0x08|0x40|0x10) ){
        if( !(((pE)->flags&(u32)(0x000001|0x000002))!=0) ){


          continue;
        }else if( (pTabItem->fg.jointype & 0x08)==0x08
               && !(((pE)->flags&(u32)(0x000001))!=0) ){
          continue;
        }else{
          Bitmask m = sqlite3WhereGetMask(&pWInfo->sMaskSet, pE->w.iJoin);
          if( m & pLevel->notReady ){

            continue;
          }
        }
      }
      if( iLoop==1 && !sqlite3ExprCoveredByIndex(pE, pLevel->iTabCur, pIdx) ){
        iNext = 2;
        continue;
      }
      if( iLoop<3 && (pTerm->wtFlags & 0x1000) ){
        if( iNext==0 ) iNext = 3;
        continue;
      }

      if( (pTerm->wtFlags & 0x0200)!=0 ){
# 164443 "c_tests/sqlite3.c"
        u32 x = pLevel->iLikeRepCntr;
        if( x>0 ){
          skipLikeAddr = sqlite3VdbeAddOp1(v, (x&1)?17:16,(int)(x>>1));
                                     ;
                                     ;
        }

      }
# 164461 "c_tests/sqlite3.c"
      sqlite3ExprIfFalse(pParse, pE, addrCont, 0x10);
      if( skipLikeAddr ) sqlite3VdbeJumpHere(v, skipLikeAddr);
      pTerm->wtFlags |= 0x0004;
    }
    iLoop = iNext;
  }while( iLoop>0 );
# 164476 "c_tests/sqlite3.c"
  for(pTerm=pWC->a, j=pWC->nBase; j>0; j--, pTerm++){
    Expr *pE, sEAlt;
    WhereTerm *pAlt;
    if( pTerm->wtFlags & (0x0002|0x0004) ) continue;
    if( (pTerm->eOperator & (0x0002|0x0080))==0 ) continue;
    if( (pTerm->eOperator & 0x0800)==0 ) continue;
    if( pTerm->leftCursor!=iCur ) continue;
    if( pTabItem->fg.jointype & (0x08|0x40|0x10) ) continue;
    pE = pTerm->pExpr;






    ((void) (0));
    ((void) (0));
    ((void) (0));
    pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm->u.x.leftColumn, notReady,
                    0x0002|0x0001|0x0080, 0);
    if( pAlt==0 ) continue;
    if( pAlt->wtFlags & (0x0004) ) continue;
    if( (pAlt->eOperator & 0x0001)
     && (((pAlt->pExpr)->flags&0x001000)!=0)
     && (pAlt->pExpr->x.pSelect->pEList->nExpr>1)
    ){
      continue;
    }
                                       ;
                                       ;
                                       ;
                                                         ;
    sEAlt = *pAlt->pExpr;
    sEAlt.pLeft = pE->pLeft;
    sqlite3ExprIfFalse(pParse, &sEAlt, addrCont, 0x10);
    pAlt->wtFlags |= 0x0004;
  }




  if( pLevel->pRJ ){
    Table *pTab;
    int nPk;
    int r;
    int jmp1 = 0;
    WhereRightJoin *pRJ = pLevel->pRJ;






    pTab = pWInfo->pTabList->a[pLevel->iFrom].pSTab;
    if( (((pTab)->tabFlags & 0x00000080)==0) ){
      r = sqlite3GetTempRange(pParse, 2);
      sqlite3ExprCodeGetColumnOfTable(v, pTab, pLevel->iTabCur, -1, r+1);
      nPk = 1;
    }else{
      int iPk;
      Index *pPk = sqlite3PrimaryKeyIndex(pTab);
      nPk = pPk->nKeyCol;
      r = sqlite3GetTempRange(pParse, nPk+1);
      for(iPk=0; iPk<nPk; iPk++){
        int iCol = pPk->aiColumn[iPk];
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol,r+1+iPk);
      }
    }
    jmp1 = sqlite3VdbeAddOp4Int(v, 29, pRJ->iMatch, 0, r+1, nPk);
                   ;
                                                     ;
    sqlite3VdbeAddOp3(v, 98, r+1, nPk, r);
    sqlite3VdbeAddOp4Int(v, 139, pRJ->iMatch, r, r+1, nPk);
    sqlite3VdbeAddOp4Int(v, 184, pRJ->regBloom, 0, r+1, nPk);
    sqlite3VdbeChangeP5(v, 0x10);
    sqlite3VdbeJumpHere(v, jmp1);
    sqlite3ReleaseTempRange(pParse, r, nPk+1);
  }




  if( pLevel->iLeftJoin ){
    pLevel->addrFirst = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp2(v, 72, 1, pLevel->iLeftJoin);
                                            ;
    if( pLevel->pRJ==0 ){
      goto code_outer_join_constraints;
    }
  }

  if( pLevel->pRJ ){






    WhereRightJoin *pRJ = pLevel->pRJ;
    sqlite3VdbeAddOp2(v, 75, 0, pRJ->regReturn);
    pRJ->addrSubrtn = sqlite3VdbeCurrentAddr(v);
    ((void) (0));
    pParse->withinRJSubrtn++;






  code_outer_join_constraints:
    for(pTerm=pWC->a, j=0; j<pWC->nBase; j++, pTerm++){
                                               ;
                                             ;
      if( pTerm->wtFlags & (0x0002|0x0004) ) continue;
      if( (pTerm->prereqAll & pLevel->notReady)!=0 ){
        ((void) (0));
        continue;
      }
      if( pTabItem->fg.jointype & 0x40 ) continue;
      ((void) (0));
      sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, 0x10);
      pTerm->wtFlags |= 0x0004;
    }
  }
# 164612 "c_tests/sqlite3.c"
  return pLevel->notReady;
}





static __attribute__((noinline)) void sqlite3WhereRightJoinLoop(
  WhereInfo *pWInfo,
  int iLevel,
  WhereLevel *pLevel
){
  Parse *pParse = pWInfo->pParse;
  Vdbe *v = pParse->pVdbe;
  WhereRightJoin *pRJ = pLevel->pRJ;
  Expr *pSubWhere = 0;
  WhereClause *pWC = &pWInfo->sWC;
  WhereInfo *pSubWInfo;
  WhereLoop *pLoop = pLevel->pWLoop;
  SrcItem *pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];
  SrcList *pFrom;
  union {
    SrcList sSrc;
    u8 fromSpace[(__builtin_offsetof(SrcList, a)+sizeof(SrcItem))];
  } uSrc;
  Bitmask mAll = 0;
  int k;

  sqlite3VdbeExplain (pParse, 1, "RIGHT-JOIN %s", pTabItem->pSTab->zName);

                                                 ;
  for(k=0; k<iLevel; k++){
    int iIdxCur;
    SrcItem *pRight;
    ((void) (0));
    pRight = &pWInfo->pTabList->a[pWInfo->a[k].iFrom];
    mAll |= pWInfo->a[k].pWLoop->maskSelf;
    if( pRight->fg.viaCoroutine ){
      Subquery *pSubq;
      ((void) (0));
      pSubq = pRight->u4.pSubq;
      ((void) (0));
      sqlite3VdbeAddOp3(
          v, 76, 0, pSubq->regResult,
          pSubq->regResult + pSubq->pSelect->pEList->nExpr-1
      );
    }
    sqlite3VdbeAddOp1(v, 137, pWInfo->a[k].iTabCur);
    iIdxCur = pWInfo->a[k].iIdxCur;
    if( iIdxCur ){
      sqlite3VdbeAddOp1(v, 137, iIdxCur);
    }
  }
  if( (pTabItem->fg.jointype & 0x40)==0 ){
    mAll |= pLoop->maskSelf;
    for(k=0; k<pWC->nTerm; k++){
      WhereTerm *pTerm = &pWC->a[k];
      if( (pTerm->wtFlags & (0x0002|0x8000))!=0
       && pTerm->eOperator!=0x2000
      ){
        break;
      }
      if( pTerm->prereqAll & ~mAll ) continue;
      if( (((pTerm->pExpr)->flags&(u32)(0x000001|0x000002))!=0) ) continue;
      pSubWhere = sqlite3ExprAnd(pParse, pSubWhere,
                                 sqlite3ExprDup(pParse->db, pTerm->pExpr, 0));
    }
  }
  pFrom = &uSrc.sSrc;
  pFrom->nSrc = 1;
  pFrom->nAlloc = 1;
  memcpy(&pFrom->a[0], pTabItem, sizeof(SrcItem));
  pFrom->a[0].fg.jointype = 0;
  ((void) (0));
  pParse->withinRJSubrtn++;
  pSubWInfo = sqlite3WhereBegin(pParse, pFrom, pSubWhere, 0, 0, 0,
                                0x1000, 0);
  if( pSubWInfo ){
    int iCur = pLevel->iTabCur;
    int r = ++pParse->nMem;
    int nPk;
    int jmp;
    int addrCont = sqlite3WhereContinueLabel(pSubWInfo);
    Table *pTab = pTabItem->pSTab;
    if( (((pTab)->tabFlags & 0x00000080)==0) ){
      sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, -1, r);
      nPk = 1;
    }else{
      int iPk;
      Index *pPk = sqlite3PrimaryKeyIndex(pTab);
      nPk = pPk->nKeyCol;
      pParse->nMem += nPk - 1;
      for(iPk=0; iPk<nPk; iPk++){
        int iCol = pPk->aiColumn[iPk];
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol,r+iPk);
      }
    }
    jmp = sqlite3VdbeAddOp4Int(v, 65, pRJ->regBloom, 0, r, nPk);
                   ;
    sqlite3VdbeAddOp4Int(v, 29, pRJ->iMatch, addrCont, r, nPk);
                   ;
    sqlite3VdbeJumpHere(v, jmp);
    sqlite3VdbeAddOp2(v, 10, pRJ->regReturn, pRJ->addrSubrtn);
    sqlite3WhereEnd(pSubWInfo);
  }
  sqlite3ExprDelete(pParse->db, pSubWhere);
  sqlite3VdbeExplainPop(pParse);
  ((void) (0));
  pParse->withinRJSubrtn--;
}
# 164747 "c_tests/sqlite3.c"
static void exprAnalyze(SrcList*, WhereClause*, int);




static void whereOrInfoDelete(sqlite3 *db, WhereOrInfo *p){
  sqlite3WhereClauseClear(&p->wc);
  sqlite3DbFree(db, p);
}




static void whereAndInfoDelete(sqlite3 *db, WhereAndInfo *p){
  sqlite3WhereClauseClear(&p->wc);
  sqlite3DbFree(db, p);
}
# 164784 "c_tests/sqlite3.c"
static int whereClauseInsert(WhereClause *pWC, Expr *p, u16 wtFlags){
  WhereTerm *pTerm;
  int idx;
                                    ;
  if( pWC->nTerm>=pWC->nSlot ){
    WhereTerm *pOld = pWC->a;
    sqlite3 *db = pWC->pWInfo->pParse->db;
    pWC->a = sqlite3WhereMalloc(pWC->pWInfo, sizeof(pWC->a[0])*pWC->nSlot*2 );
    if( pWC->a==0 ){
      if( wtFlags & 0x0001 ){
        sqlite3ExprDelete(db, p);
      }
      pWC->a = pOld;
      return 0;
    }
    memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm);
    pWC->nSlot = pWC->nSlot*2;
  }
  pTerm = &pWC->a[idx = pWC->nTerm++];
  if( (wtFlags & 0x0002)==0 ) pWC->nBase = pWC->nTerm;
  if( p && (((p)->flags&(u32)(0x080000))!=0) ){
    pTerm->truthProb = sqlite3LogEst(p->iTable) - 270;
  }else{
    pTerm->truthProb = 1;
  }
  pTerm->pExpr = sqlite3ExprSkipCollateAndLikely(p);
  pTerm->wtFlags = wtFlags;
  pTerm->pWC = pWC;
  pTerm->iParent = -1;
  memset(&pTerm->eOperator, 0,
         sizeof(WhereTerm) - __builtin_offsetof(WhereTerm, eOperator));
  return idx;
}






static int allowedOp(int op){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( op>58 ) return 0;
  if( op>=54 ) return 1;
  return op==50 || op==51 || op==45;
}





static u16 exprCommute(Parse *pParse, Expr *pExpr){
  if( pExpr->pLeft->op==177
   || pExpr->pRight->op==177
   || sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft, pExpr->pRight) !=
      sqlite3BinaryCompareCollSeq(pParse, pExpr->pRight, pExpr->pLeft)
  ){
    pExpr->flags ^= 0x000400;
  }
  {Expr* t=pExpr->pRight; pExpr->pRight=pExpr->pLeft; pExpr->pLeft=t;};
  if( pExpr->op>=55 ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    pExpr->op = ((pExpr->op-55)^2)+55;
  }
  return 0;
}




static u16 operatorMask(int op){
  u16 c;
  ((void) (0));
  if( op>=54 ){
    ((void) (0));
    c = (u16)(0x0002<<(op-54));
  }else if( op==50 ){
    c = 0x0001;
  }else if( op==51 ){
    c = 0x0100;
  }else{
    ((void) (0));
    c = 0x0080;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return c;
}
# 164902 "c_tests/sqlite3.c"
static int isLikeOrGlob(
  Parse *pParse,
  Expr *pExpr,
  Expr **ppPrefix,
  int *pisComplete,
  int *pnoCase
){
  const u8 *z = 0;
  Expr *pRight, *pLeft;
  ExprList *pList;
  u8 c;
  int cnt;
  u8 wc[4];
  sqlite3 *db = pParse->db;
  sqlite3_value *pVal = 0;
  int op;
  int rc;

  if( !sqlite3IsLikeFunction(db, pExpr, pnoCase, (char*)wc) ){
    return 0;
  }



  ((void) (0));
  pList = pExpr->x.pList;
  pLeft = pList->a[1].pExpr;

  pRight = sqlite3ExprSkipCollate(pList->a[0].pExpr);
  op = pRight->op;
  if( op==157 && (db->flags & 0x00800000)==0 ){
    Vdbe *pReprepare = pParse->pReprepare;
    int iCol = pRight->iColumn;
    pVal = sqlite3VdbeGetBoundValue(pReprepare, iCol, 0x41);
    if( pVal && sqlite3_value_type(pVal)==3 ){
      z = sqlite3_value_text(pVal);
    }
    sqlite3VdbeSetVarmask(pParse->pVdbe, iCol);
    ((void) (0));
  }else if( op==118 ){
    ((void) (0));
     z = (u8*)pRight->u.zToken;
  }
  if( z ){






    cnt = 0;
    while( (c=z[cnt])!=0 && c!=wc[0] && c!=wc[1] && c!=wc[2] ){
      cnt++;
      if( c==wc[3] && z[cnt]>0 && z[cnt]<0x80 ){
        cnt++;
      }else if( c>=0x80 ){
        const u8 *z2 = z+cnt-1;
        if( c==0xff || sqlite3Utf8Read(&z2)==0xfffd
         || ((db)->enc)==2
        ){
          cnt--;
          break;
        }else{
          cnt = (int)(z2-z);
        }
      }
    }
# 164978 "c_tests/sqlite3.c"
    if( (cnt>1 || (cnt>0 && z[0]!=wc[3])) && (255!=(u8)z[cnt-1]) ){
      Expr *pPrefix;


      *pisComplete = c==wc[0] && z[cnt+1]==0 && ((db)->enc)!=2;


      pPrefix = sqlite3Expr(db, 118, (char*)z);
      if( pPrefix ){
        int iFrom, iTo;
        char *zNew;
        ((void) (0));
        zNew = pPrefix->u.zToken;
        zNew[cnt] = 0;
        for(iFrom=iTo=0; iFrom<cnt; iFrom++){
          if( zNew[iFrom]==wc[3] ) iFrom++;
          zNew[iTo++] = zNew[iFrom];
        }
        zNew[iTo] = 0;
        ((void) (0));
# 165012 "c_tests/sqlite3.c"
        if( pLeft->op!=168
         || sqlite3ExprAffinity(pLeft)!=0x42
         || (((((pLeft)->flags&(0x1000000|0x2000000))==0))
             && (pLeft->y.pTab)
             && ((pLeft->y.pTab)->eTabType==1))
        ){
          int isNum;
          double rDummy;
          isNum = sqlite3AtoF(zNew, &rDummy, iTo, 1);
          if( isNum<=0 ){
            if( iTo==1 && zNew[0]=='-' ){
              isNum = +1;
            }else{
              zNew[iTo-1]++;
              isNum = sqlite3AtoF(zNew, &rDummy, iTo, 1);
              zNew[iTo-1]--;
            }
          }
          if( isNum>0 ){
            sqlite3ExprDelete(db, pPrefix);
            sqlite3ValueFree(pVal);
            return 0;
          }
        }
      }
      *ppPrefix = pPrefix;



      if( op==157 ){
        Vdbe *v = pParse->pVdbe;
        sqlite3VdbeSetVarmask(v, pRight->iColumn);
        ((void) (0));
        if( *pisComplete && pRight->u.zToken[1] ){






          int r1 = sqlite3GetTempReg(pParse);
          sqlite3ExprCodeTarget(pParse, pRight, r1);
          sqlite3VdbeChangeP3(v, sqlite3VdbeCurrentAddr(v)-1, 0);
          sqlite3ReleaseTempReg(pParse, r1);
        }
      }
    }else{
      z = 0;
    }
  }

  rc = (z!=0);
  sqlite3ValueFree(pVal);
  return rc;
}
# 165097 "c_tests/sqlite3.c"
static int isAuxiliaryVtabOperator(
  sqlite3 *db,
  Expr *pExpr,
  unsigned char *peOp2,
  Expr **ppLeft,
  Expr **ppRight
){
  if( pExpr->op==172 ){
    static const struct Op2 {
      const char *zOp;
      unsigned char eOp2;
    } aOp[] = {
      { "match", 64 },
      { "glob", 66 },
      { "like", 65 },
      { "regexp", 67 }
    };
    ExprList *pList;
    Expr *pCol;
    int i;

    ((void) (0));
    pList = pExpr->x.pList;
    if( pList==0 || pList->nExpr!=2 ){
      return 0;
    }
# 165131 "c_tests/sqlite3.c"
    pCol = pList->a[1].pExpr;
    ((void) (0));
    if( ((pCol)->op==168 && (pCol)->y.pTab->eTabType==1) ){
      for(i=0; i<((int)(sizeof(aOp)/sizeof(aOp[0]))); i++){
        ((void) (0));
        if( sqlite3StrICmp(pExpr->u.zToken, aOp[i].zOp)==0 ){
          *peOp2 = aOp[i].eOp2;
          *ppRight = pList->a[0].pExpr;
          *ppLeft = pCol;
          return 1;
        }
      }
    }
# 165155 "c_tests/sqlite3.c"
    pCol = pList->a[0].pExpr;
    ((void) (0));
    ((void) (0));
    if( ((pCol)->op==168 && (pCol)->y.pTab->eTabType==1) ){
      sqlite3_vtab *pVtab;
      sqlite3_module *pMod;
      void (*xNotUsed)(sqlite3_context*,int,sqlite3_value**);
      void *pNotUsed;
      pVtab = sqlite3GetVTable(db, pCol->y.pTab)->pVtab;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      pMod = (sqlite3_module *)pVtab->pModule;
      if( pMod->xFindFunction!=0 ){
        i = pMod->xFindFunction(pVtab,2, pExpr->u.zToken, &xNotUsed, &pNotUsed);
        if( i>=150 ){
          *peOp2 = i;
          *ppRight = pList->a[1].pExpr;
          *ppLeft = pCol;
          return 1;
        }
      }
    }
  }else if( pExpr->op>=54 ){


    ((void) (0));
    ((void) (0));
    ((void) (0));
    return 0;
  }else if( pExpr->op==53 || pExpr->op==46 || pExpr->op==52 ){
    int res = 0;
    Expr *pLeft = pExpr->pLeft;
    Expr *pRight = pExpr->pRight;
    ((void) (0));
    if( ((pLeft)->op==168 && (pLeft)->y.pTab->eTabType==1) ){
      res++;
    }
    ((void) (0));

    if( pRight && ((pRight)->op==168 && (pRight)->y.pTab->eTabType==1) ){
      res++;
      {Expr* t=pLeft; pLeft=pRight; pRight=t;};
    }
    *ppLeft = pLeft;
    *ppRight = pRight;
    if( pExpr->op==53 ) *peOp2 = 68;
    if( pExpr->op==46 ) *peOp2 = 69;
    if( pExpr->op==52 ) *peOp2 = 70;
    return res;
  }
  return 0;
}






static void transferJoinMarkings(Expr *pDerived, Expr *pBase){
  if( pDerived && (((pBase)->flags&(u32)(0x000001|0x000002))!=0) ){
    pDerived->flags |= pBase->flags & (0x000001|0x000002);
    pDerived->w.iJoin = pBase->w.iJoin;
  }
}




static void markTermAsChild(WhereClause *pWC, int iChild, int iParent){
  pWC->a[iChild].iParent = iParent;
  pWC->a[iChild].truthProb = pWC->a[iParent].truthProb;
  pWC->a[iParent].nChild++;
}






static WhereTerm *whereNthSubterm(WhereTerm *pTerm, int N){
  if( pTerm->eOperator!=0x0400 ){
    return N==0 ? pTerm : 0;
  }
  if( N<pTerm->u.pAndInfo->wc.nTerm ){
    return &pTerm->u.pAndInfo->wc.a[N];
  }
  return 0;
}
# 165265 "c_tests/sqlite3.c"
static void whereCombineDisjuncts(
  SrcList *pSrc,
  WhereClause *pWC,
  WhereTerm *pOne,
  WhereTerm *pTwo
){
  u16 eOp = pOne->eOperator | pTwo->eOperator;
  sqlite3 *db;
  Expr *pNew;
  int op;
  int idxNew;

  if( (pOne->wtFlags | pTwo->wtFlags) & 0x0080 ) return;
  if( (pOne->eOperator & (0x0002|(0x0002<<(57 -54))|(0x0002<<(56 -54))|(0x0002<<(55 -54))|(0x0002<<(58 -54))))==0 ) return;
  if( (pTwo->eOperator & (0x0002|(0x0002<<(57 -54))|(0x0002<<(56 -54))|(0x0002<<(55 -54))|(0x0002<<(58 -54))))==0 ) return;
  if( (eOp & (0x0002|(0x0002<<(57 -54))|(0x0002<<(56 -54))))!=eOp
   && (eOp & (0x0002|(0x0002<<(55 -54))|(0x0002<<(58 -54))))!=eOp ) return;
  ((void) (0));
  ((void) (0));
  if( sqlite3ExprCompare(0,pOne->pExpr->pLeft, pTwo->pExpr->pLeft, -1) ) return;
  if( sqlite3ExprCompare(0,pOne->pExpr->pRight, pTwo->pExpr->pRight,-1) )return;

  if( (eOp & (eOp-1))!=0 ){
    if( eOp & ((0x0002<<(57 -54))|(0x0002<<(56 -54))) ){
      eOp = (0x0002<<(56 -54));
    }else{
      ((void) (0));
      eOp = (0x0002<<(58 -54));
    }
  }
  db = pWC->pWInfo->pParse->db;
  pNew = sqlite3ExprDup(db, pOne->pExpr, 0);
  if( pNew==0 ) return;
  for(op=54; eOp!=(0x0002<<(op-54)); op++){ ((void) (0)); }
  pNew->op = op;
  idxNew = whereClauseInsert(pWC, pNew, 0x0002|0x0001);
  exprAnalyze(pSrc, pWC, idxNew);
}
# 165392 "c_tests/sqlite3.c"
static void exprAnalyzeOrTerm(
  SrcList *pSrc,
  WhereClause *pWC,
  int idxTerm
){
  WhereInfo *pWInfo = pWC->pWInfo;
  Parse *pParse = pWInfo->pParse;
  sqlite3 *db = pParse->db;
  WhereTerm *pTerm = &pWC->a[idxTerm];
  Expr *pExpr = pTerm->pExpr;
  int i;
  WhereClause *pOrWc;
  WhereTerm *pOrTerm;
  WhereOrInfo *pOrInfo;
  Bitmask chngToIN;
  Bitmask indexable;






  ((void) (0));
  ((void) (0));
  pTerm->u.pOrInfo = pOrInfo = sqlite3DbMallocZero(db, sizeof(*pOrInfo));
  if( pOrInfo==0 ) return;
  pTerm->wtFlags |= 0x0010;
  pOrWc = &pOrInfo->wc;
  memset(pOrWc->aStatic, 0, sizeof(pOrWc->aStatic));
  sqlite3WhereClauseInit(pOrWc, pWInfo);
  sqlite3WhereSplit(pOrWc, pExpr, 43);
  sqlite3WhereExprAnalyze(pSrc, pOrWc);
  if( db->mallocFailed ) return;
  ((void) (0));




  indexable = ~(Bitmask)0;
  chngToIN = ~(Bitmask)0;
  for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0 && indexable; i--, pOrTerm++){
    if( (pOrTerm->eOperator & 0x01ff)==0 ){
      WhereAndInfo *pAndInfo;
      ((void) (0));
      chngToIN = 0;
      pAndInfo = sqlite3DbMallocRawNN(db, sizeof(*pAndInfo));
      if( pAndInfo ){
        WhereClause *pAndWC;
        WhereTerm *pAndTerm;
        int j;
        Bitmask b = 0;
        pOrTerm->u.pAndInfo = pAndInfo;
        pOrTerm->wtFlags |= 0x0020;
        pOrTerm->eOperator = 0x0400;
        pOrTerm->leftCursor = -1;
        pAndWC = &pAndInfo->wc;
        memset(pAndWC->aStatic, 0, sizeof(pAndWC->aStatic));
        sqlite3WhereClauseInit(pAndWC, pWC->pWInfo);
        sqlite3WhereSplit(pAndWC, pOrTerm->pExpr, 44);
        sqlite3WhereExprAnalyze(pSrc, pAndWC);
        pAndWC->pOuter = pWC;
        if( !db->mallocFailed ){
          for(j=0, pAndTerm=pAndWC->a; j<pAndWC->nTerm; j++, pAndTerm++){
            ((void) (0));
            if( allowedOp(pAndTerm->pExpr->op)
             || pAndTerm->eOperator==0x0040
            ){
              b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pAndTerm->leftCursor);
            }
          }
        }
        indexable &= b;
      }
    }else if( pOrTerm->wtFlags & 0x0008 ){


    }else{
      Bitmask b;
      b = sqlite3WhereGetMask(&pWInfo->sMaskSet, pOrTerm->leftCursor);
      if( pOrTerm->wtFlags & 0x0002 ){
        WhereTerm *pOther = &pOrWc->a[pOrTerm->iParent];
        b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pOther->leftCursor);
      }
      indexable &= b;
      if( (pOrTerm->eOperator & 0x0002)==0 ){
        chngToIN = 0;
      }else{
        chngToIN &= b;
      }
    }
  }





  pOrInfo->indexable = indexable;
  pTerm->eOperator = 0x0200;
  pTerm->leftCursor = -1;
  if( indexable ){
    pWC->hasOr = 1;
  }



  if( indexable && pOrWc->nTerm==2 ){
    int iOne = 0;
    WhereTerm *pOne;
    while( (pOne = whereNthSubterm(&pOrWc->a[0],iOne++))!=0 ){
      int iTwo = 0;
      WhereTerm *pTwo;
      while( (pTwo = whereNthSubterm(&pOrWc->a[1],iTwo++))!=0 ){
        whereCombineDisjuncts(pSrc, pWC, pOne, pTwo);
      }
    }
  }
# 165530 "c_tests/sqlite3.c"
  if( chngToIN ){
    int okToChngToIN = 0;
    int iColumn = -1;
    int iCursor = -1;
    int j = 0;







    for(j=0; j<2 && !okToChngToIN; j++){
      Expr *pLeft = 0;
      pOrTerm = pOrWc->a;
      for(i=pOrWc->nTerm-1; i>=0; i--, pOrTerm++){
        ((void) (0));
        pOrTerm->wtFlags &= ~0x0040;
        if( pOrTerm->leftCursor==iCursor ){


          ((void) (0));
          continue;
        }
        if( (chngToIN & sqlite3WhereGetMask(&pWInfo->sMaskSet,
                                            pOrTerm->leftCursor))==0 ){




                                                    ;
                                                     ;
          ((void) (0));
          continue;
        }
        ((void) (0));
        iColumn = pOrTerm->u.x.leftColumn;
        iCursor = pOrTerm->leftCursor;
        pLeft = pOrTerm->pExpr->pLeft;
        break;
      }
      if( i<0 ){


        ((void) (0));
        ((void) (0));
        ((void) (0));
        break;
      }
                      ;



      okToChngToIN = 1;
      for(; i>=0 && okToChngToIN; i--, pOrTerm++){
        ((void) (0));
        ((void) (0));
        if( pOrTerm->leftCursor!=iCursor ){
          pOrTerm->wtFlags &= ~0x0040;
        }else if( pOrTerm->u.x.leftColumn!=iColumn || (iColumn==(-2)
               && sqlite3ExprCompare(pParse, pOrTerm->pExpr->pLeft, pLeft, -1)
        )){
          okToChngToIN = 0;
        }else{
          int affLeft, affRight;




          affRight = sqlite3ExprAffinity(pOrTerm->pExpr->pRight);
          affLeft = sqlite3ExprAffinity(pOrTerm->pExpr->pLeft);
          if( affRight!=0 && affRight!=affLeft ){
            okToChngToIN = 0;
          }else{
            pOrTerm->wtFlags |= 0x0040;
          }
        }
      }
    }





    if( okToChngToIN ){
      Expr *pDup;
      ExprList *pList = 0;
      Expr *pLeft = 0;
      Expr *pNew;

      for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0; i--, pOrTerm++){
        if( (pOrTerm->wtFlags & 0x0040)==0 ) continue;
        ((void) (0));
        ((void) (0));
        ((void) (0));
        ((void) (0));
        pDup = sqlite3ExprDup(db, pOrTerm->pExpr->pRight, 0);
        pList = sqlite3ExprListAppend(pWInfo->pParse, pList, pDup);
        pLeft = pOrTerm->pExpr->pLeft;
      }
      ((void) (0));
      pDup = sqlite3ExprDup(db, pLeft, 0);
      pNew = sqlite3PExpr(pParse, 50, pDup, 0);
      if( pNew ){
        int idxNew;
        transferJoinMarkings(pNew, pExpr);
        ((void) (0));
        pNew->x.pList = pList;
        idxNew = whereClauseInsert(pWC, pNew, 0x0002|0x0001);
                             ;
        exprAnalyze(pSrc, pWC, idxNew);

        markTermAsChild(pWC, idxNew, idxTerm);
      }else{
        sqlite3ExprListDelete(db, pList);
      }
    }
  }
}
# 165667 "c_tests/sqlite3.c"
static int termIsEquivalence(Parse *pParse, Expr *pExpr, SrcList *pSrc){
  char aff1, aff2;
  CollSeq *pColl;
  if( !(((pParse->db)->dbOptFlags&(0x00000080))==0) ) return 0;
  if( pExpr->op!=54 && pExpr->op!=45 ) return 0;
  if( (((pExpr)->flags&(u32)(0x000001))!=0) ) return 0;
  ((void) (0));
  if( pExpr->op==45
   && pSrc->nSrc>=2
   && (pSrc->a[0].fg.jointype & 0x40)!=0
  ){
    return 0;
  }
  aff1 = sqlite3ExprAffinity(pExpr->pLeft);
  aff2 = sqlite3ExprAffinity(pExpr->pRight);
  if( aff1!=aff2
   && (!((aff1)>=0x43) || !((aff2)>=0x43))
  ){
    return 0;
  }
  pColl = sqlite3ExprCompareCollSeq(pParse, pExpr);
  if( !sqlite3IsBinary(pColl)
   && !sqlite3ExprCollSeqMatch(pParse, pExpr->pLeft, pExpr->pRight)
  ){
    return 0;
  }
  return 1;
}






static Bitmask exprSelectUsage(WhereMaskSet *pMaskSet, Select *pS){
  Bitmask mask = 0;
  while( pS ){
    SrcList *pSrc = pS->pSrc;
    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pEList);
    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pGroupBy);
    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pOrderBy);
    mask |= sqlite3WhereExprUsage(pMaskSet, pS->pWhere);
    mask |= sqlite3WhereExprUsage(pMaskSet, pS->pHaving);
    if( (pSrc!=0) ){
      int i;
      for(i=0; i<pSrc->nSrc; i++){
        if( pSrc->a[i].fg.isSubquery ){
          mask |= exprSelectUsage(pMaskSet, pSrc->a[i].u4.pSubq->pSelect);
        }
        if( pSrc->a[i].fg.isUsing==0 ){
          mask |= sqlite3WhereExprUsage(pMaskSet, pSrc->a[i].u3.pOn);
        }
        if( pSrc->a[i].fg.isTabFunc ){
          mask |= sqlite3WhereExprListUsage(pMaskSet, pSrc->a[i].u1.pFuncArg);
        }
      }
    }
    pS = pS->pPrior;
  }
  return mask;
}
# 165742 "c_tests/sqlite3.c"
static __attribute__((noinline)) int exprMightBeIndexed2(
  SrcList *pFrom,
  int *aiCurCol,
  Expr *pExpr,
  int j
){
  Index *pIdx;
  int i;
  int iCur;
  do{
    iCur = pFrom->a[j].iCursor;
    for(pIdx=pFrom->a[j].pSTab->pIndex; pIdx; pIdx=pIdx->pNext){
      if( pIdx->aColExpr==0 ) continue;
      for(i=0; i<pIdx->nKeyCol; i++){
        if( pIdx->aiColumn[i]!=(-2) ) continue;
        ((void) (0));
        if( sqlite3ExprCompareSkip(pExpr,pIdx->aColExpr->a[i].pExpr,iCur)==0
         && !sqlite3ExprIsConstant(0,pIdx->aColExpr->a[i].pExpr)
        ){
          aiCurCol[0] = iCur;
          aiCurCol[1] = (-2);
          return 1;
        }
      }
    }
  }while( ++j < pFrom->nSrc );
  return 0;
}
static int exprMightBeIndexed(
  SrcList *pFrom,
  int *aiCurCol,
  Expr *pExpr,
  int op
){
  int i;




  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pExpr->op==177 && (op>=55 && (op<=58)) ){
    ((void) (0));
    pExpr = pExpr->x.pList->a[0].pExpr;
  }

  if( pExpr->op==168 ){
    aiCurCol[0] = pExpr->iTable;
    aiCurCol[1] = pExpr->iColumn;
    return 1;
  }

  for(i=0; i<pFrom->nSrc; i++){
    Index *pIdx;
    for(pIdx=pFrom->a[i].pSTab->pIndex; pIdx; pIdx=pIdx->pNext){
      if( pIdx->aColExpr ){
        return exprMightBeIndexed2(pFrom,aiCurCol,pExpr,i);
      }
    }
  }
  return 0;
}
# 165825 "c_tests/sqlite3.c"
static void exprAnalyze(
  SrcList *pSrc,
  WhereClause *pWC,
  int idxTerm
){
  WhereInfo *pWInfo = pWC->pWInfo;
  WhereTerm *pTerm;
  WhereMaskSet *pMaskSet;
  Expr *pExpr;
  Bitmask prereqLeft;
  Bitmask prereqAll;
  Bitmask extraRight = 0;
  Expr *pStr1 = 0;
  int isComplete = 0;
  int noCase = 0;
  int op;
  Parse *pParse = pWInfo->pParse;
  sqlite3 *db = pParse->db;
  unsigned char eOp2 = 0;
  int nLeft;

  if( db->mallocFailed ){
    return;
  }
  ((void) (0));
  pTerm = &pWC->a[idxTerm];



  pMaskSet = &pWInfo->sMaskSet;
  pExpr = pTerm->pExpr;
  ((void) (0));
  ((void) (0));
  pMaskSet->bVarSelect = 0;
  prereqLeft = sqlite3WhereExprUsage(pMaskSet, pExpr->pLeft);
  op = pExpr->op;
  if( op==50 ){
    ((void) (0));
    if( sqlite3ExprCheckIN(pParse, pExpr) ) return;
    if( (((pExpr)->flags&0x001000)!=0) ){
      pTerm->prereqRight = exprSelectUsage(pMaskSet, pExpr->x.pSelect);
    }else{
      pTerm->prereqRight = sqlite3WhereExprListUsage(pMaskSet, pExpr->x.pList);
    }
    prereqAll = prereqLeft | pTerm->prereqRight;
  }else{
    pTerm->prereqRight = sqlite3WhereExprUsage(pMaskSet, pExpr->pRight);
    if( pExpr->pLeft==0
     || (((pExpr)->flags&(u32)(0x001000|0x040000))!=0)
     || pExpr->x.pList!=0
    ){
      prereqAll = sqlite3WhereExprUsageNN(pMaskSet, pExpr);
    }else{
      prereqAll = prereqLeft | pTerm->prereqRight;
    }
  }
  if( pMaskSet->bVarSelect ) pTerm->wtFlags |= 0x1000;
# 165891 "c_tests/sqlite3.c"
  if( (((pExpr)->flags&(u32)(0x000001|0x000002))!=0) ){
    Bitmask x = sqlite3WhereGetMask(pMaskSet, pExpr->w.iJoin);
    if( (((pExpr)->flags&(u32)(0x000001))!=0) ){
      prereqAll |= x;
      extraRight = x-1;

    }else if( (prereqAll>>1)>=x ){
      (pExpr)->flags&=~(u32)(0x000002);
    }
  }
  pTerm->prereqAll = prereqAll;
  pTerm->leftCursor = -1;
  pTerm->iParent = -1;
  pTerm->eOperator = 0;
  if( allowedOp(op) ){
    int aiCurCol[2];
    Expr *pLeft = sqlite3ExprSkipCollate(pExpr->pLeft);
    Expr *pRight = sqlite3ExprSkipCollate(pExpr->pRight);
    u16 opMask = (pTerm->prereqRight & prereqLeft)==0 ? 0x3fff : 0x0800;

    if( pTerm->u.x.iField>0 ){
      ((void) (0));
      ((void) (0));
      ((void) (0));
      pLeft = pLeft->x.pList->a[pTerm->u.x.iField-1].pExpr;
    }

    if( exprMightBeIndexed(pSrc, aiCurCol, pLeft, op) ){
      pTerm->leftCursor = aiCurCol[0];
      ((void) (0));
      pTerm->u.x.leftColumn = aiCurCol[1];
      pTerm->eOperator = operatorMask(op) & opMask;
    }
    if( op==45 ) pTerm->wtFlags |= 0x0800;
    if( pRight
     && exprMightBeIndexed(pSrc, aiCurCol, pRight, op)
     && !(((pRight)->flags&(u32)(0x000020))!=0)
    ){
      WhereTerm *pNew;
      Expr *pDup;
      u16 eExtraOp = 0;
      ((void) (0));
      if( pTerm->leftCursor>=0 ){
        int idxNew;
        pDup = sqlite3ExprDup(db, pExpr, 0);
        if( db->mallocFailed ){
          sqlite3ExprDelete(db, pDup);
          return;
        }
        idxNew = whereClauseInsert(pWC, pDup, 0x0002|0x0001);
        if( idxNew==0 ) return;
        pNew = &pWC->a[idxNew];
        markTermAsChild(pWC, idxNew, idxTerm);
        if( op==45 ) pNew->wtFlags |= 0x0800;
        pTerm = &pWC->a[idxTerm];
        pTerm->wtFlags |= 0x0008;
        ((void) (0));
        if( termIsEquivalence(pParse, pDup, pWInfo->pTabList) ){
          pTerm->eOperator |= 0x0800;
          eExtraOp = 0x0800;
        }
      }else{
        pDup = pExpr;
        pNew = pTerm;
      }
      pNew->wtFlags |= exprCommute(pParse, pDup);
      pNew->leftCursor = aiCurCol[0];
      ((void) (0));
      pNew->u.x.leftColumn = aiCurCol[1];
                                                         ;
      pNew->prereqRight = prereqLeft | extraRight;
      pNew->prereqAll = prereqAll;
      pNew->eOperator = (operatorMask(pDup->op) + eExtraOp) & opMask;
    }else
    if( op==51
     && !(((pExpr)->flags&(u32)(0x000001))!=0)
     && 0==sqlite3ExprCanBeNull(pLeft)
    ){
      ((void) (0));
      pExpr->op = 171;
      pExpr->u.zToken = "false";
      (pExpr)->flags|=(u32)(0x20000000);
      pTerm->prereqAll = 0;
      pTerm->eOperator = 0;
    }
  }
# 165994 "c_tests/sqlite3.c"
  else if( pExpr->op==49 && pWC->op==44 ){
    ExprList *pList;
    int i;
    static const u8 ops[] = {58, 56};
    ((void) (0));
    pList = pExpr->x.pList;
    ((void) (0));
    ((void) (0));
    for(i=0; i<2; i++){
      Expr *pNewExpr;
      int idxNew;
      pNewExpr = sqlite3PExpr(pParse, ops[i],
                             sqlite3ExprDup(db, pExpr->pLeft, 0),
                             sqlite3ExprDup(db, pList->a[i].pExpr, 0));
      transferJoinMarkings(pNewExpr, pExpr);
      idxNew = whereClauseInsert(pWC, pNewExpr, 0x0002|0x0001);
                           ;
      exprAnalyze(pSrc, pWC, idxNew);
      pTerm = &pWC->a[idxTerm];
      markTermAsChild(pWC, idxNew, idxTerm);
    }
  }






  else if( pExpr->op==43 ){
    ((void) (0));
    exprAnalyzeOrTerm(pSrc, pWC, idxTerm);
    pTerm = &pWC->a[idxTerm];
  }







  else if( pExpr->op==52 ){
    if( pExpr->pLeft->op==168
     && pExpr->pLeft->iColumn>=0
     && !(((pExpr)->flags&(u32)(0x000001))!=0)
    ){
      Expr *pNewExpr;
      Expr *pLeft = pExpr->pLeft;
      int idxNew;
      WhereTerm *pNewTerm;

      pNewExpr = sqlite3PExpr(pParse, 55,
                              sqlite3ExprDup(db, pLeft, 0),
                              sqlite3ExprAlloc(db, 122, 0, 0));

      idxNew = whereClauseInsert(pWC, pNewExpr,
                                0x0002|0x0001|0x0080);
      if( idxNew ){
        pNewTerm = &pWC->a[idxNew];
        pNewTerm->prereqRight = 0;
        pNewTerm->leftCursor = pLeft->iTable;
        pNewTerm->u.x.leftColumn = pLeft->iColumn;
        pNewTerm->eOperator = (0x0002<<(55 -54));
        markTermAsChild(pWC, idxNew, idxTerm);
        pTerm = &pWC->a[idxTerm];
        pTerm->wtFlags |= 0x0008;
        pNewTerm->prereqAll = pTerm->prereqAll;
      }
    }
  }
# 166079 "c_tests/sqlite3.c"
  else if( pExpr->op==172
   && pWC->op==44
   && isLikeOrGlob(pParse, pExpr, &pStr1, &isComplete, &noCase)
  ){
    Expr *pLeft;
    Expr *pStr2;
    Expr *pNewExpr1;
    Expr *pNewExpr2;
    int idxNew1;
    int idxNew2;
    const char *zCollSeqName;
    const u16 wtFlags = 0x0100 | 0x0002 | 0x0001;

    ((void) (0));
    pLeft = pExpr->x.pList->a[1].pExpr;
    pStr2 = sqlite3ExprDup(db, pStr1, 0);
    ((void) (0));
    ((void) (0));






    if( noCase && !pParse->db->mallocFailed ){
      int i;
      char c;
      pTerm->wtFlags |= 0x0400;
      for(i=0; (c = pStr1->u.zToken[i])!=0; i++){
        pStr1->u.zToken[i] = ((c)&~(sqlite3CtypeMap[(unsigned char)(c)]&0x20));
        pStr2->u.zToken[i] = (sqlite3UpperToLower[(unsigned char)(c)]);
      }
    }

    if( !db->mallocFailed ){
      u8 *pC;
      pC = (u8*)&pStr2->u.zToken[sqlite3Strlen30(pStr2->u.zToken)-1];
      if( noCase ){






        if( *pC=='A'-1 ) isComplete = 0;
        *pC = sqlite3UpperToLower[*pC];
      }


      while( *pC==0xBF && pC>(u8*)pStr2->u.zToken ){
        *pC = 0x80;
        pC--;
      }
      ((void) (0));
      (*pC)++;
    }
    zCollSeqName = noCase ? "NOCASE" : sqlite3StrBINARY;
    pNewExpr1 = sqlite3ExprDup(db, pLeft, 0);
    pNewExpr1 = sqlite3PExpr(pParse, 58,
           sqlite3ExprAddCollateString(pParse,pNewExpr1,zCollSeqName),
           pStr1);
    transferJoinMarkings(pNewExpr1, pExpr);
    idxNew1 = whereClauseInsert(pWC, pNewExpr1, wtFlags);
                          ;
    pNewExpr2 = sqlite3ExprDup(db, pLeft, 0);
    pNewExpr2 = sqlite3PExpr(pParse, 57,
           sqlite3ExprAddCollateString(pParse,pNewExpr2,zCollSeqName),
           pStr2);
    transferJoinMarkings(pNewExpr2, pExpr);
    idxNew2 = whereClauseInsert(pWC, pNewExpr2, wtFlags);
                          ;
    exprAnalyze(pSrc, pWC, idxNew1);
    exprAnalyze(pSrc, pWC, idxNew2);
    pTerm = &pWC->a[idxTerm];
    if( isComplete ){
      markTermAsChild(pWC, idxNew1, idxTerm);
      markTermAsChild(pWC, idxNew2, idxTerm);
    }
  }
# 166170 "c_tests/sqlite3.c"
  if( (pExpr->op==54 || pExpr->op==45)
   && (nLeft = sqlite3ExprVectorSize(pExpr->pLeft))>1
   && sqlite3ExprVectorSize(pExpr->pRight)==nLeft
   && ( (pExpr->pLeft->flags & 0x001000)==0
     || (pExpr->pRight->flags & 0x001000)==0)
   && pWC->op==44
  ){
    int i;
    for(i=0; i<nLeft; i++){
      int idxNew;
      Expr *pNew;
      Expr *pLeft = sqlite3ExprForVectorField(pParse, pExpr->pLeft, i, nLeft);
      Expr *pRight = sqlite3ExprForVectorField(pParse, pExpr->pRight, i, nLeft);

      pNew = sqlite3PExpr(pParse, pExpr->op, pLeft, pRight);
      transferJoinMarkings(pNew, pExpr);
      idxNew = whereClauseInsert(pWC, pNew, 0x0001|0x8000);
      exprAnalyze(pSrc, pWC, idxNew);
    }
    pTerm = &pWC->a[idxTerm];
    pTerm->wtFlags |= 0x0004|0x0002;
    pTerm->eOperator = 0x2000;
  }
# 166203 "c_tests/sqlite3.c"
  else if( pExpr->op==50
   && pTerm->u.x.iField==0
   && pExpr->pLeft->op==177
   && ((((pExpr)->flags&0x001000)!=0))
   && (pExpr->x.pSelect->pPrior==0 || (pExpr->x.pSelect->selFlags & 0x0000200))

   && pExpr->x.pSelect->pWin==0

   && pWC->op==44
  ){
    int i;
    for(i=0; i<sqlite3ExprVectorSize(pExpr->pLeft); i++){
      int idxNew;
      idxNew = whereClauseInsert(pWC, pExpr, 0x0002|0x8000);
      pWC->a[idxNew].u.x.iField = i+1;
      exprAnalyze(pSrc, pWC, idxNew);
      markTermAsChild(pWC, idxNew, idxTerm);
    }
  }
# 166233 "c_tests/sqlite3.c"
  else if( pWC->op==44 ){
    Expr *pRight = 0, *pLeft = 0;
    int res = isAuxiliaryVtabOperator(db, pExpr, &eOp2, &pLeft, &pRight);
    while( res-- > 0 ){
      int idxNew;
      WhereTerm *pNewTerm;
      Bitmask prereqColumn, prereqExpr;

      prereqExpr = sqlite3WhereExprUsage(pMaskSet, pRight);
      prereqColumn = sqlite3WhereExprUsage(pMaskSet, pLeft);
      if( (prereqExpr & prereqColumn)==0 ){
        Expr *pNewExpr;
        pNewExpr = sqlite3PExpr(pParse, 47,
            0, sqlite3ExprDup(db, pRight, 0));
        if( (((pExpr)->flags&(u32)(0x000001))!=0) && pNewExpr ){
          (pNewExpr)->flags|=(u32)(0x000001);
          pNewExpr->w.iJoin = pExpr->w.iJoin;
        }
        idxNew = whereClauseInsert(pWC, pNewExpr, 0x0002|0x0001);
                             ;
        pNewTerm = &pWC->a[idxNew];
        pNewTerm->prereqRight = prereqExpr | extraRight;
        pNewTerm->leftCursor = pLeft->iTable;
        pNewTerm->u.x.leftColumn = pLeft->iColumn;
        pNewTerm->eOperator = 0x0040;
        pNewTerm->eMatchOp = eOp2;
        markTermAsChild(pWC, idxNew, idxTerm);
        pTerm = &pWC->a[idxTerm];
        pTerm->wtFlags |= 0x0008;
        pNewTerm->prereqAll = pTerm->prereqAll;
      }
      {Expr* t=pLeft; pLeft=pRight; pRight=t;};
    }
  }





                                     ;
  pTerm = &pWC->a[idxTerm];
  pTerm->prereqRight |= extraRight;
}
# 166299 "c_tests/sqlite3.c"
static void sqlite3WhereSplit(WhereClause *pWC, Expr *pExpr, u8 op){
  Expr *pE2 = sqlite3ExprSkipCollateAndLikely(pExpr);
  pWC->op = op;
  ((void) (0));
  if( pE2==0 ) return;
  if( pE2->op!=op ){
    whereClauseInsert(pWC, pExpr, 0);
  }else{
    sqlite3WhereSplit(pWC, pE2->pLeft, op);
    sqlite3WhereSplit(pWC, pE2->pRight, op);
  }
}
# 166323 "c_tests/sqlite3.c"
static void whereAddLimitExpr(
  WhereClause *pWC,
  int iReg,
  Expr *pExpr,
  int iCsr,
  int eMatchOp
){
  Parse *pParse = pWC->pWInfo->pParse;
  sqlite3 *db = pParse->db;
  Expr *pNew;
  int iVal = 0;

  if( sqlite3ExprIsInteger(pExpr, &iVal, pParse) && iVal>=0 ){
    Expr *pVal = sqlite3Expr(db, 156, 0);
    if( pVal==0 ) return;
    (pVal)->flags|=(u32)(0x000800);
    pVal->u.iValue = iVal;
    pNew = sqlite3PExpr(pParse, 47, 0, pVal);
  }else{
    Expr *pVal = sqlite3Expr(db, 176, 0);
    if( pVal==0 ) return;
    pVal->iTable = iReg;
    pNew = sqlite3PExpr(pParse, 47, 0, pVal);
  }
  if( pNew ){
    WhereTerm *pTerm;
    int idx;
    idx = whereClauseInsert(pWC, pNew, 0x0001|0x0002);
    pTerm = &pWC->a[idx];
    pTerm->leftCursor = iCsr;
    pTerm->eOperator = 0x0040;
    pTerm->eMatchOp = eMatchOp;
  }
}
# 166376 "c_tests/sqlite3.c"
static void __attribute__((noinline)) sqlite3WhereAddLimit(WhereClause *pWC, Select *p){
  ((void) (0));
  if( p->pGroupBy==0
   && (p->selFlags & (0x0000001|0x0000008))==0
   && (p->pSrc->nSrc==1 && ((p->pSrc->a[0].pSTab)->eTabType==1))
  ){
    ExprList *pOrderBy = p->pOrderBy;
    int iCsr = p->pSrc->a[0].iCursor;
    int ii;


    for(ii=0; ii<pWC->nTerm; ii++){
      if( pWC->a[ii].wtFlags & 0x0004 ){


        ((void) (0));
        ((void) (0));
        continue;
      }
      if( pWC->a[ii].nChild ){




        continue;
      }
      if( pWC->a[ii].leftCursor==iCsr && pWC->a[ii].prereqRight==0 ) continue;



      if( pWC->a[ii].iParent>=0 ){
        WhereTerm *pParent = &pWC->a[ pWC->a[ii].iParent ];
        if( pParent->leftCursor==iCsr
         && pParent->prereqRight==0
         && pParent->nChild==1
        ){
          continue;
        }
      }


      return;
    }


    if( pOrderBy ){
      for(ii=0; ii<pOrderBy->nExpr; ii++){
        Expr *pExpr = pOrderBy->a[ii].pExpr;
        if( pExpr->op!=168 ) return;
        if( pExpr->iTable!=iCsr ) return;
        if( pOrderBy->a[ii].fg.sortFlags & 0x02 ) return;
      }
    }


    ((void) (0));
    if( p->iOffset!=0 && (p->selFlags & 0x0000100)==0 ){
      whereAddLimitExpr(pWC, p->iOffset, p->pLimit->pRight,
                        iCsr, 74);
    }
    if( p->iOffset==0 || (p->selFlags & 0x0000100)==0 ){
      whereAddLimitExpr(pWC, p->iLimit, p->pLimit->pLeft,
                        iCsr, 73);
    }
  }
}




static void sqlite3WhereClauseInit(
  WhereClause *pWC,
  WhereInfo *pWInfo
){
  pWC->pWInfo = pWInfo;
  pWC->hasOr = 0;
  pWC->pOuter = 0;
  pWC->nTerm = 0;
  pWC->nBase = 0;
  pWC->nSlot = ((int)(sizeof(pWC->aStatic)/sizeof(pWC->aStatic[0])));
  pWC->a = pWC->aStatic;
}






static void sqlite3WhereClauseClear(WhereClause *pWC){
  sqlite3 *db = pWC->pWInfo->pParse->db;
  ((void) (0));
  if( pWC->nTerm>0 ){
    WhereTerm *a = pWC->a;
    WhereTerm *aLast = &pWC->a[pWC->nTerm-1];







    while(1){
      ((void) (0));
      if( a->wtFlags & 0x0001 ){
        sqlite3ExprDelete(db, a->pExpr);
      }
      if( a->wtFlags & (0x0010|0x0020) ){
        if( a->wtFlags & 0x0010 ){
          ((void) (0));
          whereOrInfoDelete(db, a->u.pOrInfo);
        }else{
          ((void) (0));
          whereAndInfoDelete(db, a->u.pAndInfo);
        }
      }
      if( a==aLast ) break;
      a++;
    }
  }
}
# 166529 "c_tests/sqlite3.c"
static __attribute__((noinline)) Bitmask sqlite3WhereExprUsageFull(
  WhereMaskSet *pMaskSet,
  Expr *p
){
  Bitmask mask;
  mask = (p->op==179) ? sqlite3WhereGetMask(pMaskSet, p->iTable) : 0;
  if( p->pLeft ) mask |= sqlite3WhereExprUsageNN(pMaskSet, p->pLeft);
  if( p->pRight ){
    mask |= sqlite3WhereExprUsageNN(pMaskSet, p->pRight);
    ((void) (0));
  }else if( (((p)->flags&0x001000)!=0) ){
    if( (((p)->flags&(u32)(0x000040))!=0) ) pMaskSet->bVarSelect = 1;
    mask |= exprSelectUsage(pMaskSet, p->x.pSelect);
  }else if( p->x.pList ){
    mask |= sqlite3WhereExprListUsage(pMaskSet, p->x.pList);
  }

  if( (p->op==172 || p->op==169) && (((p)->flags&0x1000000)!=0) ){
    ((void) (0));
    mask |= sqlite3WhereExprListUsage(pMaskSet, p->y.pWin->pPartition);
    mask |= sqlite3WhereExprListUsage(pMaskSet, p->y.pWin->pOrderBy);
    mask |= sqlite3WhereExprUsage(pMaskSet, p->y.pWin->pFilter);
  }

  return mask;
}
static Bitmask sqlite3WhereExprUsageNN(WhereMaskSet *pMaskSet, Expr *p){
  if( p->op==168 && !(((p)->flags&(u32)(0x000020))!=0) ){
    return sqlite3WhereGetMask(pMaskSet, p->iTable);
  }else if( (((p)->flags&(u32)(0x010000|0x800000))!=0) ){
    ((void) (0));
    return 0;
  }
  return sqlite3WhereExprUsageFull(pMaskSet, p);
}
static Bitmask sqlite3WhereExprUsage(WhereMaskSet *pMaskSet, Expr *p){
  return p ? sqlite3WhereExprUsageNN(pMaskSet,p) : 0;
}
static Bitmask sqlite3WhereExprListUsage(WhereMaskSet *pMaskSet, ExprList *pList){
  int i;
  Bitmask mask = 0;
  if( pList ){
    for(i=0; i<pList->nExpr; i++){
      mask |= sqlite3WhereExprUsage(pMaskSet, pList->a[i].pExpr);
    }
  }
  return mask;
}
# 166587 "c_tests/sqlite3.c"
static void sqlite3WhereExprAnalyze(
  SrcList *pTabList,
  WhereClause *pWC
){
  int i;
  for(i=pWC->nTerm-1; i>=0; i--){
    exprAnalyze(pTabList, pWC, i);
  }
}
# 166604 "c_tests/sqlite3.c"
static void sqlite3WhereTabFuncArgs(
  Parse *pParse,
  SrcItem *pItem,
  WhereClause *pWC
){
  Table *pTab;
  int j, k;
  ExprList *pArgs;
  Expr *pColRef;
  Expr *pTerm;
  if( pItem->fg.isTabFunc==0 ) return;
  pTab = pItem->pSTab;
  ((void) (0));
  pArgs = pItem->u1.pFuncArg;
  if( pArgs==0 ) return;
  for(j=k=0; j<pArgs->nExpr; j++){
    Expr *pRhs;
    u32 joinType;
    while( k<pTab->nCol && (pTab->aCol[k].colFlags & 0x0002)==0 ){k++;}
    if( k>=pTab->nCol ){
      sqlite3ErrorMsg(pParse, "too many arguments on %s() - max %d",
                      pTab->zName, j);
      return;
    }
    pColRef = sqlite3ExprAlloc(pParse->db, 168, 0, 0);
    if( pColRef==0 ) return;
    pColRef->iTable = pItem->iCursor;
    pColRef->iColumn = k++;
    ((void) (0));
    pColRef->y.pTab = pTab;
    pItem->colUsed |= sqlite3ExprColUsed(pColRef);
    pRhs = sqlite3PExpr(pParse, 173,
        sqlite3ExprDup(pParse->db, pArgs->a[j].pExpr, 0), 0);
    pTerm = sqlite3PExpr(pParse, 54, pColRef, pRhs);
    if( pItem->fg.jointype & (0x08|0x10) ){
                                              ;
                                               ;
      joinType = 0x000001;
    }else{
                                               ;
      joinType = 0x000002;
    }
    sqlite3SetJoinExpr(pTerm, pItem->iCursor, joinType);
    whereClauseInsert(pWC, pTerm, 0x0001);
  }
}
# 166683 "c_tests/sqlite3.c"
typedef struct HiddenIndexInfo HiddenIndexInfo;
struct HiddenIndexInfo {
  WhereClause *pWC;
  Parse *pParse;
  int eDistinct;
  u32 mIn;
  u32 mHandleIn;
  sqlite3_value *aRhs[];


};







static int whereLoopResize(sqlite3*, WhereLoop*, int);




static LogEst sqlite3WhereOutputRowCount(WhereInfo *pWInfo){
  return pWInfo->nRowOut;
}





static int sqlite3WhereIsDistinct(WhereInfo *pWInfo){
  return pWInfo->eDistinct;
}
# 166726 "c_tests/sqlite3.c"
static int sqlite3WhereIsOrdered(WhereInfo *pWInfo){
  return pWInfo->nOBSat<0 ? 0 : pWInfo->nOBSat;
}
# 166753 "c_tests/sqlite3.c"
static int sqlite3WhereOrderByLimitOptLabel(WhereInfo *pWInfo){
  WhereLevel *pInner;
  if( !pWInfo->bOrderedInnerLoop ){


    return pWInfo->iContinue;
  }
  pInner = &pWInfo->a[pWInfo->nLevel-1];
  ((void) (0));
  return pInner->pRJ ? pWInfo->iContinue : pInner->addrNxt;
}
# 166776 "c_tests/sqlite3.c"
static void sqlite3WhereMinMaxOptEarlyOut(Vdbe *v, WhereInfo *pWInfo){
  WhereLevel *pInner;
  int i;
  if( !pWInfo->bOrderedInnerLoop ) return;
  if( pWInfo->nOBSat==0 ) return;
  for(i=pWInfo->nLevel-1; i>=0; i--){
    pInner = &pWInfo->a[i];
    if( (pInner->pWLoop->wsFlags & 0x00000004)!=0 ){
      sqlite3VdbeGoto(v, pInner->addrNxt);
      return;
    }
  }
  sqlite3VdbeGoto(v, pWInfo->iBreak);
}





static int sqlite3WhereContinueLabel(WhereInfo *pWInfo){
  ((void) (0));
  return pWInfo->iContinue;
}





static int sqlite3WhereBreakLabel(WhereInfo *pWInfo){
  return pWInfo->iBreak;
}
# 166825 "c_tests/sqlite3.c"
static int sqlite3WhereOkOnePass(WhereInfo *pWInfo, int *aiCur){
  memcpy(aiCur, pWInfo->aiCurOnePass, sizeof(int)*2);







  return pWInfo->eOnePass;
}





static int sqlite3WhereUsesDeferredSeek(WhereInfo *pWInfo){
  return pWInfo->bDeferredSeek;
}




static void whereOrMove(WhereOrSet *pDest, WhereOrSet *pSrc){
  pDest->n = pSrc->n;
  memcpy(pDest->a, pSrc->a, pDest->n*sizeof(pDest->a[0]));
}
# 166860 "c_tests/sqlite3.c"
static int whereOrInsert(
  WhereOrSet *pSet,
  Bitmask prereq,
  LogEst rRun,
  LogEst nOut
){
  u16 i;
  WhereOrCost *p;
  for(i=pSet->n, p=pSet->a; i>0; i--, p++){
    if( rRun<=p->rRun && (prereq & p->prereq)==prereq ){
      goto whereOrInsert_done;
    }
    if( p->rRun<=rRun && (p->prereq & prereq)==p->prereq ){
      return 0;
    }
  }
  if( pSet->n<3 ){
    p = &pSet->a[pSet->n++];
    p->nOut = nOut;
  }else{
    p = pSet->a;
    for(i=1; i<pSet->n; i++){
      if( p->rRun>pSet->a[i].rRun ) p = pSet->a + i;
    }
    if( p->rRun<=rRun ) return 0;
  }
whereOrInsert_done:
  p->prereq = prereq;
  p->rRun = rRun;
  if( p->nOut>nOut ) p->nOut = nOut;
  return 1;
}





static Bitmask sqlite3WhereGetMask(WhereMaskSet *pMaskSet, int iCursor){
  int i;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pMaskSet->ix[0]==iCursor ){
    return 1;
  }
  for(i=1; i<pMaskSet->n; i++){
    if( pMaskSet->ix[i]==iCursor ){
      return (((Bitmask)1)<<(i));
    }
  }
  return 0;
}



static void *sqlite3WhereMalloc(WhereInfo *pWInfo, u64 nByte){
  WhereMemBlock *pBlock;
  pBlock = sqlite3DbMallocRawNN(pWInfo->pParse->db, nByte+sizeof(*pBlock));
  if( pBlock ){
    pBlock->pNext = pWInfo->pMemToFree;
    pBlock->sz = nByte;
    pWInfo->pMemToFree = pBlock;
    pBlock++;
  }
  return (void*)pBlock;
}
static void *sqlite3WhereRealloc(WhereInfo *pWInfo, void *pOld, u64 nByte){
  void *pNew = sqlite3WhereMalloc(pWInfo, nByte);
  if( pNew && pOld ){
    WhereMemBlock *pOldBlk = (WhereMemBlock*)pOld;
    pOldBlk--;
    ((void) (0));
    memcpy(pNew, pOld, pOldBlk->sz);
  }
  return pNew;
}
# 166945 "c_tests/sqlite3.c"
static void createMask(WhereMaskSet *pMaskSet, int iCursor){
  ((void) (0));
  pMaskSet->ix[pMaskSet->n++] = iCursor;
}





static Expr *whereRightSubexprIsColumn(Expr *p){
  p = sqlite3ExprSkipCollateAndLikely(p->pRight);
  if( (p!=0) && p->op==168 && !(((p)->flags&(u32)(0x000020))!=0) ){
    return p;
  }
  return 0;
}
# 166971 "c_tests/sqlite3.c"
static __attribute__((noinline)) const char *indexInAffinityOk(
  Parse *pParse,
  WhereTerm *pTerm,
  u8 idxaff
){
  Expr *pX = pTerm->pExpr;
  Expr inexpr;

  ((void) (0));

  if( sqlite3ExprIsVector(pX->pLeft) ){
    int iField = pTerm->u.x.iField - 1;
    inexpr.flags = 0;
    inexpr.op = 54;
    inexpr.pLeft = pX->pLeft->x.pList->a[iField].pExpr;
    ((void) (0));
    inexpr.pRight = pX->x.pSelect->pEList->a[iField].pExpr;
    pX = &inexpr;
  }

  if( sqlite3IndexAffinityOk(pX, idxaff) ){
    CollSeq *pRet = sqlite3ExprCompareCollSeq(pParse, pX);
    return pRet ? pRet->zName : sqlite3StrBINARY;
  }
  return 0;
}






static WhereTerm *whereScanNext(WhereScan *pScan){
  int iCur;
  i16 iColumn;
  Expr *pX;
  WhereClause *pWC;
  WhereTerm *pTerm;
  int k = pScan->k;

  ((void) (0));
  pWC = pScan->pWC;
  while(1){
    iColumn = pScan->aiColumn[pScan->iEquiv-1];
    iCur = pScan->aiCur[pScan->iEquiv-1];
    ((void) (0));
    ((void) (0));
    do{
      for(pTerm=pWC->a+k; k<pWC->nTerm; k++, pTerm++){
        ((void) (0));
        if( pTerm->leftCursor==iCur
         && pTerm->u.x.leftColumn==iColumn
         && (iColumn!=(-2)
             || sqlite3ExprCompareSkip(pTerm->pExpr->pLeft,
                                       pScan->pIdxExpr,iCur)==0)
         && (pScan->iEquiv<=1 || !(((pTerm->pExpr)->flags&(u32)(0x000001))!=0))
        ){
          if( (pTerm->eOperator & 0x0800)!=0
           && pScan->nEquiv<((int)(sizeof(pScan->aiCur)/sizeof(pScan->aiCur[0])))
           && (pX = whereRightSubexprIsColumn(pTerm->pExpr))!=0
          ){
            int j;
            for(j=0; j<pScan->nEquiv; j++){
              if( pScan->aiCur[j]==pX->iTable
               && pScan->aiColumn[j]==pX->iColumn ){
                  break;
              }
            }
            if( j==pScan->nEquiv ){
              pScan->aiCur[j] = pX->iTable;
              pScan->aiColumn[j] = pX->iColumn;
              pScan->nEquiv++;
            }
          }
          if( (pTerm->eOperator & pScan->opMask)!=0 ){

            if( pScan->zCollName && (pTerm->eOperator & 0x0100)==0 ){
              const char *zCollName;
              Parse *pParse = pWC->pWInfo->pParse;
              pX = pTerm->pExpr;

              if( (pTerm->eOperator & 0x0001) ){
                zCollName = indexInAffinityOk(pParse, pTerm, pScan->idxaff);
                if( !zCollName ) continue;
              }else{
                CollSeq *pColl;
                if( !sqlite3IndexAffinityOk(pX, pScan->idxaff) ){
                  continue;
                }
                ((void) (0));
                pColl = sqlite3ExprCompareCollSeq(pParse, pX);
                zCollName = pColl ? pColl->zName : sqlite3StrBINARY;
              }

              if( sqlite3StrICmp(zCollName, pScan->zCollName) ){
                continue;
              }
            }
            if( (pTerm->eOperator & (0x0002|0x0080))!=0
             && (pX = pTerm->pExpr->pRight, (pX!=0))
             && pX->op==168
             && pX->iTable==pScan->aiCur[0]
             && pX->iColumn==pScan->aiColumn[0]
            ){
                                                  ;
              continue;
            }
            pScan->pWC = pWC;
            pScan->k = k+1;
# 167092 "c_tests/sqlite3.c"
            return pTerm;
          }
        }
      }
      pWC = pWC->pOuter;
      k = 0;
    }while( pWC!=0 );
    if( pScan->iEquiv>=pScan->nEquiv ) break;
    pWC = pScan->pOrigWC;
    k = 0;
    pScan->iEquiv++;
  }
  return 0;
}







static __attribute__((noinline)) WhereTerm *whereScanInitIndexExpr(WhereScan *pScan){
  pScan->idxaff = sqlite3ExprAffinity(pScan->pIdxExpr);
  return whereScanNext(pScan);
}
# 167137 "c_tests/sqlite3.c"
static WhereTerm *whereScanInit(
  WhereScan *pScan,
  WhereClause *pWC,
  int iCur,
  int iColumn,
  u32 opMask,
  Index *pIdx
){
  pScan->pOrigWC = pWC;
  pScan->pWC = pWC;
  pScan->pIdxExpr = 0;
  pScan->idxaff = 0;
  pScan->zCollName = 0;
  pScan->opMask = opMask;
  pScan->k = 0;
  pScan->aiCur[0] = iCur;
  pScan->nEquiv = 1;
  pScan->iEquiv = 1;
  if( pIdx ){
    int j = iColumn;
    iColumn = pIdx->aiColumn[j];
    if( iColumn==pIdx->pTable->iPKey ){
      iColumn = (-1);
    }else if( iColumn>=0 ){
      pScan->idxaff = pIdx->pTable->aCol[iColumn].affinity;
      pScan->zCollName = pIdx->azColl[j];
    }else if( iColumn==(-2) ){
      pScan->pIdxExpr = pIdx->aColExpr->a[j].pExpr;
      pScan->zCollName = pIdx->azColl[j];
      pScan->aiColumn[0] = (-2);
      return whereScanInitIndexExpr(pScan);
    }
  }else if( iColumn==(-2) ){
    return 0;
  }
  pScan->aiColumn[0] = iColumn;
  return whereScanNext(pScan);
}
# 167201 "c_tests/sqlite3.c"
static WhereTerm *sqlite3WhereFindTerm(
  WhereClause *pWC,
  int iCur,
  int iColumn,
  Bitmask notReady,
  u32 op,
  Index *pIdx
){
  WhereTerm *pResult = 0;
  WhereTerm *p;
  WhereScan scan;

  p = whereScanInit(&scan, pWC, iCur, iColumn, op, pIdx);
  op &= 0x0002|0x0080;
  while( p ){
    if( (p->prereqRight & notReady)==0 ){
      if( p->prereqRight==0 && (p->eOperator&op)!=0 ){
                                        ;
        return p;
      }
      if( pResult==0 ) pResult = p;
    }
    p = whereScanNext(&scan);
  }
  return pResult;
}
# 167235 "c_tests/sqlite3.c"
static int findIndexCol(
  Parse *pParse,
  ExprList *pList,
  int iBase,
  Index *pIdx,
  int iCol
){
  int i;
  const char *zColl = pIdx->azColl[iCol];

  for(i=0; i<pList->nExpr; i++){
    Expr *p = sqlite3ExprSkipCollateAndLikely(pList->a[i].pExpr);
    if( (p!=0)
     && (p->op==168 || p->op==170)
     && p->iColumn==pIdx->aiColumn[iCol]
     && p->iTable==iBase
    ){
      CollSeq *pColl = sqlite3ExprNNCollSeq(pParse, pList->a[i].pExpr);
      if( 0==sqlite3StrICmp(pColl->zName, zColl) ){
        return i;
      }
    }
  }

  return -1;
}




static int indexColumnNotNull(Index *pIdx, int iCol){
  int j;
  ((void) (0));
  ((void) (0));
  j = pIdx->aiColumn[iCol];
  if( j>=0 ){
    return pIdx->pTable->aCol[j].notNull;
  }else if( j==(-1) ){
    return 1;
  }else{
    ((void) (0));
    return 0;

  }
}
# 167288 "c_tests/sqlite3.c"
static int isDistinctRedundant(
  Parse *pParse,
  SrcList *pTabList,
  WhereClause *pWC,
  ExprList *pDistinct
){
  Table *pTab;
  Index *pIdx;
  int i;
  int iBase;




  if( pTabList->nSrc!=1 ) return 0;
  iBase = pTabList->a[0].iCursor;
  pTab = pTabList->a[0].pSTab;





  for(i=0; i<pDistinct->nExpr; i++){
    Expr *p = sqlite3ExprSkipCollateAndLikely(pDistinct->a[i].pExpr);
    if( (p==0) ) continue;
    if( p->op!=168 && p->op!=170 ) continue;
    if( p->iTable==iBase && p->iColumn<0 ) return 1;
  }
# 167330 "c_tests/sqlite3.c"
  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    if( !((pIdx)->onError!=0) ) continue;
    if( pIdx->pPartIdxWhere ) continue;
    for(i=0; i<pIdx->nKeyCol; i++){
      if( 0==sqlite3WhereFindTerm(pWC, iBase, i, ~(Bitmask)0, 0x0002, pIdx) ){
        if( findIndexCol(pParse, pDistinct, iBase, pIdx, i)<0 ) break;
        if( indexColumnNotNull(pIdx, i)==0 ) break;
      }
    }
    if( i==pIdx->nKeyCol ){

      return 1;
    }
  }

  return 0;
}





static LogEst estLog(LogEst N){
  return N<=10 ? 0 : sqlite3LogEst(N) - 33;
}
# 167368 "c_tests/sqlite3.c"
static void translateColumnToCopy(
  Parse *pParse,
  int iStart,
  int iTabCur,
  int iRegister,
  int iAutoidxCur
){
  Vdbe *v = pParse->pVdbe;
  VdbeOp *pOp = sqlite3VdbeGetOp(v, iStart);
  int iEnd = sqlite3VdbeCurrentAddr(v);
  if( pParse->db->mallocFailed ) return;






  for(; iStart<iEnd; iStart++, pOp++){
    if( pOp->p1!=iTabCur ) continue;
    if( pOp->opcode==95 ){





      pOp->opcode = 81;
      pOp->p1 = pOp->p2 + iRegister;
      pOp->p2 = pOp->p3;
      pOp->p3 = 0;
      pOp->p5 = 2;
    }else if( pOp->opcode==136 ){





      pOp->opcode = 127;
      pOp->p1 = iAutoidxCur;






    }
  }
}
# 167484 "c_tests/sqlite3.c"
static int constraintCompatibleWithOuterJoin(
  const WhereTerm *pTerm,
  const SrcItem *pSrc
){
  ((void) (0));
                                                                        ;
                                                                         ;

                                                       ;
  if( !(((pTerm->pExpr)->flags&(u32)(0x000001|0x000002))!=0)
   || pTerm->pExpr->w.iJoin != pSrc->iCursor
  ){
    return 0;
  }
  if( (pSrc->fg.jointype & (0x08|0x10))!=0
   && ((((pTerm->pExpr)->flags&(u32)(0x000002))!=0))
  ){
    return 0;
  }
  return 1;
}
# 167526 "c_tests/sqlite3.c"
static __attribute__((noinline)) int columnIsGoodIndexCandidate(
  const Table *pTab,
  int iCol
){
  const Index *pIdx;
  for(pIdx = pTab->pIndex; pIdx!=0; pIdx=pIdx->pNext){
    int j;
    for(j=0; j<pIdx->nKeyCol; j++){
       if( pIdx->aiColumn[j]==iCol ){
         if( j==0 ) return 0;
         if( pIdx->hasStat1 && pIdx->aiRowLogEst[j+1]>20 ) return 0;
         break;
       }
    }
  }
  return 1;
}
# 167553 "c_tests/sqlite3.c"
static int termCanDriveIndex(
  const WhereTerm *pTerm,
  const SrcItem *pSrc,
  const Bitmask notReady
){
  char aff;
  int leftCol;

  if( pTerm->leftCursor!=pSrc->iCursor ) return 0;
  if( (pTerm->eOperator & (0x0002|0x0080))==0 ) return 0;
  ((void) (0));
  if( (pSrc->fg.jointype & (0x08|0x40|0x10))!=0
   && !constraintCompatibleWithOuterJoin(pTerm,pSrc)
  ){
    return 0;
  }
  if( (pTerm->prereqRight & notReady)!=0 ) return 0;
  ((void) (0));
  leftCol = pTerm->u.x.leftColumn;
  if( leftCol<0 ) return 0;
  aff = pSrc->pSTab->aCol[leftCol].affinity;
  if( !sqlite3IndexAffinityOk(pTerm->pExpr, aff) ) return 0;
                                     ;
  return columnIsGoodIndexCandidate(pSrc->pSTab, leftCol);
}
# 167638 "c_tests/sqlite3.c"
static __attribute__((noinline)) void constructAutomaticIndex(
  Parse *pParse,
  WhereClause *pWC,
  const Bitmask notReady,
  WhereLevel *pLevel
){
  int nKeyCol;
  WhereTerm *pTerm;
  WhereTerm *pWCEnd;
  Index *pIdx;
  Vdbe *v;
  int addrInit;
  Table *pTable;
  int addrTop;
  int regRecord;
  int n;
  int i;
  int mxBitCol;
  CollSeq *pColl;
  WhereLoop *pLoop;
  char *zNotUsed;
  Bitmask idxCols;
  Bitmask extraCols;
  u8 sentWarning = 0;
  u8 useBloomFilter = 0;
  Expr *pPartial = 0;
  int iContinue = 0;
  SrcList *pTabList;
  SrcItem *pSrc;
  int addrCounter = 0;
  int regBase;






  v = pParse->pVdbe;
  ((void) (0));
  addrInit = sqlite3VdbeAddOp0(v, 15); ;



  nKeyCol = 0;
  pTabList = pWC->pWInfo->pTabList;
  pSrc = &pTabList->a[pLevel->iFrom];
  pTable = pSrc->pSTab;
  pWCEnd = &pWC->a[pWC->nTerm];
  pLoop = pLevel->pWLoop;
  idxCols = 0;
  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){
    Expr *pExpr = pTerm->pExpr;



    if( (pTerm->wtFlags & 0x0002)==0
     && sqlite3ExprIsSingleTableConstraint(pExpr, pTabList, pLevel->iFrom, 0)
    ){
      pPartial = sqlite3ExprAnd(pParse, pPartial,
                                sqlite3ExprDup(pParse->db, pExpr, 0));
    }
    if( termCanDriveIndex(pTerm, pSrc, notReady) ){
      int iCol;
      Bitmask cMask;
      ((void) (0));
      iCol = pTerm->u.x.leftColumn;
      cMask = iCol>=((int)(sizeof(Bitmask)*8)) ? (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) : (((Bitmask)1)<<(iCol));
                           ;
                             ;
      if( !sentWarning ){
        sqlite3_log((28 | (1<<8)),
            "automatic index on %s(%s)", pTable->zName,
            pTable->aCol[iCol].zCnName);
        sentWarning = 1;
      }
      if( (idxCols & cMask)==0 ){
        if( whereLoopResize(pParse->db, pLoop, nKeyCol+1) ){
          goto end_auto_index_create;
        }
        pLoop->aLTerm[nKeyCol++] = pTerm;
        idxCols |= cMask;
      }
    }
  }
  ((void) (0));
  pLoop->u.btree.nEq = pLoop->nLTerm = nKeyCol;
  pLoop->wsFlags = 0x00000001 | 0x00000040 | 0x00000200
                     | 0x00004000;
# 167735 "c_tests/sqlite3.c"
  if( ((pTable)->eTabType==2) ){
    extraCols = ((Bitmask)-1) & ~idxCols;
  }else{
    extraCols = pSrc->colUsed & (~idxCols | (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)));
  }
  if( !(((pTable)->tabFlags & 0x00000080)==0) ){


    for(i=0; i<pTable->nCol; i++){
      if( (pTable->aCol[i].colFlags & 0x0001)==0 ) continue;
      if( i>=((int)(sizeof(Bitmask)*8))-1 ){
        extraCols |= (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1));
        break;
      }
      if( idxCols & (((Bitmask)1)<<(i)) ) continue;
      extraCols |= (((Bitmask)1)<<(i));
    }
  }
  mxBitCol = ((((int)(sizeof(Bitmask)*8))-1)<(pTable->nCol)?(((int)(sizeof(Bitmask)*8))-1):(pTable->nCol));
                                 ;
                                 ;
  for(i=0; i<mxBitCol; i++){
    if( extraCols & (((Bitmask)1)<<(i)) ) nKeyCol++;
  }
  if( pSrc->colUsed & (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) ){
    nKeyCol += pTable->nCol - ((int)(sizeof(Bitmask)*8)) + 1;
  }


  ((void) (0));

  pIdx = sqlite3AllocateIndexObject(pParse->db, nKeyCol+(((pTable)->tabFlags & 0x00000080)==0),
                                    0, &zNotUsed);
  if( pIdx==0 ) goto end_auto_index_create;
  pLoop->u.btree.pIndex = pIdx;
  pIdx->zName = "auto-index";
  pIdx->pTable = pTable;
  n = 0;
  idxCols = 0;
  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){
    if( termCanDriveIndex(pTerm, pSrc, notReady) ){
      int iCol;
      Bitmask cMask;
      ((void) (0));
      iCol = pTerm->u.x.leftColumn;
      cMask = iCol>=((int)(sizeof(Bitmask)*8)) ? (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) : (((Bitmask)1)<<(iCol));
                             ;
                           ;
      if( (idxCols & cMask)==0 ){
        Expr *pX = pTerm->pExpr;
        idxCols |= cMask;
        pIdx->aiColumn[n] = pTerm->u.x.leftColumn;
        pColl = sqlite3ExprCompareCollSeq(pParse, pX);
        ((void) (0));
        pIdx->azColl[n] = pColl ? pColl->zName : sqlite3StrBINARY;
        n++;
        if( (pX->pLeft!=0)
         && sqlite3ExprAffinity(pX->pLeft)!=0x42
        ){





          useBloomFilter = 1;
        }
      }
    }
  }
  ((void) (0));



  for(i=0; i<mxBitCol; i++){
    if( extraCols & (((Bitmask)1)<<(i)) ){
      pIdx->aiColumn[n] = i;
      pIdx->azColl[n] = sqlite3StrBINARY;
      n++;
    }
  }
  if( pSrc->colUsed & (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) ){
    for(i=((int)(sizeof(Bitmask)*8))-1; i<pTable->nCol; i++){
      pIdx->aiColumn[n] = i;
      pIdx->azColl[n] = sqlite3StrBINARY;
      n++;
    }
  }
  ((void) (0));
  if( (((pTable)->tabFlags & 0x00000080)==0) ){
    pIdx->aiColumn[n] = (-1);
    pIdx->azColl[n] = sqlite3StrBINARY;
  }


                                                            ;
  ((void) (0));
  pLevel->iIdxCur = pParse->nTab++;
  sqlite3VdbeAddOp2(v, 117, pLevel->iIdxCur, nKeyCol+1);
  sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
                                           ;
  if( (((pParse->db)->dbOptFlags&(0x00080000))==0) && useBloomFilter ){
    sqlite3WhereExplainBloomFilter(pParse, pWC->pWInfo, pLevel);
    pLevel->regFilter = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 78, 10000, pLevel->regFilter);
  }


  ((void) (0));
  if( pSrc->fg.viaCoroutine ){
    int regYield;
    Subquery *pSubq;
    ((void) (0));
    pSubq = pSrc->u4.pSubq;
    ((void) (0));
    regYield = pSubq->regReturn;
    addrCounter = sqlite3VdbeAddOp2(v, 72, 0, 0);
    sqlite3VdbeAddOp3(v, 11, regYield, 0, pSubq->addrFillSub);
    addrTop = sqlite3VdbeAddOp1(v, 12, regYield);
                   ;
                                                          ;
  }else{
    ((void) (0));
    addrTop = sqlite3VdbeAddOp2(v, 36,pLevel->iTabCur,pLevel->addrHalt);
                   ;
  }
  if( pPartial ){
    iContinue = sqlite3VdbeMakeLabel(pParse);
    sqlite3ExprIfFalse(pParse, pPartial, iContinue, 0x10);
    pLoop->wsFlags |= 0x00020000;
  }
  regRecord = sqlite3GetTempReg(pParse);
  regBase = sqlite3GenerateIndexKey(
      pParse, pIdx, pLevel->iTabCur, regRecord, 0, 0, 0, 0
  );
  if( pLevel->regFilter ){
    sqlite3VdbeAddOp4Int(v, 184, pLevel->regFilter, 0,
                         regBase, pLoop->u.btree.nEq);
  }
                                                                               ;
  sqlite3VdbeAddOp2(v, 139, pLevel->iIdxCur, regRecord);
  sqlite3VdbeChangeP5(v, 0x10);
  if( pPartial ) sqlite3VdbeResolveLabel(v, iContinue);
  if( pSrc->fg.viaCoroutine ){
    ((void) (0));
    sqlite3VdbeChangeP2(v, addrCounter, regBase+n);
                                        ;
    ((void) (0));
    translateColumnToCopy(pParse, addrTop, pLevel->iTabCur,
                          pSrc->u4.pSubq->regResult, pLevel->iIdxCur);
    sqlite3VdbeGoto(v, addrTop);
    pSrc->fg.viaCoroutine = 0;
    sqlite3VdbeJumpHere(v, addrTop);
  }else{
    sqlite3VdbeAddOp2(v, 40, pLevel->iTabCur, addrTop+1); ;
    sqlite3VdbeChangeP5(v, 3);
    if( (pSrc->fg.jointype & 0x08)!=0 ){
      sqlite3VdbeJumpHere(v, addrTop);
    }
  }
  sqlite3ReleaseTempReg(pParse, regRecord);


  sqlite3VdbeJumpHere(v, addrInit);
                                                     ;

end_auto_index_create:
  sqlite3ExprDelete(pParse->db, pPartial);
}
# 167925 "c_tests/sqlite3.c"
static __attribute__((noinline)) void sqlite3ConstructBloomFilter(
  WhereInfo *pWInfo,
  int iLevel,
  WhereLevel *pLevel,
  Bitmask notReady
){
  int addrOnce;
  int addrTop;
  int addrCont;
  const WhereTerm *pTerm;
  const WhereTerm *pWCEnd;
  Parse *pParse = pWInfo->pParse;
  Vdbe *v = pParse->pVdbe;
  WhereLoop *pLoop = pLevel->pWLoop;
  int iCur;
  IndexedExpr *saved_pIdxEpr;
  IndexedExpr *saved_pIdxPartExpr;

  saved_pIdxEpr = pParse->pIdxEpr;
  saved_pIdxPartExpr = pParse->pIdxPartExpr;
  pParse->pIdxEpr = 0;
  pParse->pIdxPartExpr = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  addrOnce = sqlite3VdbeAddOp0(v, 15); ;
  do{
    const SrcList *pTabList;
    const SrcItem *pItem;
    const Table *pTab;
    u64 sz;
    int iSrc;
    sqlite3WhereExplainBloomFilter(pParse, pWInfo, pLevel);
    addrCont = sqlite3VdbeMakeLabel(pParse);
    iCur = pLevel->iTabCur;
    pLevel->regFilter = ++pParse->nMem;
# 167973 "c_tests/sqlite3.c"
    pTabList = pWInfo->pTabList;
    iSrc = pLevel->iFrom;
    pItem = &pTabList->a[iSrc];
    ((void) (0));
    pTab = pItem->pSTab;
    ((void) (0));
    sz = sqlite3LogEstToInt(pTab->nRowLogEst);
    if( sz<10000 ){
      sz = 10000;
    }else if( sz>10000000 ){
      sz = 10000000;
    }
    sqlite3VdbeAddOp2(v, 78, (int)sz, pLevel->regFilter);

    addrTop = sqlite3VdbeAddOp1(v, 36, iCur); ;
    pWCEnd = &pWInfo->sWC.a[pWInfo->sWC.nTerm];
    for(pTerm=pWInfo->sWC.a; pTerm<pWCEnd; pTerm++){
      Expr *pExpr = pTerm->pExpr;
      if( (pTerm->wtFlags & 0x0002)==0
       && sqlite3ExprIsSingleTableConstraint(pExpr, pTabList, iSrc, 0)
      ){
        sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, 0x10);
      }
    }
    if( pLoop->wsFlags & 0x00000100 ){
      int r1 = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp2(v, 136, iCur, r1);
      sqlite3VdbeAddOp4Int(v, 184, pLevel->regFilter, 0, r1, 1);
      sqlite3ReleaseTempReg(pParse, r1);
    }else{
      Index *pIdx = pLoop->u.btree.pIndex;
      int n = pLoop->u.btree.nEq;
      int r1 = sqlite3GetTempRange(pParse, n);
      int jj;
      for(jj=0; jj<n; jj++){
        ((void) (0));
        sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iCur, jj, r1+jj);
      }
      sqlite3VdbeAddOp4Int(v, 184, pLevel->regFilter, 0, r1, n);
      sqlite3ReleaseTempRange(pParse, r1, n);
    }
    sqlite3VdbeResolveLabel(v, addrCont);
    sqlite3VdbeAddOp2(v, 40, pLevel->iTabCur, addrTop+1);
                   ;
    sqlite3VdbeJumpHere(v, addrTop);
    pLoop->wsFlags &= ~0x00400000;
    if( (((pParse->db)->dbOptFlags&(0x00100000))!=0) ) break;
    while( ++iLevel < pWInfo->nLevel ){
      const SrcItem *pTabItem;
      pLevel = &pWInfo->a[iLevel];
      pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];
      if( pTabItem->fg.jointype & (0x08|0x40) ) continue;
      pLoop = pLevel->pWLoop;
      if( (pLoop==0) ) continue;
      if( pLoop->prereq & notReady ) continue;
      if( (pLoop->wsFlags & (0x00400000|0x00000004))
                 ==0x00400000
      ){




        break;
      }
    }
  }while( iLevel < pWInfo->nLevel );
  sqlite3VdbeJumpHere(v, addrOnce);
  pParse->pIdxEpr = saved_pIdxEpr;
  pParse->pIdxPartExpr = saved_pIdxPartExpr;
}
# 168051 "c_tests/sqlite3.c"
static WhereTerm *termFromWhereClause(WhereClause *pWC, int iTerm){
  WhereClause *p;
  for(p=pWC; p; p=p->pOuter){
    if( iTerm<p->nTerm ) return &p->a[iTerm];
    iTerm -= p->nTerm;
  }
  return 0;
}






static sqlite3_index_info *allocateIndexInfo(
  WhereInfo *pWInfo,
  WhereClause *pWC,
  Bitmask mUnusable,
  SrcItem *pSrc,
  u16 *pmNoOmit
){
  int i, j;
  int nTerm;
  Parse *pParse = pWInfo->pParse;
  struct sqlite3_index_constraint *pIdxCons;
  struct sqlite3_index_orderby *pIdxOrderBy;
  struct sqlite3_index_constraint_usage *pUsage;
  struct HiddenIndexInfo *pHidden;
  WhereTerm *pTerm;
  int nOrderBy;
  sqlite3_index_info *pIdxInfo;
  u16 mNoOmit = 0;
  const Table *pTab;
  int eDistinct = 0;
  ExprList *pOrderBy = pWInfo->pOrderBy;
  WhereClause *p;

  ((void) (0));
  pTab = pSrc->pSTab;
  ((void) (0));
  ((void) (0));





  for(p=pWC, nTerm=0; p; p=p->pOuter){
    for(i=0, pTerm=p->a; i<p->nTerm; i++, pTerm++){
      pTerm->wtFlags &= ~0x0040;
      if( pTerm->leftCursor != pSrc->iCursor ) continue;
      if( pTerm->prereqRight & mUnusable ) continue;
      ((void) (0));
                                          ;
                                              ;
                                          ;
                                           ;
      if( (pTerm->eOperator & ~(0x0800))==0 ) continue;
      if( pTerm->wtFlags & 0x0080 ) continue;

      ((void) (0));
      ((void) (0));
      ((void) (0));
      if( (pSrc->fg.jointype & (0x08|0x40|0x10))!=0
          && !constraintCompatibleWithOuterJoin(pTerm,pSrc)
        ){
        continue;
      }
      nTerm++;
      pTerm->wtFlags |= 0x0040;
    }
  }





  nOrderBy = 0;
  if( pOrderBy ){
    int n = pOrderBy->nExpr;
    for(i=0; i<n; i++){
      Expr *pExpr = pOrderBy->a[i].pExpr;
      Expr *pE2;


      if( sqlite3ExprIsConstant(0, pExpr) ){
        continue;
      }


      if( pOrderBy->a[i].fg.sortFlags & 0x02 ) break;


      if( pExpr->op==168 && pExpr->iTable==pSrc->iCursor ){
        ((void) (0));
        continue;
      }



      if( pExpr->op==114
       && (pE2 = pExpr->pLeft)->op==168
       && pE2->iTable==pSrc->iCursor
      ){
        const char *zColl;
        ((void) (0));
        ((void) (0));
        ((void) (0));
        pExpr->iColumn = pE2->iColumn;
        if( pE2->iColumn<0 ) continue;
        zColl = sqlite3ColumnColl(&pTab->aCol[pE2->iColumn]);
        if( zColl==0 ) zColl = sqlite3StrBINARY;
        if( sqlite3_stricmp(pExpr->u.zToken, zColl)==0 ) continue;
      }


      break;
    }
    if( i==n ){
      nOrderBy = n;
      if( (pWInfo->wctrlFlags & 0x0080) && !pSrc->fg.rowidUsed ){
        eDistinct = 2 + ((pWInfo->wctrlFlags & 0x0200)!=0);
      }else if( pWInfo->wctrlFlags & 0x0040 ){
        eDistinct = 1;
      }
    }
  }



  pIdxInfo = sqlite3DbMallocZero(pParse->db, sizeof(*pIdxInfo)
                           + (sizeof(*pIdxCons) + sizeof(*pUsage))*nTerm
                           + sizeof(*pIdxOrderBy)*nOrderBy
                           + (__builtin_offsetof(HiddenIndexInfo, aRhs) + (nTerm)*sizeof(sqlite3_value*)) );
  if( pIdxInfo==0 ){
    sqlite3ErrorMsg(pParse, "out of memory");
    return 0;
  }
  pHidden = (struct HiddenIndexInfo*)&pIdxInfo[1];
  pIdxCons = (struct sqlite3_index_constraint*)&pHidden->aRhs[nTerm];
  pIdxOrderBy = (struct sqlite3_index_orderby*)&pIdxCons[nTerm];
  pUsage = (struct sqlite3_index_constraint_usage*)&pIdxOrderBy[nOrderBy];
  pIdxInfo->aConstraint = pIdxCons;
  pIdxInfo->aOrderBy = pIdxOrderBy;
  pIdxInfo->aConstraintUsage = pUsage;
  pIdxInfo->colUsed = (sqlite3_int64)pSrc->colUsed;
  if( (((pTab)->tabFlags & 0x00000080)==0)==0 ){


    Index *pPk = sqlite3PrimaryKeyIndex((Table*)pTab);
    ((void) (0));
    for(i=0; i<pPk->nKeyCol; i++){
      int iCol = pPk->aiColumn[i];
      ((void) (0));
      if( iCol>=((int)(sizeof(Bitmask)*8))-1 ) iCol = ((int)(sizeof(Bitmask)*8))-1;
      pIdxInfo->colUsed |= (((Bitmask)1)<<(iCol));
    }
  }
  pHidden->pWC = pWC;
  pHidden->pParse = pParse;
  pHidden->eDistinct = eDistinct;
  pHidden->mIn = 0;
  for(p=pWC, i=j=0; p; p=p->pOuter){
    int nLast = i+p->nTerm;;
    for(pTerm=p->a; i<nLast; i++, pTerm++){
      u16 op;
      if( (pTerm->wtFlags & 0x0040)==0 ) continue;
      pIdxCons[j].iColumn = pTerm->u.x.leftColumn;
      pIdxCons[j].iTermOffset = i;
      op = pTerm->eOperator & 0x3fff;
      if( op==0x0001 ){
        if( (pTerm->wtFlags & 0x8000)==0 ){
          pHidden->mIn |= ((j)<=31?((unsigned int)1)<<(j):0);
        }
        op = 0x0002;
      }
      if( op==0x0040 ){
        pIdxCons[j].op = pTerm->eMatchOp;
      }else if( op & (0x0100|0x0080) ){
        if( op==0x0100 ){
          pIdxCons[j].op = 71;
        }else{
          pIdxCons[j].op = 72;
        }
      }else{
        pIdxCons[j].op = (u8)op;



        ((void) (0));
        ((void) (0));
        ((void) (0));
        ((void) (0));
        ((void) (0));
        ((void) (0));

        if( op & ((0x0002<<(57 -54))|(0x0002<<(56 -54))|(0x0002<<(55 -54))|(0x0002<<(58 -54)))
            && sqlite3ExprIsVector(pTerm->pExpr->pRight)
          ){
                          ;
          if( j<16 ) mNoOmit |= (1 << j);
          if( op==(0x0002<<(57 -54)) ) pIdxCons[j].op = (0x0002<<(56 -54));
          if( op==(0x0002<<(55 -54)) ) pIdxCons[j].op = (0x0002<<(58 -54));
        }
      }

      j++;
    }
  }
  ((void) (0));
  pIdxInfo->nConstraint = j;
  for(i=j=0; i<nOrderBy; i++){
    Expr *pExpr = pOrderBy->a[i].pExpr;
    if( sqlite3ExprIsConstant(0, pExpr) ) continue;
    ((void) (0));


    pIdxOrderBy[j].iColumn = pExpr->iColumn;
    pIdxOrderBy[j].desc = pOrderBy->a[i].fg.sortFlags & 0x01;
    j++;
  }
  pIdxInfo->nOrderBy = j;

  *pmNoOmit = mNoOmit;
  return pIdxInfo;
}




static void freeIdxStr(sqlite3_index_info *pIdxInfo){
  if( pIdxInfo->needToFreeIdxStr ){
    sqlite3_free(pIdxInfo->idxStr);
    pIdxInfo->idxStr = 0;
    pIdxInfo->needToFreeIdxStr = 0;
  }
}





static void freeIndexInfo(sqlite3 *db, sqlite3_index_info *pIdxInfo){
  HiddenIndexInfo *pHidden;
  int i;
  ((void) (0));
  pHidden = (HiddenIndexInfo*)&pIdxInfo[1];
  ((void) (0));
  ((void) (0));
  for(i=0; i<pIdxInfo->nConstraint; i++){
    sqlite3ValueFree(pHidden->aRhs[i]);
    pHidden->aRhs[i] = 0;
  }
  freeIdxStr(pIdxInfo);
  sqlite3DbFree(db, pIdxInfo);
}
# 168323 "c_tests/sqlite3.c"
static int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p){
  int rc;
  sqlite3_vtab *pVtab;

  ((void) (0));
  pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;
                                    ;
  pParse->db->nSchemaLock++;
  rc = pVtab->pModule->xBestIndex(pVtab, p);
  pParse->db->nSchemaLock--;
                                     ;

  if( rc!=0 && rc!=19 ){
    if( rc==7 ){
      sqlite3OomFault(pParse->db);
    }else if( !pVtab->zErrMsg ){
      sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr(rc));
    }else{
      sqlite3ErrorMsg(pParse, "%s", pVtab->zErrMsg);
    }
  }
  if( pTab->u.vtab.p->bAllSchemas ){
    sqlite3VtabUsesAllSchemas(pParse);
  }
  sqlite3_free(pVtab->zErrMsg);
  pVtab->zErrMsg = 0;
  return rc;
}
# 168565 "c_tests/sqlite3.c"
static LogEst whereRangeAdjust(WhereTerm *pTerm, LogEst nNew){
  LogEst nRet = nNew;
  if( pTerm ){
    if( pTerm->truthProb<=0 ){
      nRet += pTerm->truthProb;
    }else if( (pTerm->wtFlags & 0x0080)==0 ){
      nRet -= 20; ((void) (0));
    }
  }
  return nRet;
}
# 168741 "c_tests/sqlite3.c"
static int whereRangeScanEst(
  Parse *pParse,
  WhereLoopBuilder *pBuilder,
  WhereTerm *pLower,
  WhereTerm *pUpper,
  WhereLoop *pLoop
){
  int rc = 0;
  int nOut = pLoop->nOut;
  LogEst nNew;
# 168874 "c_tests/sqlite3.c"
  (void)(pParse);
  (void)(pBuilder);
  ((void) (0));

  ((void) (0));
  nNew = whereRangeAdjust(pLower, nOut);
  nNew = whereRangeAdjust(pUpper, nNew);







  if( pLower && pLower->truthProb>0 && pUpper && pUpper->truthProb>0 ){
    nNew -= 20;
  }

  nOut -= (pLower!=0) + (pUpper!=0);
  if( nNew<10 ) nNew = 10;
  if( nNew<nOut ) nOut = nNew;






  pLoop->nOut = (LogEst)nOut;
  return rc;
}
# 169171 "c_tests/sqlite3.c"
static void whereLoopInit(WhereLoop *p){
  p->aLTerm = p->aLTermSpace;
  p->nLTerm = 0;
  p->nLSlot = ((int)(sizeof(p->aLTermSpace)/sizeof(p->aLTermSpace[0])));
  p->wsFlags = 0;
}




static void whereLoopClearUnion(sqlite3 *db, WhereLoop *p){
  if( p->wsFlags & (0x00000400|0x00004000) ){
    if( (p->wsFlags & 0x00000400)!=0 && p->u.vtab.needFree ){
      sqlite3_free(p->u.vtab.idxStr);
      p->u.vtab.needFree = 0;
      p->u.vtab.idxStr = 0;
    }else if( (p->wsFlags & 0x00004000)!=0 && p->u.btree.pIndex!=0 ){
      sqlite3DbFree(db, p->u.btree.pIndex->zColAff);
      sqlite3DbFreeNN(db, p->u.btree.pIndex);
      p->u.btree.pIndex = 0;
    }
  }
}





static void whereLoopClear(sqlite3 *db, WhereLoop *p){
  if( p->aLTerm!=p->aLTermSpace ){
    sqlite3DbFreeNN(db, p->aLTerm);
    p->aLTerm = p->aLTermSpace;
    p->nLSlot = ((int)(sizeof(p->aLTermSpace)/sizeof(p->aLTermSpace[0])));
  }
  whereLoopClearUnion(db, p);
  p->nLTerm = 0;
  p->wsFlags = 0;
}




static int whereLoopResize(sqlite3 *db, WhereLoop *p, int n){
  WhereTerm **paNew;
  if( p->nLSlot>=n ) return 0;
  n = (n+7)&~7;
  paNew = sqlite3DbMallocRawNN(db, sizeof(p->aLTerm[0])*n);
  if( paNew==0 ) return 7;
  memcpy(paNew, p->aLTerm, sizeof(p->aLTerm[0])*p->nLSlot);
  if( p->aLTerm!=p->aLTermSpace ) sqlite3DbFreeNN(db, p->aLTerm);
  p->aLTerm = paNew;
  p->nLSlot = n;
  return 0;
}




static int whereLoopXfer(sqlite3 *db, WhereLoop *pTo, WhereLoop *pFrom){
  whereLoopClearUnion(db, pTo);
  if( pFrom->nLTerm > pTo->nLSlot
   && whereLoopResize(db, pTo, pFrom->nLTerm)
  ){
    memset(pTo, 0, __builtin_offsetof(WhereLoop, nLSlot));
    return 7;
  }
  memcpy(pTo, pFrom, __builtin_offsetof(WhereLoop, nLSlot));
  memcpy(pTo->aLTerm, pFrom->aLTerm, pTo->nLTerm*sizeof(pTo->aLTerm[0]));
  if( pFrom->wsFlags & 0x00000400 ){
    pFrom->u.vtab.needFree = 0;
  }else if( (pFrom->wsFlags & 0x00004000)!=0 ){
    pFrom->u.btree.pIndex = 0;
  }
  return 0;
}




static void whereLoopDelete(sqlite3 *db, WhereLoop *p){
  ((void) (0));
  whereLoopClear(db, p);
  sqlite3DbNNFreeNN(db, p);
}




static void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo){
  ((void) (0));
  ((void) (0));
  sqlite3WhereClauseClear(&pWInfo->sWC);
  while( pWInfo->pLoops ){
    WhereLoop *p = pWInfo->pLoops;
    pWInfo->pLoops = p->pNextLoop;
    whereLoopDelete(db, p);
  }
  while( pWInfo->pMemToFree ){
    WhereMemBlock *pNext = pWInfo->pMemToFree->pNext;
    sqlite3DbNNFreeNN(db, pWInfo->pMemToFree);
    pWInfo->pMemToFree = pNext;
  }
  sqlite3DbNNFreeNN(db, pWInfo);
}
# 169301 "c_tests/sqlite3.c"
static int whereLoopCheaperProperSubset(
  const WhereLoop *pX,
  const WhereLoop *pY
){
  int i, j;
  if( pX->rRun>pY->rRun && pX->nOut>pY->nOut ) return 0;
  ((void) (0));
  ((void) (0));
  if( pX->u.btree.nEq < pY->u.btree.nEq
   && pX->u.btree.pIndex==pY->u.btree.pIndex
   && pX->nSkip==0 && pY->nSkip==0
  ){
    return 1;
  }
  if( pX->nLTerm-pX->nSkip >= pY->nLTerm-pY->nSkip ){
    return 0;
  }
  if( pY->nSkip > pX->nSkip ) return 0;
  for(i=pX->nLTerm-1; i>=0; i--){
    if( pX->aLTerm[i]==0 ) continue;
    for(j=pY->nLTerm-1; j>=0; j--){
      if( pY->aLTerm[j]==pX->aLTerm[i] ) break;
    }
    if( j<0 ) return 0;
  }
  if( (pX->wsFlags&0x00000040)!=0
   && (pY->wsFlags&0x00000040)==0 ){
    return 0;
  }
  return 1;
}
# 169347 "c_tests/sqlite3.c"
static void whereLoopAdjustCost(const WhereLoop *p, WhereLoop *pTemplate){
  if( (pTemplate->wsFlags & 0x00000200)==0 ) return;
  for(; p; p=p->pNextLoop){
    if( p->iTab!=pTemplate->iTab ) continue;
    if( (p->wsFlags & 0x00000200)==0 ) continue;
    if( whereLoopCheaperProperSubset(p, pTemplate) ){





                                                          ;
      pTemplate->rRun = ((p->rRun)<(pTemplate->rRun)?(p->rRun):(pTemplate->rRun));
      pTemplate->nOut = ((p->nOut - 1)<(pTemplate->nOut)?(p->nOut - 1):(pTemplate->nOut));
    }else if( whereLoopCheaperProperSubset(pTemplate, p) ){





                                                          ;
      pTemplate->rRun = ((p->rRun)>(pTemplate->rRun)?(p->rRun):(pTemplate->rRun));
      pTemplate->nOut = ((p->nOut + 1)>(pTemplate->nOut)?(p->nOut + 1):(pTemplate->nOut));
    }
  }
}
# 169388 "c_tests/sqlite3.c"
static WhereLoop **whereLoopFindLesser(
  WhereLoop **ppPrev,
  const WhereLoop *pTemplate
){
  WhereLoop *p;
  for(p=(*ppPrev); p; ppPrev=&p->pNextLoop, p=*ppPrev){
    if( p->iTab!=pTemplate->iTab || p->iSortIdx!=pTemplate->iSortIdx ){



      continue;
    }



    ((void) (0));





    ((void) (0));




    if( (p->wsFlags & 0x00004000)!=0
     && (pTemplate->nSkip)==0
     && (pTemplate->wsFlags & 0x00000200)!=0
     && (pTemplate->wsFlags & 0x00000001)!=0
     && (p->prereq & pTemplate->prereq)==pTemplate->prereq
    ){
      break;
    }






    if( (p->prereq & pTemplate->prereq)==p->prereq
     && p->rSetup<=pTemplate->rSetup
     && p->rRun<=pTemplate->rRun
     && p->nOut<=pTemplate->nOut
    ){
      return 0;
    }






    if( (p->prereq & pTemplate->prereq)==pTemplate->prereq
     && p->rRun>=pTemplate->rRun
     && p->nOut>=pTemplate->nOut
    ){
      ((void) (0));
      break;
    }
  }
  return ppPrev;
}
# 169476 "c_tests/sqlite3.c"
static int whereLoopInsert(WhereLoopBuilder *pBuilder, WhereLoop *pTemplate){
  WhereLoop **ppPrev, *p;
  WhereInfo *pWInfo = pBuilder->pWInfo;
  sqlite3 *db = pWInfo->pParse->db;
  int rc;


  if( pBuilder->iPlanLimit==0 ){
                                                                           ;
    if( pBuilder->pOrSet ) pBuilder->pOrSet->n = 0;
    return 101;
  }
  pBuilder->iPlanLimit--;

  whereLoopAdjustCost(pWInfo->pLoops, pTemplate);




  if( pBuilder->pOrSet!=0 ){
    if( pTemplate->nLTerm ){




      whereOrInsert(pBuilder->pOrSet, pTemplate->prereq, pTemplate->rRun,
                                    pTemplate->nOut);






    }
    return 0;
  }



  ppPrev = whereLoopFindLesser(&pWInfo->pLoops, pTemplate);

  if( ppPrev==0 ){
# 169526 "c_tests/sqlite3.c"
    return 0;
  }else{
    p = *ppPrev;
  }
# 169547 "c_tests/sqlite3.c"
  if( p==0 ){

    *ppPrev = p = sqlite3DbMallocRawNN(db, sizeof(WhereLoop));
    if( p==0 ) return 7;
    whereLoopInit(p);
    p->pNextLoop = 0;
  }else{



    WhereLoop **ppTail = &p->pNextLoop;
    WhereLoop *pToDel;
    while( *ppTail ){
      ppTail = whereLoopFindLesser(ppTail, pTemplate);
      if( ppTail==0 ) break;
      pToDel = *ppTail;
      if( pToDel==0 ) break;
      *ppTail = pToDel->pNextLoop;






      whereLoopDelete(db, pToDel);
    }
  }
  rc = whereLoopXfer(db, p, pTemplate);
  if( (p->wsFlags & 0x00000400)==0 ){
    Index *pIndex = p->u.btree.pIndex;
    if( pIndex && pIndex->idxType==3 ){
      p->u.btree.pIndex = 0;
    }
  }
  return rc;
}
# 169613 "c_tests/sqlite3.c"
static void whereLoopOutputAdjust(
  WhereClause *pWC,
  WhereLoop *pLoop,
  LogEst nRow
){
  WhereTerm *pTerm, *pX;
  Bitmask notAllowed = ~(pLoop->prereq|pLoop->maskSelf);
  int i, j;
  LogEst iReduce = 0;

  ((void) (0));
  for(i=pWC->nBase, pTerm=pWC->a; i>0; i--, pTerm++){
    ((void) (0));
    if( (pTerm->prereqAll & notAllowed)!=0 ) continue;
    if( (pTerm->prereqAll & pLoop->maskSelf)==0 ) continue;
    if( (pTerm->wtFlags & 0x0002)!=0 ) continue;
    for(j=pLoop->nLTerm-1; j>=0; j--){
      pX = pLoop->aLTerm[j];
      if( pX==0 ) continue;
      if( pX==pTerm ) break;
      if( pX->iParent>=0 && (&pWC->a[pX->iParent])==pTerm ) break;
    }
    if( j<0 ){
      sqlite3ProgressCheck(pWC->pWInfo->pParse);
      if( pLoop->maskSelf==pTerm->prereqAll ){
# 169647 "c_tests/sqlite3.c"
        if( (pTerm->eOperator & 0x3f)!=0
         || (pWC->pWInfo->pTabList->a[pLoop->iTab].fg.jointype
                  & (0x08|0x40))==0
        ){
          pLoop->wsFlags |= 0x00800000;
        }
      }
      if( pTerm->truthProb<=0 ){


        pLoop->nOut += pTerm->truthProb;
      }else{


        pLoop->nOut--;
        if( (pTerm->eOperator&(0x0002|0x0080))!=0
         && (pTerm->wtFlags & 0)==0
        ){
          Expr *pRight = pTerm->pExpr->pRight;
          int k = 0;
                                             ;
          if( sqlite3ExprIsInteger(pRight, &k, 0) && k>=(-1) && k<=1 ){
            k = 10;
          }else{
            k = 20;
          }
          if( iReduce<k ){
            pTerm->wtFlags |= 0x2000;
            iReduce = k;
          }
        }
      }
    }
  }
  if( pLoop->nOut > nRow-iReduce ){
    pLoop->nOut = nRow - iReduce;
  }
}
# 169703 "c_tests/sqlite3.c"
static int whereRangeVectorLen(
  Parse *pParse,
  int iCur,
  Index *pIdx,
  int nEq,
  WhereTerm *pTerm
){
  int nCmp = sqlite3ExprVectorSize(pTerm->pExpr->pLeft);
  int i;

  nCmp = ((nCmp)<((pIdx->nColumn - nEq))?(nCmp):((pIdx->nColumn - nEq)));
  for(i=1; i<nCmp; i++){


    char aff;
    char idxaff = 0;
    CollSeq *pColl;
    Expr *pLhs, *pRhs;

    ((void) (0));
    pLhs = pTerm->pExpr->pLeft->x.pList->a[i].pExpr;
    pRhs = pTerm->pExpr->pRight;
    if( (((pRhs)->flags&0x001000)!=0) ){
      pRhs = pRhs->x.pSelect->pEList->a[i].pExpr;
    }else{
      pRhs = pRhs->x.pList->a[i].pExpr;
    }





    if( pLhs->op!=168
     || pLhs->iTable!=iCur
     || pLhs->iColumn!=pIdx->aiColumn[i+nEq]
     || pIdx->aSortOrder[i+nEq]!=pIdx->aSortOrder[nEq]
    ){
      break;
    }

                                       ;
    aff = sqlite3CompareAffinity(pRhs, sqlite3ExprAffinity(pLhs));
    idxaff = sqlite3TableColumnAffinity(pIdx->pTable, pLhs->iColumn);
    if( aff!=idxaff ) break;

    pColl = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
    if( pColl==0 ) break;
    if( sqlite3StrICmp(pColl->zName, pIdx->azColl[i+nEq]) ) break;
  }
  return i;
}
# 169777 "c_tests/sqlite3.c"
static int whereLoopAddBtreeIndex(
  WhereLoopBuilder *pBuilder,
  SrcItem *pSrc,
  Index *pProbe,
  LogEst nInMul
){
  WhereInfo *pWInfo = pBuilder->pWInfo;
  Parse *pParse = pWInfo->pParse;
  sqlite3 *db = pParse->db;
  WhereLoop *pNew;
  WhereTerm *pTerm;
  int opMask;
  WhereScan scan;
  Bitmask saved_prereq;
  u16 saved_nLTerm;
  u16 saved_nEq;
  u16 saved_nBtm;
  u16 saved_nTop;
  u16 saved_nSkip;
  u32 saved_wsFlags;
  LogEst saved_nOut;
  int rc = 0;
  LogEst rSize;
  LogEst rLogSize;
  WhereTerm *pTop = 0, *pBtm = 0;

  pNew = pBuilder->pNew;
  ((void) (0));
  if( pParse->nErr ){
    return pParse->rc;
  }


                                                                 ;

  ((void) (0));
  ((void) (0));
  if( pNew->wsFlags & 0x00000020 ){
    opMask = (0x0002<<(57 -54))|(0x0002<<(56 -54));
  }else{
    ((void) (0));
    opMask = 0x0002|0x0001|(0x0002<<(55 -54))|(0x0002<<(58 -54))|(0x0002<<(57 -54))|(0x0002<<(56 -54))|0x0100|0x0080;
  }
  if( pProbe->bUnordered ){
    opMask &= ~((0x0002<<(55 -54))|(0x0002<<(58 -54))|(0x0002<<(57 -54))|(0x0002<<(56 -54)));
  }

  ((void) (0));
  ((void) (0));


  saved_nEq = pNew->u.btree.nEq;
  saved_nBtm = pNew->u.btree.nBtm;
  saved_nTop = pNew->u.btree.nTop;
  saved_nSkip = pNew->nSkip;
  saved_nLTerm = pNew->nLTerm;
  saved_wsFlags = pNew->wsFlags;
  saved_prereq = pNew->prereq;
  saved_nOut = pNew->nOut;
  pTerm = whereScanInit(&scan, pBuilder->pWC, pSrc->iCursor, saved_nEq,
                        opMask, pProbe);
  pNew->rSetup = 0;
  rSize = pProbe->aiRowLogEst[0];
  rLogSize = estLog(rSize);
  for(; rc==0 && pTerm!=0; pTerm = whereScanNext(&scan)){
    u16 eOp = pTerm->eOperator;
    LogEst rCostIdx;
    LogEst nOutUnadjusted;
    int nIn = 0;



    if( (eOp==0x0100 || (pTerm->wtFlags&0x0080)!=0)
     && indexColumnNotNull(pProbe, saved_nEq)
    ){
      continue;
    }
    if( pTerm->prereqRight & pNew->maskSelf ) continue;



    if( pTerm->wtFlags & 0x0100 && pTerm->eOperator==(0x0002<<(57 -54)) ) continue;

    if( (pSrc->fg.jointype & (0x08|0x40|0x10))!=0
     && !constraintCompatibleWithOuterJoin(pTerm,pSrc)
    ){
      continue;
    }
    if( ((pProbe)->onError!=0) && saved_nEq==pProbe->nKeyCol-1 ){
      pBuilder->bldFlags1 |= 0x0002;
    }else{
      pBuilder->bldFlags1 |= 0x0001;
    }
    pNew->wsFlags = saved_wsFlags;
    pNew->u.btree.nEq = saved_nEq;
    pNew->u.btree.nBtm = saved_nBtm;
    pNew->u.btree.nTop = saved_nTop;
    pNew->nLTerm = saved_nLTerm;
    if( pNew->nLTerm>=pNew->nLSlot
     && whereLoopResize(db, pNew, pNew->nLTerm+1)
    ){
       break;
    }
    pNew->aLTerm[pNew->nLTerm++] = pTerm;
    pNew->prereq = (saved_prereq | pTerm->prereqRight) & ~pNew->maskSelf;

    ((void) (0));





    if( eOp & 0x0001 ){
      Expr *pExpr = pTerm->pExpr;
      if( (((pExpr)->flags&0x001000)!=0) ){

        int i;
        int bRedundant = 0;
        nIn = 46; ((void) (0));






        for(i=0; i<pNew->nLTerm-1; i++){
          if( pNew->aLTerm[i] && pNew->aLTerm[i]->pExpr==pExpr ){
            nIn = 0;
            if( pNew->aLTerm[i]->u.x.iField == pTerm->u.x.iField ){




              bRedundant = 1;
            }
          }
        }
        if( bRedundant ){
          pNew->nLTerm--;
          continue;
        }
      }else if( (pExpr->x.pList && pExpr->x.pList->nExpr) ){

        nIn = sqlite3LogEst(pExpr->x.pList->nExpr);
      }
      if( pProbe->hasStat1 && rLogSize>=10 ){
        LogEst M, logK, x;
# 169944 "c_tests/sqlite3.c"
        M = pProbe->aiRowLogEst[saved_nEq];
        logK = estLog(nIn);

        x = M + logK + 10 - (nIn + rLogSize);
        if( x>=0 ){



                                                   ;
        }else if( nInMul<2 && (((db)->dbOptFlags&(0x00020000))==0) ){



                                                           ;
          pNew->wsFlags |= 0x00100000;
        }else{



                                                           ;
          continue;
        }
      }
      pNew->wsFlags |= 0x00000004;
    }else if( eOp & (0x0002|0x0080) ){
      int iCol = pProbe->aiColumn[saved_nEq];
      pNew->wsFlags |= 0x00000001;
      ((void) (0));
      if( iCol==(-1)
       || (iCol>=0 && nInMul==0 && saved_nEq==pProbe->nKeyCol-1)
      ){
        if( iCol==(-1) || pProbe->uniqNotNull
         || (pProbe->nKeyCol==1 && pProbe->onError && (eOp & 0x0002))
        ){
          pNew->wsFlags |= 0x00001000;
        }else{
          pNew->wsFlags |= 0x00010000;
        }
      }
      if( scan.iEquiv>1 ) pNew->wsFlags |= 0x00200000;
    }else if( eOp & 0x0100 ){
      pNew->wsFlags |= 0x00000008;
    }else{
      int nVecLen = whereRangeVectorLen(
          pParse, pSrc->iCursor, pProbe, saved_nEq, pTerm
      );
      if( eOp & ((0x0002<<(55 -54))|(0x0002<<(58 -54))) ){
                               ;
                               ;
        pNew->wsFlags |= 0x00000002|0x00000020;
        pNew->u.btree.nBtm = nVecLen;
        pBtm = pTerm;
        pTop = 0;
        if( pTerm->wtFlags & 0x0100 ){


          pTop = &pTerm[1];
          ((void) (0));
          ((void) (0));
          ((void) (0));
          if( whereLoopResize(db, pNew, pNew->nLTerm+1) ) break;
          pNew->aLTerm[pNew->nLTerm++] = pTop;
          pNew->wsFlags |= 0x00000010;
          pNew->u.btree.nTop = 1;
        }
      }else{
        ((void) (0));
                               ;
                               ;
        pNew->wsFlags |= 0x00000002|0x00000010;
        pNew->u.btree.nTop = nVecLen;
        pTop = pTerm;
        pBtm = (pNew->wsFlags & 0x00000020)!=0 ?
                       pNew->aLTerm[pNew->nLTerm-2] : 0;
      }
    }






    ((void) (0));
    if( pNew->wsFlags & 0x00000002 ){


      whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew);
    }else{
      int nEq = ++pNew->u.btree.nEq;
      ((void) (0));

      ((void) (0));
      if( pTerm->truthProb<=0 && pProbe->aiColumn[saved_nEq]>=0 ){
        ((void) (0));
                               ;
        pNew->nOut += pTerm->truthProb;
        pNew->nOut -= nIn;
      }else{
# 170090 "c_tests/sqlite3.c"
        {
          pNew->nOut += (pProbe->aiRowLogEst[nEq] - pProbe->aiRowLogEst[nEq-1]);
          if( eOp & 0x0100 ){



            pNew->nOut += 10;
          }
        }
      }
    }
# 170109 "c_tests/sqlite3.c"
    ((void) (0));
    if( pProbe->idxType==3 ){




      rCostIdx = pNew->nOut + 16;
    }else{
      rCostIdx = pNew->nOut + 1 + (15*pProbe->szIdxRow)/pSrc->pSTab->szTabRow;
    }
    rCostIdx = sqlite3LogEstAdd(rLogSize, rCostIdx);







    pNew->rRun = rCostIdx;
    if( (pNew->wsFlags & (0x00000040|0x00000100|0x04000000))==0 ){
      pNew->rRun = sqlite3LogEstAdd(pNew->rRun, pNew->nOut + 16);
    }
                                                             ;

    nOutUnadjusted = pNew->nOut;
    pNew->rRun += nInMul + nIn;
    pNew->nOut += nInMul + nIn;
    whereLoopOutputAdjust(pBuilder->pWC, pNew, rSize);
    rc = whereLoopInsert(pBuilder, pNew);

    if( pNew->wsFlags & 0x00000002 ){
      pNew->nOut = saved_nOut;
    }else{
      pNew->nOut = nOutUnadjusted;
    }

    if( (pNew->wsFlags & 0x00000010)==0
     && pNew->u.btree.nEq<pProbe->nColumn
     && (pNew->u.btree.nEq<pProbe->nKeyCol ||
          pProbe->idxType!=2)
    ){
      if( pNew->u.btree.nEq>3 ){
        sqlite3ProgressCheck(pParse);
      }
      whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, nInMul+nIn);
    }
    pNew->nOut = saved_nOut;



  }
  pNew->prereq = saved_prereq;
  pNew->u.btree.nEq = saved_nEq;
  pNew->u.btree.nBtm = saved_nBtm;
  pNew->u.btree.nTop = saved_nTop;
  pNew->nSkip = saved_nSkip;
  pNew->wsFlags = saved_wsFlags;
  pNew->nOut = saved_nOut;
  pNew->nLTerm = saved_nLTerm;
# 170179 "c_tests/sqlite3.c"
  ((void) (0));
  if( saved_nEq==saved_nSkip
   && saved_nEq+1<pProbe->nKeyCol
   && saved_nEq==pNew->nLTerm
   && pProbe->noSkipScan==0
   && pProbe->hasStat1!=0
   && (((db)->dbOptFlags&(0x00004000))==0)
   && pProbe->aiRowLogEst[saved_nEq+1]>=42
   && pSrc->fg.fromExists==0
   && (rc = whereLoopResize(db, pNew, pNew->nLTerm+1))==0
  ){
    LogEst nIter;
    pNew->u.btree.nEq++;
    pNew->nSkip++;
    pNew->aLTerm[pNew->nLTerm++] = 0;
    pNew->wsFlags |= 0x00008000;
    nIter = pProbe->aiRowLogEst[saved_nEq] - pProbe->aiRowLogEst[saved_nEq+1];
    pNew->nOut -= nIter;


    nIter += 5;
    whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, nIter + nInMul);
    pNew->nOut = saved_nOut;
    pNew->u.btree.nEq = saved_nEq;
    pNew->nSkip = saved_nSkip;
    pNew->wsFlags = saved_wsFlags;
  }


                                                                           ;
  return rc;
}
# 170220 "c_tests/sqlite3.c"
static int indexMightHelpWithOrderBy(
  WhereLoopBuilder *pBuilder,
  Index *pIndex,
  int iCursor
){
  ExprList *pOB;
  ExprList *aColExpr;
  int ii, jj;

  if( pIndex->bUnordered ) return 0;
  if( (pOB = pBuilder->pWInfo->pOrderBy)==0 ) return 0;
  for(ii=0; ii<pOB->nExpr; ii++){
    Expr *pExpr = sqlite3ExprSkipCollateAndLikely(pOB->a[ii].pExpr);
    if( (pExpr==0) ) continue;
    if( (pExpr->op==168 || pExpr->op==170)
     && pExpr->iTable==iCursor
    ){
      if( pExpr->iColumn<0 ) return 1;
      for(jj=0; jj<pIndex->nKeyCol; jj++){
        if( pExpr->iColumn==pIndex->aiColumn[jj] ) return 1;
      }
    }else if( (aColExpr = pIndex->aColExpr)!=0 ){
      for(jj=0; jj<pIndex->nKeyCol; jj++){
        if( pIndex->aiColumn[jj]!=(-2) ) continue;
        if( sqlite3ExprCompareSkip(pExpr,aColExpr->a[jj].pExpr,iCursor)==0 ){
          return 1;
        }
      }
    }
  }
  return 0;
}




static int whereUsablePartialIndex(
  int iTab,
  u8 jointype,
  WhereClause *pWC,
  Expr *pWhere
){
  int i;
  WhereTerm *pTerm;
  Parse *pParse;

  if( jointype & 0x40 ) return 0;
  pParse = pWC->pWInfo->pParse;
  while( pWhere->op==44 ){
    if( !whereUsablePartialIndex(iTab,jointype,pWC,pWhere->pLeft) ) return 0;
    pWhere = pWhere->pRight;
  }
  for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
    Expr *pExpr;
    pExpr = pTerm->pExpr;
    if( (!(((pExpr)->flags&(u32)(0x000001))!=0) || pExpr->w.iJoin==iTab)
     && ((jointype & 0x20)==0 || (((pExpr)->flags&(u32)(0x000001))!=0))
     && sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, iTab)
     && !sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, -1)
     && (pTerm->wtFlags & 0x0080)==0
    ){
      return 1;
    }
  }
  return 0;
}





static int exprIsCoveredByIndex(
  const Expr *pExpr,
  const Index *pIdx,
  int iTabCur
){
  int i;
  for(i=0; i<pIdx->nColumn; i++){
    if( pIdx->aiColumn[i]==(-2)
     && sqlite3ExprCompare(0, pExpr, pIdx->aColExpr->a[i].pExpr, iTabCur)==0
    ){
      return 1;
    }
  }
  return 0;
}




typedef struct CoveringIndexCheck CoveringIndexCheck;
struct CoveringIndexCheck {
  Index *pIdx;
  int iTabCur;
  u8 bExpr;
  u8 bUnidx;
};
# 170335 "c_tests/sqlite3.c"
static int whereIsCoveringIndexWalkCallback(Walker *pWalk, Expr *pExpr){
  int i;
  const Index *pIdx;
  const i16 *aiColumn;
  u16 nColumn;
  CoveringIndexCheck *pCk;

  pCk = pWalk->u.pCovIdxCk;
  pIdx = pCk->pIdx;
  if( (pExpr->op==168 || pExpr->op==170) ){

    if( pExpr->iTable!=pCk->iTabCur ) return 0;
    pIdx = pWalk->u.pCovIdxCk->pIdx;
    aiColumn = pIdx->aiColumn;
    nColumn = pIdx->nColumn;
    for(i=0; i<nColumn; i++){
      if( aiColumn[i]==pExpr->iColumn ) return 0;
    }
    pCk->bUnidx = 1;
    return 2;
  }else if( pIdx->bHasExpr
         && exprIsCoveredByIndex(pExpr, pIdx, pWalk->u.pCovIdxCk->iTabCur) ){
    pCk->bExpr = 1;
    return 1;
  }
  return 0;
}
# 170387 "c_tests/sqlite3.c"
static __attribute__((noinline)) u32 whereIsCoveringIndex(
  WhereInfo *pWInfo,
  Index *pIdx,
  int iTabCur
){
  int i, rc;
  struct CoveringIndexCheck ck;
  Walker w;
  if( pWInfo->pSelect==0 ){


    return 0;
  }
  if( pIdx->bHasExpr==0 ){
    for(i=0; i<pIdx->nColumn; i++){
      if( pIdx->aiColumn[i]>=((int)(sizeof(Bitmask)*8))-1 ) break;
    }
    if( i>=pIdx->nColumn ){



      return 0;
    }
  }
  ck.pIdx = pIdx;
  ck.iTabCur = iTabCur;
  ck.bExpr = 0;
  ck.bUnidx = 0;
  memset(&w, 0, sizeof(w));
  w.xExprCallback = whereIsCoveringIndexWalkCallback;
  w.xSelectCallback = sqlite3SelectWalkNoop;
  w.u.pCovIdxCk = &ck;
  sqlite3WalkSelect(&w, pWInfo->pSelect);
  if( ck.bUnidx ){
    rc = 0;
  }else if( ck.bExpr ){
    rc = 0x04000000;
  }else{
    rc = 0x00000040;
  }
  return rc;
}





static void whereIndexedExprCleanup(sqlite3 *db, void *pObject){
  IndexedExpr **pp = (IndexedExpr**)pObject;
  while( *pp!=0 ){
    IndexedExpr *p = *pp;
    *pp = p->pIENext;
    sqlite3ExprDelete(db, p->pExpr);
    sqlite3DbFreeNN(db, p);
  }
}
# 170471 "c_tests/sqlite3.c"
static void wherePartIdxExpr(
  Parse *pParse,
  Index *pIdx,
  Expr *pPart,
  Bitmask *pMask,
  int iIdxCur,
  SrcItem *pItem
){
  ((void) (0));
  ((void) (0));

  if( pPart->op==44 ){
    wherePartIdxExpr(pParse, pIdx, pPart->pRight, pMask, iIdxCur, pItem);
    pPart = pPart->pLeft;
  }

  if( (pPart->op==54 || pPart->op==45) ){
    Expr *pLeft = pPart->pLeft;
    Expr *pRight = pPart->pRight;
    u8 aff;

    if( pLeft->op!=168 ) return;
    if( !sqlite3ExprIsConstant(0, pRight) ) return;
    if( !sqlite3IsBinary(sqlite3ExprCompareCollSeq(pParse, pPart)) ) return;
    if( pLeft->iColumn<0 ) return;
    aff = pIdx->pTable->aCol[pLeft->iColumn].affinity;
    if( aff>=0x42 ){
      if( pItem ){
        sqlite3 *db = pParse->db;
        IndexedExpr *p = (IndexedExpr*)sqlite3DbMallocRaw(db, sizeof(*p));
        if( p ){
          int bNullRow = (pItem->fg.jointype&(0x08|0x40))!=0;
          p->pExpr = sqlite3ExprDup(db, pRight, 0);
          p->iDataCur = pItem->iCursor;
          p->iIdxCur = iIdxCur;
          p->iIdxCol = pLeft->iColumn;
          p->bMaybeNullRow = bNullRow;
          p->pIENext = pParse->pIdxPartExpr;
          p->aff = aff;
          pParse->pIdxPartExpr = p;
          if( p->pIENext==0 ){
            void *pArg = (void*)&pParse->pIdxPartExpr;
            sqlite3ParserAddCleanup(pParse, whereIndexedExprCleanup, pArg);
          }
        }
      }else if( pLeft->iColumn<(((int)(sizeof(Bitmask)*8))-1) ){
        *pMask &= ~((Bitmask)1 << pLeft->iColumn);
      }
    }
  }
}
# 170560 "c_tests/sqlite3.c"
static int whereLoopAddBtree(
  WhereLoopBuilder *pBuilder,
  Bitmask mPrereq
){
  WhereInfo *pWInfo;
  Index *pProbe;
  Index sPk;
  LogEst aiRowEstPk[2];
  i16 aiColumnPk = -1;
  SrcList *pTabList;
  SrcItem *pSrc;
  WhereLoop *pNew;
  int rc = 0;
  int iSortIdx = 1;
  int b;
  LogEst rSize;
  WhereClause *pWC;
  Table *pTab;

  pNew = pBuilder->pNew;
  pWInfo = pBuilder->pWInfo;
  pTabList = pWInfo->pTabList;
  pSrc = pTabList->a + pNew->iTab;
  pTab = pSrc->pSTab;
  pWC = pBuilder->pWC;
  ((void) (0));

  if( pSrc->fg.isIndexedBy ){
    ((void) (0));

    pProbe = pSrc->u2.pIBIndex;
  }else if( !(((pTab)->tabFlags & 0x00000080)==0) ){
    pProbe = pTab->pIndex;
  }else{




    Index *pFirst;
    memset(&sPk, 0, sizeof(Index));
    sPk.nKeyCol = 1;
    sPk.nColumn = 1;
    sPk.aiColumn = &aiColumnPk;
    sPk.aiRowLogEst = aiRowEstPk;
    sPk.onError = 5;
    sPk.pTable = pTab;
    sPk.szIdxRow = 3;
    sPk.idxType = 3;
    aiRowEstPk[0] = pTab->nRowLogEst;
    aiRowEstPk[1] = 0;
    pFirst = pSrc->pSTab->pIndex;
    if( pSrc->fg.notIndexed==0 ){


      sPk.pNext = pFirst;
    }
    pProbe = &sPk;
  }
  rSize = pTab->nRowLogEst;



  if( !pBuilder->pOrSet
   && (pWInfo->wctrlFlags & (0x1000|0x0020))==0
   && (pWInfo->pParse->db->flags & 0x00008000)!=0
   && !pSrc->fg.isIndexedBy
   && !pSrc->fg.notIndexed
   && !pSrc->fg.isCorrelated
   && !pSrc->fg.isRecursive
   && (pSrc->fg.jointype & 0x10)==0
  ){

    LogEst rLogSize;
    WhereTerm *pTerm;
    WhereTerm *pWCEnd = pWC->a + pWC->nTerm;
    rLogSize = estLog(rSize);
    for(pTerm=pWC->a; rc==0 && pTerm<pWCEnd; pTerm++){
      if( pTerm->prereqRight & pNew->maskSelf ) continue;
      if( termCanDriveIndex(pTerm, pSrc, 0) ){
        pNew->u.btree.nEq = 1;
        pNew->nSkip = 0;
        pNew->u.btree.pIndex = 0;
        pNew->nLTerm = 1;
        pNew->aLTerm[0] = pTerm;
# 170652 "c_tests/sqlite3.c"
        pNew->rSetup = rLogSize + rSize;
        if( !((pTab)->eTabType==2) && (pTab->tabFlags & 0x00004000)==0 ){
          pNew->rSetup += 28;
        }else{
          pNew->rSetup -= 25;

        }
                                                         ;
        if( pNew->rSetup<0 ) pNew->rSetup = 0;




        pNew->nOut = 43; ((void) (0));
        pNew->rRun = sqlite3LogEstAdd(rLogSize,pNew->nOut);
        pNew->wsFlags = 0x00004000;
        pNew->prereq = mPrereq | pTerm->prereqRight;
        rc = whereLoopInsert(pBuilder, pNew);
      }
    }
  }




  for(; rc==0 && pProbe;
      pProbe=(pSrc->fg.isIndexedBy ? 0 : pProbe->pNext), iSortIdx++
  ){
    if( pProbe->pPartIdxWhere!=0
     && !whereUsablePartialIndex(pSrc->iCursor, pSrc->fg.jointype, pWC,
                                 pProbe->pPartIdxWhere)
    ){
                                           ;
      continue;
    }
    if( pProbe->bNoQuery ) continue;
    rSize = pProbe->aiRowLogEst[0];
    pNew->u.btree.nEq = 0;
    pNew->u.btree.nBtm = 0;
    pNew->u.btree.nTop = 0;
    pNew->u.btree.nDistinctCol = 0;
    pNew->nSkip = 0;
    pNew->nLTerm = 0;
    pNew->iSortIdx = 0;
    pNew->rSetup = 0;
    pNew->prereq = mPrereq;
    pNew->nOut = rSize;
    pNew->u.btree.pIndex = pProbe;
    pNew->u.btree.pOrderBy = 0;
    b = indexMightHelpWithOrderBy(pBuilder, pProbe, pSrc->iCursor);


    ((void) (0));
    if( pProbe->idxType==3 ){

      pNew->wsFlags = 0x00000100;


      pNew->iSortIdx = b ? iSortIdx : 0;
# 170726 "c_tests/sqlite3.c"
      pNew->rRun = rSize + 16;

                                                     ;
      whereLoopOutputAdjust(pWC, pNew, rSize);
      if( pSrc->fg.isSubquery ){
        if( pSrc->fg.viaCoroutine ) pNew->wsFlags |= 0x02000000;
        pNew->u.btree.pOrderBy = pSrc->u4.pSubq->pSelect->pOrderBy;
      }
      rc = whereLoopInsert(pBuilder, pNew);
      pNew->nOut = rSize;
      if( rc ) break;
    }else{
      Bitmask m;
      if( pProbe->isCovering ){
        m = 0;
        pNew->wsFlags = 0x00000040 | 0x00000200;
      }else{
        m = pSrc->colUsed & pProbe->colNotIdxed;
        if( pProbe->pPartIdxWhere ){
          wherePartIdxExpr(
              pWInfo->pParse, pProbe, pProbe->pPartIdxWhere, &m, 0, 0
          );
        }
        pNew->wsFlags = 0x00000200;
        if( m==(((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) || (pProbe->bHasExpr && !pProbe->bHasVCol && m!=0) ){
          u32 isCov = whereIsCoveringIndex(pWInfo, pProbe, pSrc->iCursor);
          if( isCov==0 ){


                                                                         ;
            ((void) (0));
          }else{
            m = 0;
            pNew->wsFlags |= isCov;
            if( isCov & 0x00000040 ){


                                                                           ;
            }else{
              ((void) (0));


                                                                           ;
            }
          }
        }else if( m==0
           && ((((pTab)->tabFlags & 0x00000080)==0) || pWInfo->pSelect!=0 || sqlite3FaultSim(700))
        ){


                                                    ;
          pNew->wsFlags = 0x00000040 | 0x00000200;
        }
      }


      if( b
       || !(((pTab)->tabFlags & 0x00000080)==0)
       || pProbe->pPartIdxWhere!=0
       || pSrc->fg.isIndexedBy
       || ( m==0
         && pProbe->bUnordered==0
         && (pProbe->szIdxRow<pTab->szTabRow)
         && (pWInfo->wctrlFlags & 0x0004)==0
         && sqlite3Config.bUseCis
         && (((pWInfo->pParse->db)->dbOptFlags&(0x00000020))==0)
          )
      ){
        pNew->iSortIdx = b ? iSortIdx : 0;




        pNew->rRun = rSize + 1 + (15*pProbe->szIdxRow)/pTab->szTabRow;
        if( m!=0 ){





          LogEst nLookup = rSize + 16;
          int ii;
          int iCur = pSrc->iCursor;
          WhereClause *pWC2 = &pWInfo->sWC;
          for(ii=0; ii<pWC2->nTerm; ii++){
            WhereTerm *pTerm = &pWC2->a[ii];
            if( !sqlite3ExprCoveredByIndex(pTerm->pExpr, iCur, pProbe) ){
              break;
            }


            if( pTerm->truthProb<=0 ){
              nLookup += pTerm->truthProb;
            }else{
              nLookup--;
              if( pTerm->eOperator & (0x0002|0x0080) ) nLookup -= 19;
            }
          }

          pNew->rRun = sqlite3LogEstAdd(pNew->rRun, nLookup);
        }
                                                       ;
        whereLoopOutputAdjust(pWC, pNew, rSize);
        if( (pSrc->fg.jointype & 0x10)!=0 && pProbe->aColExpr ){




        }else{
          rc = whereLoopInsert(pBuilder, pNew);
        }
        pNew->nOut = rSize;
        if( rc ) break;
      }
    }

    pBuilder->bldFlags1 = 0;
    rc = whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, 0);
    if( pBuilder->bldFlags1==0x0001 ){




      pTab->tabFlags |= 0x00000100;
    }





  }
  return rc;
}






static int isLimitTerm(WhereTerm *pTerm){
  ((void) (0));
  return pTerm->eMatchOp>=73
      && pTerm->eMatchOp<=74;
}





static int allConstraintsUsed(
  struct sqlite3_index_constraint_usage *aUsage,
  int nCons
){
  int ii;
  for(ii=0; ii<nCons; ii++){
    if( aUsage[ii].argvIndex<=0 ) return 0;
  }
  return 1;
}
# 170906 "c_tests/sqlite3.c"
static int whereLoopAddVirtualOne(
  WhereLoopBuilder *pBuilder,
  Bitmask mPrereq,
  Bitmask mUsable,
  u16 mExclude,
  sqlite3_index_info *pIdxInfo,
  u16 mNoOmit,
  int *pbIn,
  int *pbRetryLimit
){
  WhereClause *pWC = pBuilder->pWC;
  HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];
  struct sqlite3_index_constraint *pIdxCons;
  struct sqlite3_index_constraint_usage *pUsage = pIdxInfo->aConstraintUsage;
  int i;
  int mxTerm;
  int rc = 0;
  WhereLoop *pNew = pBuilder->pNew;
  Parse *pParse = pBuilder->pWInfo->pParse;
  SrcItem *pSrc = &pBuilder->pWInfo->pTabList->a[pNew->iTab];
  int nConstraint = pIdxInfo->nConstraint;

  ((void) (0));
  *pbIn = 0;
  pNew->prereq = mPrereq;



  pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;
  for(i=0; i<nConstraint; i++, pIdxCons++){
    WhereTerm *pTerm = termFromWhereClause(pWC, pIdxCons->iTermOffset);
    pIdxCons->usable = 0;
    if( (pTerm->prereqRight & mUsable)==pTerm->prereqRight
     && (pTerm->eOperator & mExclude)==0
     && (pbRetryLimit || !isLimitTerm(pTerm))
    ){
      pIdxCons->usable = 1;
    }
  }


  memset(pUsage, 0, sizeof(pUsage[0])*nConstraint);
  ((void) (0));
  pIdxInfo->idxStr = 0;
  pIdxInfo->idxNum = 0;
  pIdxInfo->orderByConsumed = 0;
  pIdxInfo->estimatedCost = (1e99) / (double)2;
  pIdxInfo->estimatedRows = 25;
  pIdxInfo->idxFlags = 0;
  pHidden->mHandleIn = 0;


  rc = vtabBestIndex(pParse, pSrc->pSTab, pIdxInfo);
  if( rc ){
    if( rc==19 ){




                                                                       ;
      freeIdxStr(pIdxInfo);
      return 0;
    }
    return rc;
  }

  mxTerm = -1;
  ((void) (0));
  memset(pNew->aLTerm, 0, sizeof(pNew->aLTerm[0])*nConstraint );
  memset(&pNew->u.vtab, 0, sizeof(pNew->u.vtab));
  pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;
  for(i=0; i<nConstraint; i++, pIdxCons++){
    int iTerm;
    if( (iTerm = pUsage[i].argvIndex - 1)>=0 ){
      WhereTerm *pTerm;
      int j = pIdxCons->iTermOffset;
      if( iTerm>=nConstraint
       || j<0
       || (pTerm = termFromWhereClause(pWC, j))==0
       || pNew->aLTerm[iTerm]!=0
       || pIdxCons->usable==0
      ){
        sqlite3ErrorMsg(pParse,"%s.xBestIndex malfunction",pSrc->pSTab->zName);
        freeIdxStr(pIdxInfo);
        return 1;
      }
                                      ;
                      ;
                                 ;
      pNew->prereq |= pTerm->prereqRight;
      ((void) (0));
      pNew->aLTerm[iTerm] = pTerm;
      if( iTerm>mxTerm ) mxTerm = iTerm;
                           ;
                           ;
      if( pUsage[i].omit ){
        if( i<16 && ((1<<i)&mNoOmit)==0 ){
                              ;
          pNew->u.vtab.omitMask |= 1<<iTerm;
        }else{
                              ;
        }
        if( pTerm->eMatchOp==74 ){
          pNew->u.vtab.bOmitOffset = 1;
        }
      }
      if( ((i)<=31?((unsigned int)1)<<(i):0) & pHidden->mHandleIn ){
        pNew->u.vtab.mHandleIn |= (((unsigned int)1)<<(iTerm));
      }else if( (pTerm->eOperator & 0x0001)!=0 ){





        pIdxInfo->orderByConsumed = 0;
        pIdxInfo->idxFlags &= ~0x00000001;
        *pbIn = 1; ((void) (0));
      }



      ((void) (0));
      ((void) (0));
      ((void) (0));

      if( isLimitTerm(pTerm) && (*pbIn || !allConstraintsUsed(pUsage, i)) ){







        freeIdxStr(pIdxInfo);
        *pbRetryLimit = 1;
        return 0;
      }
    }
  }

  pNew->nLTerm = mxTerm+1;
  for(i=0; i<=mxTerm; i++){
    if( pNew->aLTerm[i]==0 ){


      sqlite3ErrorMsg(pParse,"%s.xBestIndex malfunction",pSrc->pSTab->zName);
      freeIdxStr(pIdxInfo);
      return 1;
    }
  }
  ((void) (0));
  pNew->u.vtab.idxNum = pIdxInfo->idxNum;
  pNew->u.vtab.needFree = pIdxInfo->needToFreeIdxStr;
  pIdxInfo->needToFreeIdxStr = 0;
  pNew->u.vtab.idxStr = pIdxInfo->idxStr;
  pNew->u.vtab.isOrdered = (i8)(pIdxInfo->orderByConsumed ?
      pIdxInfo->nOrderBy : 0);
  pNew->u.vtab.bIdxNumHex = (pIdxInfo->idxFlags&0x00000002)!=0;
  pNew->rSetup = 0;
  pNew->rRun = sqlite3LogEstFromDouble(pIdxInfo->estimatedCost);
  pNew->nOut = sqlite3LogEst(pIdxInfo->estimatedRows);



  if( pIdxInfo->idxFlags & 0x00000001 ){
    pNew->wsFlags |= 0x00001000;
  }else{
    pNew->wsFlags &= ~0x00001000;
  }
  rc = whereLoopInsert(pBuilder, pNew);
  if( pNew->u.vtab.needFree ){
    sqlite3_free(pNew->u.vtab.idxStr);
    pNew->u.vtab.needFree = 0;
  }


                                                                 ;

  return rc;
}
# 171102 "c_tests/sqlite3.c"
           const char *sqlite3_vtab_collation(sqlite3_index_info *pIdxInfo, int iCons){
  HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];
  const char *zRet = 0;
  if( iCons>=0 && iCons<pIdxInfo->nConstraint ){
    CollSeq *pC = 0;
    int iTerm = pIdxInfo->aConstraint[iCons].iTermOffset;
    Expr *pX = termFromWhereClause(pHidden->pWC, iTerm)->pExpr;
    if( pX->pLeft ){
      pC = sqlite3ExprCompareCollSeq(pHidden->pParse, pX);
    }
    zRet = (pC ? pC->zName : sqlite3StrBINARY);
  }
  return zRet;
}






           int sqlite3_vtab_in(sqlite3_index_info *pIdxInfo, int iCons, int bHandle){
  HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];
  u32 m = ((iCons)<=31?((unsigned int)1)<<(iCons):0);
  if( m & pHidden->mIn ){
    if( bHandle==0 ){
      pHidden->mHandleIn &= ~m;
    }else if( bHandle>0 ){
      pHidden->mHandleIn |= m;
    }
    return 1;
  }
  return 0;
}







           int sqlite3_vtab_rhs_value(
  sqlite3_index_info *pIdxInfo,
  int iCons,
  sqlite3_value **ppVal
){
  HiddenIndexInfo *pH = (HiddenIndexInfo*)&pIdxInfo[1];
  sqlite3_value *pVal = 0;
  int rc = 0;
  if( iCons<0 || iCons>=pIdxInfo->nConstraint ){
    rc = sqlite3MisuseError(171151);
  }else{
    if( pH->aRhs[iCons]==0 ){
      WhereTerm *pTerm = termFromWhereClause(
          pH->pWC, pIdxInfo->aConstraint[iCons].iTermOffset
      );
      rc = sqlite3ValueFromExpr(
          pH->pParse->db, pTerm->pExpr->pRight, ((pH->pParse->db)->enc),
          0x41, &pH->aRhs[iCons]
      );
                               ;
    }
    pVal = pH->aRhs[iCons];
  }
  *ppVal = pVal;

  if( rc==0 && pVal==0 ){
    rc = 12;
  }

  return rc;
}




           int sqlite3_vtab_distinct(sqlite3_index_info *pIdxInfo){
  HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];
  ((void) (0));
  return pHidden->eDistinct;
}
# 171192 "c_tests/sqlite3.c"
static void sqlite3VtabUsesAllSchemas(Parse *pParse){
  int nDb = pParse->db->nDb;
  int i;
  for(i=0; i<nDb; i++){
    sqlite3CodeVerifySchema(pParse, i);
  }
  if( ((pParse->writeMask)!=0) ){
    for(i=0; i<nDb; i++){
      sqlite3BeginWriteOperation(pParse, 0, i);
    }
  }
}
# 171230 "c_tests/sqlite3.c"
static int whereLoopAddVirtual(
  WhereLoopBuilder *pBuilder,
  Bitmask mPrereq,
  Bitmask mUnusable
){
  int rc = 0;
  WhereInfo *pWInfo;
  Parse *pParse;
  WhereClause *pWC;
  SrcItem *pSrc;
  sqlite3_index_info *p;
  int nConstraint;
  int bIn;
  WhereLoop *pNew;
  Bitmask mBest;
  u16 mNoOmit;
  int bRetry = 0;

  ((void) (0));
  pWInfo = pBuilder->pWInfo;
  pParse = pWInfo->pParse;
  pWC = pBuilder->pWC;
  pNew = pBuilder->pNew;
  pSrc = &pWInfo->pTabList->a[pNew->iTab];
  ((void) (0));
  p = allocateIndexInfo(pWInfo, pWC, mUnusable, pSrc, &mNoOmit);
  if( p==0 ) return 7;
  pNew->rSetup = 0;
  pNew->wsFlags = 0x00000400;
  pNew->nLTerm = 0;
  pNew->u.vtab.needFree = 0;
  nConstraint = p->nConstraint;
  if( whereLoopResize(pParse->db, pNew, nConstraint) ){
    freeIndexInfo(pParse->db, p);
    return 7;
  }


                                                                    ;
                                                   ;
  rc = whereLoopAddVirtualOne(
      pBuilder, mPrereq, ((Bitmask)-1), 0, p, mNoOmit, &bIn, &bRetry
  );
  if( bRetry ){
    ((void) (0));
    rc = whereLoopAddVirtualOne(
        pBuilder, mPrereq, ((Bitmask)-1), 0, p, mNoOmit, &bIn, 0
    );
  }






  if( rc==0 && ((mBest = (pNew->prereq & ~mPrereq))!=0 || bIn) ){
    int seenZero = 0;
    int seenZeroNoIN = 0;
    Bitmask mPrev = 0;
    Bitmask mBestNoIn = 0;



    if( bIn ){
                                                              ;
      rc = whereLoopAddVirtualOne(
          pBuilder, mPrereq, ((Bitmask)-1), 0x0001, p, mNoOmit, &bIn, 0);
      ((void) (0));
      mBestNoIn = pNew->prereq & ~mPrereq;
      if( mBestNoIn==0 ){
        seenZero = 1;
        seenZeroNoIN = 1;
      }
    }



    while( rc==0 ){
      int i;
      Bitmask mNext = ((Bitmask)-1);
      ((void) (0));
      for(i=0; i<nConstraint; i++){
        int iTerm = p->aConstraint[i].iTermOffset;
        Bitmask mThis = termFromWhereClause(pWC, iTerm)->prereqRight & ~mPrereq;
        if( mThis>mPrev && mThis<mNext ) mNext = mThis;
      }
      mPrev = mNext;
      if( mNext==((Bitmask)-1) ) break;
      if( mNext==mBest || mNext==mBestNoIn ) continue;

                                                                     ;
      rc = whereLoopAddVirtualOne(
          pBuilder, mPrereq, mNext|mPrereq, 0, p, mNoOmit, &bIn, 0);
      if( pNew->prereq==mPrereq ){
        seenZero = 1;
        if( bIn==0 ) seenZeroNoIN = 1;
      }
    }




    if( rc==0 && seenZero==0 ){
                                                         ;
      rc = whereLoopAddVirtualOne(
          pBuilder, mPrereq, mPrereq, 0, p, mNoOmit, &bIn, 0);
      if( bIn==0 ) seenZeroNoIN = 1;
    }




    if( rc==0 && seenZeroNoIN==0 ){
                                                                    ;
      rc = whereLoopAddVirtualOne(
          pBuilder, mPrereq, mPrereq, 0x0001, p, mNoOmit, &bIn, 0);
    }
  }

  freeIndexInfo(pParse->db, p);
                                                                             ;
  return rc;
}






static int whereLoopAddOr(
  WhereLoopBuilder *pBuilder,
  Bitmask mPrereq,
  Bitmask mUnusable
){
  WhereInfo *pWInfo = pBuilder->pWInfo;
  WhereClause *pWC;
  WhereLoop *pNew;
  WhereTerm *pTerm, *pWCEnd;
  int rc = 0;
  int iCur;
  WhereClause tempWC;
  WhereLoopBuilder sSubBuild;
  WhereOrSet sSum, sCur;
  SrcItem *pItem;

  pWC = pBuilder->pWC;
  pWCEnd = pWC->a + pWC->nTerm;
  pNew = pBuilder->pNew;
  memset(&sSum, 0, sizeof(sSum));
  pItem = pWInfo->pTabList->a + pNew->iTab;
  iCur = pItem->iCursor;


  if( pItem->fg.jointype & 0x10 ) return 0;

  for(pTerm=pWC->a; pTerm<pWCEnd && rc==0; pTerm++){
    if( (pTerm->eOperator & 0x0200)!=0
     && (pTerm->u.pOrInfo->indexable & pNew->maskSelf)!=0
    ){
      WhereClause * const pOrWC = &pTerm->u.pOrInfo->wc;
      WhereTerm * const pOrWCEnd = &pOrWC->a[pOrWC->nTerm];
      WhereTerm *pOrTerm;
      int once = 1;
      int i, j;

      sSubBuild = *pBuilder;
      sSubBuild.pOrSet = &sCur;

                                                                   ;
      for(pOrTerm=pOrWC->a; pOrTerm<pOrWCEnd; pOrTerm++){
        if( (pOrTerm->eOperator & 0x0400)!=0 ){
          sSubBuild.pWC = &pOrTerm->u.pAndInfo->wc;
        }else if( pOrTerm->leftCursor==iCur ){
          tempWC.pWInfo = pWC->pWInfo;
          tempWC.pOuter = pWC;
          tempWC.op = 44;
          tempWC.nTerm = 1;
          tempWC.nBase = 1;
          tempWC.a = pOrTerm;
          sSubBuild.pWC = &tempWC;
        }else{
          continue;
        }
        sCur.n = 0;
# 171422 "c_tests/sqlite3.c"
        if( ((pItem->pSTab)->eTabType==1) ){
          rc = whereLoopAddVirtual(&sSubBuild, mPrereq, mUnusable);
        }else

        {
          rc = whereLoopAddBtree(&sSubBuild, mPrereq);
        }
        if( rc==0 ){
          rc = whereLoopAddOr(&sSubBuild, mPrereq, mUnusable);
        }
                                                ;
                                   ;
        if( sCur.n==0 ){
          sSum.n = 0;
          break;
        }else if( once ){
          whereOrMove(&sSum, &sCur);
          once = 0;
        }else{
          WhereOrSet sPrev;
          whereOrMove(&sPrev, &sSum);
          sSum.n = 0;
          for(i=0; i<sPrev.n; i++){
            for(j=0; j<sCur.n; j++){
              whereOrInsert(&sSum, sPrev.a[i].prereq | sCur.a[j].prereq,
                            sqlite3LogEstAdd(sPrev.a[i].rRun, sCur.a[j].rRun),
                            sqlite3LogEstAdd(sPrev.a[i].nOut, sCur.a[j].nOut));
            }
          }
        }
      }
      pNew->nLTerm = 1;
      pNew->aLTerm[0] = pTerm;
      pNew->wsFlags = 0x00002000;
      pNew->rSetup = 0;
      pNew->iSortIdx = 0;
      memset(&pNew->u, 0, sizeof(pNew->u));
      for(i=0; rc==0 && i<sSum.n; i++){
# 171472 "c_tests/sqlite3.c"
        pNew->rRun = sSum.a[i].rRun + 1;
        pNew->nOut = sSum.a[i].nOut;
        pNew->prereq = sSum.a[i].prereq;
        rc = whereLoopInsert(pBuilder, pNew);
      }
                                                                 ;
    }
  }
  return rc;
}




static int whereLoopAddAll(WhereLoopBuilder *pBuilder){
  WhereInfo *pWInfo = pBuilder->pWInfo;
  Bitmask mPrereq = 0;
  Bitmask mPrior = 0;
  int iTab;
  SrcList *pTabList = pWInfo->pTabList;
  SrcItem *pItem;
  SrcItem *pEnd = &pTabList->a[pWInfo->nLevel];
  sqlite3 *db = pWInfo->pParse->db;
  int rc = 0;
  int bFirstPastRJ = 0;
  int hasRightJoin = 0;
  WhereLoop *pNew;



  pNew = pBuilder->pNew;


  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  pBuilder->iPlanLimit = 20000;
  for(iTab=0, pItem=pTabList->a; pItem<pEnd; iTab++, pItem++){
    Bitmask mUnusable = 0;
    pNew->iTab = iTab;
    pBuilder->iPlanLimit += 1000;
    pNew->maskSelf = sqlite3WhereGetMask(&pWInfo->sMaskSet, pItem->iCursor);
    if( bFirstPastRJ
     || (pItem->fg.jointype & (0x20|0x02|0x40))!=0
    ){
# 171529 "c_tests/sqlite3.c"
      if( pItem->fg.jointype & 0x40 ) hasRightJoin = 1;
      mPrereq |= mPrior;
      bFirstPastRJ = (pItem->fg.jointype & 0x10)!=0;
    }else if( !hasRightJoin ){
      mPrereq = 0;
    }

    if( ((pItem->pSTab)->eTabType==1) ){
      SrcItem *p;
      for(p=&pItem[1]; p<pEnd; p++){
        if( mUnusable || (p->fg.jointype & (0x20|0x02)) ){
          mUnusable |= sqlite3WhereGetMask(&pWInfo->sMaskSet, p->iCursor);
        }
      }
      rc = whereLoopAddVirtual(pBuilder, mPrereq, mUnusable);
    }else

    {
      rc = whereLoopAddBtree(pBuilder, mPrereq);
    }
    if( rc==0 && pBuilder->pWC->hasOr ){
      rc = whereLoopAddOr(pBuilder, mPrereq, mUnusable);
    }
    mPrior |= pNew->maskSelf;
    if( rc || db->mallocFailed ){
      if( rc==101 ){

        sqlite3_log(28, "abbreviated query algorithm search");
        rc = 0;
      }else{
        break;
      }
    }
  }

  whereLoopClear(db, pNew);
  return rc;
}
# 171607 "c_tests/sqlite3.c"
static __attribute__((noinline)) int wherePathMatchSubqueryOB(
  WhereInfo *pWInfo,
  WhereLoop *pLoop,
  int iLoop,
  int iCur,
  ExprList *pOrderBy,
  Bitmask *pRevMask,
  Bitmask *pOBSat
){
  int iOB;
  int jSub;
  u8 rev = 0;
  u8 revIdx = 0;
  Expr *pOBExpr;
  ExprList *pSubOB;

  pSubOB = pLoop->u.btree.pOrderBy;
  ((void) (0));
  for(iOB=0; ((((Bitmask)1)<<(iOB)) & *pOBSat)!=0; iOB++){}
  for(jSub=0; jSub<pSubOB->nExpr && iOB<pOrderBy->nExpr; jSub++, iOB++){
    if( pSubOB->a[jSub].u.x.iOrderByCol==0 ) break;
    pOBExpr = pOrderBy->a[iOB].pExpr;
    if( pOBExpr->op!=168 && pOBExpr->op!=170 ) break;
    if( pOBExpr->iTable!=iCur ) break;
    if( pOBExpr->iColumn!=pSubOB->a[jSub].u.x.iOrderByCol-1 ) break;
    if( (pWInfo->wctrlFlags & 0x0040)==0 ){
      u8 sfOB = pOrderBy->a[iOB].fg.sortFlags;
      u8 sfSub = pSubOB->a[jSub].fg.sortFlags;
      if( (sfSub & 0x02) != (sfOB & 0x02) ){
        break;
      }
      revIdx = sfSub & 0x01;
      if( jSub>0 ){
        if( (rev^revIdx)!=(sfOB & 0x01) ){
          break;
        }
      }else{
        rev = revIdx ^ (sfOB & 0x01);
        if( rev ){
          if( (pLoop->wsFlags & 0x02000000)!=0 ){

            break;
          }
          *pRevMask |= (((Bitmask)1)<<(iLoop));
        }
      }
    }
    *pOBSat |= (((Bitmask)1)<<(iOB));
  }
  return jSub>0;
}
# 171676 "c_tests/sqlite3.c"
static i8 wherePathSatisfiesOrderBy(
  WhereInfo *pWInfo,
  ExprList *pOrderBy,
  WherePath *pPath,
  u16 wctrlFlags,
  u16 nLoop,
  WhereLoop *pLast,
  Bitmask *pRevMask
){
  u8 revSet;
  u8 rev;
  u8 revIdx;
  u8 isOrderDistinct;
  u8 distinctColumns;
  u8 isMatch;
  u16 eqOpMask;
  u16 nKeyCol;
  u16 nColumn;
  u16 nOrderBy;
  int iLoop;
  int i, j;
  int iCur;
  int iColumn;
  WhereLoop *pLoop = 0;
  WhereTerm *pTerm;
  Expr *pOBExpr;
  CollSeq *pColl;
  Index *pIndex;
  sqlite3 *db = pWInfo->pParse->db;
  Bitmask obSat = 0;
  Bitmask obDone;
  Bitmask orderDistinctMask;
  Bitmask ready;
# 171732 "c_tests/sqlite3.c"
  ((void) (0));
  if( nLoop && (((db)->dbOptFlags&(0x00000040))!=0) ) return 0;

  nOrderBy = pOrderBy->nExpr;
                             ;
  if( nOrderBy>((int)(sizeof(Bitmask)*8))-1 ) return 0;
  isOrderDistinct = 1;
  obDone = (((Bitmask)1)<<(nOrderBy))-1;
  orderDistinctMask = 0;
  ready = 0;
  eqOpMask = 0x0002 | 0x0080 | 0x0100;
  if( wctrlFlags & (0x0800|0x0002|0x0001) ){
    eqOpMask |= 0x0001;
  }
  for(iLoop=0; isOrderDistinct && obSat<obDone && iLoop<=nLoop; iLoop++){
    if( iLoop>0 ) ready |= pLoop->maskSelf;
    if( iLoop<nLoop ){
      pLoop = pPath->aLoop[iLoop];
      if( wctrlFlags & 0x0800 ) continue;
    }else{
      pLoop = pLast;
    }
    if( pLoop->wsFlags & 0x00000400 ){
      if( pLoop->u.vtab.isOrdered
       && ((wctrlFlags&(0x0080|0x0200))!=0x0080)
      ){
        obSat = obDone;
      }else{


        isOrderDistinct = 0;
      }
      break;
    }
    iCur = pWInfo->pTabList->a[pLoop->iTab].iCursor;






    for(i=0; i<nOrderBy; i++){
      if( (((Bitmask)1)<<(i)) & obSat ) continue;
      pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);
      if( (pOBExpr==0) ) continue;
      if( pOBExpr->op!=168 && pOBExpr->op!=170 ) continue;
      if( pOBExpr->iTable!=iCur ) continue;
      pTerm = sqlite3WhereFindTerm(&pWInfo->sWC, iCur, pOBExpr->iColumn,
                       ~ready, eqOpMask, 0);
      if( pTerm==0 ) continue;
      if( pTerm->eOperator==0x0001 ){



        ((void) (0));

        for(j=0; j<pLoop->nLTerm && pTerm!=pLoop->aLTerm[j]; j++){}
        if( j>=pLoop->nLTerm ) continue;
      }
      if( (pTerm->eOperator&(0x0002|0x0080))!=0 && pOBExpr->iColumn>=0 ){
        Parse *pParse = pWInfo->pParse;
        CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pOrderBy->a[i].pExpr);
        CollSeq *pColl2 = sqlite3ExprCompareCollSeq(pParse, pTerm->pExpr);
        ((void) (0));
        if( pColl2==0 || sqlite3StrICmp(pColl1->zName, pColl2->zName) ){
          continue;
        }
                                           ;
      }
      obSat |= (((Bitmask)1)<<(i));
    }

    if( (pLoop->wsFlags & 0x00001000)==0 ){
      if( pLoop->wsFlags & 0x00000100 ){
        if( pLoop->u.btree.pOrderBy
         && (((db)->dbOptFlags&(0x10000000))==0)
         && wherePathMatchSubqueryOB(pWInfo,pLoop,iLoop,iCur,
                                     pOrderBy,pRevMask, &obSat)
        ){
          nColumn = 0;
          isOrderDistinct = 0;
        }else{
          nColumn = 1;
        }
        pIndex = 0;
        nKeyCol = 0;
      }else if( (pIndex = pLoop->u.btree.pIndex)==0 || pIndex->bUnordered ){
        return 0;
      }else{
        nKeyCol = pIndex->nKeyCol;
        nColumn = pIndex->nColumn;
        ((void) (0));
        ((void) (0));





        isOrderDistinct = ((pIndex)->onError!=0)
                          && (pLoop->wsFlags & 0x00008000)==0;
      }




      rev = revSet = 0;
      distinctColumns = 0;
      for(j=0; j<nColumn; j++){
        u8 bOnce = 1;

        ((void) (0));


        if( j<pLoop->u.btree.nEq && j>=pLoop->nSkip ){
          u16 eOp = pLoop->aLTerm[j]->eOperator;
# 171860 "c_tests/sqlite3.c"
          if( (eOp & eqOpMask)!=0 ){
            if( eOp & (0x0100|0x0080) ){
                                         ;
                                     ;
                                         ;
              isOrderDistinct = 0;
            }
            continue;
          }else if( (eOp & 0x0001) ){




            Expr *pX = pLoop->aLTerm[j]->pExpr;
            for(i=j+1; i<pLoop->u.btree.nEq; i++){
              if( pLoop->aLTerm[i]->pExpr==pX ){
                ((void) (0));
                bOnce = 0;
                break;
              }
            }
          }
        }




        if( pIndex ){
          iColumn = pIndex->aiColumn[j];
          revIdx = pIndex->aSortOrder[j] & 0x01;
          if( iColumn==pIndex->pTable->iPKey ) iColumn = (-1);
        }else{
          iColumn = (-1);
          revIdx = 0;
        }




        if( isOrderDistinct ){
          if( iColumn>=0
           && j>=pLoop->u.btree.nEq
           && pIndex->pTable->aCol[iColumn].notNull==0
          ){
            isOrderDistinct = 0;
          }
          if( iColumn==(-2) ){
            isOrderDistinct = 0;
          }
        }




        isMatch = 0;
        for(i=0; bOnce && i<nOrderBy; i++){
          if( (((Bitmask)1)<<(i)) & obSat ) continue;
          pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);
                                                ;
                                                   ;
          if( (pOBExpr==0) ) continue;
          if( (wctrlFlags & (0x0040|0x0080))==0 ) bOnce = 0;
          if( iColumn>=(-1) ){
            if( pOBExpr->op!=168 && pOBExpr->op!=170 ) continue;
            if( pOBExpr->iTable!=iCur ) continue;
            if( pOBExpr->iColumn!=iColumn ) continue;
          }else{
            Expr *pIxExpr = pIndex->aColExpr->a[j].pExpr;
            if( sqlite3ExprCompareSkip(pOBExpr, pIxExpr, iCur) ){
              continue;
            }
          }
          if( iColumn!=(-1) ){
            pColl = sqlite3ExprNNCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr);
            if( sqlite3StrICmp(pColl->zName, pIndex->azColl[j])!=0 ) continue;
          }
          if( wctrlFlags & 0x0080 ){
            pLoop->u.btree.nDistinctCol = j+1;
          }
          isMatch = 1;
          break;
        }
        if( isMatch && (wctrlFlags & 0x0040)==0 ){


          if( revSet ){
            if( (rev ^ revIdx)
                           != (pOrderBy->a[i].fg.sortFlags&0x01)
            ){
              isMatch = 0;
            }
          }else{
            rev = revIdx ^ (pOrderBy->a[i].fg.sortFlags & 0x01);
            if( rev ) *pRevMask |= (((Bitmask)1)<<(iLoop));
            revSet = 1;
          }
        }
        if( isMatch && (pOrderBy->a[i].fg.sortFlags & 0x02) ){
          if( j==pLoop->u.btree.nEq ){
            pLoop->wsFlags |= 0x00080000;
          }else{
            isMatch = 0;
          }
        }
        if( isMatch ){
          if( iColumn==(-1) ){
                                          ;
            distinctColumns = 1;
          }
          obSat |= (((Bitmask)1)<<(i));
        }else{

          if( j==0 || j<nKeyCol ){
                                          ;
            isOrderDistinct = 0;
          }
          break;
        }
      }
      if( distinctColumns ){
                                      ;
        isOrderDistinct = 1;
      }
    }


    if( isOrderDistinct ){
      orderDistinctMask |= pLoop->maskSelf;
      for(i=0; i<nOrderBy; i++){
        Expr *p;
        Bitmask mTerm;
        if( (((Bitmask)1)<<(i)) & obSat ) continue;
        p = pOrderBy->a[i].pExpr;
        mTerm = sqlite3WhereExprUsage(&pWInfo->sMaskSet,p);
        if( mTerm==0 && !sqlite3ExprIsConstant(0,p) ) continue;
        if( (mTerm&~orderDistinctMask)==0 ){
          obSat |= (((Bitmask)1)<<(i));
        }
      }
    }
  }
  if( obSat==obDone ) return (i8)nOrderBy;
  if( !isOrderDistinct ){
    for(i=nOrderBy-1; i>0; i--){
      Bitmask m = (i<((int)(sizeof(Bitmask)*8))) ? (((Bitmask)1)<<(i)) - 1 : 0;
      if( (obSat&m)==m ) return i;
    }
    return 0;
  }
  return -1;
}
# 172036 "c_tests/sqlite3.c"
static int sqlite3WhereIsSorted(WhereInfo *pWInfo){
  ((void) (0));
  ((void) (0));
  return pWInfo->sorted;
}
# 172059 "c_tests/sqlite3.c"
static LogEst whereSortingCost(
  WhereInfo *pWInfo,
  LogEst nRow,
  int nOrderBy,
  int nSorted
){
# 172086 "c_tests/sqlite3.c"
  LogEst rSortCost, nCol;
  ((void) (0));
  ((void) (0));

  nCol = sqlite3LogEst((pWInfo->pSelect->pEList->nExpr+59)/30);
  rSortCost = nRow + nCol;
  if( nSorted>0 ){

    rSortCost += sqlite3LogEst((nOrderBy-nSorted)*100/nOrderBy) - 66;
  }






  if( (pWInfo->wctrlFlags & 0x4000)!=0 ){
    rSortCost += 10;
    if( nSorted!=0 ){
      rSortCost += 6;
    }
    if( pWInfo->iLimit<nRow ){
      nRow = pWInfo->iLimit;
    }
  }else if( (pWInfo->wctrlFlags & 0x0100) ){


    if( nRow>10 ){ nRow -= 10; ((void) (0)); }
  }
  rSortCost += estLog(nRow);
  return rSortCost;
}
# 172174 "c_tests/sqlite3.c"
static int computeMxChoice(WhereInfo *pWInfo){
  int nLoop = pWInfo->nLevel;
  WhereLoop *pWLoop;
# 172191 "c_tests/sqlite3.c"
  if( nLoop>=5
   && !pWInfo->bStarDone
   && (((pWInfo->pParse->db)->dbOptFlags&(0x20000000))==0)
  ){
    SrcItem *aFromTabs;
    int iFromIdx;
    Bitmask m;
    Bitmask mSelfJoin = 0;
    WhereLoop *pStart;

    pWInfo->bStarDone = 1;





    ((void) (0));
    aFromTabs = pWInfo->pTabList->a;
    pStart = pWInfo->pLoops;
    for(iFromIdx=0, m=1; iFromIdx<nLoop; iFromIdx++, m<<=1){
      int nDep = 0;
      LogEst mxRun;
      Bitmask mSeen = 0;
      SrcItem *pFactTab;

      pFactTab = aFromTabs + iFromIdx;
      if( (pFactTab->fg.jointype & (0x20|0x02))!=0 ){



        if( iFromIdx+4 > nLoop ) break;
        while( pStart && pStart->iTab<=iFromIdx ){
          pStart = pStart->pNextLoop;
        }
      }
      for(pWLoop=pStart; pWLoop; pWLoop=pWLoop->pNextLoop){
        if( (aFromTabs[pWLoop->iTab].fg.jointype & (0x20|0x02))!=0 ){



          break;
        }
        if( (pWLoop->prereq & m)!=0
         && (pWLoop->maskSelf & mSeen)==0
         && (pWLoop->maskSelf & mSelfJoin)==0
        ){
          if( aFromTabs[pWLoop->iTab].pSTab==pFactTab->pSTab ){
            mSelfJoin |= m;
          }else{
            nDep++;
            mSeen |= pWLoop->maskSelf;
          }
        }
      }
      if( nDep<=3 ) continue;
# 172259 "c_tests/sqlite3.c"
      pWInfo->bStarUsed = 1;



      mxRun = (-32768);
      for(pWLoop=pStart; pWLoop; pWLoop=pWLoop->pNextLoop){
        if( pWLoop->iTab<iFromIdx ) continue;
        if( pWLoop->iTab>iFromIdx ) break;
        if( pWLoop->rRun>mxRun ) mxRun = pWLoop->rRun;
      }
      if( (mxRun<(32767)) ) mxRun++;



      for(pWLoop=pStart; pWLoop; pWLoop=pWLoop->pNextLoop){
        if( (pWLoop->maskSelf & mSeen)==0 ) continue;
        if( pWLoop->nLTerm ) continue;
        if( pWLoop->rRun<mxRun ){
# 172289 "c_tests/sqlite3.c"
          pWLoop->rRun = mxRun;
        }
      }
    }
# 172303 "c_tests/sqlite3.c"
  }
  return pWInfo->bStarUsed ? 18 : 12;
}
# 172318 "c_tests/sqlite3.c"
static __attribute__((noinline)) int whereLoopIsNoBetter(
  const WhereLoop *pCandidate,
  const WhereLoop *pBaseline
){
  if( (pCandidate->wsFlags & 0x00000200)==0 ) return 1;
  if( (pBaseline->wsFlags & 0x00000200)==0 ) return 1;
  if( pCandidate->u.btree.pIndex->szIdxRow <
        pBaseline->u.btree.pIndex->szIdxRow ) return 0;
  return 1;
}
# 172341 "c_tests/sqlite3.c"
static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){
  int mxChoice;
  int nLoop;
  Parse *pParse;
  int iLoop;
  int ii, jj;
  int mxI = 0;
  int nOrderBy;
  LogEst mxCost = 0;
  LogEst mxUnsort = 0;
  int nTo, nFrom;
  WherePath *aFrom;
  WherePath *aTo;
  WherePath *pFrom;
  WherePath *pTo;
  WhereLoop *pWLoop;
  WhereLoop **pX;
  LogEst *aSortCost = 0;
  char *pSpace;
  int nSpace;

  pParse = pWInfo->pParse;
  nLoop = pWInfo->nLevel;

                                                  ;
# 172375 "c_tests/sqlite3.c"
  if( nLoop<=1 ){
    mxChoice = 1;
  }else if( nLoop==2 ){
    mxChoice = 5;
  }else if( pParse->nErr ){
    mxChoice = 1;
  }else{
    mxChoice = computeMxChoice(pWInfo);
  }
  ((void) (0));






  if( pWInfo->pOrderBy==0 || nRowEst==0 ){
    nOrderBy = 0;
  }else{
    nOrderBy = pWInfo->pOrderBy->nExpr;
  }


  nSpace = (sizeof(WherePath)+sizeof(WhereLoop*)*nLoop)*mxChoice*2;
  nSpace += sizeof(LogEst) * nOrderBy;
  pSpace = sqlite3DbMallocRawNN(pParse->db,nSpace);
  if( pSpace==0 ) return 7;
  aTo = (WherePath*)pSpace;
  aFrom = aTo+mxChoice;
  memset(aFrom, 0, sizeof(aFrom[0]));
  pX = (WhereLoop**)(aFrom+mxChoice);
  for(ii=mxChoice*2, pFrom=aTo; ii>0; ii--, pFrom++, pX += nLoop){
    pFrom->aLoop = pX;
  }
  if( nOrderBy ){






    aSortCost = (LogEst*)pX;
    memset(aSortCost, 0, sizeof(LogEst) * nOrderBy);
  }
  ((void) (0));
  ((void) (0));






  aFrom[0].nRow = ((pParse->nQueryLoop)<(48)?(pParse->nQueryLoop):(48)); ((void) (0));
  nFrom = 1;
  ((void) (0));
  if( nOrderBy ){






    aFrom[0].isOrdered = nLoop>0 ? -1 : nOrderBy;
  }




  for(iLoop=0; iLoop<nLoop; iLoop++){
    nTo = 0;
    for(ii=0, pFrom=aFrom; ii<nFrom; ii++, pFrom++){
      for(pWLoop=pWInfo->pLoops; pWLoop; pWLoop=pWLoop->pNextLoop){
        LogEst nOut;
        LogEst rCost;
        LogEst rUnsort;
        i8 isOrdered;
        Bitmask maskNew;
        Bitmask revMask;

        if( (pWLoop->prereq & ~pFrom->maskLoop)!=0 ) continue;
        if( (pWLoop->maskSelf & pFrom->maskLoop)!=0 ) continue;
        if( (pWLoop->wsFlags & 0x00004000)!=0 && pFrom->nRow<3 ){




          ((void) (0));
          continue;
        }



        rUnsort = pWLoop->rRun + pFrom->nRow;
        if( pWLoop->rSetup ){
          rUnsort = sqlite3LogEstAdd(pWLoop->rSetup, rUnsort);
        }
        rUnsort = sqlite3LogEstAdd(rUnsort, pFrom->rUnsort);
        nOut = pFrom->nRow + pWLoop->nOut;
        maskNew = pFrom->maskLoop | pWLoop->maskSelf;
        isOrdered = pFrom->isOrdered;
        if( isOrdered<0 ){
          revMask = 0;
          isOrdered = wherePathSatisfiesOrderBy(pWInfo,
                       pWInfo->pOrderBy, pFrom, pWInfo->wctrlFlags,
                       iLoop, pWLoop, &revMask);
        }else{
          revMask = pFrom->revLoop;
        }
        if( isOrdered>=0 && isOrdered<nOrderBy ){
          if( aSortCost[isOrdered]==0 ){
            aSortCost[isOrdered] = whereSortingCost(
                pWInfo, nRowEst, nOrderBy, isOrdered
            );
          }




          rCost = sqlite3LogEstAdd(rUnsort, aSortCost[isOrdered]) + 3;




                               ;
        }else{
          rCost = rUnsort;
          rUnsort -= 2;
        }
# 172522 "c_tests/sqlite3.c"
                          ;
        for(jj=0, pTo=aTo; jj<nTo; jj++, pTo++){
          if( pTo->maskLoop==maskNew
           && ( ((pTo->isOrdered^isOrdered)&0x80)==0 || iLoop==nLoop-1 )
          ){
                                 ;
            break;
          }
        }
        if( jj>=nTo ){

          if( nTo>=mxChoice
           && (rCost>mxCost || (rCost==mxCost && rUnsort>=mxUnsort))
          ){
# 172546 "c_tests/sqlite3.c"
            continue;
          }


          if( nTo<mxChoice ){

            jj = nTo++;
          }else{

            jj = mxI;
          }
          pTo = &aTo[jj];







        }else{
# 172574 "c_tests/sqlite3.c"
          if( (pTo->rCost<rCost)
           || (pTo->rCost==rCost && pTo->nRow<nOut)
           || (pTo->rCost==rCost && pTo->nRow==nOut && pTo->rUnsort<rUnsort)
           || (pTo->rCost==rCost && pTo->nRow==nOut && pTo->rUnsort==rUnsort
                  && whereLoopIsNoBetter(pWLoop, pTo->aLoop[iLoop]) )
          ){
# 172592 "c_tests/sqlite3.c"
                                         ;
            continue;
          }
                                         ;
# 172609 "c_tests/sqlite3.c"
        }

        pTo->maskLoop = pFrom->maskLoop | pWLoop->maskSelf;
        pTo->revLoop = revMask;
        pTo->nRow = nOut;
        pTo->rCost = rCost;
        pTo->rUnsort = rUnsort;
        pTo->isOrdered = isOrdered;
        memcpy(pTo->aLoop, pFrom->aLoop, sizeof(WhereLoop*)*iLoop);
        pTo->aLoop[iLoop] = pWLoop;
        if( nTo>=mxChoice ){
          mxI = 0;
          mxCost = aTo[0].rCost;
          mxUnsort = aTo[0].nRow;
          for(jj=1, pTo=&aTo[1]; jj<mxChoice; jj++, pTo++){
            if( pTo->rCost>mxCost
             || (pTo->rCost==mxCost && pTo->rUnsort>mxUnsort)
            ){
              mxCost = pTo->rCost;
              mxUnsort = pTo->rUnsort;
              mxI = jj;
            }
          }
        }
      }
    }
# 172668 "c_tests/sqlite3.c"
    pFrom = aTo;
    aTo = aFrom;
    aFrom = pFrom;
    nFrom = nTo;
  }

  if( nFrom==0 ){
    sqlite3ErrorMsg(pParse, "no query solution");
    sqlite3DbFreeNN(pParse->db,pSpace);
    return 1;
  }


  ((void) (0));
  pFrom = aFrom;

  ((void) (0));

  for(iLoop=0; iLoop<nLoop; iLoop++){
    WhereLevel *pLevel = pWInfo->a + iLoop;
    pLevel->pWLoop = pWLoop = pFrom->aLoop[iLoop];
    pLevel->iFrom = pWLoop->iTab;
    pLevel->iTabCur = pWInfo->pTabList->a[pLevel->iFrom].iCursor;
  }
  if( (pWInfo->wctrlFlags & 0x0100)!=0
   && (pWInfo->wctrlFlags & 0x0080)==0
   && pWInfo->eDistinct==0
   && nRowEst
  ){
    Bitmask notUsed;
    int rc = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pResultSet, pFrom,
                 0x0080, nLoop-1, pFrom->aLoop[nLoop-1], &notUsed);
    if( rc==pWInfo->pResultSet->nExpr ){
      pWInfo->eDistinct = 2;
    }
  }
  pWInfo->bOrderedInnerLoop = 0;
  if( pWInfo->pOrderBy ){
    pWInfo->nOBSat = pFrom->isOrdered;
    if( pWInfo->wctrlFlags & 0x0080 ){
      if( pFrom->isOrdered==pWInfo->pOrderBy->nExpr ){
        pWInfo->eDistinct = 2;
      }

      ((void) (0));

    }else{
      pWInfo->revMask = pFrom->revLoop;
      if( pWInfo->nOBSat<=0 ){
        pWInfo->nOBSat = 0;
        if( nLoop>0 ){
          u32 wsFlags = pFrom->aLoop[nLoop-1]->wsFlags;
          if( (wsFlags & 0x00001000)==0
           && (wsFlags&(0x00000100|0x00000004))!=(0x00000100|0x00000004)
          ){
            Bitmask m = 0;
            int rc = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy, pFrom,
                      0x0800, nLoop-1, pFrom->aLoop[nLoop-1], &m);
                                           ;
                                                 ;
            if( rc==pWInfo->pOrderBy->nExpr ){
              pWInfo->bOrderedInnerLoop = 1;
              pWInfo->revMask = m;
            }
          }
        }
      }else if( nLoop
            && pWInfo->nOBSat==1
            && (pWInfo->wctrlFlags & (0x0001|0x0002))!=0
            ){
        pWInfo->bOrderedInnerLoop = 1;
      }
    }
    if( (pWInfo->wctrlFlags & 0x0200)
        && pWInfo->nOBSat==pWInfo->pOrderBy->nExpr && nLoop>0
    ){
      Bitmask revMask = 0;
      int nOrder = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy,
          pFrom, 0, nLoop-1, pFrom->aLoop[nLoop-1], &revMask
      );
      ((void) (0));
      if( nOrder==pWInfo->pOrderBy->nExpr ){
        pWInfo->sorted = 1;
        pWInfo->revMask = revMask;
      }
    }
  }

  pWInfo->nRowOut = pFrom->nRow;





  sqlite3DbFreeNN(pParse->db,pSpace);
  return 0;
}
# 172808 "c_tests/sqlite3.c"
static __attribute__((noinline)) void whereInterstageHeuristic(WhereInfo *pWInfo){
  int i;



  for(i=0; i<pWInfo->nLevel; i++){
    WhereLoop *p = pWInfo->a[i].pWLoop;
    if( p==0 ) break;
    if( (p->wsFlags & 0x00000400)!=0 ){

      break;
    }
    if( (p->wsFlags & (0x00000001|0x00000008|0x00000004))!=0 ){
      u8 iTab = p->iTab;
      WhereLoop *pLoop;
      for(pLoop=pWInfo->pLoops; pLoop; pLoop=pLoop->pNextLoop){
        if( pLoop->iTab!=iTab ) continue;
        if( (pLoop->wsFlags & (0x0000000f|0x00004000))!=0 ){

          continue;
        }
# 172838 "c_tests/sqlite3.c"
        pLoop->prereq = ((Bitmask)-1);
      }
    }else{
      break;
    }
  }
}
# 172857 "c_tests/sqlite3.c"
static int whereShortCut(WhereLoopBuilder *pBuilder){
  WhereInfo *pWInfo;
  SrcItem *pItem;
  WhereClause *pWC;
  WhereTerm *pTerm;
  WhereLoop *pLoop;
  int iCur;
  int j;
  Table *pTab;
  Index *pIdx;
  WhereScan scan;

  pWInfo = pBuilder->pWInfo;
  if( pWInfo->wctrlFlags & 0x0020 ) return 0;
  ((void) (0));
  pItem = pWInfo->pTabList->a;
  pTab = pItem->pSTab;
  if( ((pTab)->eTabType==1) ) return 0;
  if( pItem->fg.isIndexedBy || pItem->fg.notIndexed ){
                                     ;
                                    ;
    return 0;
  }
  iCur = pItem->iCursor;
  pWC = &pWInfo->sWC;
  pLoop = pBuilder->pNew;
  pLoop->wsFlags = 0;
  pLoop->nSkip = 0;
  pTerm = whereScanInit(&scan, pWC, iCur, -1, 0x0002|0x0080, 0);
  while( pTerm && pTerm->prereqRight ) pTerm = whereScanNext(&scan);
  if( pTerm ){
                                        ;
    pLoop->wsFlags = 0x00000001|0x00000100|0x00001000;
    pLoop->aLTerm[0] = pTerm;
    pLoop->nLTerm = 1;
    pLoop->u.btree.nEq = 1;

    pLoop->rRun = 33;
  }else{
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      int opMask;
      ((void) (0));
      if( !((pIdx)->onError!=0)
       || pIdx->pPartIdxWhere!=0
       || pIdx->nKeyCol>((int)(sizeof(pLoop->aLTermSpace)/sizeof(pLoop->aLTermSpace[0])))
      ) continue;
      opMask = pIdx->uniqNotNull ? (0x0002|0x0080) : 0x0002;
      for(j=0; j<pIdx->nKeyCol; j++){
        pTerm = whereScanInit(&scan, pWC, iCur, j, opMask, pIdx);
        while( pTerm && pTerm->prereqRight ) pTerm = whereScanNext(&scan);
        if( pTerm==0 ) break;
                                            ;
        pLoop->aLTerm[j] = pTerm;
      }
      if( j!=pIdx->nKeyCol ) continue;
      pLoop->wsFlags = 0x00000001|0x00001000|0x00000200;
      if( pIdx->isCovering || (pItem->colUsed & pIdx->colNotIdxed)==0 ){
        pLoop->wsFlags |= 0x00000040;
      }
      pLoop->nLTerm = j;
      pLoop->u.btree.nEq = j;
      pLoop->u.btree.pIndex = pIdx;

      pLoop->rRun = 39;
      break;
    }
  }
  if( pLoop->wsFlags ){
    pLoop->nOut = (LogEst)1;
    pWInfo->a[0].pWLoop = pLoop;
    ((void) (0));
    pLoop->maskSelf = 1;
    pWInfo->a[0].iTabCur = iCur;
    pWInfo->nRowOut = 1;
    if( pWInfo->pOrderBy ) pWInfo->nOBSat = pWInfo->pOrderBy->nExpr;
    if( pWInfo->wctrlFlags & 0x0100 ){
      pWInfo->eDistinct = 1;
    }
    if( scan.iEquiv>1 ) pLoop->wsFlags |= 0x00200000;
# 172944 "c_tests/sqlite3.c"
    return 1;
  }
  return 0;
}




static int exprNodeIsDeterministic(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==172 && (((pExpr)->flags&(u32)(0x100000))!=0)==0 ){
    pWalker->eCode = 0;
    return 2;
  }
  return 0;
}






static int exprIsDeterministic(Expr *p){
  Walker w;
  memset(&w, 0, sizeof(w));
  w.eCode = 1;
  w.xExprCallback = exprNodeIsDeterministic;
  w.xSelectCallback = sqlite3SelectWalkFail;
  sqlite3WalkExpr(&w, p);
  return w.eCode;
}
# 173037 "c_tests/sqlite3.c"
static __attribute__((noinline)) Bitmask whereOmitNoopJoin(
  WhereInfo *pWInfo,
  Bitmask notReady
){
  int i;
  Bitmask tabUsed;
  int hasRightJoin;


  ((void) (0));
  ((void) (0));



  ((void) (0));
  ((void) (0));

  tabUsed = sqlite3WhereExprListUsage(&pWInfo->sMaskSet, pWInfo->pResultSet);
  if( pWInfo->pOrderBy ){
    tabUsed |= sqlite3WhereExprListUsage(&pWInfo->sMaskSet, pWInfo->pOrderBy);
  }
  hasRightJoin = (pWInfo->pTabList->a[0].fg.jointype & 0x40)!=0;
  for(i=pWInfo->nLevel-1; i>=1; i--){
    WhereTerm *pTerm, *pEnd;
    SrcItem *pItem;
    WhereLoop *pLoop;
    Bitmask m1;
    pLoop = pWInfo->a[i].pWLoop;
    pItem = &pWInfo->pTabList->a[pLoop->iTab];
    if( (pItem->fg.jointype & (0x08|0x10))!=0x08 ) continue;
    if( (pWInfo->wctrlFlags & 0x0100)==0
     && (pLoop->wsFlags & 0x00001000)==0
    ){
      continue;
    }
    if( (tabUsed & pLoop->maskSelf)!=0 ) continue;
    pEnd = pWInfo->sWC.a + pWInfo->sWC.nTerm;
    for(pTerm=pWInfo->sWC.a; pTerm<pEnd; pTerm++){
      if( (pTerm->prereqAll & pLoop->maskSelf)!=0 ){
        if( !(((pTerm->pExpr)->flags&(u32)(0x000001))!=0)
         || pTerm->pExpr->w.iJoin!=pItem->iCursor
        ){
          break;
        }
      }
      if( hasRightJoin
       && (((pTerm->pExpr)->flags&(u32)(0x000002))!=0)
       && (pTerm->pExpr->w.iJoin==pItem->iCursor)
      ){
        break;
      }
    }
    if( pTerm<pEnd ) continue;
                                                                              ;
    m1 = (((Bitmask)1)<<(i))-1;
                                               ;
    pWInfo->revMask = (m1 & pWInfo->revMask) | ((pWInfo->revMask>>1) & ~m1);
    notReady &= ~pLoop->maskSelf;
    for(pTerm=pWInfo->sWC.a; pTerm<pEnd; pTerm++){
      if( (pTerm->prereqAll & pLoop->maskSelf)!=0 ){
        pTerm->wtFlags |= 0x0004;
      }
    }
    if( i!=pWInfo->nLevel-1 ){
      int nByte = (pWInfo->nLevel-1-i) * sizeof(WhereLevel);
      memmove(&pWInfo->a[i], &pWInfo->a[i+1], nByte);
    }
    pWInfo->nLevel--;
    ((void) (0));
  }
  return notReady;
}
# 173128 "c_tests/sqlite3.c"
static __attribute__((noinline)) void whereCheckIfBloomFilterIsUseful(
  const WhereInfo *pWInfo
){
  int i;
  LogEst nSearch = 0;

  ((void) (0));
  ((void) (0));
  for(i=0; i<pWInfo->nLevel; i++){
    WhereLoop *pLoop = pWInfo->a[i].pWLoop;
    const unsigned int reqFlags = (0x00800000|0x00000001);
    SrcItem *pItem = &pWInfo->pTabList->a[pLoop->iTab];
    Table *pTab = pItem->pSTab;
    if( (pTab->tabFlags & 0x00000010)==0 ) break;
    pTab->tabFlags |= 0x00000100;
    if( i>=1
     && (pLoop->wsFlags & reqFlags)==reqFlags

     && ((pLoop->wsFlags & (0x00000100|0x00000200))!=0)
    ){
      if( nSearch > pTab->nRowLogEst ){
                                                ;
        pLoop->wsFlags |= 0x00400000;
        pLoop->wsFlags &= ~0x00000040;




                                                         ;
      }
    }
    nSearch += pLoop->nOut;
  }
}
# 173174 "c_tests/sqlite3.c"
static __attribute__((noinline)) void whereAddIndexedExpr(
  Parse *pParse,
  Index *pIdx,
  int iIdxCur,
  SrcItem *pTabItem
){
  int i;
  IndexedExpr *p;
  Table *pTab;
  ((void) (0));
  pTab = pIdx->pTable;
  for(i=0; i<pIdx->nColumn; i++){
    Expr *pExpr;
    int j = pIdx->aiColumn[i];
    if( j==(-2) ){
      pExpr = pIdx->aColExpr->a[i].pExpr;
    }else if( j>=0 && (pTab->aCol[j].colFlags & 0x0020)!=0 ){
      pExpr = sqlite3ColumnExpr(pTab, &pTab->aCol[j]);
    }else{
      continue;
    }
    if( sqlite3ExprIsConstant(0,pExpr) ) continue;
    p = sqlite3DbMallocRaw(pParse->db, sizeof(IndexedExpr));
    if( p==0 ) break;
    p->pIENext = pParse->pIdxEpr;






    p->pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);
    p->iDataCur = pTabItem->iCursor;
    p->iIdxCur = iIdxCur;
    p->iIdxCol = i;
    p->bMaybeNullRow = (pTabItem->fg.jointype & (0x08|0x40|0x10))!=0;
    if( sqlite3IndexAffinityStr(pParse->db, pIdx) ){
      p->aff = pIdx->zColAff[i];
    }



    pParse->pIdxEpr = p;
    if( p->pIENext==0 ){
      void *pArg = (void*)&pParse->pIdxEpr;
      sqlite3ParserAddCleanup(pParse, whereIndexedExprCleanup, pArg);
    }
  }
}
# 173232 "c_tests/sqlite3.c"
static __attribute__((noinline)) void whereReverseScanOrder(WhereInfo *pWInfo){
  int ii;
  for(ii=0; ii<pWInfo->pTabList->nSrc; ii++){
    SrcItem *pItem = &pWInfo->pTabList->a[ii];
    if( !pItem->fg.isCte
     || pItem->u2.pCteUse->eM10d!=0
     || (pItem->fg.isSubquery==0)
     || pItem->u4.pSubq->pSelect->pOrderBy==0
    ){
      pWInfo->revMask |= (((Bitmask)1)<<(ii));
    }
  }
}
# 173334 "c_tests/sqlite3.c"
static WhereInfo *sqlite3WhereBegin(
  Parse *pParse,
  SrcList *pTabList,
  Expr *pWhere,
  ExprList *pOrderBy,
  ExprList *pResultSet,
  Select *pSelect,
  u16 wctrlFlags,
  int iAuxArg

){
  int nByteWInfo;
  int nTabList;
  WhereInfo *pWInfo;
  Vdbe *v = pParse->pVdbe;
  Bitmask notReady;
  WhereLoopBuilder sWLB;
  WhereMaskSet *pMaskSet;
  WhereLevel *pLevel;
  WhereLoop *pLoop;
  int ii;
  sqlite3 *db;
  int rc;
  u8 bFordelete = 0;

  ((void) (0));





  ((void) (0));



  db = pParse->db;
  memset(&sWLB, 0, sizeof(sWLB));


                                                ;
  if( pOrderBy && pOrderBy->nExpr>=((int)(sizeof(Bitmask)*8)) ){
    pOrderBy = 0;
    wctrlFlags &= ~0x0100;
    wctrlFlags |= 0x2000;
  }




                                 ;
  if( pTabList->nSrc>((int)(sizeof(Bitmask)*8)) ){
    sqlite3ErrorMsg(pParse, "at most %d tables in a join", ((int)(sizeof(Bitmask)*8)));
    return 0;
  }






  nTabList = (wctrlFlags & 0x0020) ? 1 : pTabList->nSrc;
# 173403 "c_tests/sqlite3.c"
  nByteWInfo = (((__builtin_offsetof(WhereInfo, a)+(nTabList)*sizeof(WhereLevel))+7)&~7);
  pWInfo = sqlite3DbMallocRawNN(db, nByteWInfo + sizeof(WhereLoop));
  if( db->mallocFailed ){
    sqlite3DbFree(db, pWInfo);
    pWInfo = 0;
    goto whereBeginError;
  }
  pWInfo->pParse = pParse;
  pWInfo->pTabList = pTabList;
  pWInfo->pOrderBy = pOrderBy;



  pWInfo->pResultSet = pResultSet;
  pWInfo->aiCurOnePass[0] = pWInfo->aiCurOnePass[1] = -1;
  pWInfo->nLevel = nTabList;
  pWInfo->iBreak = pWInfo->iContinue = sqlite3VdbeMakeLabel(pParse);
  pWInfo->wctrlFlags = wctrlFlags;
  pWInfo->iLimit = iAuxArg;
  pWInfo->savedNQueryLoop = pParse->nQueryLoop;
  pWInfo->pSelect = pSelect;
  memset(&pWInfo->nOBSat, 0,
         __builtin_offsetof(WhereInfo, sWC) - __builtin_offsetof(WhereInfo, nOBSat));
  memset(&pWInfo->a[0], 0, sizeof(WhereLoop)+nTabList*sizeof(WhereLevel));
  ((void) (0));
  pMaskSet = &pWInfo->sMaskSet;
  pMaskSet->n = 0;
  pMaskSet->ix[0] = -99;


  sWLB.pWInfo = pWInfo;
  sWLB.pWC = &pWInfo->sWC;
  sWLB.pNew = (WhereLoop*)(((char*)pWInfo)+nByteWInfo);
  ((void) (0));
  whereLoopInit(sWLB.pNew);







  sqlite3WhereClauseInit(&pWInfo->sWC, pWInfo);
  sqlite3WhereSplit(&pWInfo->sWC, pWhere, 44);



  if( nTabList==0 ){
    if( pOrderBy ) pWInfo->nOBSat = pOrderBy->nExpr;
    if( (wctrlFlags & 0x0100)!=0
     && (((db)->dbOptFlags&(0x00000010))==0)
    ){
      pWInfo->eDistinct = 1;
    }
    if( (pWInfo->pSelect)
     && (pWInfo->pSelect->selFlags & 0x0000400)==0
    ){
      sqlite3VdbeExplain (pParse, 0, "SCAN CONSTANT ROW");
    }
  }else{
# 173477 "c_tests/sqlite3.c"
    ii = 0;
    do{
      createMask(pMaskSet, pTabList->a[ii].iCursor);
      sqlite3WhereTabFuncArgs(pParse, &pTabList->a[ii], &pWInfo->sWC);
    }while( (++ii)<pTabList->nSrc );
# 173492 "c_tests/sqlite3.c"
  }


  sqlite3WhereExprAnalyze(pTabList, &pWInfo->sWC);
  if( pSelect && pSelect->pLimit ){
    sqlite3WhereAddLimit(&pWInfo->sWC, pSelect);
  }
  if( pParse->nErr ) goto whereBeginError;
# 173527 "c_tests/sqlite3.c"
  for(ii=0; ii<sWLB.pWC->nBase; ii++){
    WhereTerm *pT = &sWLB.pWC->a[ii];
    Expr *pX;
    if( pT->wtFlags & 0x0002 ) continue;
    pX = pT->pExpr;
    ((void) (0));
    ((void) (0));
    if( pT->prereqAll==0
     && (nTabList==0 || exprIsDeterministic(pX))
     && !((((pX)->flags&(u32)(0x000002))!=0)
          && (pTabList->a[0].fg.jointype & 0x40)!=0 )
    ){
      sqlite3ExprIfFalse(pParse, pX, pWInfo->iBreak, 0x10);
      pT->wtFlags |= 0x0004;
    }
  }

  if( wctrlFlags & 0x0100 ){
    if( (((db)->dbOptFlags&(0x00000010))!=0) ){


      wctrlFlags &= ~0x0100;
      pWInfo->wctrlFlags &= ~0x0100;
    }else if( isDistinctRedundant(pParse, pTabList, &pWInfo->sWC, pResultSet) ){

      pWInfo->eDistinct = 1;
    }else if( pOrderBy==0 ){

      pWInfo->wctrlFlags |= 0x0080;
      pWInfo->pOrderBy = pResultSet;
    }
  }
# 173585 "c_tests/sqlite3.c"
  if( nTabList!=1 || whereShortCut(&sWLB)==0 ){
    rc = whereLoopAddAll(&sWLB);
    if( rc ) goto whereBeginError;
# 173609 "c_tests/sqlite3.c"
                                          ;

    wherePathSolver(pWInfo, 0);
    if( db->mallocFailed ) goto whereBeginError;
    if( pWInfo->pOrderBy ){
       whereInterstageHeuristic(pWInfo);
       wherePathSolver(pWInfo, pWInfo->nRowOut<0 ? 1 : pWInfo->nRowOut+1);
       if( db->mallocFailed ) goto whereBeginError;
    }





    if( (pWInfo->wctrlFlags & 0x0100)!=0 ){

                                                              ;
      pWInfo->nRowOut -= 30;
    }

  }
  ((void) (0));
  if( pWInfo->pOrderBy==0 && (db->flags & 0x00001000)!=0 ){
    whereReverseScanOrder(pWInfo);
  }
  if( pParse->nErr ){
    goto whereBeginError;
  }
  ((void) (0));
# 173676 "c_tests/sqlite3.c"
  notReady = ~(Bitmask)0;
  if( pWInfo->nLevel>=2
   && pResultSet!=0
   && 0==(wctrlFlags & (0x0400|0x2000))
   && (((db)->dbOptFlags&(0x00000100))==0)
  ){
    notReady = whereOmitNoopJoin(pWInfo, notReady);
    nTabList = pWInfo->nLevel;
    ((void) (0));
  }




  if( pWInfo->nLevel>=2
   && (((db)->dbOptFlags&(0x00080000))==0)
  ){
    whereCheckIfBloomFilterIsUseful(pWInfo);
  }
# 173703 "c_tests/sqlite3.c"
  pWInfo->pParse->nQueryLoop += pWInfo->nRowOut;
# 173724 "c_tests/sqlite3.c"
  ((void) (0));
  if( (wctrlFlags & 0x0004)!=0 ){
    int wsFlags = pWInfo->a[0].pWLoop->wsFlags;
    int bOnerow = (wsFlags & 0x00001000)!=0;
    ((void) (0));
    if( bOnerow || (
        0!=(wctrlFlags & 0x0008)
     && !((pTabList->a[0].pSTab)->eTabType==1)
     && (0==(wsFlags & 0x00002000) || (wctrlFlags & 0x0010))
     && (((db)->dbOptFlags&(0x08000000))==0)
    )){
      pWInfo->eOnePass = bOnerow ? 1 : 2;
      if( (((pTabList->a[0].pSTab)->tabFlags & 0x00000080)==0) && (wsFlags & 0x00000040) ){
        if( wctrlFlags & 0x0008 ){
          bFordelete = 0x08;
        }
        pWInfo->a[0].pWLoop->wsFlags = (wsFlags & ~0x00000040);
      }
    }
  }




  for(ii=0, pLevel=pWInfo->a; ii<nTabList; ii++, pLevel++){
    Table *pTab;
    int iDb;
    SrcItem *pTabItem;

    pTabItem = &pTabList->a[pLevel->iFrom];
    pTab = pTabItem->pSTab;
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    pLoop = pLevel->pWLoop;
    pLevel->addrBrk = sqlite3VdbeMakeLabel(pParse);
    if( ii==0 || (pTabItem[0].fg.jointype & 0x08)!=0 ){
      pLevel->addrHalt = pLevel->addrBrk;
    }else if( pWInfo->a[ii-1].pRJ ){
      pLevel->addrHalt = pWInfo->a[ii-1].addrBrk;
    }else{
      pLevel->addrHalt = pWInfo->a[ii-1].addrHalt;
    }
    if( (pTab->tabFlags & 0x00004000)!=0 || ((pTab)->eTabType==2) ){

    }else

    if( (pLoop->wsFlags & 0x00000400)!=0 ){
      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
      int iCur = pTabItem->iCursor;
      sqlite3VdbeAddOp4(v, 174, iCur, 0, 0, pVTab, (-11));
    }else if( ((pTab)->eTabType==1) ){

    }else

    if( ((pLoop->wsFlags & 0x00000040)==0
         && (wctrlFlags & 0x0020)==0)
     || (pTabItem->fg.jointype & (0x40|0x10))!=0
    ){
      int op = 113;
      if( pWInfo->eOnePass!=0 ){
        op = 114;
        pWInfo->aiCurOnePass[0] = pTabItem->iCursor;
      };
      sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);
      ((void) (0));
                                                                    ;
                                                                  ;
      if( pWInfo->eOnePass==0
       && pTab->nCol<((int)(sizeof(Bitmask)*8))
       && (pTab->tabFlags & (0x00000060|0x00000080))==0
       && (pLoop->wsFlags & (0x00004000|0x00400000))==0
      ){



        Bitmask b = pTabItem->colUsed;
        int n = 0;
        for(; b; b=b>>1, n++){}
        sqlite3VdbeChangeP4(v, -1, ((void*)(long int)(n)), (-3));
        ((void) (0));
      }





      {
        sqlite3VdbeChangeP5(v, bFordelete);
      }




      if( ii>=2
       && (pTabItem[0].fg.jointype & (0x40|0x08))==0
       && pLevel->addrHalt==pWInfo->a[0].addrHalt
      ){
        sqlite3VdbeAddOp2(v, 37, pTabItem->iCursor, pWInfo->iBreak);
                       ;
      }
    }else{
      sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
    }
    if( pLoop->wsFlags & 0x00000200 ){
      Index *pIx = pLoop->u.btree.pIndex;
      int iIndexCur;
      int op = 113;

      ((void) (0));
      if( !(((pTab)->tabFlags & 0x00000080)==0) && ((pIx)->idxType==2)
       && (wctrlFlags & 0x0020)!=0
      ){


        iIndexCur = pLevel->iTabCur;
        op = 0;
      }else if( pWInfo->eOnePass!=0 ){
        Index *pJ = pTabItem->pSTab->pIndex;
        iIndexCur = iAuxArg;
        ((void) (0));
        while( (pJ) && pJ!=pIx ){
          iIndexCur++;
          pJ = pJ->pNext;
        }
        op = 114;
        pWInfo->aiCurOnePass[1] = iIndexCur;
      }else if( iAuxArg && (wctrlFlags & 0x0020)!=0 ){
        iIndexCur = iAuxArg;
        op = 102;
      }else{
        iIndexCur = pParse->nTab++;
        if( pIx->bHasExpr && (((db)->dbOptFlags&(0x01000000))==0) ){
          whereAddIndexedExpr(pParse, pIx, iIndexCur, pTabItem);
        }
        if( pIx->pPartIdxWhere && (pTabItem->fg.jointype & 0x10)==0 ){
          wherePartIdxExpr(
              pParse, pIx, pIx->pPartIdxWhere, 0, iIndexCur, pTabItem
          );
        }
      }
      pLevel->iIdxCur = iIndexCur;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      if( op ){
        sqlite3VdbeAddOp3(v, op, iIndexCur, pIx->tnum, iDb);
        sqlite3VdbeSetP4KeyInfo(pParse, pIx);
        if( (pLoop->wsFlags & 0x0000000f)!=0
         && (pLoop->wsFlags & (0x00000002|0x00008000))==0
         && (pLoop->wsFlags & 0x00080000)==0
         && (pLoop->wsFlags & 0x00100000)==0
         && (pWInfo->wctrlFlags&0x0001)==0
         && pWInfo->eDistinct!=2
        ){
          sqlite3VdbeChangeP5(v, 0x02);
        }
                                          ;
# 173895 "c_tests/sqlite3.c"
      }
    }
    if( iDb>=0 ) sqlite3CodeVerifySchema(pParse, iDb);
    if( (pTabItem->fg.jointype & 0x10)!=0
     && (pLevel->pRJ = sqlite3WhereMalloc(pWInfo, sizeof(WhereRightJoin)))!=0
    ){
      WhereRightJoin *pRJ = pLevel->pRJ;
      pRJ->iMatch = pParse->nTab++;
      pRJ->regBloom = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, 78, 65536, pRJ->regBloom);
      pRJ->regReturn = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, 76, 0, pRJ->regReturn);
      ((void) (0));
      if( (((pTab)->tabFlags & 0x00000080)==0) ){
        KeyInfo *pInfo;
        sqlite3VdbeAddOp2(v, 119, pRJ->iMatch, 1);
        pInfo = sqlite3KeyInfoAlloc(pParse->db, 1, 0);
        if( pInfo ){
          pInfo->aColl[0] = 0;
          pInfo->aSortFlags[0] = 0;
          sqlite3VdbeAppendP4(v, pInfo, (-8));
        }
      }else{
        Index *pPk = sqlite3PrimaryKeyIndex(pTab);
        sqlite3VdbeAddOp2(v, 119, pRJ->iMatch, pPk->nKeyCol);
        sqlite3VdbeSetP4KeyInfo(pParse, pPk);
      }
      pLoop->wsFlags &= ~0x00000040;



      pWInfo->nOBSat = 0;
      pWInfo->eDistinct = 3;
    }
  }
  pWInfo->iTop = sqlite3VdbeCurrentAddr(v);
  if( db->mallocFailed ) goto whereBeginError;





  for(ii=0; ii<nTabList; ii++){
    int addrExplain;
    int wsFlags;
    SrcItem *pSrc;
    if( pParse->nErr ) goto whereBeginError;
    pLevel = &pWInfo->a[ii];
    wsFlags = pLevel->pWLoop->wsFlags;
    pSrc = &pTabList->a[pLevel->iFrom];
    if( pSrc->fg.isMaterialized ){
      Subquery *pSubq;
      int iOnce = 0;
      ((void) (0));
      pSubq = pSrc->u4.pSubq;
      if( pSrc->fg.isCorrelated==0 ){
        iOnce = sqlite3VdbeAddOp0(v, 15); ;
      }else{
        iOnce = 0;
      }
      sqlite3VdbeAddOp2(v, 10, pSubq->regReturn, pSubq->addrFillSub);
                                               ;
      if( iOnce ) sqlite3VdbeJumpHere(v, iOnce);
    }
    ((void) (0));
    if( (wsFlags & (0x00004000|0x00400000))!=0 ){
      if( (wsFlags & 0x00004000)!=0 ){

        constructAutomaticIndex(pParse, &pWInfo->sWC, notReady, pLevel);

      }else{
        sqlite3ConstructBloomFilter(pWInfo, ii, pLevel, notReady);
      }
      if( db->mallocFailed ) goto whereBeginError;
    }
    addrExplain = sqlite3WhereExplainOneScan(
        pParse, pTabList, pLevel, wctrlFlags
    );
    pLevel->addrBody = sqlite3VdbeCurrentAddr(v);
    notReady = sqlite3WhereCodeOneLoopStart(pParse,v,pWInfo,ii,pLevel,notReady);
    pWInfo->iContinue = pLevel->addrCont;
    if( (wsFlags&0x00002000)==0 && (wctrlFlags&0x0020)==0 ){
      ((void)addrExplain);
    }
  }


                                            ;
  pWInfo->iEndWhere = sqlite3VdbeCurrentAddr(v);
  return pWInfo;


whereBeginError:
  if( pWInfo ){
    pParse->nQueryLoop = pWInfo->savedNQueryLoop;
    whereInfoFree(db, pWInfo);
  }





  return 0;
}
# 174025 "c_tests/sqlite3.c"
static void sqlite3WhereEnd(WhereInfo *pWInfo){
  Parse *pParse = pWInfo->pParse;
  Vdbe *v = pParse->pVdbe;
  int i;
  WhereLevel *pLevel;
  WhereLoop *pLoop;
  SrcList *pTabList = pWInfo->pTabList;
  sqlite3 *db = pParse->db;
  int iEnd = sqlite3VdbeCurrentAddr(v);
  int nRJ = 0;

  int addrSeek = 0;




                                          ;
  for(i=pWInfo->nLevel-1; i>=0; i--){
    int addr;
    pLevel = &pWInfo->a[i];
    if( pLevel->pRJ ){


      WhereRightJoin *pRJ = pLevel->pRJ;
      sqlite3VdbeResolveLabel(v, pLevel->addrCont);



      pLevel->addrCont = sqlite3VdbeMakeLabel(pParse);
      pRJ->endSubrtn = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp3(v, 68, pRJ->regReturn, pRJ->addrSubrtn, 1);
                     ;
      nRJ++;
    }
    pLoop = pLevel->pWLoop;
    if( pLevel->op!=188 ){

      Index *pIdx;
      int n;
      if( pWInfo->eDistinct==2
       && i==pWInfo->nLevel-1
       && (pLoop->wsFlags & 0x00000200)!=0
       && (pIdx = pLoop->u.btree.pIndex)->hasStat1
       && (n = pLoop->u.btree.nDistinctCol)>0
       && pIdx->aiRowLogEst[n]>=36
      ){
        int r1 = pParse->nMem+1;
        int j, op;
        for(j=0; j<n; j++){
          sqlite3VdbeAddOp3(v, 95, pLevel->iIdxCur, j, r1+j);
        }
        pParse->nMem += n+1;
        op = pLevel->op==39 ? 21 : 24;
        addrSeek = sqlite3VdbeAddOp4Int(v, op, pLevel->iIdxCur, 0, r1, n);
                                        ;
                                        ;
        sqlite3VdbeAddOp2(v, 9, 1, pLevel->p2);
      }

    }
    if( pTabList->a[pLevel->iFrom].fg.fromExists && i==pWInfo->nLevel-1 ){







      int nOuter = 0;
      while( nOuter<i ){
        if( !pTabList->a[pLevel[-nOuter-1].iFrom].fg.fromExists ) break;
        nOuter++;
      }
                          ;
      sqlite3VdbeAddOp2(v, 9, 0, pLevel[-nOuter].addrBrk);
                                      ;
    }
    sqlite3VdbeResolveLabel(v, pLevel->addrCont);
    if( pLevel->op!=188 ){
      sqlite3VdbeAddOp3(v, pLevel->op, pLevel->p1, pLevel->p2, pLevel->p3);
      sqlite3VdbeChangeP5(v, pLevel->p5);
                     ;
                                            ;
                                            ;
                                             ;
      if( pLevel->regBignull ){
        sqlite3VdbeResolveLabel(v, pLevel->addrBignull);
        sqlite3VdbeAddOp2(v, 62, pLevel->regBignull, pLevel->p2-1);
                       ;
      }

      if( addrSeek ){
        sqlite3VdbeJumpHere(v, addrSeek);
        addrSeek = 0;
      }

    }
    if( (pLoop->wsFlags & 0x00000800)!=0 && pLevel->u.in.nIn>0 ){
      struct InLoop *pIn;
      int j;
      sqlite3VdbeResolveLabel(v, pLevel->addrNxt);
      for(j=pLevel->u.in.nIn, pIn=&pLevel->u.in.aInLoop[j-1]; j>0; j--, pIn--){
        ((void) (0));

        sqlite3VdbeJumpHere(v, pIn->addrInTop+1);
        if( pIn->eEndLoopOp!=188 ){
          if( pIn->nPrefix ){
            int bEarlyOut =
                (pLoop->wsFlags & 0x00000400)==0
                 && (pLoop->wsFlags & 0x00040000)!=0;
            if( pLevel->iLeftJoin ){
# 174144 "c_tests/sqlite3.c"
              sqlite3VdbeAddOp2(v, 25, pIn->iCur,
                  sqlite3VdbeCurrentAddr(v) + 2 + bEarlyOut);
                             ;
            }
            if( bEarlyOut ){
              sqlite3VdbeAddOp4Int(v, 26, pLevel->iIdxCur,
                  sqlite3VdbeCurrentAddr(v)+2,
                  pIn->iBase, pIn->nPrefix);
                             ;




              sqlite3VdbeJumpHere(v, pIn->addrInTop+1);
            }
          }
          sqlite3VdbeAddOp2(v, pIn->eEndLoopOp, pIn->iCur, pIn->addrInTop);
                         ;
                                                     ;
                                                     ;
        }
        sqlite3VdbeJumpHere(v, pIn->addrInTop-1);
      }
    }
    sqlite3VdbeResolveLabel(v, pLevel->addrBrk);
    if( pLevel->pRJ ){
      sqlite3VdbeAddOp3(v, 68, pLevel->pRJ->regReturn, 0, 1);
                     ;
    }
    if( pLevel->addrSkip ){
      sqlite3VdbeGoto(v, pLevel->addrSkip);
                                                                            ;
      sqlite3VdbeJumpHere(v, pLevel->addrSkip);
      sqlite3VdbeJumpHere(v, pLevel->addrSkip-2);
    }

    if( pLevel->addrLikeRep ){
      sqlite3VdbeAddOp2(v, 62, (int)(pLevel->iLikeRepCntr>>1),
                        pLevel->addrLikeRep);
                     ;
    }

    if( pLevel->iLeftJoin ){
      int ws = pLoop->wsFlags;
      addr = sqlite3VdbeAddOp1(v, 60, pLevel->iLeftJoin); ;
      ((void) (0));
      if( (ws & 0x00000040)==0 ){
        SrcItem *pSrc = &pTabList->a[pLevel->iFrom];
        ((void) (0));
        if( pSrc->fg.viaCoroutine ){
          int m, n;
          ((void) (0));
          n = pSrc->u4.pSubq->regResult;
          ((void) (0));
          m = pSrc->pSTab->nCol;
          sqlite3VdbeAddOp3(v, 76, 0, n, n+m-1);
        }
        sqlite3VdbeAddOp1(v, 137, pLevel->iTabCur);
      }
      if( (ws & 0x00000200)
       || ((ws & 0x00002000) && pLevel->u.pCoveringIdx)
      ){
        if( ws & 0x00002000 ){
          Index *pIx = pLevel->u.pCoveringIdx;
          int iDb = sqlite3SchemaToIndex(db, pIx->pSchema);
          sqlite3VdbeAddOp3(v, 102, pLevel->iIdxCur, pIx->tnum, iDb);
          sqlite3VdbeSetP4KeyInfo(pParse, pIx);
        }
        sqlite3VdbeAddOp1(v, 137, pLevel->iIdxCur);
      }
      if( pLevel->op==68 ){
        sqlite3VdbeAddOp2(v, 10, pLevel->p1, pLevel->addrFirst);
      }else{
        sqlite3VdbeGoto(v, pLevel->addrFirst);
      }
      sqlite3VdbeJumpHere(v, addr);
    }

                                                                      ;
  }

  ((void) (0));
  for(i=0, pLevel=pWInfo->a; i<pWInfo->nLevel; i++, pLevel++){
    int k, last;
    VdbeOp *pOp, *pLastOp;
    Index *pIdx = 0;
    SrcItem *pTabItem = &pTabList->a[pLevel->iFrom];
    Table *pTab = pTabItem->pSTab;
    ((void) (0));
    pLoop = pLevel->pWLoop;





    if( pLevel->pRJ ){
      sqlite3WhereRightJoinLoop(pWInfo, i, pLevel);
      continue;
    }





    if( pTabItem->fg.viaCoroutine ){
                                          ;
      ((void) (0));
      ((void) (0));
      translateColumnToCopy(pParse, pLevel->addrBody, pLevel->iTabCur,
                            pTabItem->u4.pSubq->regResult, 0);
      continue;
    }
# 174268 "c_tests/sqlite3.c"
    if( pLoop->wsFlags & (0x00000200|0x00000040) ){
      pIdx = pLoop->u.btree.pIndex;
    }else if( pLoop->wsFlags & 0x00002000 ){
      pIdx = pLevel->u.pCoveringIdx;
    }
    if( pIdx
     && !db->mallocFailed
    ){
      if( pWInfo->eOnePass==0 || !(((pIdx->pTable)->tabFlags & 0x00000080)==0) ){
        last = iEnd;
      }else{
        last = pWInfo->iEndWhere;
      }
      if( pIdx->bHasExpr ){
        IndexedExpr *p = pParse->pIdxEpr;
        while( p ){
          if( p->iIdxCur==pLevel->iIdxCur ){







            p->iDataCur = -1;
            p->iIdxCur = -1;
          }
          p = p->pIENext;
        }
      }
      k = pLevel->addrBody + 1;
# 174310 "c_tests/sqlite3.c"
      pOp = sqlite3VdbeGetOp(v, k);
      pLastOp = pOp + (last - k);
      ((void) (0));
      do{
        if( pOp->p1!=pLevel->iTabCur ){

        }else if( pOp->opcode==95



        ){
          int x = pOp->p2;
          ((void) (0));





          if( !(((pTab)->tabFlags & 0x00000080)==0) ){
            Index *pPk = sqlite3PrimaryKeyIndex(pTab);
            x = pPk->aiColumn[x];
            ((void) (0));
          }else{
                                                              ;
            x = sqlite3StorageColumnToTable(pTab,x);
          }
          x = sqlite3TableColumnToIndex(pIdx, x);
          if( x>=0 ){
            pOp->p2 = x;
            pOp->p1 = pLevel->iIdxCur;
                                          ;
          }else if( pLoop->wsFlags & (0x00000040|0x04000000) ){
            if( pLoop->wsFlags & 0x00000040 ){



              sqlite3ErrorMsg(pParse, "internal query planner error");
              pParse->rc = 2;
            }else{







              pLoop->wsFlags &= ~0x04000000;
              sqlite3WhereAddExplainText(pParse,
                  pLevel->addrBody-1,
                  pTabList,
                  pLevel,
                  pWInfo->wctrlFlags
              );
            }
          }
        }else if( pOp->opcode==136 ){
          pOp->p1 = pLevel->iIdxCur;
          pOp->opcode = 143;
                                        ;
        }else if( pOp->opcode==20 ){
          pOp->p1 = pLevel->iIdxCur;
                                        ;
        }



      }while( (++pOp)<pLastOp );



    }
  }




  sqlite3VdbeResolveLabel(v, pWInfo->iBreak);



  pParse->nQueryLoop = pWInfo->savedNQueryLoop;
  whereInfoFree(db, pWInfo);
  pParse->withinRJSubrtn -= nRJ;
  return;
}
# 174544 "c_tests/sqlite3.c"
static void row_numberStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) (*p)++;
  (void)(nArg);
  (void)(apArg);
}
static void row_numberValueFunc(sqlite3_context *pCtx){
  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  sqlite3_result_int64(pCtx, (p ? *p : 0));
}





struct CallCount {
  i64 nValue;
  i64 nStep;
  i64 nTotal;
};







static void dense_rankStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) p->nStep = 1;
  (void)(nArg);
  (void)(apArg);
}
static void dense_rankValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    if( p->nStep ){
      p->nValue++;
      p->nStep = 0;
    }
    sqlite3_result_int64(pCtx, p->nValue);
  }
}






struct NthValueCtx {
  i64 nStep;
  sqlite3_value *pValue;
};
static void nth_valueStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    i64 iVal;
    switch( sqlite3_value_numeric_type(apArg[1]) ){
      case 1:
        iVal = sqlite3_value_int64(apArg[1]);
        break;
      case 2: {
        double fVal = sqlite3_value_double(apArg[1]);
        if( ((i64)fVal)!=fVal ) goto error_out;
        iVal = (i64)fVal;
        break;
      }
      default:
        goto error_out;
    }
    if( iVal<=0 ) goto error_out;

    p->nStep++;
    if( iVal==p->nStep ){
      p->pValue = sqlite3_value_dup(apArg[0]);
      if( !p->pValue ){
        sqlite3_result_error_nomem(pCtx);
      }
    }
  }
  (void)(nArg);
  (void)(apArg);
  return;

 error_out:
  sqlite3_result_error(
      pCtx, "second argument to nth_value must be a positive integer", -1
  );
}
static void nth_valueFinalizeFunc(sqlite3_context *pCtx){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, 0);
  if( p && p->pValue ){
    sqlite3_result_value(pCtx, p->pValue);
    sqlite3_value_free(p->pValue);
    p->pValue = 0;
  }
}



static void first_valueStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p && p->pValue==0 ){
    p->pValue = sqlite3_value_dup(apArg[0]);
    if( !p->pValue ){
      sqlite3_result_error_nomem(pCtx);
    }
  }
  (void)(nArg);
  (void)(apArg);
}
static void first_valueFinalizeFunc(sqlite3_context *pCtx){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p && p->pValue ){
    sqlite3_result_value(pCtx, p->pValue);
    sqlite3_value_free(p->pValue);
    p->pValue = 0;
  }
}
# 174694 "c_tests/sqlite3.c"
static void rankStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    p->nStep++;
    if( p->nValue==0 ){
      p->nValue = p->nStep;
    }
  }
  (void)(nArg);
  (void)(apArg);
}
static void rankValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    sqlite3_result_int64(pCtx, p->nValue);
    p->nValue = 0;
  }
}







static void percent_rankStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  (void)(nArg); ((void) (0));
  (void)(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    p->nTotal++;
  }
}
static void percent_rankInvFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  (void)(nArg); ((void) (0));
  (void)(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  p->nStep++;
}
static void percent_rankValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    p->nValue = p->nStep;
    if( p->nTotal>1 ){
      double r = (double)p->nValue / (double)(p->nTotal-1);
      sqlite3_result_double(pCtx, r);
    }else{
      sqlite3_result_double(pCtx, 0.0);
    }
  }
}
# 174770 "c_tests/sqlite3.c"
static void cume_distStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  (void)(nArg); ((void) (0));
  (void)(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    p->nTotal++;
  }
}
static void cume_distInvFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  (void)(nArg); ((void) (0));
  (void)(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  p->nStep++;
}
static void cume_distValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, 0);
  if( p ){
    double r = (double)(p->nStep) / (double)(p->nTotal);
    sqlite3_result_double(pCtx, r);
  }
}





struct NtileCtx {
  i64 nTotal;
  i64 nParam;
  i64 iRow;
};







static void ntileStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct NtileCtx *p;
  ((void) (0)); (void)(nArg);
  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    if( p->nTotal==0 ){
      p->nParam = sqlite3_value_int64(apArg[0]);
      if( p->nParam<=0 ){
        sqlite3_result_error(
            pCtx, "argument of ntile must be a positive integer", -1
        );
      }
    }
    p->nTotal++;
  }
}
static void ntileInvFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct NtileCtx *p;
  ((void) (0)); (void)(nArg);
  (void)(apArg);
  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  p->iRow++;
}
static void ntileValueFunc(sqlite3_context *pCtx){
  struct NtileCtx *p;
  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p && p->nParam>0 ){
    int nSize = (p->nTotal / p->nParam);
    if( nSize==0 ){
      sqlite3_result_int64(pCtx, p->iRow+1);
    }else{
      i64 nLarge = p->nTotal - p->nParam*nSize;
      i64 iSmall = nLarge*(nSize+1);
      i64 iRow = p->iRow;

      ((void) (0));

      if( iRow<iSmall ){
        sqlite3_result_int64(pCtx, 1 + iRow/(nSize+1));
      }else{
        sqlite3_result_int64(pCtx, 1 + nLarge + (iRow-iSmall)/nSize);
      }
    }
  }
}





struct LastValueCtx {
  sqlite3_value *pVal;
  int nVal;
};




static void last_valueStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct LastValueCtx *p;
  (void)(nArg);
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    sqlite3_value_free(p->pVal);
    p->pVal = sqlite3_value_dup(apArg[0]);
    if( p->pVal==0 ){
      sqlite3_result_error_nomem(pCtx);
    }else{
      p->nVal++;
    }
  }
}
static void last_valueInvFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct LastValueCtx *p;
  (void)(nArg);
  (void)(apArg);
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( (p) ){
    p->nVal--;
    if( p->nVal==0 ){
      sqlite3_value_free(p->pVal);
      p->pVal = 0;
    }
  }
}
static void last_valueValueFunc(sqlite3_context *pCtx){
  struct LastValueCtx *p;
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, 0);
  if( p && p->pVal ){
    sqlite3_result_value(pCtx, p->pVal);
  }
}
static void last_valueFinalizeFunc(sqlite3_context *pCtx){
  struct LastValueCtx *p;
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p && p->pVal ){
    sqlite3_result_value(pCtx, p->pVal);
    sqlite3_value_free(p->pVal);
    p->pVal = 0;
  }
}
# 174945 "c_tests/sqlite3.c"
static const char row_numberName[] = "row_number";
static const char dense_rankName[] = "dense_rank";
static const char rankName[] = "rank";
static const char percent_rankName[] = "percent_rank";
static const char cume_distName[] = "cume_dist";
static const char ntileName[] = "ntile";
static const char last_valueName[] = "last_value";
static const char nth_valueName[] = "nth_value";
static const char first_valueName[] = "first_value";
static const char leadName[] = "lead";
static const char lagName[] = "lag";
# 174966 "c_tests/sqlite3.c"
static void noopStepFunc(
  sqlite3_context *p,
  int n,
  sqlite3_value **a
){
  (void)(p);
  (void)(n);
  (void)(a);
  ((void) (0));
}
static void noopValueFunc(sqlite3_context *p){ (void)(p); }
# 175007 "c_tests/sqlite3.c"
static void sqlite3WindowFunctions(void){
  static FuncDef aWindowFuncs[] = {
    { 0, (0x00800000|1|0x00010000|0), 0, 0, row_numberStepFunc, row_numberValueFunc, row_numberValueFunc, noopStepFunc, row_numberName, {0} },
    { 0, (0x00800000|1|0x00010000|0), 0, 0, dense_rankStepFunc, dense_rankValueFunc, dense_rankValueFunc, noopStepFunc, dense_rankName, {0} },
    { 0, (0x00800000|1|0x00010000|0), 0, 0, rankStepFunc, rankValueFunc, rankValueFunc, noopStepFunc, rankName, {0} },
    { 0, (0x00800000|1|0x00010000|0), 0, 0, percent_rankStepFunc, percent_rankValueFunc, percent_rankValueFunc, percent_rankInvFunc, percent_rankName, {0} },
    { 0, (0x00800000|1|0x00010000|0), 0, 0, cume_distStepFunc, cume_distValueFunc, cume_distValueFunc, cume_distInvFunc, cume_distName, {0} },
    { 1, (0x00800000|1|0x00010000|0), 0, 0, ntileStepFunc, ntileValueFunc, ntileValueFunc, ntileInvFunc, ntileName, {0} },
    { 1, (0x00800000|1|0x00010000|0), 0, 0, last_valueStepFunc, last_valueFinalizeFunc, last_valueValueFunc, last_valueInvFunc, last_valueName, {0} },
    { 2, (0x00800000|1|0x00010000|0), 0, 0, nth_valueStepFunc, nth_valueFinalizeFunc, noopValueFunc, noopStepFunc, nth_valueName, {0} },
    { 1, (0x00800000|1|0x00010000|0), 0, 0, first_valueStepFunc, first_valueFinalizeFunc, noopValueFunc, noopStepFunc, first_valueName, {0} },
    { 1, (0x00800000|1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, leadName, {0} },
    { 2, (0x00800000|1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, leadName, {0} },
    { 3, (0x00800000|1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, leadName, {0} },
    { 1, (0x00800000|1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, lagName, {0} },
    { 2, (0x00800000|1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, lagName, {0} },
    { 3, (0x00800000|1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, lagName, {0} },
  };
  sqlite3InsertBuiltinFuncs(aWindowFuncs, ((int)(sizeof(aWindowFuncs)/sizeof(aWindowFuncs[0]))));
}

static Window *windowFind(Parse *pParse, Window *pList, const char *zName){
  Window *p;
  for(p=pList; p; p=p->pNextWin){
    if( sqlite3StrICmp(p->zName, zName)==0 ) break;
  }
  if( p==0 ){
    sqlite3ErrorMsg(pParse, "no such window: %s", zName);
  }
  return p;
}
# 175056 "c_tests/sqlite3.c"
static void sqlite3WindowUpdate(
  Parse *pParse,
  Window *pList,
  Window *pWin,
  FuncDef *pFunc
){
  if( pWin->zName && pWin->eFrmType==0 ){
    Window *p = windowFind(pParse, pList, pWin->zName);
    if( p==0 ) return;
    pWin->pPartition = sqlite3ExprListDup(pParse->db, p->pPartition, 0);
    pWin->pOrderBy = sqlite3ExprListDup(pParse->db, p->pOrderBy, 0);
    pWin->pStart = sqlite3ExprDup(pParse->db, p->pStart, 0);
    pWin->pEnd = sqlite3ExprDup(pParse->db, p->pEnd, 0);
    pWin->eStart = p->eStart;
    pWin->eEnd = p->eEnd;
    pWin->eFrmType = p->eFrmType;
    pWin->eExclude = p->eExclude;
  }else{
    sqlite3WindowChain(pParse, pWin, pList);
  }
  if( (pWin->eFrmType==90)
   && (pWin->pStart || pWin->pEnd)
   && (pWin->pOrderBy==0 || pWin->pOrderBy->nExpr!=1)
  ){
    sqlite3ErrorMsg(pParse,
      "RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression"
    );
  }else
  if( pFunc->funcFlags & 0x00010000 ){
    sqlite3 *db = pParse->db;
    if( pWin->pFilter ){
      sqlite3ErrorMsg(pParse,
          "FILTER clause may only be used with aggregate window functions"
      );
    }else{
      struct WindowUpdate {
        const char *zFunc;
        int eFrmType;
        int eStart;
        int eEnd;
      } aUp[] = {
        { row_numberName, 77, 91, 86 },
        { dense_rankName, 90, 91, 86 },
        { rankName, 90, 91, 86 },
        { percent_rankName, 93, 86, 91 },
        { cume_distName, 93, 87, 91 },
        { ntileName, 77, 86, 91 },
        { leadName, 77, 91, 91 },
        { lagName, 77, 91, 86 },
      };
      int i;
      for(i=0; i<((int)(sizeof(aUp)/sizeof(aUp[0]))); i++){
        if( pFunc->zName==aUp[i].zFunc ){
          sqlite3ExprDelete(db, pWin->pStart);
          sqlite3ExprDelete(db, pWin->pEnd);
          pWin->pEnd = pWin->pStart = 0;
          pWin->eFrmType = aUp[i].eFrmType;
          pWin->eStart = aUp[i].eStart;
          pWin->eEnd = aUp[i].eEnd;
          pWin->eExclude = 0;
          if( pWin->eStart==87 ){
            pWin->pStart = sqlite3Expr(db, 156, "1");
          }
          break;
        }
      }
    }
  }
  pWin->pWFunc = pFunc;
}





typedef struct WindowRewrite WindowRewrite;
struct WindowRewrite {
  Window *pWin;
  SrcList *pSrc;
  ExprList *pSub;
  Table *pTab;
  Select *pSubSelect;
};






static int selectWindowRewriteExprCb(Walker *pWalker, Expr *pExpr){
  struct WindowRewrite *p = pWalker->u.pRewrite;
  Parse *pParse = pWalker->pParse;
  ((void) (0));
  ((void) (0));






  if( p->pSubSelect ){
    if( pExpr->op!=168 ){
      return 0;
    }else{
      int nSrc = p->pSrc->nSrc;
      int i;
      for(i=0; i<nSrc; i++){
        if( pExpr->iTable==p->pSrc->a[i].iCursor ) break;
      }
      if( i==nSrc ) return 0;
    }
  }

  switch( pExpr->op ){

    case 172:
      if( !(((pExpr)->flags&(u32)(0x1000000))!=0) ){
        break;
      }else{
        Window *pWin;
        for(pWin=p->pWin; pWin; pWin=pWin->pNextWin){
          if( pExpr->y.pWin==pWin ){
            ((void) (0));
            return 1;
          }
        }
      }
                     __attribute__((fallthrough));

    case 179:
    case 169:
    case 168: {
      int iCol = -1;
      if( pParse->db->mallocFailed ) return 2;
      if( p->pSub ){
        int i;
        for(i=0; i<p->pSub->nExpr; i++){
          if( 0==sqlite3ExprCompare(0, p->pSub->a[i].pExpr, pExpr, -1) ){
            iCol = i;
            break;
          }
        }
      }
      if( iCol<0 ){
        Expr *pDup = sqlite3ExprDup(pParse->db, pExpr, 0);
        if( pDup && pDup->op==169 ) pDup->op = 172;
        p->pSub = sqlite3ExprListAppend(pParse, p->pSub, pDup);
      }
      if( p->pSub ){
        int f = pExpr->flags & 0x000200;
        ((void) (0));
        (pExpr)->flags|=(u32)(0x8000000);
        sqlite3ExprDelete(pParse->db, pExpr);
        (pExpr)->flags&=~(u32)(0x8000000);
        memset(pExpr, 0, sizeof(Expr));

        pExpr->op = 168;
        pExpr->iColumn = (iCol<0 ? p->pSub->nExpr-1: iCol);
        pExpr->iTable = p->pWin->iEphCsr;
        pExpr->y.pTab = p->pTab;
        pExpr->flags = f;
      }
      if( pParse->db->mallocFailed ) return 2;
      break;
    }

    default:
      break;
  }

  return 0;
}
static int selectWindowRewriteSelectCb(Walker *pWalker, Select *pSelect){
  struct WindowRewrite *p = pWalker->u.pRewrite;
  Select *pSave = p->pSubSelect;
  if( pSave==pSelect ){
    return 0;
  }else{
    p->pSubSelect = pSelect;
    sqlite3WalkSelect(pWalker, pSelect);
    p->pSubSelect = pSave;
  }
  return 1;
}
# 175255 "c_tests/sqlite3.c"
static void selectWindowRewriteEList(
  Parse *pParse,
  Window *pWin,
  SrcList *pSrc,
  ExprList *pEList,
  Table *pTab,
  ExprList **ppSub
){
  Walker sWalker;
  WindowRewrite sRewrite;

  ((void) (0));
  memset(&sWalker, 0, sizeof(Walker));
  memset(&sRewrite, 0, sizeof(WindowRewrite));

  sRewrite.pSub = *ppSub;
  sRewrite.pWin = pWin;
  sRewrite.pSrc = pSrc;
  sRewrite.pTab = pTab;

  sWalker.pParse = pParse;
  sWalker.xExprCallback = selectWindowRewriteExprCb;
  sWalker.xSelectCallback = selectWindowRewriteSelectCb;
  sWalker.u.pRewrite = &sRewrite;

  (void)sqlite3WalkExprList(&sWalker, pEList);

  *ppSub = sRewrite.pSub;
}





static ExprList *exprListAppendList(
  Parse *pParse,
  ExprList *pList,
  ExprList *pAppend,
  int bIntToNull
){
  if( pAppend ){
    int i;
    int nInit = pList ? pList->nExpr : 0;
    for(i=0; i<pAppend->nExpr; i++){
      sqlite3 *db = pParse->db;
      Expr *pDup = sqlite3ExprDup(db, pAppend->a[i].pExpr, 0);
      if( db->mallocFailed ){
        sqlite3ExprDelete(db, pDup);
        break;
      }
      if( bIntToNull ){
        int iDummy;
        Expr *pSub;
        pSub = sqlite3ExprSkipCollateAndLikely(pDup);
        if( sqlite3ExprIsInteger(pSub, &iDummy, 0) ){
          pSub->op = 122;
          pSub->flags &= ~(0x000800|0x10000000|0x20000000);
          pSub->u.zToken = 0;
        }
      }
      pList = sqlite3ExprListAppend(pParse, pList, pDup);
      if( pList ) pList->a[nInit+i].fg.sortFlags = pAppend->a[i].fg.sortFlags;
    }
  }
  return pList;
}
# 175330 "c_tests/sqlite3.c"
static int sqlite3WindowExtraAggFuncDepth(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==169
   && pExpr->op2>=pWalker->walkerDepth
  ){
    pExpr->op2++;
  }
  return 0;
}

static int disallowAggregatesInOrderByCb(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==169 && pExpr->pAggInfo==0 ){
    ((void) (0));
     sqlite3ErrorMsg(pWalker->pParse,
         "misuse of aggregate: %s()", pExpr->u.zToken);
  }
  return 0;
}
# 175355 "c_tests/sqlite3.c"
static int sqlite3WindowRewrite(Parse *pParse, Select *p){
  int rc = 0;
  if( p->pWin
   && p->pPrior==0
   && ((p->selFlags & 0x0100000)==0)
   && (!(pParse->eParseMode>=2))
  ){
    Vdbe *v = sqlite3GetVdbe(pParse);
    sqlite3 *db = pParse->db;
    Select *pSub = 0;
    SrcList *pSrc = p->pSrc;
    Expr *pWhere = p->pWhere;
    ExprList *pGroupBy = p->pGroupBy;
    Expr *pHaving = p->pHaving;
    ExprList *pSort = 0;

    ExprList *pSublist = 0;
    Window *pMWin = p->pWin;
    Window *pWin;
    Table *pTab;
    Walker w;

    u32 selFlags = p->selFlags;

    pTab = sqlite3DbMallocZero(db, sizeof(Table));
    if( pTab==0 ){
      return sqlite3ErrorToParser(db, 7);
    }
    sqlite3AggInfoPersistWalkerInit(&w, pParse);
    sqlite3WalkSelect(&w, p);
    if( (p->selFlags & 0x0000008)==0 ){
      w.xExprCallback = disallowAggregatesInOrderByCb;
      w.xSelectCallback = 0;
      sqlite3WalkExprList(&w, p->pOrderBy);
    }

    p->pSrc = 0;
    p->pWhere = 0;
    p->pGroupBy = 0;
    p->pHaving = 0;
    p->selFlags &= ~(u32)0x0000008;
    p->selFlags |= 0x0100000;




    pSort = exprListAppendList(pParse, 0, pMWin->pPartition, 1);
    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);
    if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){
      int nSave = pSort->nExpr;
      pSort->nExpr = p->pOrderBy->nExpr;
      if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){
        sqlite3ExprListDelete(db, p->pOrderBy);
        p->pOrderBy = 0;
      }
      pSort->nExpr = nSave;
    }




    pMWin->iEphCsr = pParse->nTab++;
    pParse->nTab += 3;

    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);
    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);
    pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);




    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);
    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);





    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
      ExprList *pArgs;
      ((void) (0));
      ((void) (0));
      pArgs = pWin->pOwner->x.pList;
      if( pWin->pWFunc->funcFlags & 0x000100000 ){
        selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);
        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
        pWin->bExprArgs = 1;
      }else{
        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
        pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);
      }
      if( pWin->pFilter ){
        Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);
        pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);
      }
      pWin->regAccum = ++pParse->nMem;
      pWin->regResult = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, 76, 0, pWin->regAccum);
    }







    if( pSublist==0 ){
      pSublist = sqlite3ExprListAppend(pParse, 0,
        sqlite3Expr(db, 156, "0")
      );
    }

    pSub = sqlite3SelectNew(
        pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0
    );


                    ;
    p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
    ((void) (0));


    if( p->pSrc==0 ){
      sqlite3SelectDelete(db, pSub);
    }else if( sqlite3SrcItemAttachSubquery(pParse, &p->pSrc->a[0], pSub, 0) ){
      Table *pTab2;
      p->pSrc->a[0].fg.isCorrelated = 1;
      sqlite3SrcListAssignCursors(pParse, p->pSrc);
      pSub->selFlags |= 0x0000040|0x8000000;
      pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, 0x40);
      pSub->selFlags |= (selFlags & 0x0000008);
      if( pTab2==0 ){



        rc = 7;
      }else{
        memcpy(pTab, pTab2, sizeof(Table));
        pTab->tabFlags |= 0x00004000;
        p->pSrc->a[0].pSTab = pTab;
        pTab = pTab2;
        memset(&w, 0, sizeof(w));
        w.xExprCallback = sqlite3WindowExtraAggFuncDepth;
        w.xSelectCallback = sqlite3WalkerDepthIncrease;
        w.xSelectCallback2 = sqlite3WalkerDepthDecrease;
        sqlite3WalkSelect(&w, pSub);
      }
    }
    if( db->mallocFailed ) rc = 7;




    sqlite3ParserAddCleanup(pParse, sqlite3DbFree, pTab);
  }

  ((void) (0));
  return rc;
}





static void sqlite3WindowUnlinkFromSelect(Window *p){
  if( p->ppThis ){
    *p->ppThis = p->pNextWin;
    if( p->pNextWin ) p->pNextWin->ppThis = p->ppThis;
    p->ppThis = 0;
  }
}




static void sqlite3WindowDelete(sqlite3 *db, Window *p){
  if( p ){
    sqlite3WindowUnlinkFromSelect(p);
    sqlite3ExprDelete(db, p->pFilter);
    sqlite3ExprListDelete(db, p->pPartition);
    sqlite3ExprListDelete(db, p->pOrderBy);
    sqlite3ExprDelete(db, p->pEnd);
    sqlite3ExprDelete(db, p->pStart);
    sqlite3DbFree(db, p->zName);
    sqlite3DbFree(db, p->zBase);
    sqlite3DbFree(db, p);
  }
}




static void sqlite3WindowListDelete(sqlite3 *db, Window *p){
  while( p ){
    Window *pNext = p->pNextWin;
    sqlite3WindowDelete(db, p);
    p = pNext;
  }
}
# 175562 "c_tests/sqlite3.c"
static Expr *sqlite3WindowOffsetExpr(Parse *pParse, Expr *pExpr){
  if( 0==sqlite3ExprIsConstant(0,pExpr) ){
    if( (pParse->eParseMode>=2) ) sqlite3RenameExprUnmap(pParse, pExpr);
    sqlite3ExprDelete(pParse->db, pExpr);
    pExpr = sqlite3ExprAlloc(pParse->db, 122, 0, 0);
  }
  return pExpr;
}




static Window *sqlite3WindowAlloc(
  Parse *pParse,
  int eType,
  int eStart,
  Expr *pStart,
  int eEnd,
  Expr *pEnd,
  u8 eExclude
){
  Window *pWin = 0;
  int bImplicitFrame = 0;


  ((void) (0));
  ((void) (0));

  ((void) (0));

  ((void) (0));
  ((void) (0));

  if( eType==0 ){
    bImplicitFrame = 1;
    eType = 90;
  }
# 175614 "c_tests/sqlite3.c"
  if( (eStart==86 && eEnd==89)
   || (eStart==87 && (eEnd==89 || eEnd==86))
  ){
    sqlite3ErrorMsg(pParse, "unsupported frame specification");
    goto windowAllocErr;
  }

  pWin = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));
  if( pWin==0 ) goto windowAllocErr;
  pWin->eFrmType = eType;
  pWin->eStart = eStart;
  pWin->eEnd = eEnd;
  if( eExclude==0 && (((pParse->db)->dbOptFlags&(0x00000002))!=0) ){
    eExclude = 67;
  }
  pWin->eExclude = eExclude;
  pWin->bImplicitFrame = bImplicitFrame;
  pWin->pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);
  pWin->pStart = sqlite3WindowOffsetExpr(pParse, pStart);
  return pWin;

windowAllocErr:
  sqlite3ExprDelete(pParse->db, pEnd);
  sqlite3ExprDelete(pParse->db, pStart);
  return 0;
}






static Window *sqlite3WindowAssemble(
  Parse *pParse,
  Window *pWin,
  ExprList *pPartition,
  ExprList *pOrderBy,
  Token *pBase
){
  if( pWin ){
    pWin->pPartition = pPartition;
    pWin->pOrderBy = pOrderBy;
    if( pBase ){
      pWin->zBase = sqlite3DbStrNDup(pParse->db, pBase->z, pBase->n);
    }
  }else{
    sqlite3ExprListDelete(pParse->db, pPartition);
    sqlite3ExprListDelete(pParse->db, pOrderBy);
  }
  return pWin;
}
# 175673 "c_tests/sqlite3.c"
static void sqlite3WindowChain(Parse *pParse, Window *pWin, Window *pList){
  if( pWin->zBase ){
    sqlite3 *db = pParse->db;
    Window *pExist = windowFind(pParse, pList, pWin->zBase);
    if( pExist ){
      const char *zErr = 0;

      if( pWin->pPartition ){
        zErr = "PARTITION clause";
      }else if( pExist->pOrderBy && pWin->pOrderBy ){
        zErr = "ORDER BY clause";
      }else if( pExist->bImplicitFrame==0 ){
        zErr = "frame specification";
      }
      if( zErr ){
        sqlite3ErrorMsg(pParse,
            "cannot override %s of window: %s", zErr, pWin->zBase
        );
      }else{
        pWin->pPartition = sqlite3ExprListDup(db, pExist->pPartition, 0);
        if( pExist->pOrderBy ){
          ((void) (0));
          pWin->pOrderBy = sqlite3ExprListDup(db, pExist->pOrderBy, 0);
        }
        sqlite3DbFree(db, pWin->zBase);
        pWin->zBase = 0;
      }
    }
  }
}




static void sqlite3WindowAttach(Parse *pParse, Expr *p, Window *pWin){
  if( p ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    p->y.pWin = pWin;
    (p)->flags|=(u32)(0x1000000|0x020000);
    pWin->pOwner = p;
    if( (p->flags & 0x000004) && pWin->eFrmType!=167 ){
      sqlite3ErrorMsg(pParse,
          "DISTINCT is not supported for window functions"
      );
    }
  }else{
    sqlite3WindowDelete(pParse->db, pWin);
  }
}







static void sqlite3WindowLink(Select *pSel, Window *pWin){
  if( pSel ){
    if( 0==pSel->pWin || 0==sqlite3WindowCompare(0, pSel->pWin, pWin, 0) ){
      pWin->pNextWin = pSel->pWin;
      if( pSel->pWin ){
        pSel->pWin->ppThis = &pWin->pNextWin;
      }
      pSel->pWin = pWin;
      pWin->ppThis = &pSel->pWin;
    }else{
      if( sqlite3ExprListCompare(pWin->pPartition, pSel->pWin->pPartition,-1) ){
        pSel->selFlags |= 0x2000000;
      }
    }
  }
}






static int sqlite3WindowCompare(
  const Parse *pParse,
  const Window *p1,
  const Window *p2,
  int bFilter
){
  int res;
  if( (p1==0) || (p2==0) ) return 1;
  if( p1->eFrmType!=p2->eFrmType ) return 1;
  if( p1->eStart!=p2->eStart ) return 1;
  if( p1->eEnd!=p2->eEnd ) return 1;
  if( p1->eExclude!=p2->eExclude ) return 1;
  if( sqlite3ExprCompare(pParse, p1->pStart, p2->pStart, -1) ) return 1;
  if( sqlite3ExprCompare(pParse, p1->pEnd, p2->pEnd, -1) ) return 1;
  if( (res = sqlite3ExprListCompare(p1->pPartition, p2->pPartition, -1)) ){
    return res;
  }
  if( (res = sqlite3ExprListCompare(p1->pOrderBy, p2->pOrderBy, -1)) ){
    return res;
  }
  if( bFilter ){
    if( (res = sqlite3ExprCompare(pParse, p1->pFilter, p2->pFilter, -1)) ){
      return res;
    }
  }
  return 0;
}







static void sqlite3WindowCodeInit(Parse *pParse, Select *pSelect){
  Window *pWin;
  int nEphExpr;
  Window *pMWin;
  Vdbe *v;

  ((void) (0));
  nEphExpr = pSelect->pSrc->a[0].u4.pSubq->pSelect->pEList->nExpr;
  pMWin = pSelect->pWin;
  v = sqlite3GetVdbe(pParse);

  sqlite3VdbeAddOp2(v, 119, pMWin->iEphCsr, nEphExpr);
  sqlite3VdbeAddOp2(v, 116, pMWin->iEphCsr+1, pMWin->iEphCsr);
  sqlite3VdbeAddOp2(v, 116, pMWin->iEphCsr+2, pMWin->iEphCsr);
  sqlite3VdbeAddOp2(v, 116, pMWin->iEphCsr+3, pMWin->iEphCsr);



  if( pMWin->pPartition ){
    int nExpr = pMWin->pPartition->nExpr;
    pMWin->regPart = pParse->nMem+1;
    pParse->nMem += nExpr;
    sqlite3VdbeAddOp3(v, 76, 0, pMWin->regPart, pMWin->regPart+nExpr-1);
  }

  pMWin->regOne = ++pParse->nMem;
  sqlite3VdbeAddOp2(v, 72, 1, pMWin->regOne);

  if( pMWin->eExclude ){
    pMWin->regStartRowid = ++pParse->nMem;
    pMWin->regEndRowid = ++pParse->nMem;
    pMWin->csrApp = pParse->nTab++;
    sqlite3VdbeAddOp2(v, 72, 1, pMWin->regStartRowid);
    sqlite3VdbeAddOp2(v, 72, 0, pMWin->regEndRowid);
    sqlite3VdbeAddOp2(v, 116, pMWin->csrApp, pMWin->iEphCsr);
    return;
  }

  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    FuncDef *p = pWin->pWFunc;
    if( (p->funcFlags & 0x1000) && pWin->eStart!=91 ){







      ExprList *pList;
      KeyInfo *pKeyInfo;
      ((void) (0));
      pList = pWin->pOwner->x.pList;
      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0);
      pWin->csrApp = pParse->nTab++;
      pWin->regApp = pParse->nMem+1;
      pParse->nMem += 3;
      if( pKeyInfo && pWin->pWFunc->zName[1]=='i' ){
        ((void) (0));
        pKeyInfo->aSortFlags[0] = 0x01;
      }
      sqlite3VdbeAddOp2(v, 119, pWin->csrApp, 2);
      sqlite3VdbeAppendP4(v, pKeyInfo, (-8));
      sqlite3VdbeAddOp2(v, 72, 0, pWin->regApp+1);
    }
    else if( p->zName==nth_valueName || p->zName==first_valueName ){


      pWin->regApp = pParse->nMem+1;
      pWin->csrApp = pParse->nTab++;
      pParse->nMem += 2;
      sqlite3VdbeAddOp2(v, 116, pWin->csrApp, pMWin->iEphCsr);
    }
    else if( p->zName==leadName || p->zName==lagName ){
      pWin->csrApp = pParse->nTab++;
      sqlite3VdbeAddOp2(v, 116, pWin->csrApp, pMWin->iEphCsr);
    }
  }
}
# 175879 "c_tests/sqlite3.c"
static void windowCheckValue(Parse *pParse, int reg, int eCond){
  static const char *azErr[] = {
    "frame starting offset must be a non-negative integer",
    "frame ending offset must be a non-negative integer",
    "second argument to nth_value must be a positive integer",
    "frame starting offset must be a non-negative number",
    "frame ending offset must be a non-negative number",
  };
  static int aOp[] = { 58, 58, 55, 58, 58 };
  Vdbe *v = sqlite3GetVdbe(pParse);
  int regZero = sqlite3GetTempReg(pParse);
  ((void) (0));
  sqlite3VdbeAddOp2(v, 72, 0, regZero);
  if( eCond>=3 ){
    int regString = sqlite3GetTempReg(pParse);
    sqlite3VdbeAddOp4(v, 118, 0, regString, 0, "", (-1));
    sqlite3VdbeAddOp3(v, 58, regString, sqlite3VdbeCurrentAddr(v)+2, reg);
    sqlite3VdbeChangeP5(v, 0x43|0x10);
                   ;
    ((void) (0));
                               ;
                               ;
  }else{
    sqlite3VdbeAddOp2(v, 13, reg, sqlite3VdbeCurrentAddr(v)+2);
                   ;
    ((void) (0));
                               ;
                               ;
                               ;
  }
  sqlite3VdbeAddOp3(v, aOp[eCond], regZero, sqlite3VdbeCurrentAddr(v)+2, reg);
  sqlite3VdbeChangeP5(v, 0x43);
                                      ;
                                      ;
                                      ;
                                      ;
                                      ;
  sqlite3MayAbort(pParse);
  sqlite3VdbeAddOp2(v, 71, 1, 2);
  sqlite3VdbeAppendP4(v, (void*)azErr[eCond], (-1));
  sqlite3ReleaseTempReg(pParse, regZero);
}





static int windowArgCount(Window *pWin){
  const ExprList *pList;
  ((void) (0));
  pList = pWin->pOwner->x.pList;
  return (pList ? pList->nExpr : 0);
}

typedef struct WindowCodeArg WindowCodeArg;
typedef struct WindowCsrAndReg WindowCsrAndReg;




struct WindowCsrAndReg {
  int csr;
  int reg;
};
# 175999 "c_tests/sqlite3.c"
struct WindowCodeArg {
  Parse *pParse;
  Window *pMWin;
  Vdbe *pVdbe;
  int addrGosub;
  int regGosub;
  int regArg;
  int eDelete;
  int regRowid;

  WindowCsrAndReg start;
  WindowCsrAndReg current;
  WindowCsrAndReg end;
};





static void windowReadPeerValues(
  WindowCodeArg *p,
  int csr,
  int reg
){
  Window *pMWin = p->pMWin;
  ExprList *pOrderBy = pMWin->pOrderBy;
  if( pOrderBy ){
    Vdbe *v = sqlite3GetVdbe(p->pParse);
    ExprList *pPart = pMWin->pPartition;
    int iColOff = pMWin->nBufferCol + (pPart ? pPart->nExpr : 0);
    int i;
    for(i=0; i<pOrderBy->nExpr; i++){
      sqlite3VdbeAddOp3(v, 95, csr, iColOff+i, reg+i);
    }
  }
}
# 176055 "c_tests/sqlite3.c"
static void windowAggStep(
  WindowCodeArg *p,
  Window *pMWin,
  int csr,
  int bInverse,
  int reg
){
  Parse *pParse = p->pParse;
  Vdbe *v = sqlite3GetVdbe(pParse);
  Window *pWin;
  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    FuncDef *pFunc = pWin->pWFunc;
    int regArg;
    int nArg = pWin->bExprArgs ? 0 : windowArgCount(pWin);
    int i;
    int addrIf = 0;

    ((void) (0));



    ((void) (0));

    for(i=0; i<nArg; i++){
      if( i!=1 || pFunc->zName!=nth_valueName ){
        sqlite3VdbeAddOp3(v, 95, csr, pWin->iArgCol+i, reg+i);
      }else{
        sqlite3VdbeAddOp3(v, 95, pMWin->iEphCsr, pWin->iArgCol+i, reg+i);
      }
    }
    regArg = reg;

    if( pWin->pFilter ){
      int regTmp;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      regTmp = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp3(v, 95, csr, pWin->iArgCol+nArg,regTmp);
      addrIf = sqlite3VdbeAddOp3(v, 17, regTmp, 0, 1);
                     ;
      sqlite3ReleaseTempReg(pParse, regTmp);
    }

    if( pMWin->regStartRowid==0
     && (pFunc->funcFlags & 0x1000)
     && (pWin->eStart!=91)
    ){
      int addrIsNull = sqlite3VdbeAddOp1(v, 51, regArg);
                     ;
      if( bInverse==0 ){
        sqlite3VdbeAddOp2(v, 87, pWin->regApp+1, 1);
        sqlite3VdbeAddOp2(v, 82, regArg, pWin->regApp);
        sqlite3VdbeAddOp3(v, 98, pWin->regApp, 2, pWin->regApp+2);
        sqlite3VdbeAddOp2(v, 139, pWin->csrApp, pWin->regApp+2);
      }else{
        sqlite3VdbeAddOp4Int(v, 23, pWin->csrApp, 0, regArg, 1);
                                 ;
        sqlite3VdbeAddOp1(v, 131, pWin->csrApp);
        sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
      }
      sqlite3VdbeJumpHere(v, addrIsNull);
    }else if( pWin->regApp ){
      ((void) (0));
      ((void) (0));


      ((void) (0));
      sqlite3VdbeAddOp2(v, 87, pWin->regApp+1-bInverse, 1);
    }else if( pFunc->xSFunc!=noopStepFunc ){
      if( pWin->bExprArgs ){
        int iOp = sqlite3VdbeCurrentAddr(v);
        int iEnd;

        ((void) (0));
        nArg = pWin->pOwner->x.pList->nExpr;
        regArg = sqlite3GetTempRange(pParse, nArg);
        sqlite3ExprCodeExprList(pParse, pWin->pOwner->x.pList, regArg, 0, 0);

        for(iEnd=sqlite3VdbeCurrentAddr(v); iOp<iEnd; iOp++){
          VdbeOp *pOp = sqlite3VdbeGetOp(v, iOp);
          if( pOp->opcode==95 && pOp->p1==pMWin->iEphCsr ){
            pOp->p1 = csr;
          }
        }
      }
      if( pFunc->funcFlags & 0x0020 ){
        CollSeq *pColl;
        ((void) (0));
        ((void) (0));
        pColl = sqlite3ExprNNCollSeq(pParse, pWin->pOwner->x.pList->a[0].pExpr);
        sqlite3VdbeAddOp4(v, 86, 0,0,0, (const char*)pColl, (-2));
      }
      sqlite3VdbeAddOp3(v, bInverse? 162 : 163,
                        bInverse, regArg, pWin->regAccum);
      sqlite3VdbeAppendP4(v, pFunc, (-7));
      sqlite3VdbeChangeP5(v, (u16)nArg);
      if( pWin->bExprArgs ){
        sqlite3ReleaseTempRange(pParse, regArg, nArg);
      }
    }

    if( addrIf ) sqlite3VdbeJumpHere(v, addrIf);
  }
}
# 176174 "c_tests/sqlite3.c"
static void windowAggFinal(WindowCodeArg *p, int bFin){
  Parse *pParse = p->pParse;
  Window *pMWin = p->pMWin;
  Vdbe *v = sqlite3GetVdbe(pParse);
  Window *pWin;

  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    if( pMWin->regStartRowid==0
     && (pWin->pWFunc->funcFlags & 0x1000)
     && (pWin->eStart!=91)
    ){
      sqlite3VdbeAddOp2(v, 76, 0, pWin->regResult);
      sqlite3VdbeAddOp1(v, 32, pWin->csrApp);
                     ;
      sqlite3VdbeAddOp3(v, 95, pWin->csrApp, 0, pWin->regResult);
      sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
    }else if( pWin->regApp ){
      ((void) (0));
    }else{
      int nArg = windowArgCount(pWin);
      if( bFin ){
        sqlite3VdbeAddOp2(v, 166, pWin->regAccum, nArg);
        sqlite3VdbeAppendP4(v, pWin->pWFunc, (-7));
        sqlite3VdbeAddOp2(v, 81, pWin->regAccum, pWin->regResult);
        sqlite3VdbeAddOp2(v, 76, 0, pWin->regAccum);
      }else{
        sqlite3VdbeAddOp3(v, 165,pWin->regAccum,nArg,pWin->regResult);
        sqlite3VdbeAppendP4(v, pWin->pWFunc, (-7));
      }
    }
  }
}







static void windowFullScan(WindowCodeArg *p){
  Window *pWin;
  Parse *pParse = p->pParse;
  Window *pMWin = p->pMWin;
  Vdbe *v = p->pVdbe;

  int regCRowid = 0;
  int regCPeer = 0;
  int regRowid = 0;
  int regPeer = 0;

  int nPeer;
  int lblNext;
  int lblBrk;
  int addrNext;
  int csr;

                                                ;

  ((void) (0));
  csr = pMWin->csrApp;
  nPeer = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);

  lblNext = sqlite3VdbeMakeLabel(pParse);
  lblBrk = sqlite3VdbeMakeLabel(pParse);

  regCRowid = sqlite3GetTempReg(pParse);
  regRowid = sqlite3GetTempReg(pParse);
  if( nPeer ){
    regCPeer = sqlite3GetTempRange(pParse, nPeer);
    regPeer = sqlite3GetTempRange(pParse, nPeer);
  }

  sqlite3VdbeAddOp2(v, 136, pMWin->iEphCsr, regCRowid);
  windowReadPeerValues(p, pMWin->iEphCsr, regCPeer);

  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    sqlite3VdbeAddOp2(v, 76, 0, pWin->regAccum);
  }

  sqlite3VdbeAddOp3(v, 23, csr, lblBrk, pMWin->regStartRowid);
                 ;
  addrNext = sqlite3VdbeCurrentAddr(v);
  sqlite3VdbeAddOp2(v, 136, csr, regRowid);
  sqlite3VdbeAddOp3(v, 55, pMWin->regEndRowid, lblBrk, regRowid);
                          ;

  if( pMWin->eExclude==86 ){
    sqlite3VdbeAddOp3(v, 54, regCRowid, lblNext, regRowid);
                            ;
  }else if( pMWin->eExclude!=67 ){
    int addr;
    int addrEq = 0;
    KeyInfo *pKeyInfo = 0;

    if( pMWin->pOrderBy ){
      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pMWin->pOrderBy, 0, 0);
    }
    if( pMWin->eExclude==95 ){
      addrEq = sqlite3VdbeAddOp3(v, 54, regCRowid, 0, regRowid);
                              ;
    }
    if( pKeyInfo ){
      windowReadPeerValues(p, csr, regPeer);
      sqlite3VdbeAddOp3(v, 91, regPeer, regCPeer, nPeer);
      sqlite3VdbeAppendP4(v, (void*)pKeyInfo, (-8));
      addr = sqlite3VdbeCurrentAddr(v)+1;
      sqlite3VdbeAddOp3(v, 14, addr, lblNext, addr);
                         ;
    }else{
      sqlite3VdbeAddOp2(v, 9, 0, lblNext);
    }
    if( addrEq ) sqlite3VdbeJumpHere(v, addrEq);
  }

  windowAggStep(p, pMWin, csr, 0, p->regArg);

  sqlite3VdbeResolveLabel(v, lblNext);
  sqlite3VdbeAddOp2(v, 40, csr, addrNext);
                 ;
  sqlite3VdbeJumpHere(v, addrNext-1);
  sqlite3VdbeJumpHere(v, addrNext+1);
  sqlite3ReleaseTempReg(pParse, regRowid);
  sqlite3ReleaseTempReg(pParse, regCRowid);
  if( nPeer ){
    sqlite3ReleaseTempRange(pParse, regPeer, nPeer);
    sqlite3ReleaseTempRange(pParse, regCPeer, nPeer);
  }

  windowAggFinal(p, 1);
                                              ;
}
# 176319 "c_tests/sqlite3.c"
static void windowReturnOneRow(WindowCodeArg *p){
  Window *pMWin = p->pMWin;
  Vdbe *v = p->pVdbe;

  if( pMWin->regStartRowid ){
    windowFullScan(p);
  }else{
    Parse *pParse = p->pParse;
    Window *pWin;

    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
      FuncDef *pFunc = pWin->pWFunc;
      ((void) (0));
      if( pFunc->zName==nth_valueName
       || pFunc->zName==first_valueName
      ){
        int csr = pWin->csrApp;
        int lbl = sqlite3VdbeMakeLabel(pParse);
        int tmpReg = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp2(v, 76, 0, pWin->regResult);

        if( pFunc->zName==nth_valueName ){
          sqlite3VdbeAddOp3(v, 95,pMWin->iEphCsr,pWin->iArgCol+1,tmpReg);
          windowCheckValue(pParse, tmpReg, 2);
        }else{
          sqlite3VdbeAddOp2(v, 72, 1, tmpReg);
        }
        sqlite3VdbeAddOp3(v, 107, tmpReg, pWin->regApp, tmpReg);
        sqlite3VdbeAddOp3(v, 55, pWin->regApp+1, lbl, tmpReg);
                                ;
        sqlite3VdbeAddOp3(v, 30, csr, 0, tmpReg);
                                 ;
        sqlite3VdbeAddOp3(v, 95, csr, pWin->iArgCol, pWin->regResult);
        sqlite3VdbeResolveLabel(v, lbl);
        sqlite3ReleaseTempReg(pParse, tmpReg);
      }
      else if( pFunc->zName==leadName || pFunc->zName==lagName ){
        int nArg = pWin->pOwner->x.pList->nExpr;
        int csr = pWin->csrApp;
        int lbl = sqlite3VdbeMakeLabel(pParse);
        int tmpReg = sqlite3GetTempReg(pParse);
        int iEph = pMWin->iEphCsr;

        if( nArg<3 ){
          sqlite3VdbeAddOp2(v, 76, 0, pWin->regResult);
        }else{
          sqlite3VdbeAddOp3(v, 95, iEph,pWin->iArgCol+2,pWin->regResult);
        }
        sqlite3VdbeAddOp2(v, 136, iEph, tmpReg);
        if( nArg<2 ){
          int val = (pFunc->zName==leadName ? 1 : -1);
          sqlite3VdbeAddOp2(v, 87, tmpReg, val);
        }else{
          int op = (pFunc->zName==leadName ? 107 : 108);
          int tmpReg2 = sqlite3GetTempReg(pParse);
          sqlite3VdbeAddOp3(v, 95, iEph, pWin->iArgCol+1, tmpReg2);
          sqlite3VdbeAddOp3(v, op, tmpReg2, tmpReg, tmpReg);
          sqlite3ReleaseTempReg(pParse, tmpReg2);
        }

        sqlite3VdbeAddOp3(v, 30, csr, lbl, tmpReg);
                       ;
        sqlite3VdbeAddOp3(v, 95, csr, pWin->iArgCol, pWin->regResult);
        sqlite3VdbeResolveLabel(v, lbl);
        sqlite3ReleaseTempReg(pParse, tmpReg);
      }
    }
  }
  sqlite3VdbeAddOp2(v, 10, p->regGosub, p->addrGosub);
}







static int windowInitAccum(Parse *pParse, Window *pMWin){
  Vdbe *v = sqlite3GetVdbe(pParse);
  int regArg;
  int nArg = 0;
  Window *pWin;
  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    FuncDef *pFunc = pWin->pWFunc;
    ((void) (0));
    sqlite3VdbeAddOp2(v, 76, 0, pWin->regAccum);
    nArg = ((nArg)>(windowArgCount(pWin))?(nArg):(windowArgCount(pWin)));
    if( pMWin->regStartRowid==0 ){
      if( pFunc->zName==nth_valueName || pFunc->zName==first_valueName ){
        sqlite3VdbeAddOp2(v, 72, 0, pWin->regApp);
        sqlite3VdbeAddOp2(v, 72, 0, pWin->regApp+1);
      }

      if( (pFunc->funcFlags & 0x1000) && pWin->csrApp ){
        ((void) (0));
        sqlite3VdbeAddOp1(v, 147, pWin->csrApp);
        sqlite3VdbeAddOp2(v, 72, 0, pWin->regApp+1);
      }
    }
  }
  regArg = pParse->nMem+1;
  pParse->nMem += nArg;
  return regArg;
}





static int windowCacheFrame(Window *pMWin){
  Window *pWin;
  if( pMWin->regStartRowid ) return 1;
  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    FuncDef *pFunc = pWin->pWFunc;
    if( (pFunc->zName==nth_valueName)
     || (pFunc->zName==first_valueName)
     || (pFunc->zName==leadName)
     || (pFunc->zName==lagName)
    ){
      return 1;
    }
  }
  return 0;
}
# 176454 "c_tests/sqlite3.c"
static void windowIfNewPeer(
  Parse *pParse,
  ExprList *pOrderBy,
  int regNew,
  int regOld,
  int addr
){
  Vdbe *v = sqlite3GetVdbe(pParse);
  if( pOrderBy ){
    int nVal = pOrderBy->nExpr;
    KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOrderBy, 0, 0);
    sqlite3VdbeAddOp3(v, 91, regOld, regNew, nVal);
    sqlite3VdbeAppendP4(v, (void*)pKeyInfo, (-8));
    sqlite3VdbeAddOp3(v, 14,
      sqlite3VdbeCurrentAddr(v)+1, addr, sqlite3VdbeCurrentAddr(v)+1
    );
                       ;
    sqlite3VdbeAddOp3(v, 81, regNew, regOld, nVal-1);
  }else{
    sqlite3VdbeAddOp2(v, 9, 0, addr);
  }
}
# 176500 "c_tests/sqlite3.c"
static void windowCodeRangeTest(
  WindowCodeArg *p,
  int op,
  int csr1,
  int regVal,
  int csr2,
  int lbl
){
  Parse *pParse = p->pParse;
  Vdbe *v = sqlite3GetVdbe(pParse);
  ExprList *pOrderBy = p->pMWin->pOrderBy;
  int reg1 = sqlite3GetTempReg(pParse);
  int reg2 = sqlite3GetTempReg(pParse);
  int regString = ++pParse->nMem;
  int arith = 107;
  int addrGe;
  int addrDone = sqlite3VdbeMakeLabel(pParse);
  CollSeq *pColl;


  windowReadPeerValues(p, csr1, reg1);
  windowReadPeerValues(p, csr2, reg2);

  ((void) (0));
  ((void) (0));
  if( pOrderBy->a[0].fg.sortFlags & 0x01 ){
    switch( op ){
      case 58: op = 56; break;
      case 55: op = 57; break;
      default: ((void) (0)); op = 58; break;
    }
    arith = 108;
  }




    ;
# 176558 "c_tests/sqlite3.c"
  if( pOrderBy->a[0].fg.sortFlags & 0x02 ){

    int addr = sqlite3VdbeAddOp1(v, 52, reg1); ;
    switch( op ){
      case 58:
        sqlite3VdbeAddOp2(v, 9, 0, lbl);
        break;
      case 55:
        sqlite3VdbeAddOp2(v, 52, reg2, lbl);
                       ;
        break;
      case 56:
        sqlite3VdbeAddOp2(v, 51, reg2, lbl);
                       ;
        break;
      default: ((void) (0)); break;
    }
    sqlite3VdbeAddOp2(v, 9, 0, addrDone);


    sqlite3VdbeJumpHere(v, addr);
    sqlite3VdbeAddOp2(v, 51, reg2,
                      (op==55 || op==58) ? addrDone : lbl);
                   ;
  }
# 176597 "c_tests/sqlite3.c"
  sqlite3VdbeAddOp4(v, 118, 0, regString, 0, "", (-1));
  addrGe = sqlite3VdbeAddOp3(v, 58, regString, 0, reg1);
                 ;
  if( (op==58 && arith==107) || (op==56 && arith==108) ){
    sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); ;
  }
  sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1);
  sqlite3VdbeJumpHere(v, addrGe);




  sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); ;
  pColl = sqlite3ExprNNCollSeq(pParse, pOrderBy->a[0].pExpr);
  sqlite3VdbeAppendP4(v, (void*)pColl, (-2));
  sqlite3VdbeChangeP5(v, 0x80);
  sqlite3VdbeResolveLabel(v, addrDone);

  ((void) (0));
                     ; ;
                     ; ;
                     ; ;
                     ; ;
  sqlite3ReleaseTempReg(pParse, reg1);
  sqlite3ReleaseTempReg(pParse, reg2);

                                              ;
}







static int windowCodeOp(
 WindowCodeArg *p,
 int op,
 int regCountdown,
 int jumpOnEof
){
  int csr, reg;
  Parse *pParse = p->pParse;
  Window *pMWin = p->pMWin;
  int ret = 0;
  Vdbe *v = p->pVdbe;
  int addrContinue = 0;
  int bPeer = (pMWin->eFrmType!=77);

  int lblDone = sqlite3VdbeMakeLabel(pParse);
  int addrNextRange = 0;



  if( op==2 && pMWin->eStart==91 ){
    ((void) (0));
    return 0;
  }

  if( regCountdown>0 ){
    if( pMWin->eFrmType==90 ){
      addrNextRange = sqlite3VdbeCurrentAddr(v);
      ((void) (0));
      if( op==2 ){
        if( pMWin->eStart==87 ){
          windowCodeRangeTest(
              p, 56, p->current.csr, regCountdown, p->start.csr, lblDone
          );
        }else{
          windowCodeRangeTest(
              p, 58, p->start.csr, regCountdown, p->current.csr, lblDone
          );
        }
      }else{
        windowCodeRangeTest(
            p, 55, p->end.csr, regCountdown, p->current.csr, lblDone
        );
      }
    }else{
      sqlite3VdbeAddOp3(v, 60, regCountdown, lblDone, 1);
                     ;
    }
  }

  if( op==1 && pMWin->regStartRowid==0 ){
    windowAggFinal(p, 0);
  }
  addrContinue = sqlite3VdbeCurrentAddr(v);







  if( pMWin->eStart==pMWin->eEnd && regCountdown
   && pMWin->eFrmType==90
  ){
    int regRowid1 = sqlite3GetTempReg(pParse);
    int regRowid2 = sqlite3GetTempReg(pParse);
    if( op==2 ){
      sqlite3VdbeAddOp2(v, 136, p->start.csr, regRowid1);
      sqlite3VdbeAddOp2(v, 136, p->end.csr, regRowid2);
      sqlite3VdbeAddOp3(v, 58, regRowid2, lblDone, regRowid1);
                     ;
    }else if( p->regRowid ){
      sqlite3VdbeAddOp2(v, 136, p->end.csr, regRowid1);
      sqlite3VdbeAddOp3(v, 58, p->regRowid, lblDone, regRowid1);
                              ;
    }
    sqlite3ReleaseTempReg(pParse, regRowid1);
    sqlite3ReleaseTempReg(pParse, regRowid2);
    ((void) (0));
  }

  switch( op ){
    case 1:
      csr = p->current.csr;
      reg = p->current.reg;
      windowReturnOneRow(p);
      break;

    case 2:
      csr = p->start.csr;
      reg = p->start.reg;
      if( pMWin->regStartRowid ){
        ((void) (0));
        sqlite3VdbeAddOp2(v, 87, pMWin->regStartRowid, 1);
      }else{
        windowAggStep(p, pMWin, csr, 1, p->regArg);
      }
      break;

    default:
      ((void) (0));
      csr = p->end.csr;
      reg = p->end.reg;
      if( pMWin->regStartRowid ){
        ((void) (0));
        sqlite3VdbeAddOp2(v, 87, pMWin->regEndRowid, 1);
      }else{
        windowAggStep(p, pMWin, csr, 0, p->regArg);
      }
      break;
  }

  if( op==p->eDelete ){
    sqlite3VdbeAddOp1(v, 131, csr);
    sqlite3VdbeChangeP5(v, 0x02);
  }

  if( jumpOnEof ){
    sqlite3VdbeAddOp2(v, 40, csr, sqlite3VdbeCurrentAddr(v)+2);
                   ;
    ret = sqlite3VdbeAddOp0(v, 9);
  }else{
    sqlite3VdbeAddOp2(v, 40, csr, sqlite3VdbeCurrentAddr(v)+1+bPeer);
                   ;
    if( bPeer ){
      sqlite3VdbeAddOp2(v, 9, 0, lblDone);
    }
  }

  if( bPeer ){
    int nReg = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);
    int regTmp = (nReg ? sqlite3GetTempRange(pParse, nReg) : 0);
    windowReadPeerValues(p, csr, regTmp);
    windowIfNewPeer(pParse, pMWin->pOrderBy, regTmp, reg, addrContinue);
    sqlite3ReleaseTempRange(pParse, regTmp, nReg);
  }

  if( addrNextRange ){
    sqlite3VdbeAddOp2(v, 9, 0, addrNextRange);
  }
  sqlite3VdbeResolveLabel(v, lblDone);
  return ret;
}







static Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){
  Window *pNew = 0;
  if( (p) ){
    pNew = sqlite3DbMallocZero(db, sizeof(Window));
    if( pNew ){
      pNew->zName = sqlite3DbStrDup(db, p->zName);
      pNew->zBase = sqlite3DbStrDup(db, p->zBase);
      pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);
      pNew->pWFunc = p->pWFunc;
      pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);
      pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);
      pNew->eFrmType = p->eFrmType;
      pNew->eEnd = p->eEnd;
      pNew->eStart = p->eStart;
      pNew->eExclude = p->eExclude;
      pNew->regResult = p->regResult;
      pNew->regAccum = p->regAccum;
      pNew->iArgCol = p->iArgCol;
      pNew->iEphCsr = p->iEphCsr;
      pNew->bExprArgs = p->bExprArgs;
      pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);
      pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);
      pNew->pOwner = pOwner;
      pNew->bImplicitFrame = p->bImplicitFrame;
    }
  }
  return pNew;
}





static Window *sqlite3WindowListDup(sqlite3 *db, Window *p){
  Window *pWin;
  Window *pRet = 0;
  Window **pp = &pRet;

  for(pWin=p; pWin; pWin=pWin->pNextWin){
    *pp = sqlite3WindowDup(db, 0, pWin);
    if( *pp==0 ) break;
    pp = &((*pp)->pNextWin);
  }

  return pRet;
}
# 176836 "c_tests/sqlite3.c"
static int windowExprGtZero(Parse *pParse, Expr *pExpr){
  int ret = 0;
  sqlite3 *db = pParse->db;
  sqlite3_value *pVal = 0;
  sqlite3ValueFromExpr(db, pExpr, db->enc, 0x43, &pVal);
  if( pVal && sqlite3_value_int(pVal)>0 ){
    ret = 1;
  }
  sqlite3ValueFree(pVal);
  return ret;
}
# 177183 "c_tests/sqlite3.c"
static void sqlite3WindowCodeStep(
  Parse *pParse,
  Select *p,
  WhereInfo *pWInfo,
  int regGosub,
  int addrGosub
){
  Window *pMWin = p->pWin;
  ExprList *pOrderBy = pMWin->pOrderBy;
  Vdbe *v = sqlite3GetVdbe(pParse);
  int csrWrite;
  int csrInput = p->pSrc->a[0].iCursor;
  int nInput = p->pSrc->a[0].pSTab->nCol;
  int iInput;
  int addrNe;
  int addrGosubFlush = 0;
  int addrInteger = 0;
  int addrEmpty;
  int regNew;
  int regRecord;
  int regNewPeer = 0;
  int regPeer = 0;
  int regFlushPart = 0;
  WindowCodeArg s;
  int lblWhereEnd;
  int regStart = 0;
  int regEnd = 0;

  ((void) (0));


  ((void) (0));


  ((void) (0));




  lblWhereEnd = sqlite3VdbeMakeLabel(pParse);


  memset(&s, 0, sizeof(WindowCodeArg));
  s.pParse = pParse;
  s.pMWin = pMWin;
  s.pVdbe = v;
  s.regGosub = regGosub;
  s.addrGosub = addrGosub;
  s.current.csr = pMWin->iEphCsr;
  csrWrite = s.current.csr+1;
  s.start.csr = s.current.csr+2;
  s.end.csr = s.current.csr+3;







  switch( pMWin->eStart ){
    case 87:
      if( pMWin->eFrmType!=90
       && windowExprGtZero(pParse, pMWin->pStart)
      ){
        s.eDelete = 1;
      }
      break;
    case 91:
      if( windowCacheFrame(pMWin)==0 ){
        if( pMWin->eEnd==89 ){
          if( pMWin->eFrmType!=90
           && windowExprGtZero(pParse, pMWin->pEnd)
          ){
            s.eDelete = 3;
          }
        }else{
          s.eDelete = 1;
        }
      }
      break;
    default:
      s.eDelete = 2;
      break;
  }




  regNew = pParse->nMem+1;
  pParse->nMem += nInput;
  regRecord = ++pParse->nMem;
  s.regRowid = ++pParse->nMem;




  if( pMWin->eStart==89 || pMWin->eStart==87 ){
    regStart = ++pParse->nMem;
  }
  if( pMWin->eEnd==89 || pMWin->eEnd==87 ){
    regEnd = ++pParse->nMem;
  }




  if( pMWin->eFrmType!=77 ){
    int nPeer = (pOrderBy ? pOrderBy->nExpr : 0);
    regNewPeer = regNew + pMWin->nBufferCol;
    if( pMWin->pPartition ) regNewPeer += pMWin->pPartition->nExpr;
    regPeer = pParse->nMem+1; pParse->nMem += nPeer;
    s.start.reg = pParse->nMem+1; pParse->nMem += nPeer;
    s.current.reg = pParse->nMem+1; pParse->nMem += nPeer;
    s.end.reg = pParse->nMem+1; pParse->nMem += nPeer;
  }




  for(iInput=0; iInput<nInput; iInput++){
    sqlite3VdbeAddOp3(v, 95, csrInput, iInput, regNew+iInput);
  }
  sqlite3VdbeAddOp3(v, 98, regNew, nInput, regRecord);






  if( pMWin->pPartition ){
    int addr;
    ExprList *pPart = pMWin->pPartition;
    int nPart = pPart->nExpr;
    int regNewPart = regNew + pMWin->nBufferCol;
    KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, 0, 0);

    regFlushPart = ++pParse->nMem;
    addr = sqlite3VdbeAddOp3(v, 91, regNewPart, pMWin->regPart, nPart);
    sqlite3VdbeAppendP4(v, (void*)pKeyInfo, (-8));
    sqlite3VdbeAddOp3(v, 14, addr+2, addr+4, addr+2);
                       ;
    addrGosubFlush = sqlite3VdbeAddOp1(v, 10, regFlushPart);
                                            ;
    sqlite3VdbeAddOp3(v, 81, regNewPart, pMWin->regPart, nPart-1);
  }


  sqlite3VdbeAddOp2(v, 128, csrWrite, s.regRowid);
  sqlite3VdbeAddOp3(v, 129, csrWrite, regRecord, s.regRowid);
  addrNe = sqlite3VdbeAddOp3(v, 53, pMWin->regOne, 0, s.regRowid);
                          ;


  s.regArg = windowInitAccum(pParse, pMWin);

  if( regStart ){
    sqlite3ExprCode(pParse, pMWin->pStart, regStart);
    windowCheckValue(pParse, regStart, 0 + (pMWin->eFrmType==90?3:0));
  }
  if( regEnd ){
    sqlite3ExprCode(pParse, pMWin->pEnd, regEnd);
    windowCheckValue(pParse, regEnd, 1 + (pMWin->eFrmType==90?3:0));
  }

  if( pMWin->eFrmType!=90 && pMWin->eStart==pMWin->eEnd && regStart ){
    int op = ((pMWin->eStart==87) ? 58 : 56);
    int addrGe = sqlite3VdbeAddOp3(v, op, regStart, 0, regEnd);
                                         ;
                                         ;
    windowAggFinal(&s, 0);
    sqlite3VdbeAddOp1(v, 36, s.current.csr);
    windowReturnOneRow(&s);
    sqlite3VdbeAddOp1(v, 147, s.current.csr);
    sqlite3VdbeAddOp2(v, 9, 0, lblWhereEnd);
    sqlite3VdbeJumpHere(v, addrGe);
  }
  if( pMWin->eStart==87 && pMWin->eFrmType!=90 && regEnd ){
    ((void) (0));
    sqlite3VdbeAddOp3(v, 108, regStart, regEnd, regStart);
  }

  if( pMWin->eStart!=91 ){
    sqlite3VdbeAddOp1(v, 36, s.start.csr);
  }
  sqlite3VdbeAddOp1(v, 36, s.current.csr);
  sqlite3VdbeAddOp1(v, 36, s.end.csr);
  if( regPeer && pOrderBy ){
    sqlite3VdbeAddOp3(v, 81, regNewPeer, regPeer, pOrderBy->nExpr-1);
    sqlite3VdbeAddOp3(v, 81, regPeer, s.start.reg, pOrderBy->nExpr-1);
    sqlite3VdbeAddOp3(v, 81, regPeer, s.current.reg, pOrderBy->nExpr-1);
    sqlite3VdbeAddOp3(v, 81, regPeer, s.end.reg, pOrderBy->nExpr-1);
  }

  sqlite3VdbeAddOp2(v, 9, 0, lblWhereEnd);

  sqlite3VdbeJumpHere(v, addrNe);


  if( regPeer ){
    windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer, lblWhereEnd);
  }
  if( pMWin->eStart==87 ){
    windowCodeOp(&s, 3, 0, 0);
    if( pMWin->eEnd!=91 ){
      if( pMWin->eFrmType==90 ){
        int lbl = sqlite3VdbeMakeLabel(pParse);
        int addrNext = sqlite3VdbeCurrentAddr(v);
        windowCodeRangeTest(&s, 58, s.current.csr, regEnd, s.end.csr, lbl);
        windowCodeOp(&s, 2, regStart, 0);
        windowCodeOp(&s, 1, 0, 0);
        sqlite3VdbeAddOp2(v, 9, 0, addrNext);
        sqlite3VdbeResolveLabel(v, lbl);
      }else{
        windowCodeOp(&s, 1, regEnd, 0);
        windowCodeOp(&s, 2, regStart, 0);
      }
    }
  }else
  if( pMWin->eEnd==89 ){
    int bRPS = (pMWin->eStart==89 && pMWin->eFrmType==90);
    windowCodeOp(&s, 3, regEnd, 0);
    if( bRPS ) windowCodeOp(&s, 2, regStart, 0);
    windowCodeOp(&s, 1, 0, 0);
    if( !bRPS ) windowCodeOp(&s, 2, regStart, 0);
  }else{
    int addr = 0;
    windowCodeOp(&s, 3, 0, 0);
    if( pMWin->eEnd!=91 ){
      if( pMWin->eFrmType==90 ){
        int lbl = 0;
        addr = sqlite3VdbeCurrentAddr(v);
        if( regEnd ){
          lbl = sqlite3VdbeMakeLabel(pParse);
          windowCodeRangeTest(&s, 58, s.current.csr, regEnd, s.end.csr, lbl);
        }
        windowCodeOp(&s, 1, 0, 0);
        windowCodeOp(&s, 2, regStart, 0);
        if( regEnd ){
          sqlite3VdbeAddOp2(v, 9, 0, addr);
          sqlite3VdbeResolveLabel(v, lbl);
        }
      }else{
        if( regEnd ){
          addr = sqlite3VdbeAddOp3(v, 60, regEnd, 0, 1);
                         ;
        }
        windowCodeOp(&s, 1, 0, 0);
        windowCodeOp(&s, 2, regStart, 0);
        if( regEnd ) sqlite3VdbeJumpHere(v, addr);
      }
    }
  }


  sqlite3VdbeResolveLabel(v, lblWhereEnd);
  sqlite3WhereEnd(pWInfo);


  if( pMWin->pPartition ){
    addrInteger = sqlite3VdbeAddOp2(v, 72, 0, regFlushPart);
    sqlite3VdbeJumpHere(v, addrGosubFlush);
  }

  s.regRowid = 0;
  addrEmpty = sqlite3VdbeAddOp1(v, 36, csrWrite);
                 ;
  if( pMWin->eEnd==89 ){
    int bRPS = (pMWin->eStart==89 && pMWin->eFrmType==90);
    windowCodeOp(&s, 3, regEnd, 0);
    if( bRPS ) windowCodeOp(&s, 2, regStart, 0);
    windowCodeOp(&s, 1, 0, 0);
  }else if( pMWin->eStart==87 ){
    int addrStart;
    int addrBreak1;
    int addrBreak2;
    int addrBreak3;
    windowCodeOp(&s, 3, 0, 0);
    if( pMWin->eFrmType==90 ){
      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak2 = windowCodeOp(&s, 2, regStart, 1);
      addrBreak1 = windowCodeOp(&s, 1, 0, 1);
    }else
    if( pMWin->eEnd==91 ){
      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak1 = windowCodeOp(&s, 1, regStart, 1);
      addrBreak2 = windowCodeOp(&s, 2, 0, 1);
    }else{
      ((void) (0));



      sqlite3VdbeAddOp3(v, 108, regStart, regEnd, regEnd);
      sqlite3VdbeAddOp2(v, 72, 0, regStart);

      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak1 = windowCodeOp(&s, 1, regEnd, 1);
      addrBreak2 = windowCodeOp(&s, 2, regStart, 1);
    }
    sqlite3VdbeAddOp2(v, 9, 0, addrStart);
    sqlite3VdbeJumpHere(v, addrBreak2);
    addrStart = sqlite3VdbeCurrentAddr(v);
    addrBreak3 = windowCodeOp(&s, 1, 0, 1);
    sqlite3VdbeAddOp2(v, 9, 0, addrStart);
    sqlite3VdbeJumpHere(v, addrBreak1);
    sqlite3VdbeJumpHere(v, addrBreak3);
  }else{
    int addrBreak;
    int addrStart;
    windowCodeOp(&s, 3, 0, 0);
    addrStart = sqlite3VdbeCurrentAddr(v);
    addrBreak = windowCodeOp(&s, 1, 0, 1);
    windowCodeOp(&s, 2, regStart, 0);
    sqlite3VdbeAddOp2(v, 9, 0, addrStart);
    sqlite3VdbeJumpHere(v, addrBreak);
  }
  sqlite3VdbeJumpHere(v, addrEmpty);

  sqlite3VdbeAddOp1(v, 147, s.current.csr);
  if( pMWin->pPartition ){
    if( pMWin->regStartRowid ){
      sqlite3VdbeAddOp2(v, 72, 1, pMWin->regStartRowid);
      sqlite3VdbeAddOp2(v, 72, 0, pMWin->regEndRowid);
    }
    sqlite3VdbeChangeP1(v, addrInteger, sqlite3VdbeCurrentAddr(v));
    sqlite3VdbeAddOp1(v, 68, regFlushPart);
  }
}
# 177591 "c_tests/sqlite3.c"
struct TrigEvent { int a; IdList * b; };

struct FrameBound { int eType; Expr *pExpr; };




static void parserSyntaxError(Parse *pParse, Token *p){
  sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", p);
}





static void disableLookaside(Parse *pParse){
  sqlite3 *db = pParse->db;
  pParse->disableLookaside++;



  memset(&pParse->u1.cr, 0, sizeof(pParse->u1.cr));
  db->lookaside.bDisable++;db->lookaside.sz=0;
}
# 177643 "c_tests/sqlite3.c"
  static void parserDoubleLinkSelect(Parse *pParse, Select *p){
    ((void) (0));
    if( p->pPrior ){
      Select *pNext = 0, *pLoop = p;
      int mxSelect, cnt = 1;
      while(1){
        pLoop->pNext = pNext;
        pLoop->selFlags |= 0x0000100;
        pNext = pLoop;
        pLoop = pLoop->pPrior;
        if( pLoop==0 ) break;
        cnt++;
        if( pLoop->pOrderBy || pLoop->pLimit ){
          sqlite3ErrorMsg(pParse,"%s clause should come after %s not before",
             pLoop->pOrderBy!=0 ? "ORDER BY" : "LIMIT",
             sqlite3SelectOpName(pNext->op));
          break;
        }
      }
      if( (p->selFlags & (0x0000400|0x0000200))==0
       && (mxSelect = pParse->db->aLimit[4])>0
       && cnt>mxSelect
      ){
        sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
      }
    }
  }




  static Select *attachWithToSelect(Parse *pParse, Select *pSelect, With *pWith){
    if( pSelect ){
      pSelect->pWith = pWith;
      parserDoubleLinkSelect(pParse, pSelect);
    }else{
      sqlite3WithDelete(pParse->db, pWith);
    }
    return pSelect;
  }





  static void *parserStackRealloc(void *pOld, sqlite3_uint64 newSize){
    return sqlite3FaultSim(700) ? 0 : sqlite3_realloc(pOld, newSize);
  }



  static Expr *tokenExpr(Parse *pParse, int op, Token t){
    Expr *p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr)+t.n+1);
    if( p ){

      p->op = (u8)op;
      p->affExpr = 0;
      p->flags = 0x800000;
                               ;

      p->pLeft = p->pRight = 0;
      p->pAggInfo = 0;
      memset(&p->x, 0, sizeof(p->x));
      memset(&p->y, 0, sizeof(p->y));
      p->op2 = 0;
      p->iTable = 0;
      p->iColumn = 0;
      p->u.zToken = (char*)&p[1];
      memcpy(p->u.zToken, t.z, t.n);
      p->u.zToken[t.n] = 0;
      p->w.iOfst = (int)(t.z - pParse->zTail);
      if( (sqlite3CtypeMap[(unsigned char)(p->u.zToken[0])]&0x80) ){
        sqlite3DequoteExpr(p);
      }

      p->nHeight = 1;

      if( (pParse->eParseMode>=2) ){
        return (Expr*)sqlite3RenameTokenMap(pParse, (void*)p, &t);
      }
    }
    return p;
  }




  static void binaryToUnaryIfNull(Parse *pParse, Expr *pY, Expr *pA, int op){
    sqlite3 *db = pParse->db;
    if( pA && pY && pY->op==122 && !(pParse->eParseMode>=2) ){
      pA->op = (u8)op;
      sqlite3ExprDelete(db, pA->pRight);
      pA->pRight = 0;
    }
  }






  static ExprList *parserAddExprIdListTerm(
    Parse *pParse,
    ExprList *pPrior,
    Token *pIdToken,
    int hasCollate,
    int sortOrder
  ){
    ExprList *p = sqlite3ExprListAppend(pParse, pPrior, 0);
    if( (hasCollate || sortOrder!=-1)
        && pParse->db->init.busy==0
    ){
      sqlite3ErrorMsg(pParse, "syntax error after column name \"%.*s\"",
                         pIdToken->n, pIdToken->z);
    }
    sqlite3ExprListSetName(pParse, p, pIdToken, 1);
    return p;
  }
# 178023 "c_tests/sqlite3.c"
typedef union {
  int yyinit;
  Token yy0;
  u32 yy9;
  struct TrigEvent yy28;
  With* yy125;
  IdList* yy204;
  struct FrameBound yy205;
  TriggerStep* yy319;
  const char* yy342;
  Cte* yy361;
  ExprList* yy402;
  Upsert* yy403;
  OnOrUsing yy421;
  u8 yy444;
  struct {int value; int mask;} yy481;
  Window* yy483;
  int yy502;
  SrcList* yy563;
  Expr* yy590;
  Select* yy637;
} YYMINORTYPE;
# 178159 "c_tests/sqlite3.c"
static const unsigned short int yy_action[] = {
               130, 127, 234, 282, 282, 1328, 576, 1307, 460, 289,
               289, 576, 1622, 381, 576, 1328, 573, 576, 562, 413,
              1300, 1542, 573, 481, 562, 524, 460, 459, 558, 82,
                82, 983, 294, 375, 51, 51, 498, 61, 61, 984,
                82, 82, 1577, 137, 138, 91, 7, 1228, 1228, 1063,
              1066, 1053, 1053, 135, 135, 136, 136, 136, 136, 413,
               288, 288, 182, 288, 288, 481, 536, 288, 288, 130,
               127, 234, 432, 573, 525, 562, 573, 557, 562, 1290,
               573, 421, 562, 137, 138, 91, 559, 1228, 1228, 1063,
              1066, 1053, 1053, 135, 135, 136, 136, 136, 136, 296,
               460, 398, 1249, 134, 134, 134, 134, 133, 133, 132,
               132, 132, 131, 128, 451, 451, 1050, 1050, 1064, 1067,
              1255, 1, 1, 582, 2, 1259, 581, 1174, 1259, 1174,
               321, 413, 155, 321, 1584, 155, 379, 112, 481, 1341,
               456, 299, 1341, 134, 134, 134, 134, 133, 133, 132,
               132, 132, 131, 128, 451, 137, 138, 91, 498, 1228,
              1228, 1063, 1066, 1053, 1053, 135, 135, 136, 136, 136,
               136, 1204, 862, 1281, 288, 288, 283, 288, 288, 523,
               523, 1250, 139, 578, 7, 578, 1345, 573, 1169, 562,
               573, 1054, 562, 136, 136, 136, 136, 129, 573, 547,
               562, 1169, 245, 1541, 1169, 245, 133, 133, 132, 132,
               132, 131, 128, 451, 302, 134, 134, 134, 134, 133,
               133, 132, 132, 132, 131, 128, 451, 1575, 1204, 1205,
              1204, 7, 470, 550, 455, 413, 550, 455, 130, 127,
               234, 134, 134, 134, 134, 133, 133, 132, 132, 132,
               131, 128, 451, 136, 136, 136, 136, 538, 483, 137,
               138, 91, 1019, 1228, 1228, 1063, 1066, 1053, 1053, 135,
               135, 136, 136, 136, 136, 1085, 576, 1204, 132, 132,
               132, 131, 128, 451, 93, 214, 134, 134, 134, 134,
               133, 133, 132, 132, 132, 131, 128, 451, 401, 19,
                19, 134, 134, 134, 134, 133, 133, 132, 132, 132,
               131, 128, 451, 1498, 426, 267, 344, 467, 332, 134,
               134, 134, 134, 133, 133, 132, 132, 132, 131, 128,
               451, 1281, 576, 6, 1204, 1205, 1204, 257, 576, 413,
               511, 508, 507, 1279, 94, 1019, 464, 1204, 551, 551,
               506, 1224, 1571, 44, 38, 51, 51, 411, 576, 413,
                45, 51, 51, 137, 138, 91, 530, 1228, 1228, 1063,
              1066, 1053, 1053, 135, 135, 136, 136, 136, 136, 398,
              1148, 82, 82, 137, 138, 91, 39, 1228, 1228, 1063,
              1066, 1053, 1053, 135, 135, 136, 136, 136, 136, 344,
                44, 288, 288, 375, 1204, 1205, 1204, 209, 1204, 1224,
               320, 567, 471, 576, 573, 576, 562, 576, 316, 264,
               231, 46, 160, 134, 134, 134, 134, 133, 133, 132,
               132, 132, 131, 128, 451, 303, 82, 82, 82, 82,
                82, 82, 442, 134, 134, 134, 134, 133, 133, 132,
               132, 132, 131, 128, 451, 1582, 544, 320, 567, 1250,
               874, 1582, 380, 382, 413, 1204, 1205, 1204, 360, 182,
               288, 288, 1576, 557, 1339, 557, 7, 557, 1277, 472,
               346, 526, 531, 573, 556, 562, 439, 1511, 137, 138,
                91, 219, 1228, 1228, 1063, 1066, 1053, 1053, 135, 135,
               136, 136, 136, 136, 465, 1511, 1513, 532, 413, 288,
               288, 423, 512, 288, 288, 411, 288, 288, 874, 130,
               127, 234, 573, 1107, 562, 1204, 573, 1107, 562, 573,
               560, 562, 137, 138, 91, 1293, 1228, 1228, 1063, 1066,
              1053, 1053, 135, 135, 136, 136, 136, 136, 134, 134,
               134, 134, 133, 133, 132, 132, 132, 131, 128, 451,
               493, 503, 1292, 1204, 257, 288, 288, 511, 508, 507,
              1204, 1628, 1169, 123, 568, 275, 4, 506, 573, 1511,
               562, 331, 1204, 1205, 1204, 1169, 548, 548, 1169, 261,
               571, 7, 134, 134, 134, 134, 133, 133, 132, 132,
               132, 131, 128, 451, 108, 533, 130, 127, 234, 1204,
               448, 447, 413, 1451, 452, 983, 886, 96, 1598, 1233,
              1204, 1205, 1204, 984, 1235, 1450, 565, 1204, 1205, 1204,
               229, 522, 1234, 534, 1333, 1333, 137, 138, 91, 1449,
              1228, 1228, 1063, 1066, 1053, 1053, 135, 135, 136, 136,
               136, 136, 373, 1595, 971, 1040, 413, 1236, 418, 1236,
               879, 121, 121, 948, 373, 1595, 1204, 1205, 1204, 122,
              1204, 452, 577, 452, 363, 417, 1028, 882, 373, 1595,
               137, 138, 91, 462, 1228, 1228, 1063, 1066, 1053, 1053,
               135, 135, 136, 136, 136, 136, 134, 134, 134, 134,
               133, 133, 132, 132, 132, 131, 128, 451, 1028, 1028,
              1030, 1031, 35, 570, 570, 570, 197, 423, 1040, 198,
              1204, 123, 568, 1204, 4, 320, 567, 1204, 1205, 1204,
                40, 388, 576, 384, 882, 1029, 423, 1188, 571, 1028,
               134, 134, 134, 134, 133, 133, 132, 132, 132, 131,
               128, 451, 529, 1568, 1204, 19, 19, 1204, 575, 492,
               413, 157, 452, 489, 1187, 1331, 1331, 5, 1204, 949,
               431, 1028, 1028, 1030, 565, 22, 22, 1204, 1205, 1204,
              1204, 1205, 1204, 477, 137, 138, 91, 212, 1228, 1228,
              1063, 1066, 1053, 1053, 135, 135, 136, 136, 136, 136,
              1188, 48, 111, 1040, 413, 1204, 213, 970, 1041, 121,
               121, 1204, 1205, 1204, 1204, 1205, 1204, 122, 221, 452,
               577, 452, 44, 487, 1028, 1204, 1205, 1204, 137, 138,
                91, 378, 1228, 1228, 1063, 1066, 1053, 1053, 135, 135,
               136, 136, 136, 136, 134, 134, 134, 134, 133, 133,
               132, 132, 132, 131, 128, 451, 1028, 1028, 1030, 1031,
                35, 461, 1204, 1205, 1204, 1569, 1040, 377, 214, 1149,
              1657, 535, 1657, 437, 902, 320, 567, 1568, 364, 320,
               567, 412, 329, 1029, 519, 1188, 3, 1028, 134, 134,
               134, 134, 133, 133, 132, 132, 132, 131, 128, 451,
              1659, 399, 1169, 307, 893, 307, 515, 576, 413, 214,
               498, 944, 1024, 540, 903, 1169, 943, 392, 1169, 1028,
              1028, 1030, 406, 298, 1204, 50, 1149, 1658, 413, 1658,
               145, 145, 137, 138, 91, 293, 1228, 1228, 1063, 1066,
              1053, 1053, 135, 135, 136, 136, 136, 136, 1188, 1147,
               514, 1568, 137, 138, 91, 1505, 1228, 1228, 1063, 1066,
              1053, 1053, 135, 135, 136, 136, 136, 136, 434, 323,
               435, 539, 111, 1506, 274, 291, 372, 517, 367, 516,
               262, 1204, 1205, 1204, 1574, 481, 363, 576, 7, 1569,
              1568, 377, 134, 134, 134, 134, 133, 133, 132, 132,
               132, 131, 128, 451, 1568, 576, 1147, 576, 232, 576,
                19, 19, 134, 134, 134, 134, 133, 133, 132, 132,
               132, 131, 128, 451, 1169, 433, 576, 1207, 19, 19,
                19, 19, 19, 19, 1627, 576, 911, 1169, 47, 120,
              1169, 117, 413, 306, 498, 438, 1125, 206, 336, 19,
                19, 1435, 49, 449, 449, 449, 1368, 315, 81, 81,
               576, 304, 413, 1570, 207, 377, 137, 138, 91, 115,
              1228, 1228, 1063, 1066, 1053, 1053, 135, 135, 136, 136,
               136, 136, 576, 82, 82, 1207, 137, 138, 91, 1340,
              1228, 1228, 1063, 1066, 1053, 1053, 135, 135, 136, 136,
               136, 136, 1569, 386, 377, 82, 82, 463, 1126, 1552,
               333, 463, 335, 131, 128, 451, 1569, 161, 377, 16,
               317, 387, 428, 1127, 448, 447, 134, 134, 134, 134,
               133, 133, 132, 132, 132, 131, 128, 451, 1128, 576,
              1105, 10, 445, 267, 576, 1554, 134, 134, 134, 134,
               133, 133, 132, 132, 132, 131, 128, 451, 532, 576,
               922, 576, 19, 19, 576, 1573, 576, 147, 147, 7,
               923, 1236, 498, 1236, 576, 487, 413, 552, 285, 1224,
               969, 215, 82, 82, 66, 66, 1435, 67, 67, 21,
                21, 1110, 1110, 495, 334, 297, 413, 53, 53, 297,
               137, 138, 91, 119, 1228, 1228, 1063, 1066, 1053, 1053,
               135, 135, 136, 136, 136, 136, 413, 1336, 1311, 446,
               137, 138, 91, 227, 1228, 1228, 1063, 1066, 1053, 1053,
               135, 135, 136, 136, 136, 136, 574, 1224, 936, 936,
               137, 126, 91, 141, 1228, 1228, 1063, 1066, 1053, 1053,
               135, 135, 136, 136, 136, 136, 533, 429, 472, 346,
               134, 134, 134, 134, 133, 133, 132, 132, 132, 131,
               128, 451, 576, 457, 233, 343, 1435, 403, 498, 1550,
               134, 134, 134, 134, 133, 133, 132, 132, 132, 131,
               128, 451, 576, 324, 576, 82, 82, 487, 576, 969,
               134, 134, 134, 134, 133, 133, 132, 132, 132, 131,
               128, 451, 288, 288, 546, 68, 68, 54, 54, 553,
               413, 69, 69, 351, 6, 573, 944, 562, 410, 409,
              1435, 943, 450, 545, 260, 259, 258, 576, 158, 576,
               413, 222, 1180, 479, 969, 138, 91, 430, 1228, 1228,
              1063, 1066, 1053, 1053, 135, 135, 136, 136, 136, 136,
                70, 70, 71, 71, 576, 1126, 91, 576, 1228, 1228,
              1063, 1066, 1053, 1053, 135, 135, 136, 136, 136, 136,
              1127, 166, 850, 851, 852, 1282, 419, 72, 72, 108,
                73, 73, 1310, 358, 1180, 1128, 576, 305, 576, 123,
               568, 494, 4, 488, 134, 134, 134, 134, 133, 133,
               132, 132, 132, 131, 128, 451, 571, 564, 534, 55,
                55, 56, 56, 576, 134, 134, 134, 134, 133, 133,
               132, 132, 132, 131, 128, 451, 576, 1104, 233, 1104,
               452, 1602, 582, 2, 1259, 576, 57, 57, 576, 321,
               576, 155, 565, 1435, 485, 353, 576, 356, 1341, 59,
                59, 576, 44, 969, 569, 419, 576, 238, 60, 60,
               261, 74, 74, 75, 75, 287, 231, 576, 1366, 76,
                76, 1040, 420, 184, 20, 20, 576, 121, 121, 77,
                77, 97, 218, 288, 288, 122, 125, 452, 577, 452,
               143, 143, 1028, 576, 520, 576, 573, 576, 562, 144,
               144, 474, 227, 1244, 478, 123, 568, 576, 4, 320,
               567, 245, 411, 576, 443, 411, 78, 78, 62, 62,
                79, 79, 571, 319, 1028, 1028, 1030, 1031, 35, 418,
                63, 63, 576, 290, 411, 9, 80, 80, 1144, 576,
               400, 576, 486, 455, 576, 1223, 452, 576, 325, 342,
               576, 111, 576, 1188, 242, 64, 64, 473, 565, 576,
                23, 576, 170, 170, 171, 171, 576, 87, 87, 328,
                65, 65, 542, 83, 83, 146, 146, 541, 123, 568,
               341, 4, 84, 84, 168, 168, 576, 1040, 576, 148,
               148, 576, 1380, 121, 121, 571, 1021, 576, 266, 576,
               424, 122, 576, 452, 577, 452, 576, 553, 1028, 142,
               142, 169, 169, 576, 162, 162, 528, 889, 371, 452,
               152, 152, 151, 151, 1379, 149, 149, 109, 370, 150,
               150, 565, 576, 480, 576, 266, 86, 86, 576, 1092,
              1028, 1028, 1030, 1031, 35, 542, 482, 576, 266, 466,
               543, 123, 568, 1616, 4, 88, 88, 85, 85, 475,
              1040, 52, 52, 222, 901, 900, 121, 121, 571, 1188,
                58, 58, 244, 1032, 122, 889, 452, 577, 452, 908,
               909, 1028, 300, 347, 504, 111, 263, 361, 165, 111,
               111, 1088, 452, 263, 974, 1153, 266, 1092, 986, 987,
               942, 939, 125, 125, 565, 1103, 872, 1103, 159, 941,
              1309, 125, 1557, 1028, 1028, 1030, 1031, 35, 542, 337,
              1530, 205, 1529, 541, 499, 1589, 490, 348, 1376, 352,
               355, 1032, 357, 1040, 359, 1324, 1308, 366, 563, 121,
               121, 376, 1188, 1389, 1434, 1362, 280, 122, 1374, 452,
               577, 452, 167, 1439, 1028, 1289, 1280, 1268, 1267, 1269,
              1609, 1359, 312, 313, 314, 397, 12, 237, 224, 1421,
               295, 1416, 1409, 1426, 339, 484, 340, 509, 1371, 1612,
              1372, 1425, 1244, 404, 301, 228, 1028, 1028, 1030, 1031,
                35, 1601, 1192, 454, 345, 1307, 292, 369, 1502, 1501,
               270, 396, 396, 395, 277, 393, 1370, 1369, 859, 1549,
               186, 123, 568, 235, 4, 1188, 391, 210, 211, 223,
              1547, 239, 1241, 327, 422, 96, 220, 195, 571, 180,
               188, 326, 468, 469, 190, 191, 502, 192, 193, 566,
               247, 109, 1430, 491, 199, 251, 102, 281, 402, 476,
               405, 1496, 452, 497, 253, 1422, 13, 1428, 14, 1427,
               203, 1507, 241, 500, 565, 354, 407, 92, 95, 1270,
               175, 254, 518, 43, 1327, 255, 1326, 1325, 436, 1518,
               350, 1318, 104, 229, 893, 1626, 440, 441, 1625, 408,
               240, 1296, 268, 1040, 310, 269, 1297, 527, 444, 121,
               121, 368, 1295, 1594, 1624, 311, 1394, 122, 1317, 452,
               577, 452, 374, 1580, 1028, 1393, 140, 553, 11, 90,
               568, 385, 4, 116, 318, 414, 1579, 110, 1483, 537,
               320, 567, 1350, 555, 42, 579, 571, 1349, 1198, 383,
               276, 390, 216, 389, 278, 279, 1028, 1028, 1030, 1031,
                35, 172, 580, 1265, 458, 1260, 415, 416, 185, 156,
               452, 1534, 1535, 173, 1533, 1532, 89, 308, 225, 226,
               846, 174, 565, 453, 217, 1188, 322, 236, 1102, 154,
              1100, 330, 187, 176, 1223, 243, 189, 925, 338, 246,
              1116, 194, 177, 425, 178, 427, 98, 196, 99, 100,
               101, 1040, 179, 1119, 1115, 248, 249, 121, 121, 163,
                24, 250, 349, 1238, 496, 122, 1108, 452, 577, 452,
              1192, 454, 1028, 266, 292, 200, 252, 201, 861, 396,
               396, 395, 277, 393, 15, 501, 859, 370, 292, 256,
               202, 554, 505, 396, 396, 395, 277, 393, 103, 239,
               859, 327, 25, 26, 1028, 1028, 1030, 1031, 35, 326,
               362, 510, 891, 239, 365, 327, 513, 904, 105, 309,
               164, 181, 27, 326, 106, 521, 107, 1185, 1069, 1155,
                17, 1154, 230, 1188, 284, 286, 265, 204, 125, 1171,
               241, 28, 978, 972, 29, 41, 1175, 1179, 175, 1173,
                30, 43, 31, 8, 241, 1178, 32, 1160, 208, 549,
                33, 111, 175, 1083, 1070, 43, 1068, 1072, 240, 113,
               114, 34, 561, 118, 1124, 271, 1073, 36, 18, 572,
              1033, 873, 240, 124, 37, 935, 272, 273, 1617, 183,
               153, 394, 1194, 1193, 1256, 1256, 1256, 1256, 1256, 1256,
              1256, 1256, 1256, 414, 1256, 1256, 1256, 1256, 320, 567,
              1256, 1256, 1256, 1256, 1256, 1256, 1256, 414, 1256, 1256,
              1256, 1256, 320, 567, 1256, 1256, 1256, 1256, 1256, 1256,
              1256, 1256, 458, 1256, 1256, 1256, 1256, 1256, 1256, 1256,
              1256, 1256, 1256, 1256, 1256, 1256, 458,
};
static const unsigned short int yy_lookahead[] = {
               277, 278, 279, 241, 242, 225, 195, 227, 195, 241,
               242, 195, 217, 221, 195, 235, 254, 195, 256, 19,
               225, 298, 254, 195, 256, 206, 213, 214, 206, 218,
               219, 31, 206, 195, 218, 219, 195, 218, 219, 39,
               218, 219, 313, 43, 44, 45, 317, 47, 48, 49,
                50, 51, 52, 53, 54, 55, 56, 57, 58, 19,
               241, 242, 195, 241, 242, 195, 255, 241, 242, 277,
               278, 279, 234, 254, 255, 256, 254, 255, 256, 218,
               254, 240, 256, 43, 44, 45, 264, 47, 48, 49,
                50, 51, 52, 53, 54, 55, 56, 57, 58, 271,
               287, 22, 23, 103, 104, 105, 106, 107, 108, 109,
               110, 111, 112, 113, 114, 114, 47, 48, 49, 50,
               187, 188, 189, 190, 191, 192, 190, 87, 192, 89,
               197, 19, 199, 197, 318, 199, 320, 25, 195, 206,
               299, 271, 206, 103, 104, 105, 106, 107, 108, 109,
               110, 111, 112, 113, 114, 43, 44, 45, 195, 47,
                48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
                58, 60, 21, 195, 241, 242, 215, 241, 242, 312,
               313, 102, 70, 205, 317, 207, 242, 254, 77, 256,
               254, 122, 256, 55, 56, 57, 58, 59, 254, 88,
               256, 90, 269, 240, 93, 269, 107, 108, 109, 110,
               111, 112, 113, 114, 271, 103, 104, 105, 106, 107,
               108, 109, 110, 111, 112, 113, 114, 313, 117, 118,
               119, 317, 81, 195, 301, 19, 195, 301, 277, 278,
               279, 103, 104, 105, 106, 107, 108, 109, 110, 111,
               112, 113, 114, 55, 56, 57, 58, 146, 195, 43,
                44, 45, 74, 47, 48, 49, 50, 51, 52, 53,
                54, 55, 56, 57, 58, 124, 195, 60, 109, 110,
               111, 112, 113, 114, 68, 195, 103, 104, 105, 106,
               107, 108, 109, 110, 111, 112, 113, 114, 208, 218,
               219, 103, 104, 105, 106, 107, 108, 109, 110, 111,
               112, 113, 114, 162, 233, 24, 128, 129, 130, 103,
               104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
               114, 195, 195, 215, 117, 118, 119, 120, 195, 19,
               123, 124, 125, 207, 24, 74, 246, 60, 310, 311,
               133, 60, 311, 82, 22, 218, 219, 257, 195, 19,
                73, 218, 219, 43, 44, 45, 206, 47, 48, 49,
                50, 51, 52, 53, 54, 55, 56, 57, 58, 22,
                23, 218, 219, 43, 44, 45, 54, 47, 48, 49,
                50, 51, 52, 53, 54, 55, 56, 57, 58, 128,
                82, 241, 242, 195, 117, 118, 119, 289, 60, 118,
               139, 140, 294, 195, 254, 195, 256, 195, 255, 259,
               260, 73, 22, 103, 104, 105, 106, 107, 108, 109,
               110, 111, 112, 113, 114, 206, 218, 219, 218, 219,
               218, 219, 234, 103, 104, 105, 106, 107, 108, 109,
               110, 111, 112, 113, 114, 318, 319, 139, 140, 102,
                60, 318, 319, 221, 19, 117, 118, 119, 23, 195,
               241, 242, 313, 255, 206, 255, 317, 255, 206, 129,
               130, 206, 264, 254, 264, 256, 264, 195, 43, 44,
                45, 151, 47, 48, 49, 50, 51, 52, 53, 54,
                55, 56, 57, 58, 246, 213, 214, 19, 19, 241,
               242, 195, 23, 241, 242, 257, 241, 242, 118, 277,
               278, 279, 254, 29, 256, 60, 254, 33, 256, 254,
               206, 256, 43, 44, 45, 218, 47, 48, 49, 50,
                51, 52, 53, 54, 55, 56, 57, 58, 103, 104,
               105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
                66, 19, 218, 60, 120, 241, 242, 123, 124, 125,
                60, 232, 77, 19, 20, 26, 22, 133, 254, 287,
               256, 265, 117, 118, 119, 90, 312, 313, 93, 47,
                36, 317, 103, 104, 105, 106, 107, 108, 109, 110,
               111, 112, 113, 114, 116, 117, 277, 278, 279, 60,
               107, 108, 19, 276, 60, 31, 23, 152, 195, 116,
               117, 118, 119, 39, 121, 276, 72, 117, 118, 119,
               166, 167, 129, 145, 237, 238, 43, 44, 45, 276,
                47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 315, 316, 144, 101, 19, 154, 116, 156,
                23, 107, 108, 109, 315, 316, 117, 118, 119, 115,
                60, 117, 118, 119, 132, 200, 122, 60, 315, 316,
                43, 44, 45, 272, 47, 48, 49, 50, 51, 52,
                53, 54, 55, 56, 57, 58, 103, 104, 105, 106,
               107, 108, 109, 110, 111, 112, 113, 114, 154, 155,
               156, 157, 158, 212, 213, 214, 22, 195, 101, 22,
                60, 19, 20, 60, 22, 139, 140, 117, 118, 119,
                22, 251, 195, 253, 117, 118, 195, 183, 36, 122,
               103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
               113, 114, 195, 195, 60, 218, 219, 60, 195, 284,
                19, 25, 60, 288, 23, 237, 238, 22, 60, 109,
               233, 154, 155, 156, 72, 218, 219, 117, 118, 119,
               117, 118, 119, 116, 43, 44, 45, 265, 47, 48,
                49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
               183, 243, 25, 101, 19, 60, 265, 144, 23, 107,
               108, 117, 118, 119, 117, 118, 119, 115, 151, 117,
               118, 119, 82, 195, 122, 117, 118, 119, 43, 44,
                45, 195, 47, 48, 49, 50, 51, 52, 53, 54,
                55, 56, 57, 58, 103, 104, 105, 106, 107, 108,
               109, 110, 111, 112, 113, 114, 154, 155, 156, 157,
               158, 121, 117, 118, 119, 307, 101, 309, 195, 22,
                23, 195, 25, 19, 35, 139, 140, 195, 24, 139,
               140, 208, 195, 118, 109, 183, 22, 122, 103, 104,
               105, 106, 107, 108, 109, 110, 111, 112, 113, 114,
               304, 305, 77, 230, 127, 232, 67, 195, 19, 195,
               195, 136, 23, 88, 75, 90, 141, 203, 93, 154,
               155, 156, 208, 295, 60, 243, 22, 23, 19, 25,
               218, 219, 43, 44, 45, 100, 47, 48, 49, 50,
                51, 52, 53, 54, 55, 56, 57, 58, 183, 102,
                96, 195, 43, 44, 45, 240, 47, 48, 49, 50,
                51, 52, 53, 54, 55, 56, 57, 58, 114, 134,
               131, 146, 25, 286, 120, 121, 122, 123, 124, 125,
               126, 117, 118, 119, 313, 195, 132, 195, 317, 307,
               195, 309, 103, 104, 105, 106, 107, 108, 109, 110,
               111, 112, 113, 114, 195, 195, 102, 195, 195, 195,
               218, 219, 103, 104, 105, 106, 107, 108, 109, 110,
               111, 112, 113, 114, 77, 233, 195, 60, 218, 219,
               218, 219, 218, 219, 23, 195, 25, 90, 243, 159,
                93, 161, 19, 233, 195, 233, 23, 233, 16, 218,
               219, 195, 243, 212, 213, 214, 262, 263, 218, 219,
               195, 271, 19, 307, 233, 309, 43, 44, 45, 160,
                47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 195, 218, 219, 118, 43, 44, 45, 240,
                47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 58, 307, 195, 309, 218, 219, 263, 12, 195,
                78, 267, 80, 112, 113, 114, 307, 22, 309, 24,
               255, 281, 266, 27, 107, 108, 103, 104, 105, 106,
               107, 108, 109, 110, 111, 112, 113, 114, 42, 195,
                11, 22, 255, 24, 195, 195, 103, 104, 105, 106,
               107, 108, 109, 110, 111, 112, 113, 114, 19, 195,
                64, 195, 218, 219, 195, 313, 195, 218, 219, 317,
                74, 154, 195, 156, 195, 195, 19, 233, 23, 60,
                25, 24, 218, 219, 218, 219, 195, 218, 219, 218,
               219, 128, 129, 130, 162, 263, 19, 218, 219, 267,
                43, 44, 45, 160, 47, 48, 49, 50, 51, 52,
                53, 54, 55, 56, 57, 58, 19, 240, 228, 255,
                43, 44, 45, 25, 47, 48, 49, 50, 51, 52,
                53, 54, 55, 56, 57, 58, 135, 118, 137, 138,
                43, 44, 45, 22, 47, 48, 49, 50, 51, 52,
                53, 54, 55, 56, 57, 58, 117, 266, 129, 130,
               103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
               113, 114, 195, 195, 119, 295, 195, 206, 195, 195,
               103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
               113, 114, 195, 195, 195, 218, 219, 195, 195, 144,
               103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
               113, 114, 241, 242, 67, 218, 219, 218, 219, 146,
                19, 218, 219, 240, 215, 254, 136, 256, 107, 108,
               195, 141, 255, 86, 128, 129, 130, 195, 165, 195,
                19, 143, 95, 272, 25, 44, 45, 266, 47, 48,
                49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
               218, 219, 218, 219, 195, 12, 45, 195, 47, 48,
                49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
                27, 23, 7, 8, 9, 210, 211, 218, 219, 116,
               218, 219, 228, 16, 147, 42, 195, 295, 195, 19,
                20, 266, 22, 294, 103, 104, 105, 106, 107, 108,
               109, 110, 111, 112, 113, 114, 36, 64, 145, 218,
               219, 218, 219, 195, 103, 104, 105, 106, 107, 108,
               109, 110, 111, 112, 113, 114, 195, 154, 119, 156,
                60, 189, 190, 191, 192, 195, 218, 219, 195, 197,
               195, 199, 72, 195, 19, 78, 195, 80, 206, 218,
               219, 195, 82, 144, 210, 211, 195, 15, 218, 219,
                47, 218, 219, 218, 219, 259, 260, 195, 261, 218,
               219, 101, 302, 303, 218, 219, 195, 107, 108, 218,
               219, 150, 151, 241, 242, 115, 25, 117, 118, 119,
               218, 219, 122, 195, 146, 195, 254, 195, 256, 218,
               219, 246, 25, 61, 246, 19, 20, 195, 22, 139,
               140, 269, 257, 195, 266, 257, 218, 219, 218, 219,
               218, 219, 36, 246, 154, 155, 156, 157, 158, 116,
               218, 219, 195, 22, 257, 49, 218, 219, 23, 195,
                25, 195, 117, 301, 195, 25, 60, 195, 195, 23,
               195, 25, 195, 183, 24, 218, 219, 130, 72, 195,
                22, 195, 218, 219, 218, 219, 195, 218, 219, 195,
               218, 219, 86, 218, 219, 218, 219, 91, 19, 20,
               153, 22, 218, 219, 218, 219, 195, 101, 195, 218,
               219, 195, 195, 107, 108, 36, 23, 195, 25, 195,
                62, 115, 195, 117, 118, 119, 195, 146, 122, 218,
               219, 218, 219, 195, 218, 219, 19, 60, 122, 60,
               218, 219, 218, 219, 195, 218, 219, 150, 132, 218,
               219, 72, 195, 23, 195, 25, 218, 219, 195, 60,
               154, 155, 156, 157, 158, 86, 23, 195, 25, 195,
                91, 19, 20, 142, 22, 218, 219, 218, 219, 130,
               101, 218, 219, 143, 121, 122, 107, 108, 36, 183,
               218, 219, 142, 60, 115, 118, 117, 118, 119, 7,
                 8, 122, 153, 23, 23, 25, 25, 23, 23, 25,
                25, 23, 60, 25, 23, 98, 25, 118, 84, 85,
                23, 23, 25, 25, 72, 154, 23, 156, 25, 23,
               228, 25, 195, 154, 155, 156, 157, 158, 86, 195,
               195, 258, 195, 91, 291, 322, 195, 195, 195, 195,
               195, 118, 195, 101, 195, 195, 195, 195, 238, 107,
               108, 195, 183, 195, 195, 195, 290, 115, 195, 117,
               118, 119, 244, 195, 122, 195, 195, 195, 195, 195,
               195, 258, 258, 258, 258, 193, 245, 300, 216, 274,
               247, 270, 270, 274, 296, 296, 248, 222, 262, 198,
               262, 274, 61, 274, 248, 231, 154, 155, 156, 157,
               158, 0, 1, 2, 247, 227, 5, 221, 221, 221,
               142, 10, 11, 12, 13, 14, 262, 262, 17, 202,
               300, 19, 20, 300, 22, 183, 247, 251, 251, 245,
               202, 30, 38, 32, 202, 152, 151, 22, 36, 43,
               236, 40, 18, 202, 239, 239, 18, 239, 239, 283,
               201, 150, 236, 202, 236, 201, 159, 202, 248, 248,
               248, 248, 60, 63, 201, 275, 273, 275, 273, 275,
                22, 286, 71, 223, 72, 202, 223, 297, 297, 202,
                79, 201, 116, 82, 220, 201, 220, 220, 65, 293,
               292, 229, 22, 166, 127, 226, 24, 114, 226, 223,
                99, 222, 202, 101, 285, 92, 220, 308, 83, 107,
               108, 220, 220, 316, 220, 285, 268, 115, 229, 117,
               118, 119, 223, 321, 122, 268, 149, 146, 22, 19,
                20, 202, 22, 159, 282, 134, 321, 148, 280, 147,
               139, 140, 252, 141, 25, 204, 36, 252, 13, 251,
               196, 248, 250, 249, 196, 6, 154, 155, 156, 157,
               158, 209, 194, 194, 163, 194, 306, 306, 303, 224,
                60, 215, 215, 209, 215, 215, 215, 224, 216, 216,
                 4, 209, 72, 3, 22, 183, 164, 15, 23, 16,
                23, 140, 152, 131, 25, 24, 143, 20, 16, 145,
                 1, 143, 131, 62, 131, 37, 54, 152, 54, 54,
                54, 101, 131, 117, 1, 34, 142, 107, 108, 5,
                22, 116, 162, 76, 41, 115, 69, 117, 118, 119,
                 1, 2, 122, 25, 5, 69, 142, 116, 20, 10,
                11, 12, 13, 14, 24, 19, 17, 132, 5, 126,
                22, 141, 68, 10, 11, 12, 13, 14, 22, 30,
                17, 32, 22, 22, 154, 155, 156, 157, 158, 40,
                23, 68, 60, 30, 24, 32, 97, 28, 22, 68,
                23, 37, 34, 40, 150, 22, 25, 23, 23, 23,
                22, 98, 142, 183, 23, 23, 34, 22, 25, 89,
                71, 34, 117, 144, 34, 22, 76, 76, 79, 87,
                34, 82, 34, 44, 71, 94, 34, 23, 25, 24,
                34, 25, 79, 23, 23, 82, 23, 23, 99, 143,
               143, 22, 25, 25, 23, 22, 11, 22, 22, 25,
                23, 23, 99, 22, 22, 136, 142, 142, 142, 25,
                23, 15, 1, 1, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 134, 323, 323, 323, 323, 139, 140,
               323, 323, 323, 323, 323, 323, 323, 134, 323, 323,
               323, 323, 139, 140, 323, 323, 323, 323, 323, 323,
               323, 323, 163, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 163, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
               323, 187, 187, 187, 187, 187, 187, 187, 187, 187,
               187, 187, 187, 187, 187, 187, 187, 187, 187, 187,
               187, 187, 187, 187, 187, 187, 187, 187, 187, 187,
               187, 187, 187, 187, 187, 187, 187, 187, 187, 187,
               187, 187, 187, 187, 187, 187, 187, 187, 187, 187,
               187, 187, 187, 187,
};



static const unsigned short int yy_shift_ofst[] = {
              2029, 1801, 2043, 1380, 1380, 318, 271, 1496, 1569, 1642,
               702, 702, 702, 740, 318, 318, 318, 318, 318, 0,
                 0, 216, 1177, 702, 702, 702, 702, 702, 702, 702,
               702, 702, 702, 702, 702, 702, 702, 702, 503, 503,
               111, 111, 217, 287, 348, 610, 610, 736, 736, 736,
               736, 40, 112, 320, 340, 445, 489, 593, 637, 741,
               785, 889, 909, 1023, 1043, 1157, 1177, 1177, 1177, 1177,
              1177, 1177, 1177, 1177, 1177, 1177, 1177, 1177, 1177, 1177,
              1177, 1177, 1177, 1177, 1197, 1177, 1301, 1321, 1321, 554,
              1802, 1910, 702, 702, 702, 702, 702, 702, 702, 702,
               702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
               702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
               702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
               702, 702, 702, 702, 702, 702, 702, 702, 702, 702,
               702, 702, 138, 198, 198, 198, 198, 198, 198, 198,
               183, 99, 169, 549, 610, 151, 542, 610, 610, 1017,
              1017, 610, 1001, 350, 464, 464, 464, 586, 1, 1,
              2207, 2207, 854, 854, 854, 465, 694, 694, 694, 694,
              1096, 1096, 825, 549, 847, 904, 610, 610, 610, 610,
               610, 610, 610, 610, 610, 610, 610, 610, 610, 610,
               610, 610, 610, 610, 610, 488, 947, 947, 610, 1129,
               495, 495, 1139, 1139, 967, 967, 1173, 2207, 2207, 2207,
              2207, 2207, 2207, 2207, 617, 765, 765, 697, 444, 708,
               660, 745, 510, 663, 864, 610, 610, 610, 610, 610,
               610, 610, 610, 610, 610, 188, 610, 610, 610, 610,
               610, 610, 610, 610, 610, 610, 610, 610, 839, 839,
               839, 610, 610, 610, 1155, 610, 610, 610, 1119, 1247,
               610, 1353, 610, 610, 610, 610, 610, 610, 610, 610,
              1063, 494, 1101, 291, 291, 291, 291, 1319, 1101, 1101,
               775, 1221, 1375, 1452, 667, 1341, 1198, 1341, 1435, 1487,
               667, 667, 1487, 667, 1198, 1435, 777, 1011, 1423, 584,
               584, 584, 1273, 1273, 1273, 1273, 1471, 1471, 880, 1530,
              1190, 1095, 1731, 1731, 1668, 1668, 1794, 1794, 1668, 1683,
              1685, 1815, 1796, 1824, 1824, 1824, 1824, 1668, 1828, 1701,
              1685, 1685, 1701, 1815, 1796, 1701, 1796, 1701, 1668, 1828,
              1697, 1800, 1668, 1828, 1848, 1668, 1828, 1668, 1828, 1848,
              1766, 1766, 1766, 1823, 1870, 1870, 1848, 1766, 1767, 1766,
              1823, 1766, 1766, 1727, 1872, 1783, 1783, 1848, 1668, 1813,
              1813, 1825, 1825, 1777, 1781, 1906, 1668, 1774, 1777, 1789,
              1792, 1701, 1919, 1935, 1935, 1949, 1949, 1949, 2207, 2207,
              2207, 2207, 2207, 2207, 2207, 2207, 2207, 2207, 2207, 2207,
              2207, 2207, 2207, 69, 1032, 79, 357, 1377, 1206, 400,
              1525, 835, 332, 1540, 1437, 1539, 1536, 1548, 1583, 1620,
              1633, 1670, 1671, 1674, 1567, 1553, 1682, 1506, 1675, 1358,
              1607, 1589, 1678, 1681, 1624, 1687, 1688, 1283, 1561, 1693,
              1696, 1623, 1521, 1976, 1980, 1962, 1822, 1972, 1973, 1965,
              1967, 1851, 1840, 1862, 1969, 1969, 1971, 1853, 1977, 1854,
              1982, 1999, 1858, 1871, 1969, 1873, 1941, 1968, 1969, 1855,
              1952, 1954, 1955, 1956, 1881, 1896, 1981, 1874, 2013, 2014,
              1998, 1905, 1860, 1957, 2008, 1966, 1947, 1983, 1894, 1921,
              2020, 2018, 2026, 1915, 1923, 2028, 1984, 2036, 2040, 2047,
              2041, 2003, 2012, 2050, 1979, 2049, 2056, 2011, 2044, 2057,
              2048, 1934, 2063, 2064, 2065, 2061, 2066, 2068, 1993, 1950,
              2071, 2072, 1985, 2062, 2075, 1959, 2073, 2067, 2070, 2076,
              2078, 2010, 2030, 2022, 2069, 2031, 2021, 2082, 2094, 2083,
              2095, 2093, 2096, 2086, 1986, 1987, 2100, 2073, 2101, 2103,
              2104, 2109, 2107, 2108, 2111, 2113, 2125, 2115, 2116, 2117,
              2118, 2121, 2122, 2114, 2009, 2004, 2005, 2006, 2124, 2127,
              2136, 2151, 2152,
};



static const short yy_reduce_ofst[] = {
               -67, 1252, -64, -178, -181, 160, 1071, 143, -184, 137,
               218, 220, 222, -174, 229, 268, 272, 275, 324, -208,
               242, -277, -39, 81, 537, 792, 810, 812, -189, 814,
               831, 163, 865, 944, 887, 840, 964, 1077, -187, 292,
              -133, 274, 673, 558, 682, 795, 809, -238, -232, -238,
              -232, 329, 329, 329, 329, 329, 329, 329, 329, 329,
               329, 329, 329, 329, 329, 329, 329, 329, 329, 329,
               329, 329, 329, 329, 329, 329, 329, 329, 329, 329,
               329, 329, 329, 329, 329, 329, 329, 329, 329, 557,
               712, 949, 966, 969, 971, 979, 1097, 1099, 1103, 1142,
              1144, 1169, 1172, 1201, 1203, 1228, 1241, 1250, 1253, 1255,
              1261, 1266, 1271, 1282, 1291, 1308, 1310, 1312, 1322, 1328,
              1347, 1354, 1356, 1359, 1362, 1365, 1367, 1374, 1376, 1381,
              1401, 1403, 1406, 1412, 1414, 1417, 1421, 1428, 1447, 1449,
              1453, 1462, 329, 329, 329, 329, 329, 329, 329, 329,
               329, 329, 329, -22, -159, 475, -220, 756, 38, 501,
               841, 714, 329, 118, 337, 349, 363, -56, 329, 329,
               329, 329, -205, -205, -205, 687, -172, -130, -57, 790,
               397, 528, -271, 136, 596, 596, 90, 316, 522, 541,
               -37, 715, 849, 977, 628, 856, 980, 991, 1081, 1102,
              1135, 1083, -162, 208, 1258, 794, -86, 159, 41, 1109,
               671, 852, 844, 932, 1175, 1254, 480, 1180, 100, 258,
              1265, 1268, 1216, 1287, -139, 317, 344, 63, 339, 423,
               563, 636, 676, 813, 908, 914, 950, 1078, 1084, 1098,
              1363, 1384, 1407, 1439, 1464, 411, 1527, 1534, 1535, 1537,
              1541, 1542, 1543, 1544, 1545, 1547, 1549, 1550, 990, 1164,
              1492, 1551, 1552, 1556, 1217, 1558, 1559, 1560, 1473, 1413,
              1563, 1510, 1568, 563, 1570, 1571, 1572, 1573, 1574, 1575,
              1443, 1466, 1518, 1513, 1514, 1515, 1516, 1217, 1518, 1518,
              1531, 1562, 1582, 1477, 1505, 1511, 1533, 1512, 1488, 1538,
              1509, 1517, 1546, 1519, 1557, 1489, 1565, 1564, 1578, 1586,
              1587, 1588, 1526, 1528, 1554, 1555, 1576, 1577, 1566, 1579,
              1584, 1591, 1520, 1523, 1617, 1628, 1580, 1581, 1632, 1585,
              1590, 1593, 1604, 1605, 1606, 1608, 1609, 1641, 1649, 1610,
              1592, 1594, 1611, 1595, 1616, 1612, 1618, 1613, 1651, 1654,
              1596, 1598, 1655, 1663, 1650, 1673, 1680, 1677, 1684, 1653,
              1664, 1666, 1667, 1662, 1669, 1672, 1676, 1686, 1679, 1691,
              1689, 1692, 1694, 1597, 1599, 1619, 1630, 1699, 1700, 1602,
              1615, 1648, 1657, 1690, 1698, 1658, 1729, 1652, 1695, 1702,
              1704, 1703, 1741, 1754, 1758, 1768, 1769, 1771, 1660, 1661,
              1665, 1752, 1756, 1757, 1759, 1760, 1764, 1745, 1753, 1762,
              1763, 1761, 1772,
};
static const unsigned short int yy_default[] = {
              1663, 1663, 1663, 1491, 1254, 1367, 1254, 1254, 1254, 1254,
              1491, 1491, 1491, 1254, 1254, 1254, 1254, 1254, 1254, 1397,
              1397, 1544, 1287, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1490, 1254, 1254, 1254, 1254,
              1578, 1578, 1254, 1254, 1254, 1254, 1254, 1563, 1562, 1254,
              1254, 1254, 1406, 1254, 1413, 1254, 1254, 1254, 1254, 1254,
              1492, 1493, 1254, 1254, 1254, 1254, 1543, 1545, 1508, 1420,
              1419, 1418, 1417, 1526, 1385, 1411, 1404, 1408, 1487, 1488,
              1486, 1641, 1493, 1492, 1254, 1407, 1455, 1471, 1454, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1463, 1470, 1469, 1468, 1477, 1467, 1464, 1457,
              1456, 1458, 1459, 1278, 1254, 1275, 1329, 1254, 1254, 1254,
              1254, 1254, 1460, 1287, 1448, 1447, 1446, 1254, 1474, 1461,
              1473, 1472, 1551, 1615, 1614, 1509, 1254, 1254, 1254, 1254,
              1254, 1254, 1578, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1387, 1578, 1578, 1254, 1287,
              1578, 1578, 1388, 1388, 1283, 1283, 1391, 1558, 1358, 1358,
              1358, 1358, 1367, 1358, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1548,
              1546, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1363, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1608,
              1254, 1521, 1343, 1363, 1363, 1363, 1363, 1365, 1344, 1342,
              1357, 1288, 1261, 1655, 1423, 1412, 1364, 1412, 1652, 1410,
              1423, 1423, 1410, 1423, 1364, 1652, 1304, 1630, 1299, 1397,
              1397, 1397, 1387, 1387, 1387, 1387, 1391, 1391, 1489, 1364,
              1357, 1254, 1655, 1655, 1373, 1373, 1654, 1654, 1373, 1509,
              1638, 1432, 1332, 1338, 1338, 1338, 1338, 1373, 1272, 1410,
              1638, 1638, 1410, 1432, 1332, 1410, 1332, 1410, 1373, 1272,
              1525, 1649, 1373, 1272, 1499, 1373, 1272, 1373, 1272, 1499,
              1330, 1330, 1330, 1319, 1254, 1254, 1499, 1330, 1304, 1330,
              1319, 1330, 1330, 1596, 1254, 1503, 1503, 1499, 1373, 1588,
              1588, 1400, 1400, 1405, 1391, 1494, 1373, 1254, 1405, 1403,
              1401, 1410, 1322, 1611, 1611, 1607, 1607, 1607, 1660, 1660,
              1558, 1623, 1287, 1287, 1287, 1287, 1623, 1306, 1306, 1288,
              1288, 1287, 1623, 1254, 1254, 1254, 1254, 1254, 1254, 1618,
              1254, 1553, 1510, 1377, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1564, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1437, 1254, 1257, 1555, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1414, 1415, 1378, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1429, 1254, 1254, 1254, 1424, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1651, 1254, 1254,
              1254, 1254, 1254, 1254, 1524, 1523, 1254, 1254, 1375, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1302, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1402, 1254, 1254, 1254,
              1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1593, 1392, 1254, 1254, 1254, 1254, 1642, 1254, 1254,
              1254, 1254, 1352, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
              1254, 1254, 1254, 1634, 1346, 1438, 1254, 1441, 1276, 1254,
              1266, 1254, 1254,
};
# 178813 "c_tests/sqlite3.c"
static const unsigned short int yyFallback[] = {
    0,
    0,
   60,
   60,
   60,
   60,
    0,
   60,
   60,
   60,
    0,
   60,
   60,
   60,
   60,
    0,
    0,
    0,
   60,
    0,
    0,
   60,
    0,
    0,
    0,
    0,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
    0,
    0,
    0,
    0,
   60,
   60,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
   60,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
};
# 179020 "c_tests/sqlite3.c"
struct yyStackEntry {
  unsigned short int stateno;
  unsigned short int major;

  YYMINORTYPE minor;

};
typedef struct yyStackEntry yyStackEntry;



struct yyParser {
  yyStackEntry *yytos;







  Parse *pParse;
  yyStackEntry *yystackEnd;
  yyStackEntry *yystack;
  yyStackEntry yystk0[100];
};
typedef struct yyParser yyParser;
# 179832 "c_tests/sqlite3.c"
static int yyGrowStack(yyParser *p){
  int oldSize = 1 + (int)(p->yystackEnd - p->yystack);
  int newSize;
  int idx;
  yyStackEntry *pNew;

  newSize = oldSize*2 + 100;
  idx = (int)(p->yytos - p->yystack);
  if( p->yystack==p->yystk0 ){
    pNew = parserStackRealloc(0, newSize*sizeof(pNew[0]));
    if( pNew==0 ) return 1;
    memcpy(pNew, p->yystack, oldSize*sizeof(pNew[0]));
  }else{
    pNew = parserStackRealloc(p->yystack, newSize*sizeof(pNew[0]));
    if( pNew==0 ) return 1;
  }
  p->yystack = pNew;
  p->yytos = &p->yystack[idx];






  p->yystackEnd = &p->yystack[newSize-1];
  return 0;
}
# 179879 "c_tests/sqlite3.c"
static void sqlite3ParserInit(void *yypRawParser ,Parse *pParse){
  yyParser *yypParser = (yyParser*)yypRawParser;
  yypParser->pParse=pParse;



  yypParser->yystack = yypParser->yystk0;
  yypParser->yystackEnd = &yypParser->yystack[100 -1];



  yypParser->yytos = yypParser->yystack;
  yypParser->yystack[0].stateno = 0;
  yypParser->yystack[0].major = 0;
}
# 179927 "c_tests/sqlite3.c"
static void yy_destructor(
  yyParser *yypParser,
  unsigned short int yymajor,
  YYMINORTYPE *yypminor
){

  Parse *pParse=yypParser->pParse;
  switch( yymajor ){
# 179946 "c_tests/sqlite3.c"
    case 206:
    case 241:
    case 242:
    case 254:
    case 256:
{
sqlite3SelectDelete(pParse->db, (yypminor->yy637));
}
      break;
    case 218:
    case 219:
    case 248:
    case 250:
    case 270:
    case 281:
    case 283:
    case 286:
    case 293:
    case 298:
    case 315:
{
sqlite3ExprDelete(pParse->db, (yypminor->yy590));
}
      break;
    case 223:
    case 233:
    case 234:
    case 246:
    case 249:
    case 251:
    case 255:
    case 257:
    case 264:
    case 271:
    case 280:
    case 282:
    case 314:
{
sqlite3ExprListDelete(pParse->db, (yypminor->yy402));
}
      break;
    case 240:
    case 247:
    case 259:
    case 260:
    case 265:
{
sqlite3SrcListDelete(pParse->db, (yypminor->yy563));
}
      break;
    case 243:
{
sqlite3WithDelete(pParse->db, (yypminor->yy125));
}
      break;
    case 253:
    case 310:
{
sqlite3WindowListDelete(pParse->db, (yypminor->yy483));
}
      break;
    case 266:
    case 273:
{
sqlite3IdListDelete(pParse->db, (yypminor->yy204));
}
      break;
    case 276:
    case 311:
    case 312:
    case 313:
    case 316:
{
sqlite3WindowDelete(pParse->db, (yypminor->yy483));
}
      break;
    case 289:
    case 294:
{
sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy319));
}
      break;
    case 291:
{
sqlite3IdListDelete(pParse->db, (yypminor->yy28).b);
}
      break;
    case 318:
    case 319:
    case 320:
{
sqlite3ExprDelete(pParse->db, (yypminor->yy205).pExpr);
}
      break;

    default: break;
  }
}







static void yy_pop_parser_stack(yyParser *pParser){
  yyStackEntry *yytos;
  ((void) (0));
  ((void) (0));
  yytos = pParser->yytos--;







  yy_destructor(pParser, yytos->major, &yytos->minor);
}




static void sqlite3ParserFinalize(void *p){
  yyParser *pParser = (yyParser*)p;



  yyStackEntry *yytos = pParser->yytos;
  while( yytos>pParser->yystack ){







    if( yytos->major>=206 ){
      yy_destructor(pParser, yytos->major, &yytos->minor);
    }
    yytos--;
  }


  if( pParser->yystack!=pParser->yystk0 ) sqlite3_free(pParser->yystack);

}
# 180166 "c_tests/sqlite3.c"
static unsigned short int yy_find_shift_action(
  unsigned short int iLookAhead,
  unsigned short int stateno
){
  int i;

  if( stateno>582 ) return stateno;
  ((void) (0));



  do{
    i = yy_shift_ofst[stateno];
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    i += iLookAhead;
    ((void) (0));
    if( yy_lookahead[i]!=iLookAhead ){

      unsigned short int iFallback;
      ((void) (0));
      iFallback = yyFallback[iLookAhead];
      if( iFallback!=0 ){






        ((void) (0));
        iLookAhead = iFallback;
        continue;
      }


      {
        int j = i - iLookAhead + 102;
        ((void) (0));
        if( yy_lookahead[j]==102 && iLookAhead>0 ){







          return yy_action[j];
        }
      }

      return yy_default[stateno];
    }else{
      ((void) (0));
      return yy_action[i];
    }
  }while(1);
}





static unsigned short int yy_find_reduce_action(
  unsigned short int stateno,
  unsigned short int iLookAhead
){
  int i;





  ((void) (0));

  i = yy_reduce_ofst[stateno];
  ((void) (0));
  i += iLookAhead;





  ((void) (0));
  ((void) (0));

  return yy_action[i];
}




static void yyStackOverflow(yyParser *yypParser){

   Parse *pParse=yypParser->pParse;





   while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);




  sqlite3OomFault(pParse->db);


   yypParser->pParse=pParse;
}
# 180303 "c_tests/sqlite3.c"
static void yy_shift(
  yyParser *yypParser,
  unsigned short int yyNewState,
  unsigned short int yyMajor,
  Token yyMinor
){
  yyStackEntry *yytos;
  yypParser->yytos++;






  yytos = yypParser->yytos;
  if( yytos>yypParser->yystackEnd ){
    if( yyGrowStack(yypParser) ){
      yypParser->yytos--;
      yyStackOverflow(yypParser);
      return;
    }
    yytos = yypParser->yytos;
    ((void) (0));
  }
  if( yyNewState > 582 ){
    yyNewState += 1257 - 845;
  }
  yytos->stateno = yyNewState;
  yytos->major = yyMajor;
  yytos->minor.yy0 = yyMinor;
                                              ;
}



static const unsigned short int yyRuleInfoLhs[] = {
   191,
   191,
   190,
   192,
   193,
   193,
   193,
   193,
   192,
   192,
   192,
   192,
   192,
   197,
   199,
   201,
   201,
   200,
   200,
   198,
   198,
   205,
   205,
   207,
   207,
   208,
   210,
   210,
   210,
   211,
   215,
   216,
   217,
   217,
   217,
   217,
   217,
   217,
   217,
   217,
   217,
   217,
   217,
   217,
   217,
   226,
   226,
   222,
   222,
   224,
   224,
   227,
   227,
   227,
   227,
   228,
   228,
   228,
   228,
   228,
   225,
   225,
   229,
   229,
   229,
   204,
   231,
   232,
   232,
   232,
   232,
   232,
   235,
   220,
   220,
   236,
   236,
   237,
   237,
   192,
   239,
   239,
   192,
   192,
   192,
   206,
   206,
   206,
   241,
   244,
   244,
   244,
   242,
   242,
   254,
   242,
   256,
   256,
   245,
   245,
   245,
   257,
   246,
   246,
   246,
   258,
   258,
   247,
   247,
   260,
   260,
   259,
   259,
   259,
   259,
   259,
   202,
   202,
   240,
   240,
   265,
   265,
   265,
   265,
   261,
   261,
   261,
   261,
   262,
   262,
   262,
   267,
   263,
   263,
   251,
   251,
   233,
   233,
   221,
   221,
   221,
   268,
   268,
   268,
   249,
   249,
   250,
   250,
   252,
   252,
   252,
   252,
   192,
   248,
   248,
   270,
   270,
   270,
   270,
   192,
   271,
   271,
   271,
   271,
   192,
   192,
   274,
   274,
   274,
   274,
   274,
   274,
   275,
   272,
   272,
   273,
   273,
   266,
   266,
   219,
   219,
   219,
   219,
   218,
   218,
   218,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   218,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   277,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   219,
   278,
   278,
   219,
   279,
   279,
   219,
   219,
   219,
   219,
   219,
   219,
   282,
   282,
   283,
   283,
   281,
   264,
   255,
   255,
   280,
   280,
   192,
   284,
   284,
   223,
   223,
   234,
   234,
   285,
   285,
   192,
   192,
   192,
   286,
   286,
   192,
   192,
   192,
   192,
   192,
   213,
   214,
   192,
   288,
   290,
   290,
   290,
   291,
   291,
   291,
   293,
   293,
   289,
   289,
   295,
   296,
   296,
   294,
   294,
   294,
   294,
   219,
   219,
   238,
   238,
   238,
   192,
   192,
   192,
   298,
   298,
   192,
   192,
   192,
   192,
   192,
   192,
   192,
   299,
   192,
   192,
   192,
   301,
   303,
   304,
   304,
   305,
   269,
   269,
   308,
   308,
   308,
   307,
   309,
   243,
   243,
   310,
   311,
   312,
   312,
   312,
   312,
   312,
   313,
   313,
   313,
   317,
   319,
   319,
   320,
   320,
   318,
   318,
   321,
   321,
   322,
   322,
   322,
   253,
   276,
   276,
   276,
   316,
   316,
   315,
   218,
   187,
   188,
   188,
   189,
   189,
   189,
   194,
   194,
   194,
   196,
   196,
   192,
   205,
   203,
   203,
   195,
   195,
   210,
   211,
   212,
   212,
   209,
   209,
   217,
   217,
   217,
   204,
   230,
   230,
   231,
   235,
   237,
   241,
   242,
   257,
   258,
   267,
   275,
   219,
   277,
   281,
   264,
   287,
   287,
   287,
   287,
   287,
   213,
   292,
   292,
   295,
   296,
   297,
   297,
   300,
   300,
   302,
   302,
   303,
   306,
   306,
   306,
   269,
   310,
   312,
};



static const signed char yyRuleInfoNRhs[] = {
   -1,
   -3,
   -1,
   -3,
    0,
   -1,
   -1,
   -1,
   -2,
   -2,
   -2,
   -3,
   -5,
   -6,
   -1,
    0,
   -3,
   -1,
    0,
   -5,
   -2,
    0,
   -3,
   -2,
   -1,
   -2,
    0,
   -4,
   -6,
   -2,
    0,
    0,
   -2,
   -3,
   -4,
   -4,
   -4,
   -3,
   -3,
   -5,
   -2,
   -4,
   -4,
   -1,
   -2,
   -3,
   -4,
    0,
   -1,
    0,
   -2,
   -2,
   -3,
   -3,
   -3,
   -2,
   -2,
   -1,
   -1,
   -2,
   -3,
   -2,
    0,
   -2,
   -2,
    0,
   -1,
   -2,
   -7,
   -5,
   -5,
  -10,
    0,
    0,
   -3,
    0,
   -2,
   -1,
   -1,
   -4,
   -2,
    0,
   -9,
   -4,
   -1,
   -3,
   -4,
   -1,
   -3,
   -1,
   -2,
   -1,
   -9,
  -10,
   -4,
   -1,
   -5,
   -5,
   -1,
   -1,
    0,
    0,
   -5,
   -3,
   -5,
   -2,
    0,
    0,
   -2,
   -2,
    0,
   -5,
   -6,
   -8,
   -6,
   -6,
    0,
   -2,
   -1,
   -3,
   -1,
   -3,
   -5,
   -3,
   -1,
   -2,
   -3,
   -4,
   -2,
   -4,
    0,
    0,
   -3,
   -2,
    0,
   -3,
   -5,
   -3,
   -1,
   -1,
    0,
   -2,
   -2,
    0,
    0,
   -3,
    0,
   -2,
    0,
   -2,
   -4,
   -4,
   -6,
    0,
   -2,
    0,
   -2,
   -2,
   -4,
   -9,
   -5,
   -7,
   -3,
   -5,
   -7,
   -8,
    0,
   -2,
  -12,
   -9,
   -5,
   -8,
   -2,
   -2,
   -1,
    0,
   -3,
   -3,
   -1,
   -3,
   -1,
   -3,
   -5,
   -1,
   -1,
   -1,
   -1,
   -3,
   -6,
   -5,
   -8,
   -4,
   -6,
   -9,
   -5,
   -1,
   -5,
   -3,
   -3,
   -3,
   -3,
   -3,
   -3,
   -3,
   -3,
   -2,
   -3,
   -5,
   -2,
   -3,
   -3,
   -4,
   -6,
   -5,
   -2,
   -2,
   -2,
   -3,
   -1,
   -2,
   -5,
   -1,
   -2,
   -5,
   -3,
   -5,
   -5,
   -4,
   -5,
   -5,
   -4,
   -2,
    0,
    0,
    0,
   -3,
   -1,
    0,
   -3,
  -12,
   -1,
    0,
    0,
   -3,
   -5,
   -3,
    0,
   -2,
   -4,
   -2,
   -3,
   -2,
    0,
   -3,
   -5,
   -6,
   -5,
   -6,
   -2,
   -2,
   -5,
  -11,
   -1,
   -2,
    0,
   -1,
   -1,
   -3,
    0,
   -2,
   -3,
   -2,
   -3,
   -3,
   -2,
   -9,
   -8,
   -6,
   -3,
   -4,
   -6,
   -1,
   -1,
   -1,
   -4,
   -6,
   -3,
    0,
   -2,
   -1,
   -3,
   -1,
   -3,
   -6,
   -7,
   -6,
   -1,
   -8,
   -1,
   -4,
   -8,
    0,
   -1,
   -3,
   -1,
   -2,
   -3,
   -1,
   -2,
   -3,
   -6,
   -1,
   -1,
   -3,
   -3,
   -5,
   -5,
   -6,
   -4,
   -5,
   -2,
    0,
   -3,
   -6,
   -1,
   -1,
   -2,
   -1,
   -2,
   -2,
   -2,
    0,
   -2,
   -2,
   -2,
   -1,
   -2,
   -2,
   -1,
   -1,
   -4,
   -2,
   -5,
   -1,
   -1,
   -2,
   -1,
   -1,
   -2,
   -3,
    0,
   -1,
   -2,
   -1,
    0,
   -2,
   -1,
   -4,
   -2,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
   -2,
    0,
   -2,
   -4,
   -2,
   -2,
   -3,
   -1,
    0,
   -1,
   -1,
   -1,
   -1,
   -2,
   -1,
   -1,
    0,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
    0,
   -3,
   -1,
    0,
   -1,
    0,
    0,
   -1,
   -1,
   -3,
   -2,
    0,
   -4,
   -2,
    0,
   -1,
   -1,
};

static void yy_accept(yyParser*);
# 181176 "c_tests/sqlite3.c"
static unsigned short int yy_reduce(
  yyParser *yypParser,
  unsigned int yyruleno,
  int yyLookahead,
  Token yyLookaheadToken
  ,Parse *pParse
){
  int yygoto;
  unsigned short int yyact;
  yyStackEntry *yymsp;
  int yysize;

  (void)yyLookahead;
  (void)yyLookaheadToken;
  yymsp = yypParser->yytos;

  switch( yyruleno ){
# 181202 "c_tests/sqlite3.c"
        YYMINORTYPE yylhsminor;
      case 0:
{ if( pParse->pReprepare==0 ) pParse->explain = 1; }
        break;
      case 1:
{ if( pParse->pReprepare==0 ) pParse->explain = 2; }
        break;
      case 2:
{ sqlite3FinishCoding(pParse); }
        break;
      case 3:
{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy502);}
        break;
      case 4:
{yymsp[1].minor.yy502 = 7;}
        break;
      case 5:
      case 6: ;
      case 7: ;
      case 324: ;
{yymsp[0].minor.yy502 = yymsp[0].major; }
        break;
      case 8:
      case 9: ;
{sqlite3EndTransaction(pParse,yymsp[-1].major);}
        break;
      case 10:
{
  sqlite3Savepoint(pParse, 0, &yymsp[0].minor.yy0);
}
        break;
      case 11:
{
  sqlite3Savepoint(pParse, 1, &yymsp[0].minor.yy0);
}
        break;
      case 12:
{
  sqlite3Savepoint(pParse, 2, &yymsp[0].minor.yy0);
}
        break;
      case 13:
{
   sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy502,0,0,yymsp[-2].minor.yy502);
}
        break;
      case 14:
{
  disableLookaside(pParse);
}
        break;
      case 15:
      case 18: ;
      case 47: ;
      case 62: ;
      case 72: ;
      case 81: ;
      case 100: ;
      case 246: ;
{yymsp[1].minor.yy502 = 0;}
        break;
      case 16:
{yymsp[-2].minor.yy502 = 1;}
        break;
      case 17:
{yymsp[0].minor.yy502 = pParse->db->init.busy==0;}
        break;
      case 19:
{
  sqlite3EndTable(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,yymsp[0].minor.yy9,0);
}
        break;
      case 20:
{
  sqlite3EndTable(pParse,0,0,0,yymsp[0].minor.yy637);
  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy637);
}
        break;
      case 21:
{yymsp[1].minor.yy9 = 0;}
        break;
      case 22:
{yylhsminor.yy9 = yymsp[-2].minor.yy9|yymsp[0].minor.yy9;}
  yymsp[-2].minor.yy9 = yylhsminor.yy9;
        break;
      case 23:
{
  if( yymsp[0].minor.yy0.n==5 && sqlite3_strnicmp(yymsp[0].minor.yy0.z,"rowid",5)==0 ){
    yymsp[-1].minor.yy9 = 0x00000080 | 0x00000200;
  }else{
    yymsp[-1].minor.yy9 = 0;
    sqlite3ErrorMsg(pParse, "unknown table option: %.*s", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);
  }
}
        break;
      case 24:
{
  if( yymsp[0].minor.yy0.n==6 && sqlite3_strnicmp(yymsp[0].minor.yy0.z,"strict",6)==0 ){
    yylhsminor.yy9 = 0x00010000;
  }else{
    yylhsminor.yy9 = 0;
    sqlite3ErrorMsg(pParse, "unknown table option: %.*s", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);
  }
}
  yymsp[0].minor.yy9 = yylhsminor.yy9;
        break;
      case 25:
{sqlite3AddColumn(pParse,yymsp[-1].minor.yy0,yymsp[0].minor.yy0);}
        break;
      case 26:
      case 65: ;
      case 106: ;
{yymsp[1].minor.yy0.n = 0; yymsp[1].minor.yy0.z = 0;}
        break;
      case 27:
{
  yymsp[-3].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z);
}
        break;
      case 28:
{
  yymsp[-5].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z);
}
        break;
      case 29:
{yymsp[-1].minor.yy0.n=yymsp[0].minor.yy0.n+(int)(yymsp[0].minor.yy0.z-yymsp[-1].minor.yy0.z);}
        break;
      case 30:
{
  ((void) (0));
  yymsp[1].minor.yy342 = yyLookaheadToken.z;
}
        break;
      case 31:
{
  ((void) (0));
  yymsp[1].minor.yy0 = yyLookaheadToken;
}
        break;
      case 32:
      case 67: ;
{((void) (0)); pParse->u1.cr.constraintName = yymsp[0].minor.yy0;}
        break;
      case 33:
{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy590,yymsp[-1].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}
        break;
      case 34:
{sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy590,yymsp[-2].minor.yy0.z+1,yymsp[0].minor.yy0.z);}
        break;
      case 35:
{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy590,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}
        break;
      case 36:
{
  Expr *p = sqlite3PExpr(pParse, 174, yymsp[0].minor.yy590, 0);
  sqlite3AddDefaultValue(pParse,p,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);
}
        break;
      case 37:
{
  Expr *p = tokenExpr(pParse, 118, yymsp[0].minor.yy0);
  if( p ){
    sqlite3ExprIdToTrueFalse(p);
                                                               ;
  }
    sqlite3AddDefaultValue(pParse,p,yymsp[0].minor.yy0.z,yymsp[0].minor.yy0.z+yymsp[0].minor.yy0.n);
}
        break;
      case 38:
{sqlite3AddNotNull(pParse, yymsp[0].minor.yy502);}
        break;
      case 39:
{sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy502,yymsp[0].minor.yy502,yymsp[-2].minor.yy502);}
        break;
      case 40:
{sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy502,0,0,0,0,
                                   1);}
        break;
      case 41:
{sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy590,yymsp[-2].minor.yy0.z,yymsp[0].minor.yy0.z);}
        break;
      case 42:
{sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy402,yymsp[0].minor.yy502);}
        break;
      case 43:
{sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy502);}
        break;
      case 44:
{sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0);}
        break;
      case 45:
{sqlite3AddGenerated(pParse,yymsp[-1].minor.yy590,0);}
        break;
      case 46:
{sqlite3AddGenerated(pParse,yymsp[-2].minor.yy590,&yymsp[0].minor.yy0);}
        break;
      case 48:
{yymsp[0].minor.yy502 = 1;}
        break;
      case 49:
{ yymsp[1].minor.yy502 = 0*0x0101; }
        break;
      case 50:
{ yymsp[-1].minor.yy502 = (yymsp[-1].minor.yy502 & ~yymsp[0].minor.yy481.mask) | yymsp[0].minor.yy481.value; }
        break;
      case 51:
{ yymsp[-1].minor.yy481.value = 0; yymsp[-1].minor.yy481.mask = 0x000000; }
        break;
      case 52:
{ yymsp[-2].minor.yy481.value = 0; yymsp[-2].minor.yy481.mask = 0x000000; }
        break;
      case 53:
{ yymsp[-2].minor.yy481.value = yymsp[0].minor.yy502; yymsp[-2].minor.yy481.mask = 0x0000ff; }
        break;
      case 54:
{ yymsp[-2].minor.yy481.value = yymsp[0].minor.yy502<<8; yymsp[-2].minor.yy481.mask = 0x00ff00; }
        break;
      case 55:
{ yymsp[-1].minor.yy502 = 8; }
        break;
      case 56:
{ yymsp[-1].minor.yy502 = 9; }
        break;
      case 57:
{ yymsp[0].minor.yy502 = 10; }
        break;
      case 58:
{ yymsp[0].minor.yy502 = 7; }
        break;
      case 59:
{ yymsp[-1].minor.yy502 = 0; }
        break;
      case 60:
{yymsp[-2].minor.yy502 = 0;}
        break;
      case 61:
      case 76: ;
      case 173: ;
{yymsp[-1].minor.yy502 = yymsp[0].minor.yy502;}
        break;
      case 63:
      case 80: ;
      case 219: ;
      case 222: ;
      case 247: ;
{yymsp[-1].minor.yy502 = 1;}
        break;
      case 64:
{yymsp[-1].minor.yy502 = 0;}
        break;
      case 66:
{((void) (0)); pParse->u1.cr.constraintName.n = 0;}
        break;
      case 68:
{sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy402,yymsp[0].minor.yy502,yymsp[-2].minor.yy502,0);}
        break;
      case 69:
{sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy402,yymsp[0].minor.yy502,0,0,0,0,
                                       1);}
        break;
      case 70:
{sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy590,yymsp[-3].minor.yy0.z,yymsp[-1].minor.yy0.z);}
        break;
      case 71:
{
    sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy402, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy402, yymsp[-1].minor.yy502);
    sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy502);
}
        break;
      case 73:
      case 75: ;
{yymsp[1].minor.yy502 = 11;}
        break;
      case 74:
{yymsp[-2].minor.yy502 = yymsp[0].minor.yy502;}
        break;
      case 77:
{yymsp[0].minor.yy502 = 4;}
        break;
      case 78:
      case 174: ;
{yymsp[0].minor.yy502 = 5;}
        break;
      case 79:
{
  sqlite3DropTable(pParse, yymsp[0].minor.yy563, 0, yymsp[-1].minor.yy502);
}
        break;
      case 82:
{
  sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy402, yymsp[0].minor.yy637, yymsp[-7].minor.yy502, yymsp[-5].minor.yy502);
}
        break;
      case 83:
{
  sqlite3DropTable(pParse, yymsp[0].minor.yy563, 1, yymsp[-1].minor.yy502);
}
        break;
      case 84:
{
  SelectDest dest = {9, 0, 0, 0, 0, 0, 0};
  if( (pParse->db->mDbFlags & 0x0040)!=0
   || sqlite3ReadSchema(pParse)==0
  ){
    sqlite3Select(pParse, yymsp[0].minor.yy637, &dest);
  }
  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy637);
}
        break;
      case 85:
{yymsp[-2].minor.yy637 = attachWithToSelect(pParse,yymsp[0].minor.yy637,yymsp[-1].minor.yy125);}
        break;
      case 86:
{yymsp[-3].minor.yy637 = attachWithToSelect(pParse,yymsp[0].minor.yy637,yymsp[-1].minor.yy125);}
        break;
      case 87:
{
  Select *p = yymsp[0].minor.yy637;
  if( p ){
    parserDoubleLinkSelect(pParse, p);
  }
}
        break;
      case 88:
{
  Select *pRhs = yymsp[0].minor.yy637;
  Select *pLhs = yymsp[-2].minor.yy637;
  if( pRhs && pRhs->pPrior ){
    SrcList *pFrom;
    Token x;
    x.n = 0;
    parserDoubleLinkSelect(pParse, pRhs);
    pFrom = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&x,pRhs,0);
    pRhs = sqlite3SelectNew(pParse,0,pFrom,0,0,0,0,0,0);
  }
  if( pRhs ){
    pRhs->op = (u8)yymsp[-1].minor.yy502;
    pRhs->pPrior = pLhs;
    if( (pLhs) ) pLhs->selFlags &= ~(u32)0x0000400;
    pRhs->selFlags &= ~(u32)0x0000400;
    if( yymsp[-1].minor.yy502!=136 ) pParse->hasCompound = 1;
  }else{
    sqlite3SelectDelete(pParse->db, pLhs);
  }
  yymsp[-2].minor.yy637 = pRhs;
}
        break;
      case 89:
      case 91: ;
{yymsp[0].minor.yy502 = yymsp[0].major; }
        break;
      case 90:
{yymsp[-1].minor.yy502 = 136;}
        break;
      case 92:
{
  yymsp[-8].minor.yy637 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy402,yymsp[-5].minor.yy563,yymsp[-4].minor.yy590,yymsp[-3].minor.yy402,yymsp[-2].minor.yy590,yymsp[-1].minor.yy402,yymsp[-7].minor.yy502,yymsp[0].minor.yy590);
}
        break;
      case 93:
{
  yymsp[-9].minor.yy637 = sqlite3SelectNew(pParse,yymsp[-7].minor.yy402,yymsp[-6].minor.yy563,yymsp[-5].minor.yy590,yymsp[-4].minor.yy402,yymsp[-3].minor.yy590,yymsp[-1].minor.yy402,yymsp[-8].minor.yy502,yymsp[0].minor.yy590);
  if( yymsp[-9].minor.yy637 ){
    yymsp[-9].minor.yy637->pWinDefn = yymsp[-2].minor.yy483;
  }else{
    sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy483);
  }
}
        break;
      case 94:
{
  yymsp[-3].minor.yy637 = sqlite3SelectNew(pParse,yymsp[-1].minor.yy402,0,0,0,0,0,0x0000200,0);
}
        break;
      case 95:
{
  sqlite3MultiValuesEnd(pParse, yymsp[0].minor.yy637);
}
        break;
      case 96:
      case 97: ;
{
  yymsp[-4].minor.yy637 = sqlite3MultiValues(pParse, yymsp[-4].minor.yy637, yymsp[-1].minor.yy402);
}
        break;
      case 98:
{yymsp[0].minor.yy502 = 0x0000001;}
        break;
      case 99:
{yymsp[0].minor.yy502 = 0x0000002;}
        break;
      case 101:
      case 134: ;
      case 144: ;
      case 234: ;
      case 237: ;
      case 242: ;
{yymsp[1].minor.yy402 = 0;}
        break;
      case 102:
{
   yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy402, yymsp[-2].minor.yy590);
   if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy402, &yymsp[0].minor.yy0, 1);
   sqlite3ExprListSetSpan(pParse,yymsp[-4].minor.yy402,yymsp[-3].minor.yy342,yymsp[-1].minor.yy342);
}
        break;
      case 103:
{
  Expr *p = sqlite3Expr(pParse->db, 180, 0);
  sqlite3ExprSetErrorOffset(p, (int)(yymsp[0].minor.yy0.z - pParse->zTail));
  yymsp[-2].minor.yy402 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy402, p);
}
        break;
      case 104:
{
  Expr *pRight, *pLeft, *pDot;
  pRight = sqlite3PExpr(pParse, 180, 0, 0);
  sqlite3ExprSetErrorOffset(pRight, (int)(yymsp[0].minor.yy0.z - pParse->zTail));
  pLeft = tokenExpr(pParse, 60, yymsp[-2].minor.yy0);
  pDot = sqlite3PExpr(pParse, 142, pLeft, pRight);
  yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402, pDot);
}
        break;
      case 105:
      case 117: ;
      case 258: ;
      case 259: ;
{yymsp[-1].minor.yy0 = yymsp[0].minor.yy0;}
        break;
      case 107:
      case 110: ;
{yymsp[1].minor.yy563 = 0;}
        break;
      case 108:
{
  yymsp[-1].minor.yy563 = yymsp[0].minor.yy563;
  sqlite3SrcListShiftJoinType(pParse,yymsp[-1].minor.yy563);
}
        break;
      case 109:
{
   if( (yymsp[-1].minor.yy563 && yymsp[-1].minor.yy563->nSrc>0) ) yymsp[-1].minor.yy563->a[yymsp[-1].minor.yy563->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy502;
}
        break;
      case 111:
{
  yymsp[-4].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-4].minor.yy563,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy421);
}
        break;
      case 112:
{
  yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,0,&yymsp[0].minor.yy421);
  sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy563, &yymsp[-1].minor.yy0);
}
        break;
      case 113:
{
  yymsp[-7].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-7].minor.yy563,&yymsp[-6].minor.yy0,&yymsp[-5].minor.yy0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy421);
  sqlite3SrcListFuncArgs(pParse, yymsp[-7].minor.yy563, yymsp[-3].minor.yy402);
}
        break;
      case 114:
{
    yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,0,0,&yymsp[-1].minor.yy0,yymsp[-3].minor.yy637,&yymsp[0].minor.yy421);
  }
        break;
      case 115:
{
    if( yymsp[-5].minor.yy563==0 && yymsp[-1].minor.yy0.n==0 && yymsp[0].minor.yy421.pOn==0 && yymsp[0].minor.yy421.pUsing==0 ){
      yymsp[-5].minor.yy563 = yymsp[-3].minor.yy563;
    }else if( (yymsp[-3].minor.yy563!=0) && yymsp[-3].minor.yy563->nSrc==1 ){
      yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,0,0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy421);
      if( yymsp[-5].minor.yy563 ){
        SrcItem *pNew = &yymsp[-5].minor.yy563->a[yymsp[-5].minor.yy563->nSrc-1];
        SrcItem *pOld = yymsp[-3].minor.yy563->a;
        ((void) (0));
        pNew->zName = pOld->zName;
        ((void) (0));
        if( pOld->fg.isSubquery ){
          pNew->fg.isSubquery = 1;
          pNew->u4.pSubq = pOld->u4.pSubq;
          pOld->u4.pSubq = 0;
          pOld->fg.isSubquery = 0;
          ((void) (0));
          if( (pNew->u4.pSubq->pSelect->selFlags & 0x0000800)!=0 ){
            pNew->fg.isNestedFrom = 1;
          }
        }else{
          pNew->u4.zDatabase = pOld->u4.zDatabase;
          pOld->u4.zDatabase = 0;
        }
        if( pOld->fg.isTabFunc ){
          pNew->u1.pFuncArg = pOld->u1.pFuncArg;
          pOld->u1.pFuncArg = 0;
          pOld->fg.isTabFunc = 0;
          pNew->fg.isTabFunc = 1;
        }
        pOld->zName = 0;
      }
      sqlite3SrcListDelete(pParse->db, yymsp[-3].minor.yy563);
    }else{
      Select *pSubquery;
      sqlite3SrcListShiftJoinType(pParse,yymsp[-3].minor.yy563);
      pSubquery = sqlite3SelectNew(pParse,0,yymsp[-3].minor.yy563,0,0,0,0,0x0000800,0);
      yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,0,0,&yymsp[-1].minor.yy0,pSubquery,&yymsp[0].minor.yy421);
    }
  }
        break;
      case 116:
      case 131: ;
{yymsp[1].minor.yy0.z=0; yymsp[1].minor.yy0.n=0;}
        break;
      case 118:
{
  yylhsminor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0);
  if( (pParse->eParseMode>=2) && yylhsminor.yy563 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy563->a[0].zName, &yymsp[0].minor.yy0);
}
  yymsp[0].minor.yy563 = yylhsminor.yy563;
        break;
      case 119:
{
  yylhsminor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);
  if( (pParse->eParseMode>=2) && yylhsminor.yy563 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy563->a[0].zName, &yymsp[0].minor.yy0);
}
  yymsp[-2].minor.yy563 = yylhsminor.yy563;
        break;
      case 120:
{yymsp[0].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0); }
        break;
      case 121:
{yymsp[-2].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); }
        break;
      case 122:
{
   yymsp[-4].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,&yymsp[-2].minor.yy0);
   if( yymsp[-4].minor.yy563 ) yymsp[-4].minor.yy563->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);
}
        break;
      case 123:
{
   yymsp[-2].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,0);
   if( yymsp[-2].minor.yy563 ) yymsp[-2].minor.yy563->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);
}
        break;
      case 124:
{ yymsp[0].minor.yy502 = 0x01; }
        break;
      case 125:
{yymsp[-1].minor.yy502 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0); }
        break;
      case 126:
{yymsp[-2].minor.yy502 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); }
        break;
      case 127:
{yymsp[-3].minor.yy502 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0); }
        break;
      case 128:
{yymsp[-1].minor.yy421.pOn = yymsp[0].minor.yy590; yymsp[-1].minor.yy421.pUsing = 0;}
        break;
      case 129:
{yymsp[-3].minor.yy421.pOn = 0; yymsp[-3].minor.yy421.pUsing = yymsp[-1].minor.yy204;}
        break;
      case 130:
{yymsp[1].minor.yy421.pOn = 0; yymsp[1].minor.yy421.pUsing = 0;}
        break;
      case 132:
{yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;}
        break;
      case 133:
{yymsp[-1].minor.yy0.z=0; yymsp[-1].minor.yy0.n=1;}
        break;
      case 135:
      case 145: ;
{yymsp[-2].minor.yy402 = yymsp[0].minor.yy402;}
        break;
      case 136:
{
  yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402,yymsp[-2].minor.yy590);
  sqlite3ExprListSetSortOrder(yymsp[-4].minor.yy402,yymsp[-1].minor.yy502,yymsp[0].minor.yy502);
}
        break;
      case 137:
{
  yymsp[-2].minor.yy402 = sqlite3ExprListAppend(pParse,0,yymsp[-2].minor.yy590);
  sqlite3ExprListSetSortOrder(yymsp[-2].minor.yy402,yymsp[-1].minor.yy502,yymsp[0].minor.yy502);
}
        break;
      case 138:
{yymsp[0].minor.yy502 = 0;}
        break;
      case 139:
{yymsp[0].minor.yy502 = 1;}
        break;
      case 140:
      case 143: ;
{yymsp[1].minor.yy502 = -1;}
        break;
      case 141:
{yymsp[-1].minor.yy502 = 0;}
        break;
      case 142:
{yymsp[-1].minor.yy502 = 1;}
        break;
      case 146:
      case 148: ;
      case 153: ;
      case 155: ;
      case 232: ;
      case 233: ;
      case 252: ;
{yymsp[1].minor.yy590 = 0;}
        break;
      case 147:
      case 154: ;
      case 156: ;
      case 231: ;
      case 251: ;
{yymsp[-1].minor.yy590 = yymsp[0].minor.yy590;}
        break;
      case 149:
{yymsp[-1].minor.yy590 = sqlite3PExpr(pParse,149,yymsp[0].minor.yy590,0);}
        break;
      case 150:
{yymsp[-3].minor.yy590 = sqlite3PExpr(pParse,149,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);}
        break;
      case 151:
{yymsp[-3].minor.yy590 = sqlite3PExpr(pParse,149,yymsp[0].minor.yy590,yymsp[-2].minor.yy590);}
        break;
      case 152:
{
  sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy563, &yymsp[-1].minor.yy0);
  sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy563,yymsp[0].minor.yy590,0,0);
}
        break;
      case 157:
{sqlite3AddReturning(pParse,yymsp[0].minor.yy402); yymsp[-1].minor.yy590 = 0;}
        break;
      case 158:
{sqlite3AddReturning(pParse,yymsp[0].minor.yy402); yymsp[-3].minor.yy590 = yymsp[-2].minor.yy590;}
        break;
      case 159:
{
  sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy563, &yymsp[-4].minor.yy0);
  sqlite3ExprListCheckLength(pParse,yymsp[-2].minor.yy402,"set list");
  if( yymsp[-1].minor.yy563 ){
    SrcList *pFromClause = yymsp[-1].minor.yy563;
    if( pFromClause->nSrc>1 ){
      Select *pSubquery;
      Token as;
      pSubquery = sqlite3SelectNew(pParse,0,pFromClause,0,0,0,0,0x0000800,0);
      as.n = 0;
      as.z = 0;
      pFromClause = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&as,pSubquery,0);
    }
    yymsp[-5].minor.yy563 = sqlite3SrcListAppendList(pParse, yymsp[-5].minor.yy563, pFromClause);
  }
  sqlite3Update(pParse,yymsp[-5].minor.yy563,yymsp[-2].minor.yy402,yymsp[0].minor.yy590,yymsp[-6].minor.yy502,0,0,0);
}
        break;
      case 160:
{
  yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy402, yymsp[0].minor.yy590);
  sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy402, &yymsp[-2].minor.yy0, 1);
}
        break;
      case 161:
{
  yymsp[-6].minor.yy402 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy402, yymsp[-3].minor.yy204, yymsp[0].minor.yy590);
}
        break;
      case 162:
{
  yylhsminor.yy402 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy590);
  sqlite3ExprListSetName(pParse, yylhsminor.yy402, &yymsp[-2].minor.yy0, 1);
}
  yymsp[-2].minor.yy402 = yylhsminor.yy402;
        break;
      case 163:
{
  yymsp[-4].minor.yy402 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy204, yymsp[0].minor.yy590);
}
        break;
      case 164:
{
  sqlite3Insert(pParse, yymsp[-3].minor.yy563, yymsp[-1].minor.yy637, yymsp[-2].minor.yy204, yymsp[-5].minor.yy502, yymsp[0].minor.yy403);
}
        break;
      case 165:
{
  sqlite3Insert(pParse, yymsp[-4].minor.yy563, 0, yymsp[-3].minor.yy204, yymsp[-6].minor.yy502, 0);
}
        break;
      case 166:
{ yymsp[1].minor.yy403 = 0; }
        break;
      case 167:
{ yymsp[-1].minor.yy403 = 0; sqlite3AddReturning(pParse,yymsp[0].minor.yy402); }
        break;
      case 168:
{ yymsp[-11].minor.yy403 = sqlite3UpsertNew(pParse->db,yymsp[-8].minor.yy402,yymsp[-6].minor.yy590,yymsp[-2].minor.yy402,yymsp[-1].minor.yy590,yymsp[0].minor.yy403);}
        break;
      case 169:
{ yymsp[-8].minor.yy403 = sqlite3UpsertNew(pParse->db,yymsp[-5].minor.yy402,yymsp[-3].minor.yy590,0,0,yymsp[0].minor.yy403); }
        break;
      case 170:
{ yymsp[-4].minor.yy403 = sqlite3UpsertNew(pParse->db,0,0,0,0,0); }
        break;
      case 171:
{ yymsp[-7].minor.yy403 = sqlite3UpsertNew(pParse->db,0,0,yymsp[-2].minor.yy402,yymsp[-1].minor.yy590,0);}
        break;
      case 172:
{sqlite3AddReturning(pParse,yymsp[0].minor.yy402);}
        break;
      case 175:
{yymsp[1].minor.yy204 = 0;}
        break;
      case 176:
{yymsp[-2].minor.yy204 = yymsp[-1].minor.yy204;}
        break;
      case 177:
{yymsp[-2].minor.yy204 = sqlite3IdListAppend(pParse,yymsp[-2].minor.yy204,&yymsp[0].minor.yy0);}
        break;
      case 178:
{yymsp[0].minor.yy204 = sqlite3IdListAppend(pParse,0,&yymsp[0].minor.yy0); }
        break;
      case 179:
{yymsp[-2].minor.yy590 = yymsp[-1].minor.yy590;}
        break;
      case 180:
{yymsp[0].minor.yy590=tokenExpr(pParse,60,yymsp[0].minor.yy0); }
        break;
      case 181:
{
  Expr *temp1 = tokenExpr(pParse,60,yymsp[-2].minor.yy0);
  Expr *temp2 = tokenExpr(pParse,60,yymsp[0].minor.yy0);
  yylhsminor.yy590 = sqlite3PExpr(pParse, 142, temp1, temp2);
}
  yymsp[-2].minor.yy590 = yylhsminor.yy590;
        break;
      case 182:
{
  Expr *temp1 = tokenExpr(pParse,60,yymsp[-4].minor.yy0);
  Expr *temp2 = tokenExpr(pParse,60,yymsp[-2].minor.yy0);
  Expr *temp3 = tokenExpr(pParse,60,yymsp[0].minor.yy0);
  Expr *temp4 = sqlite3PExpr(pParse, 142, temp2, temp3);
  if( (pParse->eParseMode>=2) ){
    sqlite3RenameTokenRemap(pParse, 0, temp1);
  }
  yylhsminor.yy590 = sqlite3PExpr(pParse, 142, temp1, temp4);
}
  yymsp[-4].minor.yy590 = yylhsminor.yy590;
        break;
      case 183:
      case 184: ;
{yymsp[0].minor.yy590=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0); }
        break;
      case 185:
{
  yylhsminor.yy590 = sqlite3ExprAlloc(pParse->db, 156, &yymsp[0].minor.yy0, 1);
  if( yylhsminor.yy590 ) yylhsminor.yy590->w.iOfst = (int)(yymsp[0].minor.yy0.z - pParse->zTail);
}
  yymsp[0].minor.yy590 = yylhsminor.yy590;
        break;
      case 186:
{
  if( !(yymsp[0].minor.yy0.z[0]=='#' && (sqlite3CtypeMap[(unsigned char)(yymsp[0].minor.yy0.z[1])]&0x04)) ){
    u32 n = yymsp[0].minor.yy0.n;
    yymsp[0].minor.yy590 = tokenExpr(pParse, 157, yymsp[0].minor.yy0);
    sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy590, n);
  }else{



    Token t = yymsp[0].minor.yy0;
    ((void) (0));
    if( pParse->nested==0 ){
      parserSyntaxError(pParse, &t);
      yymsp[0].minor.yy590 = 0;
    }else{
      yymsp[0].minor.yy590 = sqlite3PExpr(pParse, 176, 0, 0);
      if( yymsp[0].minor.yy590 ) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy590->iTable);
    }
  }
}
        break;
      case 187:
{
  yymsp[-2].minor.yy590 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy590, &yymsp[0].minor.yy0, 1);
}
        break;
      case 188:
{
  yymsp[-5].minor.yy590 = sqlite3ExprAlloc(pParse->db, 36, &yymsp[-1].minor.yy0, 1);
  sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy590, yymsp[-3].minor.yy590, 0);
}
        break;
      case 189:
{
  yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy402, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy502);
}
  yymsp[-4].minor.yy590 = yylhsminor.yy590;
        break;
      case 190:
{
  yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-4].minor.yy402, &yymsp[-7].minor.yy0, yymsp[-5].minor.yy502);
  sqlite3ExprAddFunctionOrderBy(pParse, yylhsminor.yy590, yymsp[-1].minor.yy402);
}
  yymsp[-7].minor.yy590 = yylhsminor.yy590;
        break;
      case 191:
{
  yylhsminor.yy590 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0);
}
  yymsp[-3].minor.yy590 = yylhsminor.yy590;
        break;
      case 192:
{
  yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy402, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy502);
  sqlite3WindowAttach(pParse, yylhsminor.yy590, yymsp[0].minor.yy483);
}
  yymsp[-5].minor.yy590 = yylhsminor.yy590;
        break;
      case 193:
{
  yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-5].minor.yy402, &yymsp[-8].minor.yy0, yymsp[-6].minor.yy502);
  sqlite3WindowAttach(pParse, yylhsminor.yy590, yymsp[0].minor.yy483);
  sqlite3ExprAddFunctionOrderBy(pParse, yylhsminor.yy590, yymsp[-2].minor.yy402);
}
  yymsp[-8].minor.yy590 = yylhsminor.yy590;
        break;
      case 194:
{
  yylhsminor.yy590 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);
  sqlite3WindowAttach(pParse, yylhsminor.yy590, yymsp[0].minor.yy483);
}
  yymsp[-4].minor.yy590 = yylhsminor.yy590;
        break;
      case 195:
{
  yylhsminor.yy590 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0);
}
  yymsp[0].minor.yy590 = yylhsminor.yy590;
        break;
      case 196:
{
  ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy402, yymsp[-1].minor.yy590);
  yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 177, 0, 0);
  if( yymsp[-4].minor.yy590 ){
    yymsp[-4].minor.yy590->x.pList = pList;
    if( (pList->nExpr) ){
      yymsp[-4].minor.yy590->flags |= pList->a[0].pExpr->flags & (0x000200|0x400000|0x000008);
    }
  }else{
    sqlite3ExprListDelete(pParse->db, pList);
  }
}
        break;
      case 197:
{yymsp[-2].minor.yy590=sqlite3ExprAnd(pParse,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);}
        break;
      case 198:
      case 199: ;
      case 200: ;
      case 201: ;
      case 202: ;
      case 203: ;
      case 204: ;
{yymsp[-2].minor.yy590=sqlite3PExpr(pParse,yymsp[-1].major,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);}
        break;
      case 205:
{yymsp[-1].minor.yy0=yymsp[0].minor.yy0; yymsp[-1].minor.yy0.n|=0x80000000; }
        break;
      case 206:
{
  ExprList *pList;
  int bNot = yymsp[-1].minor.yy0.n & 0x80000000;
  yymsp[-1].minor.yy0.n &= 0x7fffffff;
  pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy590);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy590);
  yymsp[-2].minor.yy590 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);
  if( bNot ) yymsp[-2].minor.yy590 = sqlite3PExpr(pParse, 19, yymsp[-2].minor.yy590, 0);
  if( yymsp[-2].minor.yy590 ) yymsp[-2].minor.yy590->flags |= 0x000100;
}
        break;
      case 207:
{
  ExprList *pList;
  int bNot = yymsp[-3].minor.yy0.n & 0x80000000;
  yymsp[-3].minor.yy0.n &= 0x7fffffff;
  pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy590);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy590);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy590);
  yymsp[-4].minor.yy590 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);
  if( bNot ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy590, 0);
  if( yymsp[-4].minor.yy590 ) yymsp[-4].minor.yy590->flags |= 0x000100;
}
        break;
      case 208:
{yymsp[-1].minor.yy590 = sqlite3PExpr(pParse,yymsp[0].major,yymsp[-1].minor.yy590,0);}
        break;
      case 209:
{yymsp[-2].minor.yy590 = sqlite3PExpr(pParse,52,yymsp[-2].minor.yy590,0);}
        break;
      case 210:
{
  yymsp[-2].minor.yy590 = sqlite3PExpr(pParse,45,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);
  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-2].minor.yy590, 51);
}
        break;
      case 211:
{
  yymsp[-3].minor.yy590 = sqlite3PExpr(pParse,46,yymsp[-3].minor.yy590,yymsp[0].minor.yy590);
  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-3].minor.yy590, 52);
}
        break;
      case 212:
{
  yymsp[-5].minor.yy590 = sqlite3PExpr(pParse,45,yymsp[-5].minor.yy590,yymsp[0].minor.yy590);
  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-5].minor.yy590, 51);
}
        break;
      case 213:
{
  yymsp[-4].minor.yy590 = sqlite3PExpr(pParse,46,yymsp[-4].minor.yy590,yymsp[0].minor.yy590);
  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-4].minor.yy590, 52);
}
        break;
      case 214:
      case 215: ;
{yymsp[-1].minor.yy590 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy590, 0); }
        break;
      case 216:
{
  Expr *p = yymsp[0].minor.yy590;
  u8 op = yymsp[-1].major + (173 -107);
  ((void) (0));
  ((void) (0));
  if( p && p->op==173 ){
    p->op = op;
    yymsp[-1].minor.yy590 = p;
  }else{
    yymsp[-1].minor.yy590 = sqlite3PExpr(pParse, op, p, 0);

  }
}
        break;
      case 217:
{
  ExprList *pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy590);
  pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy590);
  yylhsminor.yy590 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);
}
  yymsp[-2].minor.yy590 = yylhsminor.yy590;
        break;
      case 218:
      case 221: ;
{yymsp[0].minor.yy502 = 0;}
        break;
      case 220:
{
  ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy590);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy590);
  yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 49, yymsp[-4].minor.yy590, 0);
  if( yymsp[-4].minor.yy590 ){
    yymsp[-4].minor.yy590->x.pList = pList;
  }else{
    sqlite3ExprListDelete(pParse->db, pList);
  }
  if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy590, 0);
}
        break;
      case 223:
{
    if( yymsp[-1].minor.yy402==0 ){
# 182188 "c_tests/sqlite3.c"
      Expr *pB = sqlite3Expr(pParse->db, 118, yymsp[-3].minor.yy502 ? "true" : "false");
      if( pB ) sqlite3ExprIdToTrueFalse(pB);
      if( !(((yymsp[-4].minor.yy590)->flags&(u32)(0x000008))!=0) ){
        sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy590);
        yymsp[-4].minor.yy590 = pB;
      }else{
        yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, yymsp[-3].minor.yy502 ? 43 : 44, pB, yymsp[-4].minor.yy590);
      }
    }else{
      Expr *pRHS = yymsp[-1].minor.yy402->a[0].pExpr;
      if( yymsp[-1].minor.yy402->nExpr==1 && sqlite3ExprIsConstant(pParse,pRHS) && yymsp[-4].minor.yy590->op!=177 ){
        yymsp[-1].minor.yy402->a[0].pExpr = 0;
        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy402);
        pRHS = sqlite3PExpr(pParse, 173, pRHS, 0);
        yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 54, yymsp[-4].minor.yy590, pRHS);
      }else if( yymsp[-1].minor.yy402->nExpr==1 && pRHS->op==139 ){
        yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 50, yymsp[-4].minor.yy590, 0);
        sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, pRHS->x.pSelect);
        pRHS->x.pSelect = 0;
        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy402);
      }else{
        yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 50, yymsp[-4].minor.yy590, 0);
        if( yymsp[-4].minor.yy590==0 ){
          sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy402);
        }else if( yymsp[-4].minor.yy590->pLeft->op==177 ){
          int nExpr = yymsp[-4].minor.yy590->pLeft->x.pList->nExpr;
          Select *pSelectRHS = sqlite3ExprListToValues(pParse, nExpr, yymsp[-1].minor.yy402);
          if( pSelectRHS ){
            parserDoubleLinkSelect(pParse, pSelectRHS);
            sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, pSelectRHS);
          }
        }else{
          yymsp[-4].minor.yy590->x.pList = yymsp[-1].minor.yy402;
          sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy590);
        }
      }
      if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy590, 0);
    }
  }
        break;
      case 224:
{
    yymsp[-2].minor.yy590 = sqlite3PExpr(pParse, 139, 0, 0);
    sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy590, yymsp[-1].minor.yy637);
  }
        break;
      case 225:
{
    yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 50, yymsp[-4].minor.yy590, 0);
    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, yymsp[-1].minor.yy637);
    if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy590, 0);
  }
        break;
      case 226:
{
    SrcList *pSrc = sqlite3SrcListAppend(pParse, 0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);
    Select *pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0);
    if( yymsp[0].minor.yy402 ) sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy402);
    yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 50, yymsp[-4].minor.yy590, 0);
    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, pSelect);
    if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy590, 0);
  }
        break;
      case 227:
{
    Expr *p;
    p = yymsp[-3].minor.yy590 = sqlite3PExpr(pParse, 20, 0, 0);
    sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy637);
  }
        break;
      case 228:
{
  yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, 158, yymsp[-3].minor.yy590, 0);
  if( yymsp[-4].minor.yy590 ){
    yymsp[-4].minor.yy590->x.pList = yymsp[-1].minor.yy590 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy402,yymsp[-1].minor.yy590) : yymsp[-2].minor.yy402;
    sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy590);
  }else{
    sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy402);
    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy590);
  }
}
        break;
      case 229:
{
  yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402, yymsp[-2].minor.yy590);
  yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402, yymsp[0].minor.yy590);
}
        break;
      case 230:
{
  yymsp[-3].minor.yy402 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy590);
  yymsp[-3].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy402, yymsp[0].minor.yy590);
}
        break;
      case 235:
{yymsp[-2].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy402,yymsp[0].minor.yy590);}
        break;
      case 236:
{yymsp[0].minor.yy402 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy590); }
        break;
      case 238:
      case 243: ;
{yymsp[-2].minor.yy402 = yymsp[-1].minor.yy402;}
        break;
      case 239:
{
  sqlite3CreateIndex(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0,
                     sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy402, yymsp[-10].minor.yy502,
                      &yymsp[-11].minor.yy0, yymsp[0].minor.yy590, 0, yymsp[-8].minor.yy502, 0);
  if( (pParse->eParseMode>=2) && pParse->pNewIndex ){
    sqlite3RenameTokenMap(pParse, pParse->pNewIndex->zName, &yymsp[-4].minor.yy0);
  }
}
        break;
      case 240:
      case 282: ;
{yymsp[0].minor.yy502 = 2;}
        break;
      case 241:
{yymsp[1].minor.yy502 = 0;}
        break;
      case 244:
{
  yymsp[-4].minor.yy402 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy402, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy502, yymsp[0].minor.yy502);
}
        break;
      case 245:
{
  yymsp[-2].minor.yy402 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy502, yymsp[0].minor.yy502);
}
        break;
      case 248:
{sqlite3DropIndex(pParse, yymsp[0].minor.yy563, yymsp[-1].minor.yy502);}
        break;
      case 249:
{sqlite3Vacuum(pParse,0,yymsp[0].minor.yy590);}
        break;
      case 250:
{sqlite3Vacuum(pParse,&yymsp[-1].minor.yy0,yymsp[0].minor.yy590);}
        break;
      case 253:
{sqlite3Pragma(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0,0);}
        break;
      case 254:
{sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,0);}
        break;
      case 255:
{sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,0);}
        break;
      case 256:
{sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,1);}
        break;
      case 257:
{sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,1);}
        break;
      case 260:
{
  Token all;
  all.z = yymsp[-3].minor.yy0.z;
  all.n = (int)(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n;
  sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy319, &all);
}
        break;
      case 261:
{
  sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy502, yymsp[-4].minor.yy28.a, yymsp[-4].minor.yy28.b, yymsp[-2].minor.yy563, yymsp[0].minor.yy590, yymsp[-10].minor.yy502, yymsp[-8].minor.yy502);
  yymsp[-10].minor.yy0 = (yymsp[-6].minor.yy0.n==0?yymsp[-7].minor.yy0:yymsp[-6].minor.yy0);




}
        break;
      case 262:
{ yymsp[0].minor.yy502 = yymsp[0].major; }
        break;
      case 263:
{ yymsp[-1].minor.yy502 = 66;}
        break;
      case 264:
{ yymsp[1].minor.yy502 = 33; }
        break;
      case 265:
      case 266: ;
{yymsp[0].minor.yy28.a = yymsp[0].major; yymsp[0].minor.yy28.b = 0;}
        break;
      case 267:
{yymsp[-2].minor.yy28.a = 130; yymsp[-2].minor.yy28.b = yymsp[0].minor.yy204;}
        break;
      case 268:
      case 287: ;
{ yymsp[1].minor.yy590 = 0; }
        break;
      case 269:
      case 288: ;
{ yymsp[-1].minor.yy590 = yymsp[0].minor.yy590; }
        break;
      case 270:
{
  ((void) (0));
  yymsp[-2].minor.yy319->pLast->pNext = yymsp[-1].minor.yy319;
  yymsp[-2].minor.yy319->pLast = yymsp[-1].minor.yy319;
}
        break;
      case 271:
{
  ((void) (0));
  yymsp[-1].minor.yy319->pLast = yymsp[-1].minor.yy319;
}
        break;
      case 272:
{
  yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;
  sqlite3ErrorMsg(pParse,
        "qualified table names are not allowed on INSERT, UPDATE, and DELETE "
        "statements within triggers");
}
        break;
      case 273:
{
  sqlite3ErrorMsg(pParse,
        "the INDEXED BY clause is not allowed on UPDATE or DELETE statements "
        "within triggers");
}
        break;
      case 274:
{
  sqlite3ErrorMsg(pParse,
        "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements "
        "within triggers");
}
        break;
      case 275:
{yylhsminor.yy319 = sqlite3TriggerUpdateStep(pParse, &yymsp[-6].minor.yy0, yymsp[-2].minor.yy563, yymsp[-3].minor.yy402, yymsp[-1].minor.yy590, yymsp[-7].minor.yy502, yymsp[-8].minor.yy0.z, yymsp[0].minor.yy342);}
  yymsp[-8].minor.yy319 = yylhsminor.yy319;
        break;
      case 276:
{
   yylhsminor.yy319 = sqlite3TriggerInsertStep(pParse,&yymsp[-4].minor.yy0,yymsp[-3].minor.yy204,yymsp[-2].minor.yy637,yymsp[-6].minor.yy502,yymsp[-1].minor.yy403,yymsp[-7].minor.yy342,yymsp[0].minor.yy342);
}
  yymsp[-7].minor.yy319 = yylhsminor.yy319;
        break;
      case 277:
{yylhsminor.yy319 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy590, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy342);}
  yymsp[-5].minor.yy319 = yylhsminor.yy319;
        break;
      case 278:
{yylhsminor.yy319 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy637, yymsp[-2].minor.yy342, yymsp[0].minor.yy342); }
  yymsp[-2].minor.yy319 = yylhsminor.yy319;
        break;
      case 279:
{
  yymsp[-3].minor.yy590 = sqlite3PExpr(pParse, 72, 0, 0);
  if( yymsp[-3].minor.yy590 ){
    yymsp[-3].minor.yy590->affExpr = 4;
  }
}
        break;
      case 280:
{
  yymsp[-5].minor.yy590 = sqlite3PExpr(pParse, 72, yymsp[-1].minor.yy590, 0);
  if( yymsp[-5].minor.yy590 ) {
    yymsp[-5].minor.yy590->affExpr = (char)yymsp[-3].minor.yy502;
  }
}
        break;
      case 281:
{yymsp[0].minor.yy502 = 1;}
        break;
      case 283:
{yymsp[0].minor.yy502 = 3;}
        break;
      case 284:
{
  sqlite3DropTrigger(pParse,yymsp[0].minor.yy563,yymsp[-1].minor.yy502);
}
        break;
      case 285:
{
  sqlite3Attach(pParse, yymsp[-3].minor.yy590, yymsp[-1].minor.yy590, yymsp[0].minor.yy590);
}
        break;
      case 286:
{
  sqlite3Detach(pParse, yymsp[0].minor.yy590);
}
        break;
      case 289:
{sqlite3Reindex(pParse, 0, 0);}
        break;
      case 290:
{sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
        break;
      case 291:
{sqlite3Analyze(pParse, 0, 0);}
        break;
      case 292:
{sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
        break;
      case 293:
{
  sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy563,&yymsp[0].minor.yy0);
}
        break;
      case 294:
{
  yymsp[-1].minor.yy0.n = (int)(pParse->sLastToken.z-yymsp[-1].minor.yy0.z) + pParse->sLastToken.n;
  sqlite3AlterFinishAddColumn(pParse, &yymsp[-1].minor.yy0);
}
        break;
      case 295:
{
  sqlite3AlterDropColumn(pParse, yymsp[-3].minor.yy563, &yymsp[0].minor.yy0);
}
        break;
      case 296:
{
  disableLookaside(pParse);
  sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy563);
}
        break;
      case 297:
{
  sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy563, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);
}
        break;
      case 298:
{sqlite3VtabFinishParse(pParse,0);}
        break;
      case 299:
{sqlite3VtabFinishParse(pParse,&yymsp[0].minor.yy0);}
        break;
      case 300:
{
    sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy502);
}
        break;
      case 301:
{sqlite3VtabArgInit(pParse);}
        break;
      case 302:
      case 303: ;
      case 304: ;
{sqlite3VtabArgExtend(pParse,&yymsp[0].minor.yy0);}
        break;
      case 305:
      case 306: ;
{ sqlite3WithPush(pParse, yymsp[0].minor.yy125, 1); }
        break;
      case 307:
{yymsp[0].minor.yy444 = 1;}
        break;
      case 308:
{yymsp[-1].minor.yy444 = 0;}
        break;
      case 309:
{yymsp[-2].minor.yy444 = 2;}
        break;
      case 310:
{
  yymsp[-5].minor.yy361 = sqlite3CteNew(pParse, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy402, yymsp[-1].minor.yy637, yymsp[-3].minor.yy444);
}
        break;
      case 311:
{pParse->bHasWith = 1;}
        break;
      case 312:
{
  yymsp[0].minor.yy125 = sqlite3WithAdd(pParse, 0, yymsp[0].minor.yy361);
}
        break;
      case 313:
{
  yymsp[-2].minor.yy125 = sqlite3WithAdd(pParse, yymsp[-2].minor.yy125, yymsp[0].minor.yy361);
}
        break;
      case 314:
{
  ((void) (0));
  sqlite3WindowChain(pParse, yymsp[0].minor.yy483, yymsp[-2].minor.yy483);
  yymsp[0].minor.yy483->pNextWin = yymsp[-2].minor.yy483;
  yylhsminor.yy483 = yymsp[0].minor.yy483;
}
  yymsp[-2].minor.yy483 = yylhsminor.yy483;
        break;
      case 315:
{
  if( (yymsp[-1].minor.yy483) ){
    yymsp[-1].minor.yy483->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);
  }
  yylhsminor.yy483 = yymsp[-1].minor.yy483;
}
  yymsp[-4].minor.yy483 = yylhsminor.yy483;
        break;
      case 316:
{
  yymsp[-4].minor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, yymsp[-2].minor.yy402, yymsp[-1].minor.yy402, 0);
}
        break;
      case 317:
{
  yylhsminor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, yymsp[-2].minor.yy402, yymsp[-1].minor.yy402, &yymsp[-5].minor.yy0);
}
  yymsp[-5].minor.yy483 = yylhsminor.yy483;
        break;
      case 318:
{
  yymsp[-3].minor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, 0, yymsp[-1].minor.yy402, 0);
}
        break;
      case 319:
{
  yylhsminor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, 0, yymsp[-1].minor.yy402, &yymsp[-4].minor.yy0);
}
  yymsp[-4].minor.yy483 = yylhsminor.yy483;
        break;
      case 320:
{
  yylhsminor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, 0, 0, &yymsp[-1].minor.yy0);
}
  yymsp[-1].minor.yy483 = yylhsminor.yy483;
        break;
      case 321:
{
  yymsp[1].minor.yy483 = sqlite3WindowAlloc(pParse, 0, 91, 0, 86, 0, 0);
}
        break;
      case 322:
{
  yylhsminor.yy483 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy502, yymsp[-1].minor.yy205.eType, yymsp[-1].minor.yy205.pExpr, 86, 0, yymsp[0].minor.yy444);
}
  yymsp[-2].minor.yy483 = yylhsminor.yy483;
        break;
      case 323:
{
  yylhsminor.yy483 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy502, yymsp[-3].minor.yy205.eType, yymsp[-3].minor.yy205.pExpr, yymsp[-1].minor.yy205.eType, yymsp[-1].minor.yy205.pExpr, yymsp[0].minor.yy444);
}
  yymsp[-5].minor.yy483 = yylhsminor.yy483;
        break;
      case 325:
      case 327: ;
{yylhsminor.yy205 = yymsp[0].minor.yy205;}
  yymsp[0].minor.yy205 = yylhsminor.yy205;
        break;
      case 326:
      case 328: ;
      case 330: ;
{yylhsminor.yy205.eType = yymsp[-1].major; yylhsminor.yy205.pExpr = 0;}
  yymsp[-1].minor.yy205 = yylhsminor.yy205;
        break;
      case 329:
{yylhsminor.yy205.eType = yymsp[0].major; yylhsminor.yy205.pExpr = yymsp[-1].minor.yy590;}
  yymsp[-1].minor.yy205 = yylhsminor.yy205;
        break;
      case 331:
{yymsp[1].minor.yy444 = 0;}
        break;
      case 332:
{yymsp[-1].minor.yy444 = yymsp[0].minor.yy444;}
        break;
      case 333:
      case 334: ;
{yymsp[-1].minor.yy444 = yymsp[-1].major; }
        break;
      case 335:
{yymsp[0].minor.yy444 = yymsp[0].major; }
        break;
      case 336:
{ yymsp[-1].minor.yy483 = yymsp[0].minor.yy483; }
        break;
      case 337:
{
  if( yymsp[0].minor.yy483 ){
    yymsp[0].minor.yy483->pFilter = yymsp[-1].minor.yy590;
  }else{
    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy590);
  }
  yylhsminor.yy483 = yymsp[0].minor.yy483;
}
  yymsp[-1].minor.yy483 = yylhsminor.yy483;
        break;
      case 338:
{
  yylhsminor.yy483 = yymsp[0].minor.yy483;
}
  yymsp[0].minor.yy483 = yylhsminor.yy483;
        break;
      case 339:
{
  yylhsminor.yy483 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));
  if( yylhsminor.yy483 ){
    yylhsminor.yy483->eFrmType = 167;
    yylhsminor.yy483->pFilter = yymsp[0].minor.yy590;
  }else{
    sqlite3ExprDelete(pParse->db, yymsp[0].minor.yy590);
  }
}
  yymsp[0].minor.yy483 = yylhsminor.yy483;
        break;
      case 340:
{
  yymsp[-3].minor.yy483 = yymsp[-1].minor.yy483;
  ((void) (0));
}
        break;
      case 341:
{
  yymsp[-1].minor.yy483 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));
  if( yymsp[-1].minor.yy483 ){
    yymsp[-1].minor.yy483->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);
  }
}
        break;
      case 342:
{ yymsp[-4].minor.yy590 = yymsp[-1].minor.yy590; }
        break;
      case 343:
{
  yylhsminor.yy590=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0);
  sqlite3DequoteNumber(pParse, yylhsminor.yy590);
}
  yymsp[0].minor.yy590 = yylhsminor.yy590;
        break;
      default:
                                                             ;
                                                                    ;
                                                   ((void) (0));
                                                         ;
                                                              ;
                                                             ((void) (0));
                                                         ;
                                                                     ;
                                                                        ;
                                                                       ;
                                                             ;
                                                                                  ;
                                                                    ((void) (0));
                                                                                               ;
                                                                              ;
                                                                     ;
                                                         ;
                                                                  ;
                                                                  ;
                                                      ((void) (0));
                                                       ((void) (0));
                                                                       ;
                                                        ;
                                                                 ;
                                                                                   ;
                                                                  ;
                                                                           ;
                                                                                  ;
                                                     ((void) (0));
                                                          ;
                                                                          ((void) (0));
                                                            ((void) (0));
                                                             ((void) (0));
                                                                ;
                                                                     ;
                                                            ;
                                                             ((void) (0));
                                                         ;
                                                ((void) (0));
                                                                    ;
                                                                 ;
                                                                  ;
                                                     ((void) (0));
                                               ((void) (0));
                                                        ;
                                                            ;
                                                             ;
                                                                      ;
                                                              ;
                                                                           ;
                                                       ;
                                                       ;
                                                                        ;
                                                               ;
                                                            ;
                                                                     ;
                                                                   ;
                                                                                     ;
                                                                            ;
                                                       ;
                                                                             ;
                                                                   ;
                                                    ;
                                                                 ((void) (0));
                                                       ((void) (0));
        break;

  };
  ((void) (0));
  yygoto = yyRuleInfoLhs[yyruleno];
  yysize = yyRuleInfoNRhs[yyruleno];
  yyact = yy_find_reduce_action(yymsp[yysize].stateno,(unsigned short int)yygoto);



  ((void) (0));


  ((void) (0));

  yymsp += yysize+1;
  yypParser->yytos = yymsp;
  yymsp->stateno = (unsigned short int)yyact;
  yymsp->major = (unsigned short int)yygoto;
                                                  ;
  return yyact;
}
# 182827 "c_tests/sqlite3.c"
static void yy_syntax_error(
  yyParser *yypParser,
  int yymajor,
  Token yyminor
){

  Parse *pParse=yypParser->pParse;



  (void)(yymajor);
  if( yyminor.z[0] ){
    parserSyntaxError(pParse, &yyminor);
  }else{
    sqlite3ErrorMsg(pParse, "incomplete input");
  }


  yypParser->pParse=pParse;
}




static void yy_accept(
  yyParser *yypParser
){

  Parse *pParse=yypParser->pParse;
# 182864 "c_tests/sqlite3.c"
  ((void) (0));





  yypParser->pParse=pParse;
}
# 182892 "c_tests/sqlite3.c"
static void sqlite3Parser(
  void *yyp,
  int yymajor,
  Token yyminor

){
  YYMINORTYPE yyminorunion;
  unsigned short int yyact;






  yyParser *yypParser = (yyParser*)yyp;
  Parse *pParse=yypParser->pParse;


  ((void) (0));




  yyact = yypParser->yytos->stateno;
# 182928 "c_tests/sqlite3.c"
  while(1){
    ((void) (0));
    ((void) (0));
    yyact = yy_find_shift_action((unsigned short int)yymajor,yyact);
    if( yyact >= 1257 ){
      unsigned int yyruleno = yyact - 1257;
# 182955 "c_tests/sqlite3.c"
      if( yyRuleInfoNRhs[yyruleno]==0 ){







        if( yypParser->yytos>=yypParser->yystackEnd ){
          if( yyGrowStack(yypParser) ){
            yyStackOverflow(yypParser);
            break;
          }
        }
      }
      yyact = yy_reduce(yypParser,yyruleno,yymajor,yyminor ,pParse);
    }else if( yyact <= 1253 ){
      yy_shift(yypParser,yyact,(unsigned short int)yymajor,yyminor);



      break;
    }else if( yyact==1255 ){
      yypParser->yytos--;
      yy_accept(yypParser);
      return;
    }else{
      ((void) (0));
      yyminorunion.yy0 = yyminor;
# 183055 "c_tests/sqlite3.c"
      yy_syntax_error(yypParser,yymajor, yyminor);
      yy_destructor(yypParser,(unsigned short int)yymajor,&yyminorunion);
      break;
# 183081 "c_tests/sqlite3.c"
    }
  }
# 183095 "c_tests/sqlite3.c"
  return;
}





static int sqlite3ParserFallback(int iToken){

  ((void) (0));
  return yyFallback[iToken];




}
# 183174 "c_tests/sqlite3.c"
static const unsigned char aiClass[] = {


           29, 28, 28, 28, 28, 28, 28, 28, 28, 7, 7, 28, 7, 7, 28, 28,
           28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
            7, 15, 8, 5, 4, 22, 24, 8, 17, 18, 21, 20, 23, 11, 26, 16,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 19, 12, 14, 13, 6,
            5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 9, 28, 28, 28, 2,
            8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 28, 10, 28, 25, 28,
           27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
           27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
           27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
           27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
           27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
           27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
           27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 30,
           27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27
# 183213 "c_tests/sqlite3.c"
};
# 183290 "c_tests/sqlite3.c"
static const char zKWText[666] = {
  'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',
  'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',
  'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',
  'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',
  'E','R','R','A','B','L','E','L','S','E','X','C','L','U','D','E','L','E',
  'T','E','M','P','O','R','A','R','Y','I','S','N','U','L','L','S','A','V',
  'E','P','O','I','N','T','E','R','S','E','C','T','I','E','S','N','O','T',
  'N','U','L','L','I','K','E','X','C','E','P','T','R','A','N','S','A','C',
  'T','I','O','N','A','T','U','R','A','L','T','E','R','A','I','S','E','X',
  'C','L','U','S','I','V','E','X','I','S','T','S','C','O','N','S','T','R',
  'A','I','N','T','O','F','F','S','E','T','R','I','G','G','E','R','A','N',
  'G','E','N','E','R','A','T','E','D','E','T','A','C','H','A','V','I','N',
  'G','L','O','B','E','G','I','N','N','E','R','E','F','E','R','E','N','C',
  'E','S','U','N','I','Q','U','E','R','Y','W','I','T','H','O','U','T','E',
  'R','E','L','E','A','S','E','A','T','T','A','C','H','B','E','T','W','E',
  'E','N','O','T','H','I','N','G','R','O','U','P','S','C','A','S','C','A',
  'D','E','F','A','U','L','T','C','A','S','E','C','O','L','L','A','T','E',
  'C','R','E','A','T','E','C','U','R','R','E','N','T','_','D','A','T','E',
  'I','M','M','E','D','I','A','T','E','J','O','I','N','S','E','R','T','M',
  'A','T','C','H','P','L','A','N','A','L','Y','Z','E','P','R','A','G','M',
  'A','T','E','R','I','A','L','I','Z','E','D','E','F','E','R','R','E','D',
  'I','S','T','I','N','C','T','U','P','D','A','T','E','V','A','L','U','E',
  'S','V','I','R','T','U','A','L','W','A','Y','S','W','H','E','N','W','H',
  'E','R','E','C','U','R','S','I','V','E','A','B','O','R','T','A','F','T',
  'E','R','E','N','A','M','E','A','N','D','R','O','P','A','R','T','I','T',
  'I','O','N','A','U','T','O','I','N','C','R','E','M','E','N','T','C','A',
  'S','T','C','O','L','U','M','N','C','O','M','M','I','T','C','O','N','F',
  'L','I','C','T','C','R','O','S','S','C','U','R','R','E','N','T','_','T',
  'I','M','E','S','T','A','M','P','R','E','C','E','D','I','N','G','F','A',
  'I','L','A','S','T','F','I','L','T','E','R','E','P','L','A','C','E','F',
  'I','R','S','T','F','O','L','L','O','W','I','N','G','F','R','O','M','F',
  'U','L','L','I','M','I','T','I','F','O','R','D','E','R','E','S','T','R',
  'I','C','T','O','T','H','E','R','S','O','V','E','R','E','T','U','R','N',
  'I','N','G','R','I','G','H','T','R','O','L','L','B','A','C','K','R','O',
  'W','S','U','N','B','O','U','N','D','E','D','U','N','I','O','N','U','S',
  'I','N','G','V','A','C','U','U','M','V','I','E','W','I','N','D','O','W',
  'B','Y','I','N','I','T','I','A','L','L','Y','P','R','I','M','A','R','Y',
};

static const unsigned char aKWHash[127] = {
    84, 92, 134, 82, 105, 29, 0, 0, 94, 0, 85, 72, 0,
    53, 35, 86, 15, 0, 42, 97, 54, 89, 135, 19, 0, 0,
   140, 0, 40, 129, 0, 22, 107, 0, 9, 0, 0, 123, 80,
     0, 78, 6, 0, 65, 103, 147, 0, 136, 115, 0, 0, 48,
     0, 90, 24, 0, 17, 0, 27, 70, 23, 26, 5, 60, 142,
   110, 122, 0, 73, 91, 71, 145, 61, 120, 74, 0, 49, 0,
    11, 41, 0, 113, 0, 0, 0, 109, 10, 111, 116, 125, 14,
    50, 124, 0, 100, 0, 18, 121, 144, 56, 130, 139, 88, 83,
    37, 30, 126, 0, 0, 108, 51, 131, 128, 0, 34, 0, 0,
   132, 0, 98, 38, 39, 0, 20, 45, 117, 93,
};



static const unsigned char aKWNext[148] = {0,
     0, 0, 0, 0, 4, 0, 43, 0, 0, 106, 114, 0, 0,
     0, 2, 0, 0, 143, 0, 0, 0, 13, 0, 0, 0, 0,
   141, 0, 0, 119, 52, 0, 0, 137, 12, 0, 0, 62, 0,
   138, 0, 133, 0, 0, 36, 0, 0, 28, 77, 0, 0, 0,
     0, 59, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 69, 0, 0, 0, 0, 0, 146, 3, 0, 58, 0, 1,
    75, 0, 0, 0, 31, 0, 0, 0, 0, 0, 127, 0, 104,
     0, 64, 66, 63, 0, 0, 0, 0, 0, 46, 0, 16, 8,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 101, 0,
   112, 21, 7, 67, 0, 79, 96, 118, 0, 0, 68, 0, 0,
    99, 44, 0, 55, 0, 76, 0, 95, 32, 33, 57, 25, 0,
   102, 0, 0, 87,
};

static const unsigned char aKWLen[148] = {0,
     7, 7, 5, 4, 6, 4, 5, 3, 6, 7, 3, 6, 6,
     7, 7, 3, 8, 2, 6, 5, 4, 4, 3, 10, 4, 7,
     6, 9, 4, 2, 6, 5, 9, 9, 4, 7, 3, 2, 4,
     4, 6, 11, 6, 2, 7, 5, 5, 9, 6, 10, 4, 6,
     2, 3, 7, 5, 9, 6, 6, 4, 5, 5, 10, 6, 5,
     7, 4, 5, 7, 6, 7, 7, 6, 5, 7, 3, 7, 4,
     7, 6, 12, 9, 4, 6, 5, 4, 7, 6, 12, 8, 8,
     2, 6, 6, 7, 6, 4, 5, 9, 5, 5, 6, 3, 4,
     9, 13, 2, 2, 4, 6, 6, 8, 5, 17, 12, 7, 9,
     4, 4, 6, 7, 5, 9, 4, 4, 5, 2, 5, 8, 6,
     4, 9, 5, 8, 4, 3, 9, 5, 5, 6, 4, 6, 2,
     2, 9, 3, 7,
};


static const unsigned short int aKWOffset[148] = {0,
     0, 2, 2, 8, 9, 14, 16, 20, 23, 25, 25, 29, 33,
    36, 41, 46, 48, 53, 54, 59, 62, 65, 67, 69, 78, 81,
    86, 90, 90, 94, 99, 101, 105, 111, 119, 123, 123, 123, 126,
   129, 132, 137, 142, 146, 147, 152, 156, 160, 168, 174, 181, 184,
   184, 187, 189, 195, 198, 206, 211, 216, 219, 222, 226, 236, 239,
   244, 244, 248, 252, 259, 265, 271, 277, 277, 283, 284, 288, 295,
   299, 306, 312, 324, 333, 335, 341, 346, 348, 355, 359, 370, 377,
   378, 385, 391, 397, 402, 408, 412, 415, 424, 429, 433, 439, 441,
   444, 453, 455, 457, 466, 470, 476, 482, 490, 495, 495, 495, 511,
   520, 523, 527, 532, 539, 544, 553, 557, 560, 565, 567, 571, 579,
   585, 588, 597, 602, 610, 610, 614, 623, 628, 633, 639, 642, 645,
   648, 650, 655, 659,
};

static const unsigned char aKWCode[148] = {0,
  99, 117, 162, 39, 59,
  41, 125, 68, 33, 133,
  63, 64, 48, 2, 66,
  164, 38, 24, 139, 16,
  119, 160, 11, 132, 161,
  92, 129, 21, 21, 43,
  51, 83, 13, 138, 95,
  52, 19, 67, 122, 48,
  137, 6,28, 116, 119,
  163, 72, 9, 20, 120,
  152, 70, 69, 131, 78,
  90, 96, 40, 148, 48,
  5, 119, 126, 124, 3,
  26, 82, 119, 14, 32,
  49, 153, 93, 147, 35,
  31, 121, 158, 114, 17,
  101, 8, 144, 128, 47,
  4, 30, 71, 98, 7,
  141, 45, 130, 140, 81,
  97, 159, 150, 73, 27,
  29, 100, 44, 134, 88,
  127, 15, 50, 36, 61,
  10, 37, 119, 101, 101,
  86, 89, 42, 85, 167,
  74, 84, 87, 143, 119,
  149, 18, 146, 75, 94,
  166, 151, 119, 12, 77,
  76, 91, 135, 145, 79,
  80, 165, 62, 34, 65,
  136, 123,
};
# 183555 "c_tests/sqlite3.c"
static int keywordCode(const char *z, int n, int *pType){
  int i, j;
  const char *zKW;
  ((void) (0));
  i = ((sqlite3UpperToLower[(unsigned char)z[0]]*4) ^ (sqlite3UpperToLower[(unsigned char)z[n-1]]*3) ^ n*1) % 127;
  for(i=(int)aKWHash[i]; i>0; i=aKWNext[i]){
    if( aKWLen[i]!=n ) continue;
    zKW = &zKWText[aKWOffset[i]];

    if( (z[0]&~0x20)!=zKW[0] ) continue;
    if( (z[1]&~0x20)!=zKW[1] ) continue;
    j = 2;
    while( j<n && (z[j]&~0x20)==zKW[j] ){ j++; }







    if( j<n ) continue;
                    ;
                    ;
                    ;
                    ;
                    ;
                    ;
                    ;
                    ;
                    ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                     ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
    *pType = aKWCode[i];
    break;
  }
  return n;
}
static int sqlite3KeywordCode(const unsigned char *z, int n){
  int id = 60;
  if( n>=2 ) keywordCode((char*)z, n, &id);
  return id;
}

           int sqlite3_keyword_name(int i,const char **pzName,int *pnName){
  if( i<0 || i>=147 ) return 1;
  i++;
  *pzName = zKWText + aKWOffset[i];
  *pnName = aKWLen[i];
  return 0;
}
           int sqlite3_keyword_count(void){ return 147; }
           int sqlite3_keyword_check(const char *zName, int nName){
  return 60!=sqlite3KeywordCode((const u8*)zName, nName);
}
# 183789 "c_tests/sqlite3.c"
static int sqlite3IsIdChar(u8 c){ return ((sqlite3CtypeMap[(unsigned char)c]&0x46)!=0); }






static int getToken(const unsigned char **pz){
  const unsigned char *z = *pz;
  int t;
  do {
    z += sqlite3GetToken(z, &t);
  }while( t==184 || t==185 );
  if( t==60
   || t==118
   || t==119
   || t==165
   || t==166
   || sqlite3ParserFallback(t)==60
  ){
    t = 60;
  }
  *pz = z;
  return t;
}
# 183845 "c_tests/sqlite3.c"
static int analyzeWindowKeyword(const unsigned char *z){
  int t;
  t = getToken(&z);
  if( t!=60 ) return 60;
  t = getToken(&z);
  if( t!=24 ) return 60;
  return 165;
}
static int analyzeOverKeyword(const unsigned char *z, int lastToken){
  if( lastToken==23 ){
    int t = getToken(&z);
    if( t==22 || t==60 ) return 166;
  }
  return 60;
}
static int analyzeFilterKeyword(const unsigned char *z, int lastToken){
  if( lastToken==23 && getToken(&z)==22 ){
    return 167;
  }
  return 60;
}






static i64 sqlite3GetToken(const unsigned char *z, int *tokenType){
  i64 i;
  int c;
  switch( aiClass[*z] ){


    case 7: {
                           ;
                            ;
                            ;
                            ;
                            ;
      for(i=1; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x01); i++){}
      *tokenType = 184;
      return i;
    }
    case 11: {
      if( z[1]=='-' ){
        for(i=2; (c=z[i])!=0 && c!='\n'; i++){}
        *tokenType = 185;
        return i;
      }else if( z[1]=='>' ){
        *tokenType = 113;
        return 2 + (z[2]=='>');
      }
      *tokenType = 108;
      return 1;
    }
    case 17: {
      *tokenType = 22;
      return 1;
    }
    case 18: {
      *tokenType = 23;
      return 1;
    }
    case 19: {
      *tokenType = 1;
      return 1;
    }
    case 20: {
      *tokenType = 107;
      return 1;
    }
    case 21: {
      *tokenType = 109;
      return 1;
    }
    case 16: {
      if( z[1]!='*' || z[2]==0 ){
        *tokenType = 110;
        return 1;
      }
      for(i=3, c=z[2]; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++){}
      if( c ) i++;
      *tokenType = 185;
      return i;
    }
    case 22: {
      *tokenType = 111;
      return 1;
    }
    case 14: {
      *tokenType = 54;
      return 1 + (z[1]=='=');
    }
    case 12: {
      if( (c=z[1])=='=' ){
        *tokenType = 56;
        return 2;
      }else if( c=='>' ){
        *tokenType = 53;
        return 2;
      }else if( c=='<' ){
        *tokenType = 105;
        return 2;
      }else{
        *tokenType = 57;
        return 1;
      }
    }
    case 13: {
      if( (c=z[1])=='=' ){
        *tokenType = 58;
        return 2;
      }else if( c=='>' ){
        *tokenType = 106;
        return 2;
      }else{
        *tokenType = 55;
        return 1;
      }
    }
    case 15: {
      if( z[1]!='=' ){
        *tokenType = 186;
        return 1;
      }else{
        *tokenType = 53;
        return 2;
      }
    }
    case 10: {
      if( z[1]!='|' ){
        *tokenType = 104;
        return 1;
      }else{
        *tokenType = 112;
        return 2;
      }
    }
    case 23: {
      *tokenType = 25;
      return 1;
    }
    case 24: {
      *tokenType = 103;
      return 1;
    }
    case 25: {
      *tokenType = 115;
      return 1;
    }
    case 8: {
      int delim = z[0];
                            ;
                             ;
                            ;
      for(i=1; (c=z[i])!=0; i++){
        if( c==delim ){
          if( z[i+1]==delim ){
            i++;
          }else{
            break;
          }
        }
      }
      if( c=='\'' ){
        *tokenType = 118;
        return i+1;
      }else if( c!=0 ){
        *tokenType = 60;
        return i+1;
      }else{
        *tokenType = 186;
        return i;
      }
    }
    case 26: {

      if( !(sqlite3CtypeMap[(unsigned char)(z[1])]&0x04) )

      {
        *tokenType = 142;
        return 1;
      }


                     __attribute__((fallthrough));
    }
    case 3: {
                           ; ; ;
                           ; ; ;
                           ; ; ;
                           ; ;
      *tokenType = 156;

      if( z[0]=='0' && (z[1]=='x' || z[1]=='X') && (sqlite3CtypeMap[(unsigned char)(z[2])]&0x08) ){
        for(i=3; 1; i++){
          if( (sqlite3CtypeMap[(unsigned char)(z[i])]&0x08)==0 ){
            if( z[i]=='_' ){
              *tokenType = 183;
            }else{
              break;
            }
          }
        }
      }else

        {
        for(i=0; 1; i++){
          if( (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04)==0 ){
            if( z[i]=='_' ){
              *tokenType = 183;
            }else{
              break;
            }
          }
        }

        if( z[i]=='.' ){
          if( *tokenType==156 ) *tokenType = 154;
          for(i++; 1; i++){
            if( (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04)==0 ){
              if( z[i]=='_' ){
                *tokenType = 183;
              }else{
                break;
              }
            }
          }
        }
        if( (z[i]=='e' || z[i]=='E') &&
             ( (sqlite3CtypeMap[(unsigned char)(z[i+1])]&0x04)
              || ((z[i+1]=='+' || z[i+1]=='-') && (sqlite3CtypeMap[(unsigned char)(z[i+2])]&0x04))
             )
        ){
          if( *tokenType==156 ) *tokenType = 154;
          for(i+=2; 1; i++){
            if( (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04)==0 ){
              if( z[i]=='_' ){
                *tokenType = 183;
              }else{
                break;
              }
            }
          }
        }

      }
      while( ((sqlite3CtypeMap[(unsigned char)z[i]]&0x46)!=0) ){
        *tokenType = 186;
        i++;
      }
      return i;
    }
    case 9: {
      for(i=1, c=z[0]; c!=']' && (c=z[i])!=0; i++){}
      *tokenType = c==']' ? 60 : 186;
      return i;
    }
    case 6: {
      *tokenType = 157;
      for(i=1; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04); i++){}
      return i;
    }
    case 4:
    case 5: {
      int n = 0;
                           ; ;
                           ; ;
      *tokenType = 157;
      for(i=1; (c=z[i])!=0; i++){
        if( ((sqlite3CtypeMap[(unsigned char)c]&0x46)!=0) ){
          n++;

        }else if( c=='(' && n>0 ){
          do{
            i++;
          }while( (c=z[i])!=0 && !(sqlite3CtypeMap[(unsigned char)(c)]&0x01) && c!=')' );
          if( c==')' ){
            i++;
          }else{
            *tokenType = 186;
          }
          break;
        }else if( c==':' && z[i+1]==':' ){
          i++;

        }else{
          break;
        }
      }
      if( n==0 ) *tokenType = 186;
      return i;
    }
    case 1: {
      if( aiClass[z[1]]>2 ){ i = 1; break; }
      for(i=2; aiClass[z[i]]<=2; i++){}
      if( ((sqlite3CtypeMap[(unsigned char)z[i]]&0x46)!=0) ){



        i++;
        break;
      }
      *tokenType = 60;
      return keywordCode((char*)z, i, tokenType);
    }
    case 0: {

                           ; ;
      if( z[1]=='\'' ){
        *tokenType = 155;
        for(i=2; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x08); i++){}
        if( z[i]!='\'' || i%2 ){
          *tokenType = 186;
          while( z[i] && z[i]!='\'' ){ i++; }
        }
        if( z[i] ) i++;
        return i;
      }



                     __attribute__((fallthrough));
    }
    case 2:
    case 27: {
      i = 1;
      break;
    }
    case 30: {
      if( z[1]==0xbb && z[2]==0xbf ){
        *tokenType = 184;
        return 3;
      }
      i = 1;
      break;
    }
    case 29: {
      *tokenType = 186;
      return 0;
    }
    default: {
      *tokenType = 186;
      return 1;
    }
  }
  while( ((sqlite3CtypeMap[(unsigned char)z[i]]&0x46)!=0) ){ i++; }
  *tokenType = 60;
  return i;
}




static int sqlite3RunParser(Parse *pParse, const char *zSql){
  int nErr = 0;
  void *pEngine;
  i64 n = 0;
  int tokenType;
  int lastTokenParsed = -1;
  sqlite3 *db = pParse->db;
  int mxSqlLen;
  Parse *pParentParse = 0;

  yyParser sEngine;

                                                  ;

  ((void) (0));
  mxSqlLen = db->aLimit[1];
  if( db->nVdbeActive==0 ){
    __atomic_store_n((&db->u1.isInterrupted),(0),0);
  }
  pParse->rc = 0;
  pParse->zTail = zSql;
# 184229 "c_tests/sqlite3.c"
  pEngine = &sEngine;
  sqlite3ParserInit(pEngine, pParse);







  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  pParentParse = db->pParse;
  db->pParse = pParse;
  while( 1 ){
    n = sqlite3GetToken((u8*)zSql, &tokenType);
    mxSqlLen -= n;
    if( mxSqlLen<0 ){
      pParse->rc = 18;
      pParse->nErr++;
      break;
    }

    if( tokenType>=165 ){
      ((void) (0));
# 184264 "c_tests/sqlite3.c"
      if( __atomic_load_n((&db->u1.isInterrupted),0) ){
        pParse->rc = 9;
        pParse->nErr++;
        break;
      }
      if( tokenType==184 ){
        zSql += n;
        continue;
      }
      if( zSql[0]==0 ){


        if( lastTokenParsed==1 ){
          tokenType = 0;
        }else if( lastTokenParsed==0 ){
          break;
        }else{
          tokenType = 1;
        }
        n = 0;

      }else if( tokenType==165 ){
        ((void) (0));
        tokenType = analyzeWindowKeyword((const u8*)&zSql[6]);
      }else if( tokenType==166 ){
        ((void) (0));
        tokenType = analyzeOverKeyword((const u8*)&zSql[4], lastTokenParsed);
      }else if( tokenType==167 ){
        ((void) (0));
        tokenType = analyzeFilterKeyword((const u8*)&zSql[6], lastTokenParsed);

      }else if( tokenType==185
             && (db->init.busy || (db->flags & ((u64)(0x00040)<<32))!=0)
      ){


        zSql += n;
        continue;
      }else if( tokenType!=183 ){
        Token x;
        x.z = zSql;
        x.n = (u32)n;
        sqlite3ErrorMsg(pParse, "unrecognized token: \"%T\"", &x);
        break;
      }
    }
    pParse->sLastToken.z = zSql;
    pParse->sLastToken.n = (u32)n;
    sqlite3Parser(pEngine, tokenType, pParse->sLastToken);
    lastTokenParsed = tokenType;
    zSql += n;
    ((void) (0));
    if( pParse->rc!=0 ) break;
  }
  ((void) (0));
# 184327 "c_tests/sqlite3.c"
  sqlite3ParserFinalize(pEngine);



  if( db->mallocFailed ){
    pParse->rc = 7;
  }
  if( pParse->zErrMsg || (pParse->rc!=0 && pParse->rc!=101) ){
    if( pParse->zErrMsg==0 ){
      pParse->zErrMsg = sqlite3MPrintf(db, "%s", sqlite3ErrStr(pParse->rc));
    }
    if( (pParse->prepFlags & 0x10)==0 ){
      sqlite3_log(pParse->rc, "%s in \"%s\"", pParse->zErrMsg, pParse->zTail);
    }
    nErr++;
  }
  pParse->zTail = zSql;

  sqlite3_free(pParse->apVtabLock);


  if( pParse->pNewTable && !(pParse->eParseMode!=0) ){




    sqlite3DeleteTable(db, pParse->pNewTable);
  }
  if( pParse->pNewTrigger && !(pParse->eParseMode>=2) ){
    sqlite3DeleteTrigger(db, pParse->pNewTrigger);
  }
  if( pParse->pVList ) sqlite3DbNNFreeNN(db, pParse->pVList);
  db->pParse = pParentParse;
  ((void) (0));
  return nErr;
}
# 184605 "c_tests/sqlite3.c"
           int sqlite3_complete(const char *zSql){
  u8 state = 0;
  u8 token;





  static const u8 trans[8][8] = {


                      { 1, 0, 2, 3, 4, 2, 2, 2, },
                      { 1, 1, 2, 3, 4, 2, 2, 2, },
                      { 1, 2, 2, 2, 2, 2, 2, 2, },
                      { 1, 3, 3, 2, 4, 2, 2, 2, },
                      { 1, 4, 2, 2, 2, 4, 5, 2, },
                      { 6, 5, 5, 5, 5, 5, 5, 5, },
                      { 6, 6, 5, 5, 5, 5, 5, 7, },
                      { 1, 7, 5, 5, 5, 5, 5, 5, },
  };
# 184645 "c_tests/sqlite3.c"
  while( *zSql ){
    switch( *zSql ){
      case ';': {
        token = 0;
        break;
      }
      case ' ':
      case '\r':
      case '\t':
      case '\n':
      case '\f': {
        token = 1;
        break;
      }
      case '/': {
        if( zSql[1]!='*' ){
          token = 2;
          break;
        }
        zSql += 2;
        while( zSql[0] && (zSql[0]!='*' || zSql[1]!='/') ){ zSql++; }
        if( zSql[0]==0 ) return 0;
        zSql++;
        token = 1;
        break;
      }
      case '-': {
        if( zSql[1]!='-' ){
          token = 2;
          break;
        }
        while( *zSql && *zSql!='\n' ){ zSql++; }
        if( *zSql==0 ) return state==1;
        token = 1;
        break;
      }
      case '[': {
        zSql++;
        while( *zSql && *zSql!=']' ){ zSql++; }
        if( *zSql==0 ) return 0;
        token = 2;
        break;
      }
      case '`':
      case '"':
      case '\'': {
        int c = *zSql;
        zSql++;
        while( *zSql && *zSql!=c ){ zSql++; }
        if( *zSql==0 ) return 0;
        token = 2;
        break;
      }
      default: {



        if( ((sqlite3CtypeMap[(unsigned char)(u8)*zSql]&0x46)!=0) ){

          int nId;
          for(nId=1; ((sqlite3CtypeMap[(unsigned char)zSql[nId]]&0x46)!=0); nId++){}



          switch( *zSql ){
            case 'c': case 'C': {
              if( nId==6 && sqlite3_strnicmp(zSql, "create", 6)==0 ){
                token = 4;
              }else{
                token = 2;
              }
              break;
            }
            case 't': case 'T': {
              if( nId==7 && sqlite3_strnicmp(zSql, "trigger", 7)==0 ){
                token = 6;
              }else if( nId==4 && sqlite3_strnicmp(zSql, "temp", 4)==0 ){
                token = 5;
              }else if( nId==9 && sqlite3_strnicmp(zSql, "temporary", 9)==0 ){
                token = 5;
              }else{
                token = 2;
              }
              break;
            }
            case 'e': case 'E': {
              if( nId==3 && sqlite3_strnicmp(zSql, "end", 3)==0 ){
                token = 7;
              }else

              if( nId==7 && sqlite3_strnicmp(zSql, "explain", 7)==0 ){
                token = 3;
              }else

              {
                token = 2;
              }
              break;
            }
            default: {
              token = 2;
              break;
            }
          }

          zSql += nId-1;
        }else{

          token = 2;
        }
        break;
      }
    }
    state = trans[state][token];
    zSql++;
  }
  return state==1;
}







           int sqlite3_complete16(const void *zSql){
  sqlite3_value *pVal;
  char const *zSql8;
  int rc;


  rc = sqlite3_initialize();
  if( rc ) return rc;

  pVal = sqlite3ValueNew(0);
  sqlite3ValueSetStr(pVal, -1, zSql, 2, ((sqlite3_destructor_type)0));
  zSql8 = sqlite3ValueText(pVal, 1);
  if( zSql8 ){
    rc = sqlite3_complete(zSql8);
  }else{
    rc = 7;
  }
  sqlite3ValueFree(pVal);
  return rc & 0xff;
}
# 184922 "c_tests/sqlite3.c"
static int sqlite3TestExtInit(sqlite3 *db){
  (void)db;
  return sqlite3FaultSim(500);
}
# 184945 "c_tests/sqlite3.c"
static int (*const sqlite3BuiltinExtensions[])(sqlite3*) = {
# 184964 "c_tests/sqlite3.c"
  sqlite3TestExtInit,
# 184974 "c_tests/sqlite3.c"
};
# 184986 "c_tests/sqlite3.c"
           const char *sqlite3_libversion(void){ return sqlite3_version; }
# 184999 "c_tests/sqlite3.c"
           int sqlite3_libversion_number(void){ return 3051002; }





           int sqlite3_threadsafe(void){ return 1; }
# 185036 "c_tests/sqlite3.c"
           char *sqlite3_temp_directory = 0;
# 185045 "c_tests/sqlite3.c"
           char *sqlite3_data_directory = 0;
# 185078 "c_tests/sqlite3.c"
           int sqlite3_initialize(void){
  sqlite3_mutex *pMainMtx;
  int rc;
# 185095 "c_tests/sqlite3.c"
  ((void) (0));






  if( sqlite3Config.isInit ){
    sqlite3MemoryBarrier();
    return 0;
  }
# 185115 "c_tests/sqlite3.c"
  rc = sqlite3MutexInit();
  if( rc ) return rc;







  pMainMtx = sqlite3MutexAlloc(2);
  sqlite3_mutex_enter(pMainMtx);
  sqlite3Config.isMutexInit = 1;
  if( !sqlite3Config.isMallocInit ){
    rc = sqlite3MallocInit();
  }
  if( rc==0 ){
    sqlite3Config.isMallocInit = 1;
    if( !sqlite3Config.pInitMutex ){
      sqlite3Config.pInitMutex =
           sqlite3MutexAlloc(1);
      if( sqlite3Config.bCoreMutex && !sqlite3Config.pInitMutex ){
        rc = 7;
      }
    }
  }
  if( rc==0 ){
    sqlite3Config.nRefInitMutex++;
  }
  sqlite3_mutex_leave(pMainMtx);




  if( rc!=0 ){
    return rc;
  }
# 185165 "c_tests/sqlite3.c"
  sqlite3_mutex_enter(sqlite3Config.pInitMutex);
  if( sqlite3Config.isInit==0 && sqlite3Config.inProgress==0 ){
    sqlite3Config.inProgress = 1;






    memset(&sqlite3BuiltinFunctions, 0, sizeof(sqlite3BuiltinFunctions));
    sqlite3RegisterBuiltinFunctions();
    if( sqlite3Config.isPCacheInit==0 ){
      rc = sqlite3PcacheInitialize();
    }
    if( rc==0 ){
      sqlite3Config.isPCacheInit = 1;
      rc = sqlite3OsInit();
    }

    if( rc==0 ){
      rc = sqlite3MemdbInit();
    }

    if( rc==0 ){
      sqlite3PCacheBufferSetup( sqlite3Config.pPage,
          sqlite3Config.szPage, sqlite3Config.nPage);






    }
    if( rc==0 ){
      sqlite3MemoryBarrier();
      sqlite3Config.isInit = 1;



    }
    sqlite3Config.inProgress = 0;
  }
  sqlite3_mutex_leave(sqlite3Config.pInitMutex);




  sqlite3_mutex_enter(pMainMtx);
  sqlite3Config.nRefInitMutex--;
  if( sqlite3Config.nRefInitMutex<=0 ){
    ((void) (0));
    sqlite3_mutex_free(sqlite3Config.pInitMutex);
    sqlite3Config.pInitMutex = 0;
  }
  sqlite3_mutex_leave(pMainMtx);
# 185249 "c_tests/sqlite3.c"
  return rc;
}
# 185260 "c_tests/sqlite3.c"
           int sqlite3_shutdown(void){







  if( sqlite3Config.isInit ){




    sqlite3_os_end();
    sqlite3_reset_auto_extension();
    sqlite3Config.isInit = 0;
  }
  if( sqlite3Config.isPCacheInit ){
    sqlite3PcacheShutdown();
    sqlite3Config.isPCacheInit = 0;
  }
  if( sqlite3Config.isMallocInit ){
    sqlite3MallocEnd();
    sqlite3Config.isMallocInit = 0;
# 185293 "c_tests/sqlite3.c"
    sqlite3_data_directory = 0;
    sqlite3_temp_directory = 0;

  }
  if( sqlite3Config.isMutexInit ){
    sqlite3MutexEnd();
    sqlite3Config.isMutexInit = 0;
  }

  return 0;
}
# 185314 "c_tests/sqlite3.c"
           int sqlite3_config(int op, ...){
  va_list ap;
  int rc = 0;





  if( sqlite3Config.isInit ){
    static const u64 mAnytimeConfigOption = 0
       | (((u64)1)<<(16))
       | (((u64)1)<<(24))
    ;
    if( op<0 || op>63 || ((((u64)1)<<(op)) & mAnytimeConfigOption)==0 ){
      return sqlite3MisuseError(185328);
    }
                                     ;
                                              ;
  }

  __builtin_va_start(ap, op);
  switch( op ){





    case 1: {


      sqlite3Config.bCoreMutex = 0;
      sqlite3Config.bFullMutex = 0;
      break;
    }


    case 2: {


      sqlite3Config.bCoreMutex = 1;
      sqlite3Config.bFullMutex = 0;
      break;
    }


    case 3: {


      sqlite3Config.bCoreMutex = 1;
      sqlite3Config.bFullMutex = 1;
      break;
    }


    case 10: {

      sqlite3Config.mutex = *__builtin_va_arg(ap, sqlite3_mutex_methods*);
      break;
    }


    case 11: {

      *__builtin_va_arg(ap, sqlite3_mutex_methods*) = sqlite3Config.mutex;
      break;
    }


    case 4: {





      sqlite3Config.m = *__builtin_va_arg(ap, sqlite3_mem_methods*);
      break;
    }
    case 5: {




      if( sqlite3Config.m.xMalloc==0 ) sqlite3MemSetDefault();
      *__builtin_va_arg(ap, sqlite3_mem_methods*) = sqlite3Config.m;
      break;
    }
    case 9: {
      ((void) (0));



      sqlite3Config.bMemstat = __builtin_va_arg(ap, int);
      break;
    }
    case 27: {
      sqlite3Config.bSmallMalloc = __builtin_va_arg(ap, int);
      break;
    }
    case 7: {




      sqlite3Config.pPage = __builtin_va_arg(ap, void*);
      sqlite3Config.szPage = __builtin_va_arg(ap, int);
      sqlite3Config.nPage = __builtin_va_arg(ap, int);
      break;
    }
    case 24: {




      *__builtin_va_arg(ap, int*) =
          sqlite3HeaderSizeBtree() +
          sqlite3HeaderSizePcache() +
          sqlite3HeaderSizePcache1();
      break;
    }

    case 14: {

      break;
    }
    case 15: {

      rc = 1;
      break;
    }

    case 18: {




      sqlite3Config.pcache2 = *__builtin_va_arg(ap, sqlite3_pcache_methods2*);
      break;
    }
    case 19: {




      if( sqlite3Config.pcache2.xInit==0 ){
        sqlite3PCacheSetDefault();
      }
      *__builtin_va_arg(ap, sqlite3_pcache_methods2*) = sqlite3Config.pcache2;
      break;
    }
# 185509 "c_tests/sqlite3.c"
    case 13: {
      sqlite3Config.szLookaside = __builtin_va_arg(ap, int);
      sqlite3Config.nLookaside = __builtin_va_arg(ap, int);
      break;
    }





    case 16: {




      typedef void(*LOGFUNC_t)(void*,int,const char*);
      LOGFUNC_t xLog = __builtin_va_arg(ap, LOGFUNC_t);
      void *pLogArg = __builtin_va_arg(ap, void*);
      __atomic_store_n((&sqlite3Config.xLog),(xLog),0);
      __atomic_store_n((&sqlite3Config.pLogArg),(pLogArg),0);
      break;
    }






    case 17: {




      int bOpenUri = __builtin_va_arg(ap, int);
      __atomic_store_n((&sqlite3Config.bOpenUri),(bOpenUri),0);
      break;
    }

    case 20: {




      sqlite3Config.bUseCis = __builtin_va_arg(ap, int);
      break;
    }
# 185565 "c_tests/sqlite3.c"
    case 22: {




      sqlite3_int64 szMmap = __builtin_va_arg(ap, sqlite3_int64);
      sqlite3_int64 mxMmap = __builtin_va_arg(ap, sqlite3_int64);
# 185580 "c_tests/sqlite3.c"
      if( mxMmap<0 || mxMmap>0x7fff0000 ){
        mxMmap = 0x7fff0000;
      }
      if( szMmap<0 ) szMmap = 0;
      if( szMmap>mxMmap) szMmap = mxMmap;
      sqlite3Config.mxMmap = mxMmap;
      sqlite3Config.szMmap = szMmap;
      break;
    }
# 185600 "c_tests/sqlite3.c"
    case 25: {
      sqlite3Config.szPma = __builtin_va_arg(ap, unsigned int);
      break;
    }

    case 26: {
      sqlite3Config.nStmtSpill = __builtin_va_arg(ap, int);
      break;
    }
# 185622 "c_tests/sqlite3.c"
    case 29: {
      sqlite3Config.mxMemdbSize = __builtin_va_arg(ap, sqlite3_int64);
      break;
    }


    case 30: {
      int *pVal = __builtin_va_arg(ap, int*);





      *pVal = 0;

      break;
    }

    default: {
      rc = 1;
      break;
    }
  }
  __builtin_va_end(ap);
  return rc;
}
# 185660 "c_tests/sqlite3.c"
static int setupLookaside(
  sqlite3 *db,
  void *pBuf,
  int sz,
  int cnt
){

  void *pStart;
  sqlite3_int64 szAlloc;
  int nBig;
  int nSm;

  if( sqlite3LookasideUsed(db,0)>0 ){
    return 5;
  }




  if( db->lookaside.bMalloced ){
    sqlite3_free(db->lookaside.pStart);
  }



  sz = ((sz)&~7);
  if( sz<=(int)sizeof(LookasideSlot*) ) sz = 0;
  if( sz>65528 ) sz = 65528;


  if( cnt<1 ) cnt = 0;
  if( sz>0 && cnt>(0x7fff0000/sz) ) cnt = 0x7fff0000/sz;
  szAlloc = (i64)sz*(i64)cnt;
  if( szAlloc==0 ){
    sz = 0;
    pStart = 0;
  }else if( pBuf==0 ){
    sqlite3BeginBenignMalloc();
    pStart = sqlite3Malloc( szAlloc );
    sqlite3EndBenignMalloc();
    if( pStart ) szAlloc = sqlite3MallocSize(pStart);
  }else{
    pStart = pBuf;
  }

  if( sz>=128*3 ){
    nBig = szAlloc/(3*128 +sz);
    nSm = (szAlloc - (i64)sz*(i64)nBig)/128;
  }else if( sz>=128*2 ){
    nBig = szAlloc/(128 +sz);
    nSm = (szAlloc - (i64)sz*(i64)nBig)/128;
  }else

  if( sz>0 ){
    nBig = szAlloc/sz;
    nSm = 0;
  }else{
    nBig = nSm = 0;
  }
  db->lookaside.pStart = pStart;
  db->lookaside.pInit = 0;
  db->lookaside.pFree = 0;
  db->lookaside.sz = (u16)sz;
  db->lookaside.szTrue = (u16)sz;
  if( pStart ){
    int i;
    LookasideSlot *p;
    ((void) (0));
    p = (LookasideSlot*)pStart;
    for(i=0; i<nBig; i++){
      p->pNext = db->lookaside.pInit;
      db->lookaside.pInit = p;
      p = (LookasideSlot*)&((u8*)p)[sz];
    }

    db->lookaside.pSmallInit = 0;
    db->lookaside.pSmallFree = 0;
    db->lookaside.pMiddle = p;
    for(i=0; i<nSm; i++){
      p->pNext = db->lookaside.pSmallInit;
      db->lookaside.pSmallInit = p;
      p = (LookasideSlot*)&((u8*)p)[128];
    }

    ((void) (0));
    db->lookaside.pEnd = p;
    db->lookaside.bDisable = 0;
    db->lookaside.bMalloced = pBuf==0 ?1:0;
    db->lookaside.nSlot = nBig+nSm;
  }else{
    db->lookaside.pStart = 0;

    db->lookaside.pSmallInit = 0;
    db->lookaside.pSmallFree = 0;
    db->lookaside.pMiddle = 0;

    db->lookaside.pEnd = 0;
    db->lookaside.bDisable = 1;
    db->lookaside.sz = 0;
    db->lookaside.bMalloced = 0;
    db->lookaside.nSlot = 0;
  }
  db->lookaside.pTrueEnd = db->lookaside.pEnd;
  ((void) (0));

  return 0;
}




           sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db){






  return db->mutex;
}





           int sqlite3_db_release_memory(sqlite3 *db){
  int i;




  sqlite3_mutex_enter(db->mutex);
  sqlite3BtreeEnterAll(db);
  for(i=0; i<db->nDb; i++){
    Btree *pBt = db->aDb[i].pBt;
    if( pBt ){
      Pager *pPager = sqlite3BtreePager(pBt);
      sqlite3PagerShrink(pPager);
    }
  }
  sqlite3BtreeLeaveAll(db);
  sqlite3_mutex_leave(db->mutex);
  return 0;
}





           int sqlite3_db_cacheflush(sqlite3 *db){
  int i;
  int rc = 0;
  int bSeenBusy = 0;




  sqlite3_mutex_enter(db->mutex);
  sqlite3BtreeEnterAll(db);
  for(i=0; rc==0 && i<db->nDb; i++){
    Btree *pBt = db->aDb[i].pBt;
    if( pBt && sqlite3BtreeTxnState(pBt)==2 ){
      Pager *pPager = sqlite3BtreePager(pBt);
      rc = sqlite3PagerFlush(pPager);
      if( rc==5 ){
        bSeenBusy = 1;
        rc = 0;
      }
    }
  }
  sqlite3BtreeLeaveAll(db);
  sqlite3_mutex_leave(db->mutex);
  return ((rc==0 && bSeenBusy) ? 5 : rc);
}




           int sqlite3_db_config(sqlite3 *db, int op, ...){
  va_list ap;
  int rc;




  sqlite3_mutex_enter(db->mutex);
  __builtin_va_start(ap, op);
  switch( op ){
    case 1000: {


      db->aDb[0].zDbSName = __builtin_va_arg(ap, char*);
      rc = 0;
      break;
    }
    case 1001: {
      void *pBuf = __builtin_va_arg(ap, void*);
      int sz = __builtin_va_arg(ap, int);
      int cnt = __builtin_va_arg(ap, int);
      rc = setupLookaside(db, pBuf, sz, cnt);
      break;
    }
    default: {
      static const struct {
        int op;
        u64 mask;
      } aFlagOp[] = {
        { 1002, 0x00004000 },
        { 1003, 0x00040000 },
        { 1015, 0x80000000 },
        { 1004, 0x00400000 },
        { 1005, 0x00010000 },
        { 1006, 0x00000800 },
        { 1007, 0x00800000 },
        { 1008, 0x01000000 },
        { 1009, 0x02000000 },
        { 1010, 0x10000000 },
        { 1011, 0x00000001|
                                                 0x08000000 },
        { 1012, 0x04000000 },
        { 1014, 0x20000000 },
        { 1013, 0x40000000 },
        { 1016, 0x00000002 },
        { 1017, 0x00000080 },
        { 1018, 0x00000400 },
        { 1019, 0x00001000 },
        { 1020, ((u64)(0x00010)<<32) },
        { 1021, ((u64)(0x00020)<<32) },
        { 1022, ((u64)(0x00040)<<32) },
      };
      unsigned int i;
      rc = 1;
      for(i=0; i<((int)(sizeof(aFlagOp)/sizeof(aFlagOp[0]))); i++){
        if( aFlagOp[i].op==op ){
          int onoff = __builtin_va_arg(ap, int);
          int *pRes = __builtin_va_arg(ap, int*);
          u64 oldFlags = db->flags;
          if( onoff>0 ){
            db->flags |= aFlagOp[i].mask;
          }else if( onoff==0 ){
            db->flags &= ~(u64)aFlagOp[i].mask;
          }
          if( oldFlags!=db->flags ){
            sqlite3ExpirePreparedStatements(db, 0);
          }
          if( pRes ){
            *pRes = (db->flags & aFlagOp[i].mask)!=0;
          }
          rc = 0;
          break;
        }
      }
      break;
    }
  }
  __builtin_va_end(ap);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}





static int binCollFunc(
  void *NotUsed,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
){
  int rc, n;
  (void)(NotUsed);
  n = nKey1<nKey2 ? nKey1 : nKey2;



  ((void) (0));
  rc = memcmp(pKey1, pKey2, n);
  if( rc==0 ){
    rc = nKey1 - nKey2;
  }
  return rc;
}





static int rtrimCollFunc(
  void *pUser,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
){
  const u8 *pK1 = (const u8*)pKey1;
  const u8 *pK2 = (const u8*)pKey2;
  while( nKey1 && pK1[nKey1-1]==' ' ) nKey1--;
  while( nKey2 && pK2[nKey2-1]==' ' ) nKey2--;
  return binCollFunc(pUser, nKey1, pKey1, nKey2, pKey2);
}




static int sqlite3IsBinary(const CollSeq *p){
  ((void) (0));
  return p==0 || p->xCmp==binCollFunc;
}
# 185976 "c_tests/sqlite3.c"
static int nocaseCollatingFunc(
  void *NotUsed,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
){
  int r = sqlite3_strnicmp(
      (const char *)pKey1, (const char *)pKey2, (nKey1<nKey2)?nKey1:nKey2);
  (void)(NotUsed);
  if( 0==r ){
    r = nKey1-nKey2;
  }
  return r;
}




           sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){






  return db->lastRowid;
}




           void sqlite3_set_last_insert_rowid(sqlite3 *db, sqlite3_int64 iRowid){






  sqlite3_mutex_enter(db->mutex);
  db->lastRowid = iRowid;
  sqlite3_mutex_leave(db->mutex);
}




           sqlite3_int64 sqlite3_changes64(sqlite3 *db){






  return db->nChange;
}
           int sqlite3_changes(sqlite3 *db){
  return (int)sqlite3_changes64(db);
}




           sqlite3_int64 sqlite3_total_changes64(sqlite3 *db){






  return db->nTotalChange;
}
           int sqlite3_total_changes(sqlite3 *db){
  return (int)sqlite3_total_changes64(db);
}






static void sqlite3CloseSavepoints(sqlite3 *db){
  while( db->pSavepoint ){
    Savepoint *pTmp = db->pSavepoint;
    db->pSavepoint = pTmp->pNext;
    sqlite3DbFree(db, pTmp);
  }
  db->nSavepoint = 0;
  db->nStatement = 0;
  db->isTransactionSavepoint = 0;
}







static void functionDestroy(sqlite3 *db, FuncDef *p){
  FuncDestructor *pDestructor;
  ((void) (0));
  pDestructor = p->u.pDestructor;
  if( pDestructor ){
    pDestructor->nRef--;
    if( pDestructor->nRef==0 ){
      pDestructor->xDestroy(pDestructor->pUserData);
      sqlite3DbFree(db, pDestructor);
    }
  }
}





static void disconnectAllVtab(sqlite3 *db){

  int i;
  HashElem *p;
  sqlite3BtreeEnterAll(db);
  for(i=0; i<db->nDb; i++){
    Schema *pSchema = db->aDb[i].pSchema;
    if( pSchema ){
      for(p=((&pSchema->tblHash)->first); p; p=((p)->next)){
        Table *pTab = (Table *)((p)->data);
        if( ((pTab)->eTabType==1) ) sqlite3VtabDisconnect(db, pTab);
      }
    }
  }
  for(p=((&db->aModule)->first); p; p=((p)->next)){
    Module *pMod = (Module *)((p)->data);
    if( pMod->pEpoTab ){
      sqlite3VtabDisconnect(db, pMod->pEpoTab);
    }
  }
  sqlite3VtabUnlockList(db);
  sqlite3BtreeLeaveAll(db);



}





static int connectionIsBusy(sqlite3 *db){
  int j;
  ((void) (0));
  if( db->pVdbe ) return 1;
  for(j=0; j<db->nDb; j++){
    Btree *pBt = db->aDb[j].pBt;
    if( pBt && sqlite3BtreeIsInBackup(pBt) ) return 1;
  }
  return 0;
}




static int sqlite3Close(sqlite3 *db, int forceZombie){
  if( !db ){


    return 0;
  }
  if( !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3MisuseError(186141);
  }
  sqlite3_mutex_enter(db->mutex);
  if( db->mTrace & 0x08 ){
    db->trace.xV2(0x08, db->pTraceArg, db, 0);
  }


  disconnectAllVtab(db);
# 186158 "c_tests/sqlite3.c"
  sqlite3VtabRollback(db);




  if( !forceZombie && connectionIsBusy(db) ){
    sqlite3ErrorWithMsg(db, 5, "unable to close due to unfinalized "
       "statements or unfinished backups");
    sqlite3_mutex_leave(db->mutex);
    return 5;
  }
# 186177 "c_tests/sqlite3.c"
  while( db->pDbData ){
    DbClientData *p = db->pDbData;
    db->pDbData = p->pNext;
    ((void) (0));
    if( p->xDestructor ) p->xDestructor(p->pData);
    sqlite3_free(p);
  }



  db->eOpenState = 0xa7;
  sqlite3LeaveMutexAndCloseZombie(db);
  return 0;
}





           int sqlite3_txn_state(sqlite3 *db, const char *zSchema){
  int iDb, nDb;
  int iTxn = -1;






  sqlite3_mutex_enter(db->mutex);
  if( zSchema ){
    nDb = iDb = sqlite3FindDbName(db, zSchema);
    if( iDb<0 ) nDb--;
  }else{
    iDb = 0;
    nDb = db->nDb-1;
  }
  for(; iDb<=nDb; iDb++){
    Btree *pBt = db->aDb[iDb].pBt;
    int x = pBt!=0 ? sqlite3BtreeTxnState(pBt) : 0;
    if( x>iTxn ) iTxn = x;
  }
  sqlite3_mutex_leave(db->mutex);
  return iTxn;
}
# 186231 "c_tests/sqlite3.c"
           int sqlite3_close(sqlite3 *db){ return sqlite3Close(db,0); }
           int sqlite3_close_v2(sqlite3 *db){ return sqlite3Close(db,1); }
# 186243 "c_tests/sqlite3.c"
static void sqlite3LeaveMutexAndCloseZombie(sqlite3 *db){
  HashElem *i;
  int j;





  if( db->eOpenState!=0xa7 || connectionIsBusy(db) ){
    sqlite3_mutex_leave(db->mutex);
    return;
  }
# 186266 "c_tests/sqlite3.c"
  sqlite3RollbackAll(db, 0);


  sqlite3CloseSavepoints(db);


  for(j=0; j<db->nDb; j++){
    struct Db *pDb = &db->aDb[j];
    if( pDb->pBt ){
      sqlite3BtreeClose(pDb->pBt);
      pDb->pBt = 0;
      if( j!=1 ){
        pDb->pSchema = 0;
      }
    }
  }

  if( db->aDb[1].pSchema ){
    sqlite3SchemaClear(db->aDb[1].pSchema);
    ((void) (0));
  }
  sqlite3VtabUnlockList(db);


  sqlite3CollapseDatabaseArray(db);
  ((void) (0));
  ((void) (0));




                             ;

  for(i=((&db->aFunc)->first); i; i=((i)->next)){
    FuncDef *pNext, *p;
    p = ((i)->data);
    do{
      functionDestroy(db, p);
      pNext = p->pNext;
      sqlite3DbFree(db, p);
      p = pNext;
    }while( p );
  }
  sqlite3HashClear(&db->aFunc);
  for(i=((&db->aCollSeq)->first); i; i=((i)->next)){
    CollSeq *pColl = (CollSeq *)((i)->data);

    for(j=0; j<3; j++){
      if( pColl[j].xDel ){
        pColl[j].xDel(pColl[j].pUser);
      }
    }
    sqlite3DbFree(db, pColl);
  }
  sqlite3HashClear(&db->aCollSeq);

  for(i=((&db->aModule)->first); i; i=((i)->next)){
    Module *pMod = (Module *)((i)->data);
    sqlite3VtabEponymousTableClear(db, pMod);
    sqlite3VtabModuleUnref(db, pMod);
  }
  sqlite3HashClear(&db->aModule);


  sqlite3Error(db, 0);
  sqlite3ValueFree(db->pErr);
  sqlite3CloseExtensions(db);

  db->eOpenState = 0xd5;







  sqlite3DbFree(db, db->aDb[1].pSchema);
  if( db->xAutovacDestr ){
    db->xAutovacDestr(db->pAutovacPagesArg);
  }
  sqlite3_mutex_leave(db->mutex);
  db->eOpenState = 0xce;
  sqlite3_mutex_free(db->mutex);
  ((void) (0));
  if( db->lookaside.bMalloced ){
    sqlite3_free(db->lookaside.pStart);
  }
  sqlite3_free(db);
}
# 186363 "c_tests/sqlite3.c"
static void sqlite3RollbackAll(sqlite3 *db, int tripCode){
  int i;
  int inTrans = 0;
  int schemaChange;
  ((void) (0));
  sqlite3BeginBenignMalloc();







  sqlite3BtreeEnterAll(db);
  schemaChange = (db->mDbFlags & 0x0001)!=0 && db->init.busy==0;

  for(i=0; i<db->nDb; i++){
    Btree *p = db->aDb[i].pBt;
    if( p ){
      if( sqlite3BtreeTxnState(p)==2 ){
        inTrans = 1;
      }
      sqlite3BtreeRollback(p, tripCode, !schemaChange);
    }
  }
  sqlite3VtabRollback(db);
  sqlite3EndBenignMalloc();

  if( schemaChange ){
    sqlite3ExpirePreparedStatements(db, 0);
    sqlite3ResetAllSchemasOfConnection(db);
  }
  sqlite3BtreeLeaveAll(db);


  db->nDeferredCons = 0;
  db->nDeferredImmCons = 0;
  db->flags &= ~(u64)(0x00080000|((u64)(0x00002)<<32));


  if( db->xRollbackCallback && (inTrans || !db->autoCommit) ){
    db->xRollbackCallback(db->pRollbackArg);
  }
}
# 186528 "c_tests/sqlite3.c"
static const char *sqlite3ErrStr(int rc){
  static const char* const aMsg[] = {
                             "not an error",
                             "SQL logic error",
                             0,
                             "access permission denied",
                             "query aborted",
                             "database is locked",
                             "database table is locked",
                             "out of memory",
                             "attempt to write a readonly database",
                             "interrupted",
                             "disk I/O error",
                             "database disk image is malformed",
                             "unknown operation",
                             "database or disk is full",
                             "unable to open database file",
                             "locking protocol",
                             0,
                             "database schema has changed",
                             "string or blob too big",
                             "constraint failed",
                             "datatype mismatch",
                             "bad parameter or other API misuse",



                             0,

                             "authorization denied",
                             0,
                             "column index out of range",
                             "file is not a database",
                             "notification message",
                             "warning message",
  };
  const char *zErr = "unknown error";
  switch( rc ){
    case (4 | (2<<8)): {
      zErr = "abort due to ROLLBACK";
      break;
    }
    case 100: {
      zErr = "another row available";
      break;
    }
    case 101: {
      zErr = "no more rows available";
      break;
    }
    default: {
      rc &= 0xff;
      if( (rc>=0) && rc<((int)(sizeof(aMsg)/sizeof(aMsg[0]))) && aMsg[rc]!=0 ){
        zErr = aMsg[rc];
      }
      break;
    }
  }
  return zErr;
}
# 186598 "c_tests/sqlite3.c"
static int sqliteDefaultBusyCallback(
  void *ptr,
  int count
){



  static const u8 delays[] =
     { 1, 2, 5, 10, 15, 20, 25, 25, 25, 50, 50, 100 };
  static const u8 totals[] =
     { 0, 1, 3, 8, 18, 33, 53, 78, 103, 128, 178, 228 };

  sqlite3 *db = (sqlite3 *)ptr;
  int tmout = db->busyTimeout;
  int delay, prior;

  ((void) (0));
  if( count < ((int)(sizeof(delays)/sizeof(delays[0]))) ){
    delay = delays[count];
    prior = totals[count];
  }else{
    delay = delays[((int)(sizeof(delays)/sizeof(delays[0])))-1];
    prior = totals[((int)(sizeof(delays)/sizeof(delays[0])))-1] + delay*(count-(((int)(sizeof(delays)/sizeof(delays[0])))-1));
  }
  if( prior + delay > tmout ){
    delay = tmout - prior;
    if( delay<=0 ) return 0;
  }
  sqlite3OsSleep(db->pVfs, delay*1000);
  return 1;
# 186639 "c_tests/sqlite3.c"
}
# 186650 "c_tests/sqlite3.c"
static int sqlite3InvokeBusyHandler(BusyHandler *p){
  int rc;
  if( p->xBusyHandler==0 || p->nBusy<0 ) return 0;
  rc = p->xBusyHandler(p->pBusyArg, p->nBusy);
  if( rc==0 ){
    p->nBusy = -1;
  }else{
    p->nBusy++;
  }
  return rc;
}





           int sqlite3_busy_handler(
  sqlite3 *db,
  int (*xBusy)(void*,int),
  void *pArg
){



  sqlite3_mutex_enter(db->mutex);
  db->busyHandler.xBusyHandler = xBusy;
  db->busyHandler.pBusyArg = pArg;
  db->busyHandler.nBusy = 0;
  db->busyTimeout = 0;



  sqlite3_mutex_leave(db->mutex);
  return 0;
}







           void sqlite3_progress_handler(
  sqlite3 *db,
  int nOps,
  int (*xProgress)(void*),
  void *pArg
){






  sqlite3_mutex_enter(db->mutex);
  if( nOps>0 ){
    db->xProgress = xProgress;
    db->nProgressOps = (unsigned)nOps;
    db->pProgressArg = pArg;
  }else{
    db->xProgress = 0;
    db->nProgressOps = 0;
    db->pProgressArg = 0;
  }
  sqlite3_mutex_leave(db->mutex);
}







           int sqlite3_busy_timeout(sqlite3 *db, int ms){



  if( ms>0 ){
    sqlite3_busy_handler(db, (int(*)(void*,int))sqliteDefaultBusyCallback,
                             (void*)db);
    db->busyTimeout = ms;



  }else{
    sqlite3_busy_handler(db, 0, 0);
  }
  return 0;
}




           int sqlite3_setlk_timeout(sqlite3 *db, int ms, int flags){







  if( ms<-1 ) return 25;
# 186768 "c_tests/sqlite3.c"
  (void)(db);
  (void)(flags);

  return 0;
}




           void sqlite3_interrupt(sqlite3 *db){
# 186786 "c_tests/sqlite3.c"
  __atomic_store_n((&db->u1.isInterrupted),(1),0);
}





           int sqlite3_is_interrupted(sqlite3 *db){
# 186802 "c_tests/sqlite3.c"
  return __atomic_load_n((&db->u1.isInterrupted),0)!=0;
}







static int sqlite3CreateFunc(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int enc,
  void *pUserData,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*),
  void (*xValue)(sqlite3_context*),
  void (*xInverse)(sqlite3_context*,int,sqlite3_value **),
  FuncDestructor *pDestructor
){
  FuncDef *p;
  int extraFlags;

  ((void) (0));
  ((void) (0));
  if( zFunctionName==0
   || (xSFunc!=0 && xFinal!=0)
   || ((xFinal==0)!=(xStep==0))
   || ((xValue==0)!=(xInverse==0))
   || (nArg<-1 || nArg>1000)
   || (255<sqlite3Strlen30(zFunctionName))
  ){
    return sqlite3MisuseError(186836);
  }

  ((void) (0));
  ((void) (0));
  extraFlags = enc & (0x000000800|0x000080000|
                       0x000100000|0x000200000|
                       0x001000000|0x002000000);
  enc &= (0x0003|5);



  ((void) (0));
  extraFlags ^= 0x00200000;
# 186860 "c_tests/sqlite3.c"
  switch( enc ){
    case 4:
      enc = 2;
      break;
    case 5: {
      int rc;
      rc = sqlite3CreateFunc(db, zFunctionName, nArg,
           (1|extraFlags)^0x00200000,
           pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor);
      if( rc==0 ){
        rc = sqlite3CreateFunc(db, zFunctionName, nArg,
             (2|extraFlags)^0x00200000,
             pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor);
      }
      if( rc!=0 ){
        return rc;
      }
      enc = 3;
      break;
    }
    case 1:
    case 2:
    case 3:
      break;
    default:
      enc = 1;
      break;
  }
# 186897 "c_tests/sqlite3.c"
  p = sqlite3FindFunction(db, zFunctionName, nArg, (u8)enc, 0);
  if( p && (p->funcFlags & 0x0003)==(u32)enc && p->nArg==nArg ){
    if( db->nVdbeActive ){
      sqlite3ErrorWithMsg(db, 5,
        "unable to delete/modify user-function due to active statements");
      ((void) (0));
      return 5;
    }else{
      sqlite3ExpirePreparedStatements(db, 0);
    }
  }else if( xSFunc==0 && xFinal==0 ){


    return 0;
  }

  p = sqlite3FindFunction(db, zFunctionName, nArg, (u8)enc, 1);
  ((void) (0));
  if( !p ){
    return 7;
  }



  functionDestroy(db, p);

  if( pDestructor ){
    pDestructor->nRef++;
  }
  p->u.pDestructor = pDestructor;
  p->funcFlags = (p->funcFlags & 0x0003) | extraFlags;
                                                 ;
                                              ;
  p->xSFunc = xSFunc ? xSFunc : xStep;
  p->xFinalize = xFinal;
  p->xValue = xValue;
  p->xInverse = xInverse;
  p->pUserData = pUserData;
  p->nArg = (u16)nArg;
  return 0;
}
# 186946 "c_tests/sqlite3.c"
static int createFunctionApi(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*),
  void (*xValue)(sqlite3_context*),
  void (*xInverse)(sqlite3_context*,int,sqlite3_value**),
  void(*xDestroy)(void*)
){
  int rc = 1;
  FuncDestructor *pArg = 0;






  sqlite3_mutex_enter(db->mutex);
  if( xDestroy ){
    pArg = (FuncDestructor *)sqlite3Malloc(sizeof(FuncDestructor));
    if( !pArg ){
      sqlite3OomFault(db);
      xDestroy(p);
      goto out;
    }
    pArg->nRef = 0;
    pArg->xDestroy = xDestroy;
    pArg->pUserData = p;
  }
  rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p,
      xSFunc, xStep, xFinal, xValue, xInverse, pArg
  );
  if( pArg && pArg->nRef==0 ){
    ((void) (0));
    xDestroy(p);
    sqlite3_free(pArg);
  }

 out:
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}




           int sqlite3_create_function(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*)
){
  return createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep,
                                    xFinal, 0, 0, 0);
}
           int sqlite3_create_function_v2(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*),
  void (*xDestroy)(void *)
){
  return createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep,
                                    xFinal, 0, 0, xDestroy);
}
           int sqlite3_create_window_function(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*),
  void (*xValue)(sqlite3_context*),
  void (*xInverse)(sqlite3_context*,int,sqlite3_value **),
  void (*xDestroy)(void *)
){
  return createFunctionApi(db, zFunc, nArg, enc, p, 0, xStep,
                                    xFinal, xValue, xInverse, xDestroy);
}


           int sqlite3_create_function16(
  sqlite3 *db,
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void *p,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
){
  int rc;
  char *zFunc8;




  sqlite3_mutex_enter(db->mutex);
  ((void) (0));
  zFunc8 = sqlite3Utf16to8(db, zFunctionName, -1, 2);
  rc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xSFunc,xStep,xFinal,0,0,0);
  sqlite3DbFree(db, zFunc8);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 187077 "c_tests/sqlite3.c"
static void sqlite3InvalidFunction(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  const char *zName = (const char*)sqlite3_user_data(context);
  char *zErr;
  (void)(NotUsed),(void)(NotUsed2);
  zErr = sqlite3_mprintf(
      "unable to use function %s in the requested context", zName);
  sqlite3_result_error(context, zErr, -1);
  sqlite3_free(zErr);
}
# 187103 "c_tests/sqlite3.c"
           int sqlite3_overload_function(
  sqlite3 *db,
  const char *zName,
  int nArg
){
  int rc;
  char *zCopy;






  sqlite3_mutex_enter(db->mutex);
  rc = sqlite3FindFunction(db, zName, nArg, 1, 0)!=0;
  sqlite3_mutex_leave(db->mutex);
  if( rc ) return 0;
  zCopy = sqlite3_mprintf("%s", zName);
  if( zCopy==0 ) return 7;
  return sqlite3_create_function_v2(db, zName, nArg, 1,
                           zCopy, sqlite3InvalidFunction, 0, 0, sqlite3_free);
}
# 187136 "c_tests/sqlite3.c"
           void *sqlite3_trace(sqlite3 *db, void(*xTrace)(void*,const char*), void *pArg){
  void *pOld;







  sqlite3_mutex_enter(db->mutex);
  pOld = db->pTraceArg;
  db->mTrace = xTrace ? 0x40 : 0;
  db->trace.xLegacy = xTrace;
  db->pTraceArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return pOld;
}




           int sqlite3_trace_v2(
  sqlite3 *db,
  unsigned mTrace,
  int(*xTrace)(unsigned,void*,void*,void*),
  void *pArg
){





  sqlite3_mutex_enter(db->mutex);
  if( mTrace==0 ) xTrace = 0;
  if( xTrace==0 ) mTrace = 0;
  db->mTrace = mTrace;
  db->trace.xV2 = xTrace;
  db->pTraceArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return 0;
}
# 187187 "c_tests/sqlite3.c"
           void *sqlite3_profile(
  sqlite3 *db,
  void (*xProfile)(void*,const char*,sqlite_uint64),
  void *pArg
){
  void *pOld;







  sqlite3_mutex_enter(db->mutex);
  pOld = db->pProfileArg;
  db->xProfile = xProfile;
  db->pProfileArg = pArg;
  db->mTrace &= 0x0f;
  if( db->xProfile ) db->mTrace |= 0x80;
  sqlite3_mutex_leave(db->mutex);
  return pOld;
}
# 187217 "c_tests/sqlite3.c"
           void *sqlite3_commit_hook(
  sqlite3 *db,
  int (*xCallback)(void*),
  void *pArg
){
  void *pOld;







  sqlite3_mutex_enter(db->mutex);
  pOld = db->pCommitArg;
  db->xCommitCallback = xCallback;
  db->pCommitArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return pOld;
}





           void *sqlite3_update_hook(
  sqlite3 *db,
  void (*xCallback)(void*,int,char const *,char const *,sqlite_int64),
  void *pArg
){
  void *pRet;







  sqlite3_mutex_enter(db->mutex);
  pRet = db->pUpdateArg;
  db->xUpdateCallback = xCallback;
  db->pUpdateArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return pRet;
}





           void *sqlite3_rollback_hook(
  sqlite3 *db,
  void (*xCallback)(void*),
  void *pArg
){
  void *pRet;







  sqlite3_mutex_enter(db->mutex);
  pRet = db->pRollbackArg;
  db->xRollbackCallback = xCallback;
  db->pRollbackArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return pRet;
}
# 187319 "c_tests/sqlite3.c"
           int sqlite3_autovacuum_pages(
  sqlite3 *db,
  unsigned int (*xCallback)(void*,const char*,u32,u32,u32),
  void *pArg,
  void (*xDestructor)(void*)
){






  sqlite3_mutex_enter(db->mutex);
  if( db->xAutovacDestr ){
    db->xAutovacDestr(db->pAutovacPagesArg);
  }
  db->xAutovacPages = xCallback;
  db->pAutovacPagesArg = pArg;
  db->xAutovacDestr = xDestructor;
  sqlite3_mutex_leave(db->mutex);
  return 0;
}
# 187350 "c_tests/sqlite3.c"
static int sqlite3WalDefaultHook(
  void *pClientData,
  sqlite3 *db,
  const char *zDb,
  int nFrame
){
  if( nFrame>=((int)(long int)(pClientData)) ){
    sqlite3BeginBenignMalloc();
    sqlite3_wal_checkpoint(db, zDb);
    sqlite3EndBenignMalloc();
  }
  return 0;
}
# 187376 "c_tests/sqlite3.c"
           int sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame){







  if( nFrame>0 ){
    sqlite3_wal_hook(db, sqlite3WalDefaultHook, ((void*)(long int)(nFrame)));
  }else{
    sqlite3_wal_hook(db, 0, 0);
  }

  return 0;
}





           void *sqlite3_wal_hook(
  sqlite3 *db,
  int(*xCallback)(void *, sqlite3*, const char*, int),
  void *pArg
){

  void *pRet;






  sqlite3_mutex_enter(db->mutex);
  pRet = db->pWalArg;
  db->xWalCallback = xCallback;
  db->pWalArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return pRet;



}




           int sqlite3_wal_checkpoint_v2(
  sqlite3 *db,
  const char *zDb,
  int eMode,
  int *pnLog,
  int *pnCkpt
){



  int rc;
  int iDb;






  if( pnLog ) *pnLog = -1;
  if( pnCkpt ) *pnCkpt = -1;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( eMode<0 || eMode>3 ){


    return sqlite3MisuseError(187452);
  }

  sqlite3_mutex_enter(db->mutex);
  if( zDb && zDb[0] ){
    iDb = sqlite3FindDbName(db, zDb);
  }else{
    iDb = (10 +2);
  }
  if( iDb<0 ){
    rc = 1;
    sqlite3ErrorWithMsg(db, 1, "unknown database: %s", zDb);
  }else{
    db->busyHandler.nBusy = 0;
    rc = sqlite3Checkpoint(db, iDb, eMode, pnLog, pnCkpt);
    sqlite3Error(db, rc);
  }
  rc = sqlite3ApiExit(db, rc);



  if( db->nVdbeActive==0 ){
    __atomic_store_n((&db->u1.isInterrupted),(0),0);
  }

  sqlite3_mutex_leave(db->mutex);
  return rc;

}







           int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb){


  return sqlite3_wal_checkpoint_v2(db,zDb,0,0,0);
}
# 187515 "c_tests/sqlite3.c"
static int sqlite3Checkpoint(sqlite3 *db, int iDb, int eMode, int *pnLog, int *pnCkpt){
  int rc = 0;
  int i;
  int bBusy = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
                                      ;
                                ;

  for(i=0; i<db->nDb && rc==0; i++){
    if( i==iDb || iDb==(10 +2) ){
      rc = sqlite3BtreeCheckpoint(db->aDb[i].pBt, eMode, pnLog, pnCkpt);
      pnLog = 0;
      pnCkpt = 0;
      if( rc==5 ){
        bBusy = 1;
        rc = 0;
      }
    }
  }

  return (rc==0 && bBusy) ? 5 : rc;
}
# 187561 "c_tests/sqlite3.c"
static int sqlite3TempInMemory(const sqlite3 *db){

  return ( db->temp_store==2 );
# 187576 "c_tests/sqlite3.c"
}





           const char *sqlite3_errmsg(sqlite3 *db){
  const char *z;
  if( !db ){
    return sqlite3ErrStr(7);
  }
  if( !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3ErrStr(sqlite3MisuseError(187588));
  }
  sqlite3_mutex_enter(db->mutex);
  if( db->mallocFailed ){
    z = sqlite3ErrStr(7);
  }else{
                           ;
    z = db->errCode ? (char*)sqlite3_value_text(db->pErr) : 0;
    ((void) (0));
    if( z==0 ){
      z = sqlite3ErrStr(db->errCode);
    }
  }
  sqlite3_mutex_leave(db->mutex);
  return z;
}
# 187612 "c_tests/sqlite3.c"
           int sqlite3_set_errmsg(sqlite3 *db, int errcode, const char *zMsg){
  int rc = 0;
  if( !sqlite3SafetyCheckOk(db) ){
    return sqlite3MisuseError(187615);
  }
  sqlite3_mutex_enter(db->mutex);
  if( zMsg ){
    sqlite3ErrorWithMsg(db, errcode, "%s", zMsg);
  }else{
    sqlite3Error(db, errcode);
  }
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}




           int sqlite3_error_offset(sqlite3 *db){
  int iOffset = -1;
  if( db && sqlite3SafetyCheckSickOrOk(db) && db->errCode ){
    sqlite3_mutex_enter(db->mutex);
    iOffset = db->errByteOffset;
    sqlite3_mutex_leave(db->mutex);
  }
  return iOffset;
}






           const void *sqlite3_errmsg16(sqlite3 *db){
  static const u16 outOfMem[] = {
    'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0
  };
  static const u16 misuse[] = {
    'b', 'a', 'd', ' ', 'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', ' ',
    'o', 'r', ' ', 'o', 't', 'h', 'e', 'r', ' ', 'A', 'P', 'I', ' ',
    'm', 'i', 's', 'u', 's', 'e', 0
  };

  const void *z;
  if( !db ){
    return (void *)outOfMem;
  }
  if( !sqlite3SafetyCheckSickOrOk(db) ){
    return (void *)misuse;
  }
  sqlite3_mutex_enter(db->mutex);
  if( db->mallocFailed ){
    z = (void *)outOfMem;
  }else{
    z = sqlite3_value_text16(db->pErr);
    if( z==0 ){
      sqlite3ErrorWithMsg(db, db->errCode, sqlite3ErrStr(db->errCode));
      z = sqlite3_value_text16(db->pErr);
    }





    sqlite3OomClear(db);
  }
  sqlite3_mutex_leave(db->mutex);
  return z;
}






           int sqlite3_errcode(sqlite3 *db){
  if( db && !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3MisuseError(187690);
  }
  if( !db || db->mallocFailed ){
    return 7;
  }
  return db->errCode & db->errMask;
}
           int sqlite3_extended_errcode(sqlite3 *db){
  if( db && !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3MisuseError(187699);
  }
  if( !db || db->mallocFailed ){
    return 7;
  }
  return db->errCode;
}
           int sqlite3_system_errno(sqlite3 *db){
  return db ? db->iSysErrno : 0;
}






           const char *sqlite3_errstr(int rc){
  return sqlite3ErrStr(rc);
}





static int createCollation(
  sqlite3* db,
  const char *zName,
  u8 enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDel)(void*)
){
  CollSeq *pColl;
  int enc2;

  ((void) (0));





  enc2 = enc;
                                ;
                                        ;
  if( enc2==4 || enc2==8 ){
    enc2 = 2;
  }
  if( enc2<1 || enc2>3 ){
    return sqlite3MisuseError(187747);
  }





  pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 0);
  if( pColl && pColl->xCmp ){
    if( db->nVdbeActive ){
      sqlite3ErrorWithMsg(db, 5,
        "unable to delete/modify collation sequence due to active statements");
      return 5;
    }
    sqlite3ExpirePreparedStatements(db, 0);







    if( (pColl->enc & ~8)==enc2 ){
      CollSeq *aColl = sqlite3HashFind(&db->aCollSeq, zName);
      int j;
      for(j=0; j<3; j++){
        CollSeq *p = &aColl[j];
        if( p->enc==pColl->enc ){
          if( p->xDel ){
            p->xDel(p->pUser);
          }
          p->xCmp = 0;
        }
      }
    }
  }

  pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 1);
  if( pColl==0 ) return 7;
  pColl->xCmp = xCompare;
  pColl->pUser = pCtx;
  pColl->xDel = xDel;
  pColl->enc = (u8)(enc2 | (enc & 8));
  sqlite3Error(db, 0);
  return 0;
}







static const int aHardLimit[] = {
  1000000000,
  1000000000,
  2000,
  1000,
  500,
  250000000,
  1000,
  10,
  50000,
  32766,
  1000,
  8,
};
# 187863 "c_tests/sqlite3.c"
           int sqlite3_limit(sqlite3 *db, int limitId, int newLimit){
  int oldLimit;
# 187878 "c_tests/sqlite3.c"
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  if( limitId<0 || limitId>=(11 +1) ){
    return -1;
  }
  oldLimit = db->aLimit[limitId];
  if( newLimit>=0 ){
    if( newLimit>aHardLimit[limitId] ){
      newLimit = aHardLimit[limitId];
    }else if( newLimit<30 && limitId==0 ){
      newLimit = 30;
    }
    db->aLimit[limitId] = newLimit;
  }
  return oldLimit;
}
# 187935 "c_tests/sqlite3.c"
static int sqlite3ParseUri(
  const char *zDefaultVfs,
  const char *zUri,
  unsigned int *pFlags,
  sqlite3_vfs **ppVfs,
  char **pzFile,
  char **pzErrMsg
){
  int rc = 0;
  unsigned int flags = *pFlags;
  const char *zVfs = zDefaultVfs;
  char *zFile;
  char c;
  int nUri = sqlite3Strlen30(zUri);

  ((void) (0));

  if( ((flags & 0x00000040)
       || __atomic_load_n((&sqlite3Config.bOpenUri),0))
   && nUri>=5 && memcmp(zUri, "file:", 5)==0
  ){
    char *zOpt;
    int eState;
    int iIn;
    int iOut = 0;
    u64 nByte = nUri+8;



    flags |= 0x00000040;

    for(iIn=0; iIn<nUri; iIn++) nByte += (zUri[iIn]=='&');
    zFile = sqlite3_malloc64(nByte);
    if( !zFile ) return 7;

    memset(zFile, 0, 4);
    zFile += 4;

    iIn = 5;
# 187988 "c_tests/sqlite3.c"
    if( zUri[5]=='/' && zUri[6]=='/' ){
      iIn = 7;
      while( zUri[iIn] && zUri[iIn]!='/' ) iIn++;
      if( iIn!=7 && (iIn!=16 || memcmp("localhost", &zUri[7], 9)) ){
        *pzErrMsg = sqlite3_mprintf("invalid uri authority: %.*s",
            iIn-7, &zUri[7]);
        rc = 1;
        goto parse_uri_out;
      }
    }
# 188010 "c_tests/sqlite3.c"
    eState = 0;
    while( (c = zUri[iIn])!=0 && c!='#' ){
      iIn++;
      if( c=='%'
       && (sqlite3CtypeMap[(unsigned char)(zUri[iIn])]&0x08)
       && (sqlite3CtypeMap[(unsigned char)(zUri[iIn+1])]&0x08)
      ){
        int octet = (sqlite3HexToInt(zUri[iIn++]) << 4);
        octet += sqlite3HexToInt(zUri[iIn++]);

        ((void) (0));
        if( octet==0 ){





          while( (c = zUri[iIn])!=0 && c!='#'
              && (eState!=0 || c!='?')
              && (eState!=1 || (c!='=' && c!='&'))
              && (eState!=2 || c!='&')
          ){
            iIn++;
          }
          continue;






        }
        c = octet;
      }else if( eState==1 && (c=='&' || c=='=') ){
        if( zFile[iOut-1]==0 ){

          while( zUri[iIn] && zUri[iIn]!='#' && zUri[iIn-1]!='&' ) iIn++;
          continue;
        }
        if( c=='&' ){
          zFile[iOut++] = '\0';
        }else{
          eState = 2;
        }
        c = 0;
      }else if( (eState==0 && c=='?') || (eState==2 && c=='&') ){
        c = 0;
        eState = 1;
      }
      zFile[iOut++] = c;
    }
    if( eState==1 ) zFile[iOut++] = '\0';
    memset(zFile+iOut, 0, 4);





    zOpt = &zFile[sqlite3Strlen30(zFile)+1];
    while( zOpt[0] ){
      int nOpt = sqlite3Strlen30(zOpt);
      char *zVal = &zOpt[nOpt+1];
      int nVal = sqlite3Strlen30(zVal);

      if( nOpt==3 && memcmp("vfs", zOpt, 3)==0 ){
        zVfs = zVal;
      }else{
        struct OpenMode {
          const char *z;
          int mode;
        } *aMode = 0;
        char *zModeType = 0;
        int mask = 0;
        int limit = 0;

        if( nOpt==5 && memcmp("cache", zOpt, 5)==0 ){
          static struct OpenMode aCacheMode[] = {
            { "shared", 0x00020000 },
            { "private", 0x00040000 },
            { 0, 0 }
          };

          mask = 0x00020000|0x00040000;
          aMode = aCacheMode;
          limit = mask;
          zModeType = "cache";
        }
        if( nOpt==4 && memcmp("mode", zOpt, 4)==0 ){
          static struct OpenMode aOpenMode[] = {
            { "ro", 0x00000001 },
            { "rw", 0x00000002 },
            { "rwc", 0x00000002 | 0x00000004 },
            { "memory", 0x00000080 },
            { 0, 0 }
          };

          mask = 0x00000001 | 0x00000002
                   | 0x00000004 | 0x00000080;
          aMode = aOpenMode;
          limit = mask & flags;
          zModeType = "access";
        }

        if( aMode ){
          int i;
          int mode = 0;
          for(i=0; aMode[i].z; i++){
            const char *z = aMode[i].z;
            if( nVal==sqlite3Strlen30(z) && 0==memcmp(zVal, z, nVal) ){
              mode = aMode[i].mode;
              break;
            }
          }
          if( mode==0 ){
            *pzErrMsg = sqlite3_mprintf("no such %s mode: %s", zModeType, zVal);
            rc = 1;
            goto parse_uri_out;
          }
          if( (mode & ~0x00000080)>limit ){
            *pzErrMsg = sqlite3_mprintf("%s mode not allowed: %s",
                                        zModeType, zVal);
            rc = 3;
            goto parse_uri_out;
          }
          flags = (flags & ~mask) | mode;
        }
      }

      zOpt = &zVal[nVal+1];
    }

  }else{
    zFile = sqlite3_malloc64(nUri+8);
    if( !zFile ) return 7;
    memset(zFile, 0, 4);
    zFile += 4;
    if( nUri ){
      memcpy(zFile, zUri, nUri);
    }
    memset(zFile+nUri, 0, 4);
    flags &= ~0x00000040;
  }

  *ppVfs = sqlite3_vfs_find(zVfs);
  if( *ppVfs==0 ){
    *pzErrMsg = sqlite3_mprintf("no such vfs: %s", zVfs);
    rc = 1;
  }
 parse_uri_out:
  if( rc!=0 ){
    sqlite3_free_filename(zFile);
    zFile = 0;
  }
  *pFlags = flags;
  *pzFile = zFile;
  return rc;
}





static const char *uriParameter(const char *zFilename, const char *zParam){
  zFilename += sqlite3Strlen30(zFilename) + 1;
  while( (zFilename!=0) && zFilename[0] ){
    int x = strcmp(zFilename, zParam);
    zFilename += sqlite3Strlen30(zFilename) + 1;
    if( x==0 ) return zFilename;
    zFilename += sqlite3Strlen30(zFilename) + 1;
  }
  return 0;
}
# 188190 "c_tests/sqlite3.c"
static int openDatabase(
  const char *zFilename,
  sqlite3 **ppDb,
  unsigned int flags,
  const char *zVfs
){
  sqlite3 *db;
  int rc;
  int isThreadsafe;
  char *zOpen = 0;
  char *zErrMsg = 0;
  int i;




  *ppDb = 0;

  rc = sqlite3_initialize();
  if( rc ) return rc;


  if( sqlite3Config.bCoreMutex==0 ){
    isThreadsafe = 0;
  }else if( flags & 0x00008000 ){
    isThreadsafe = 0;
  }else if( flags & 0x00010000 ){
    isThreadsafe = 1;
  }else{
    isThreadsafe = sqlite3Config.bFullMutex;
  }

  if( flags & 0x00040000 ){
    flags &= ~0x00020000;
  }else if( sqlite3Config.sharedCacheEnabled ){
    flags |= 0x00020000;
  }
# 188237 "c_tests/sqlite3.c"
  flags &= ~( 0x00000008 |
               0x00000010 |
               0x00000100 |
               0x00000200 |
               0x00000400 |
               0x00000800 |
               0x00001000 |
               0x00002000 |
               0x00004000 |
               0x00008000 |
               0x00010000 |
               0x00080000
             );


  db = sqlite3MallocZero( sizeof(sqlite3) );
  if( db==0 ) goto opendb_out;
  if( isThreadsafe



  ){
    db->mutex = sqlite3MutexAlloc(1);
    if( db->mutex==0 ){
      sqlite3_free(db);
      db = 0;
      goto opendb_out;
    }
    if( isThreadsafe==0 ){
                                             ;
    }
  }
  sqlite3_mutex_enter(db->mutex);
  db->errMask = (flags & 0x02000000)!=0 ? 0xffffffff : 0xff;
  db->nDb = 2;
  db->eOpenState = 0x6d;
  db->aDb = db->aDbStatic;
  db->lookaside.bDisable = 1;
  db->lookaside.sz = 0;

  ((void) (0));
  memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit));
  db->aLimit[11] = 0;
  db->autoCommit = 1;
  db->nextAutovac = -1;
  db->szMmap = sqlite3Config.szMmap;
  db->nextPagesize = 0;
  db->init.azInit = sqlite3StdType;
# 188293 "c_tests/sqlite3.c"
  db->flags |= 0x00000040
                 | 0x00040000
                 | 0x80000000
                 | 0x00000020
                 | ((u64)(0x00010)<<32)
                 | ((u64)(0x00020)<<32)
                 | ((u64)(0x00040)<<32)

                 | 0x00000080
# 188322 "c_tests/sqlite3.c"
                 | 0x40000000


                 | 0x20000000



                 | 0x00008000
# 188367 "c_tests/sqlite3.c"
      ;
  sqlite3HashInit(&db->aCollSeq);

  sqlite3HashInit(&db->aModule);
# 188380 "c_tests/sqlite3.c"
  createCollation(db, sqlite3StrBINARY, 1, 0, binCollFunc, 0);
  createCollation(db, sqlite3StrBINARY, 3, 0, binCollFunc, 0);
  createCollation(db, sqlite3StrBINARY, 2, 0, binCollFunc, 0);
  createCollation(db, "NOCASE", 1, 0, nocaseCollatingFunc, 0);
  createCollation(db, "RTRIM", 1, 0, rtrimCollFunc, 0);
  if( db->mallocFailed ){
    goto opendb_out;
  }
# 188414 "c_tests/sqlite3.c"
  db->openFlags = flags;
  ((void) (0));
  ((void) (0));
  ((void) (0));
                                  ;
                                  ;
                                  ;
  if( ((1<<(flags&7)) & 0x46)==0 ){
    rc = sqlite3MisuseError(188422);
  }else{
    if( zFilename==0 ) zFilename = ":memory:";
    rc = sqlite3ParseUri(zVfs, zFilename, &flags, &db->pVfs, &zOpen, &zErrMsg);
  }
  if( rc!=0 ){
    if( rc==7 ) sqlite3OomFault(db);
    sqlite3ErrorWithMsg(db, rc, zErrMsg ? "%s" : 0, zErrMsg);
    sqlite3_free(zErrMsg);
    goto opendb_out;
  }
  ((void) (0));







  rc = sqlite3BtreeOpen(db->pVfs, zOpen, db, &db->aDb[0].pBt, 0,
                        flags | 0x00000100);
  if( rc!=0 ){
    if( rc==(10 | (12<<8)) ){
      rc = 7;
    }
    sqlite3Error(db, rc);
    goto opendb_out;
  }
  sqlite3BtreeEnter(db->aDb[0].pBt);
  db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt);
  if( !db->mallocFailed ){
    sqlite3SetTextEncoding(db, ((db)->aDb[0].pSchema->enc));
  }
  sqlite3BtreeLeave(db->aDb[0].pBt);
  db->aDb[1].pSchema = sqlite3SchemaGet(db, 0);




  db->aDb[0].zDbSName = "main";
  db->aDb[0].safety_level = 2 +1;
  db->aDb[1].zDbSName = "temp";
  db->aDb[1].safety_level = 0x01;

  db->eOpenState = 0x76;
  if( db->mallocFailed ){
    goto opendb_out;
  }





  sqlite3Error(db, 0);
  sqlite3RegisterPerConnectionBuiltinFunctions(db);
  rc = sqlite3_errcode(db);



  for(i=0; rc==0 && i<((int)(sizeof(sqlite3BuiltinExtensions)/sizeof(sqlite3BuiltinExtensions[0]))); i++){
    rc = sqlite3BuiltinExtensions[i](db);
  }




  if( rc==0 ){
    sqlite3AutoLoadExtensions(db);
    rc = sqlite3_errcode(db);
    if( rc!=0 ){
      goto opendb_out;
    }
  }
# 188513 "c_tests/sqlite3.c"
  if( rc ) sqlite3Error(db, rc);


  setupLookaside(db, 0, sqlite3Config.szLookaside,
                        sqlite3Config.nLookaside);

  sqlite3_wal_autocheckpoint(db, 1000);

opendb_out:
  if( db ){
    ((void) (0));

    sqlite3_mutex_leave(db->mutex);
  }
  rc = sqlite3_errcode(db);
  ((void) (0));
  if( (rc&0xff)==7 ){
    sqlite3_close(db);
    db = 0;
  }else if( rc!=0 ){
    db->eOpenState = 0xba;
  }
  *ppDb = db;







  sqlite3_free_filename(zOpen);
  return rc;
}





           int sqlite3_open(
  const char *zFilename,
  sqlite3 **ppDb
){
  return openDatabase(zFilename, ppDb,
                      0x00000002 | 0x00000004, 0);
}
           int sqlite3_open_v2(
  const char *filename,
  sqlite3 **ppDb,
  int flags,
  const char *zVfs
){
  return openDatabase(filename, ppDb, (unsigned int)flags, zVfs);
}





           int sqlite3_open16(
  const void *zFilename,
  sqlite3 **ppDb
){
  char const *zFilename8;
  sqlite3_value *pVal;
  int rc;




  *ppDb = 0;

  rc = sqlite3_initialize();
  if( rc ) return rc;

  if( zFilename==0 ) zFilename = "\000\000";
  pVal = sqlite3ValueNew(0);
  sqlite3ValueSetStr(pVal, -1, zFilename, 2, ((sqlite3_destructor_type)0));
  zFilename8 = sqlite3ValueText(pVal, 1);
  if( zFilename8 ){
    rc = openDatabase(zFilename8, ppDb,
                      0x00000002 | 0x00000004, 0);
    ((void) (0));
    if( rc==0 && !(((*ppDb)->aDb[0].pSchema->schemaFlags&(0x0001))==(0x0001)) ){
      ((*ppDb)->aDb[0].pSchema->enc) = ((*ppDb)->enc) = 2;
    }
  }else{
    rc = 7;
  }
  sqlite3ValueFree(pVal);

  return rc & 0xff;
}





           int sqlite3_create_collation(
  sqlite3* db,
  const char *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*)
){
  return sqlite3_create_collation_v2(db, zName, enc, pCtx, xCompare, 0);
}




           int sqlite3_create_collation_v2(
  sqlite3* db,
  const char *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDel)(void*)
){
  int rc;




  sqlite3_mutex_enter(db->mutex);
  ((void) (0));
  rc = createCollation(db, zName, (u8)enc, pCtx, xCompare, xDel);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}





           int sqlite3_create_collation16(
  sqlite3* db,
  const void *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*)
){
  int rc = 0;
  char *zName8;




  sqlite3_mutex_enter(db->mutex);
  ((void) (0));
  zName8 = sqlite3Utf16to8(db, zName, -1, 2);
  if( zName8 ){
    rc = createCollation(db, zName8, (u8)enc, pCtx, xCompare, 0);
    sqlite3DbFree(db, zName8);
  }
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}






           int sqlite3_collation_needed(
  sqlite3 *db,
  void *pCollNeededArg,
  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*)
){



  sqlite3_mutex_enter(db->mutex);
  db->xCollNeeded = xCollNeeded;
  db->xCollNeeded16 = 0;
  db->pCollNeededArg = pCollNeededArg;
  sqlite3_mutex_leave(db->mutex);
  return 0;
}






           int sqlite3_collation_needed16(
  sqlite3 *db,
  void *pCollNeededArg,
  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*)
){



  sqlite3_mutex_enter(db->mutex);
  db->xCollNeeded = 0;
  db->xCollNeeded16 = xCollNeeded16;
  db->pCollNeededArg = pCollNeededArg;
  sqlite3_mutex_leave(db->mutex);
  return 0;
}





           void *sqlite3_get_clientdata(sqlite3 *db, const char *zName){
  DbClientData *p;
  sqlite3_mutex_enter(db->mutex);
  for(p=db->pDbData; p; p=p->pNext){
    if( strcmp(p->zName, zName)==0 ){
      void *pResult = p->pData;
      sqlite3_mutex_leave(db->mutex);
      return pResult;
    }
  }
  sqlite3_mutex_leave(db->mutex);
  return 0;
}




           int sqlite3_set_clientdata(
  sqlite3 *db,
  const char *zName,
  void *pData,
  void (*xDestructor)(void*)
){
  DbClientData *p, **pp;
  sqlite3_mutex_enter(db->mutex);
  pp = &db->pDbData;
  for(p=db->pDbData; p && strcmp(p->zName,zName); p=p->pNext){
    pp = &p->pNext;
  }
  if( p ){
    ((void) (0));
    if( p->xDestructor ) p->xDestructor(p->pData);
    if( pData==0 ){
      *pp = p->pNext;
      sqlite3_free(p);
      sqlite3_mutex_leave(db->mutex);
      return 0;
    }
  }else if( pData==0 ){
    sqlite3_mutex_leave(db->mutex);
    return 0;
  }else{
    size_t n = strlen(zName);
    p = sqlite3_malloc64( (__builtin_offsetof(DbClientData, zName)+(n+1)) );
    if( p==0 ){
      if( xDestructor ) xDestructor(pData);
      sqlite3_mutex_leave(db->mutex);
      return 7;
    }
    memcpy(p->zName, zName, n+1);
    p->pNext = db->pDbData;
    db->pDbData = p;
  }
  p->pData = pData;
  p->xDestructor = xDestructor;
  sqlite3_mutex_leave(db->mutex);
  return 0;
}







           int sqlite3_global_recover(void){
  return 0;
}
# 188795 "c_tests/sqlite3.c"
           int sqlite3_get_autocommit(sqlite3 *db){






  return db->autoCommit;
}
# 188816 "c_tests/sqlite3.c"
static int sqlite3ReportError(int iErr, int lineno, const char *zType){
  sqlite3_log(iErr, "%s at line %d of [%.10s]",
              zType, lineno, 20+sqlite3_sourceid());
  return iErr;
}
static int sqlite3CorruptError(int lineno){
                                         ;
  return sqlite3ReportError(11, lineno, "database corruption");
}
static int sqlite3MisuseError(int lineno){
                                         ;
  return sqlite3ReportError(21, lineno, "misuse");
}
static int sqlite3CantopenError(int lineno){
                                         ;
  return sqlite3ReportError(14, lineno, "cannot open file");
}
# 188860 "c_tests/sqlite3.c"
           void sqlite3_thread_cleanup(void){
}






           int sqlite3_table_column_metadata(
  sqlite3 *db,
  const char *zDbName,
  const char *zTableName,
  const char *zColumnName,
  char const **pzDataType,
  char const **pzCollSeq,
  int *pNotNull,
  int *pPrimaryKey,
  int *pAutoinc
){
  int rc;
  char *zErrMsg = 0;
  Table *pTab = 0;
  Column *pCol = 0;
  int iCol = 0;
  char const *zDataType = 0;
  char const *zCollSeq = 0;
  int notnull = 0;
  int primarykey = 0;
  int autoinc = 0;
# 188898 "c_tests/sqlite3.c"
  sqlite3_mutex_enter(db->mutex);
  sqlite3BtreeEnterAll(db);
  rc = sqlite3Init(db, &zErrMsg);
  if( 0!=rc ){
    goto error_out;
  }


  pTab = sqlite3FindTable(db, zTableName, zDbName);
  if( !pTab || ((pTab)->eTabType==2) ){
    pTab = 0;
    goto error_out;
  }


  if( zColumnName==0 ){

  }else{
    iCol = sqlite3ColumnIndex(pTab, zColumnName);
    if( iCol>=0 ){
      pCol = &pTab->aCol[iCol];
    }else{
      if( (((pTab)->tabFlags & 0x00000080)==0) && sqlite3IsRowid(zColumnName) ){
        iCol = pTab->iPKey;
        pCol = iCol>=0 ? &pTab->aCol[iCol] : 0;
      }else{
        pTab = 0;
        goto error_out;
      }
    }
  }
# 188940 "c_tests/sqlite3.c"
  if( pCol ){
    zDataType = sqlite3ColumnType(pCol,0);
    zCollSeq = sqlite3ColumnColl(pCol);
    notnull = pCol->notNull!=0;
    primarykey = (pCol->colFlags & 0x0001)!=0;
    autoinc = pTab->iPKey==iCol && (pTab->tabFlags & 0x00000008)!=0;
  }else{
    zDataType = "INTEGER";
    primarykey = 1;
  }
  if( !zCollSeq ){
    zCollSeq = sqlite3StrBINARY;
  }

error_out:
  sqlite3BtreeLeaveAll(db);





  if( pzDataType ) *pzDataType = zDataType;
  if( pzCollSeq ) *pzCollSeq = zCollSeq;
  if( pNotNull ) *pNotNull = notnull;
  if( pPrimaryKey ) *pPrimaryKey = primarykey;
  if( pAutoinc ) *pAutoinc = autoinc;

  if( 0==rc && !pTab ){
    sqlite3DbFree(db, zErrMsg);
    zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName,
        zColumnName);
    rc = 1;
  }
  sqlite3ErrorWithMsg(db, rc, (zErrMsg?"%s":0), zErrMsg);
  sqlite3DbFree(db, zErrMsg);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}




           int sqlite3_sleep(int ms){
  sqlite3_vfs *pVfs;
  int rc;
  pVfs = sqlite3_vfs_find(0);
  if( pVfs==0 ) return 0;




  rc = (sqlite3OsSleep(pVfs, ms<0 ? 0 : 1000*ms)/1000);
  return rc;
}




           int sqlite3_extended_result_codes(sqlite3 *db, int onoff){



  sqlite3_mutex_enter(db->mutex);
  db->errMask = onoff ? 0xffffffff : 0xff;
  sqlite3_mutex_leave(db->mutex);
  return 0;
}




           int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){
  int rc = 1;
  Btree *pBtree;




  sqlite3_mutex_enter(db->mutex);
  pBtree = sqlite3DbNameToBtree(db, zDbName);
  if( pBtree ){
    Pager *pPager;
    sqlite3_file *fd;
    sqlite3BtreeEnter(pBtree);
    pPager = sqlite3BtreePager(pBtree);
    ((void) (0));
    fd = sqlite3PagerFile(pPager);
    ((void) (0));
    if( op==7 ){
      *(sqlite3_file**)pArg = fd;
      rc = 0;
    }else if( op==27 ){
      *(sqlite3_vfs**)pArg = sqlite3PagerVfs(pPager);
      rc = 0;
    }else if( op==28 ){
      *(sqlite3_file**)pArg = sqlite3PagerJrnlFile(pPager);
      rc = 0;
    }else if( op==35 ){
      *(unsigned int*)pArg = sqlite3PagerDataVersion(pPager);
      rc = 0;
    }else if( op==38 ){
      int iNew = *(int*)pArg;
      *(int*)pArg = sqlite3BtreeGetRequestedReserve(pBtree);
      if( iNew>=0 && iNew<=255 ){
        sqlite3BtreeSetPageSize(pBtree, 0, iNew, 0);
      }
      rc = 0;
    }else if( op==42 ){
      sqlite3BtreeClearCache(pBtree);
      rc = 0;
    }else{
      int nSave = db->busyHandler.nBusy;
      rc = sqlite3OsFileControl(fd, op, pArg);
      db->busyHandler.nBusy = nSave;
    }
    sqlite3BtreeLeave(pBtree);
  }
  sqlite3_mutex_leave(db->mutex);
  return rc;
}




           int sqlite3_test_control(int op, ...){
  int rc = 0;



  va_list ap;
  __builtin_va_start(ap, op);
  switch( op ){




    case 5: {
      sqlite3PrngSaveState();
      break;
    }






    case 6: {
      sqlite3PrngRestoreState();
      break;
    }
# 189113 "c_tests/sqlite3.c"
    case 28: {
      int x = __builtin_va_arg(ap, int);
      int y;
      sqlite3 *db = __builtin_va_arg(ap, sqlite3*);
      ((void) (0));
      if( db && (y = db->aDb[0].pSchema->schema_cookie)!=0 ){ x = y; }
      sqlite3Config.iPrngSeed = x;
      sqlite3_randomness(0,0);
      break;
    }
# 189136 "c_tests/sqlite3.c"
    case 7: {
      sqlite3 *db = __builtin_va_arg(ap, sqlite3*);
      int b = __builtin_va_arg(ap, int);
      if( b ){
        db->flags |= ((u64)(0x00008)<<32);
      }else{
        db->flags &= ~((u64)(0x00008)<<32);
      }
      break;
    }
# 189155 "c_tests/sqlite3.c"
    case 8: {
      int sz = __builtin_va_arg(ap, int);
      int *aProg = __builtin_va_arg(ap, int*);
      rc = sqlite3BitvecBuiltinTest(sz, aProg);
      break;
    }
# 189173 "c_tests/sqlite3.c"
    case 9: {
# 189182 "c_tests/sqlite3.c"
      typedef int(*sqlite3FaultFuncType)(int);
      sqlite3Config.xTestCallback = __builtin_va_arg(ap, sqlite3FaultFuncType);
      rc = sqlite3FaultSim(0);
      break;
    }







    case 10: {
      typedef void (*void_function)(void);
      void_function xBenignBegin;
      void_function xBenignEnd;
      xBenignBegin = __builtin_va_arg(ap, void_function);
      xBenignEnd = __builtin_va_arg(ap, void_function);
      sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);
      break;
    }
# 189216 "c_tests/sqlite3.c"
    case 11: {
      rc = sqlite3PendingByte;

      {
        unsigned int newVal = __builtin_va_arg(ap, unsigned int);
        if( newVal ) sqlite3PendingByte = newVal;
      }

      break;
    }
# 189238 "c_tests/sqlite3.c"
    case 12: {
      volatile int x = 0;
      ((void) (0));
      rc = x;
# 189265 "c_tests/sqlite3.c"
      break;
    }
# 189296 "c_tests/sqlite3.c"
    case 13: {
      int x = __builtin_va_arg(ap, int);
      rc = x ? (x) : 0;
      break;
    }
# 189313 "c_tests/sqlite3.c"
    case 22: {
      rc = 1234*100 + 1*10 + 0;
      break;
    }
# 189327 "c_tests/sqlite3.c"
    case 15: {
      sqlite3 *db = __builtin_va_arg(ap, sqlite3*);
      db->dbOptFlags = __builtin_va_arg(ap, u32);
      break;
    }






    case 16: {
      sqlite3 *db = __builtin_va_arg(ap, sqlite3*);
      int *pN = __builtin_va_arg(ap, int*);
      *pN = db->dbOptFlags;
      break;
    }
# 189358 "c_tests/sqlite3.c"
    case 18: {
      sqlite3Config.bLocaltimeFault = __builtin_va_arg(ap, int);
      if( sqlite3Config.bLocaltimeFault==2 ){
        typedef int(*sqlite3LocaltimeType)(const void*,void*);
        sqlite3Config.xAltLocaltime = __builtin_va_arg(ap, sqlite3LocaltimeType);
      }else{
        sqlite3Config.xAltLocaltime = 0;
      }
      break;
    }






    case 17: {
      sqlite3 *db = __builtin_va_arg(ap, sqlite3*);
      db->mDbFlags ^= 0x0020;
      break;
    }
# 189388 "c_tests/sqlite3.c"
    case 20: {
      sqlite3Config.neverCorrupt = __builtin_va_arg(ap, int);
      break;
    }
# 189405 "c_tests/sqlite3.c"
    case 29: {
      sqlite3Config.bExtraSchemaChecks = __builtin_va_arg(ap, int);
      break;
    }






    case 19: {
      sqlite3Config.iOnceResetThreshold = __builtin_va_arg(ap, int);
      break;
    }






    case 21: {






      break;
    }


    case 24: {
      sqlite3 *db = __builtin_va_arg(ap, sqlite3*);
      db->nMaxSorterMmap = __builtin_va_arg(ap, int);
      break;
    }






    case 23: {
      if( sqlite3Config.isInit==0 ) rc = 1;
      break;
    }
# 189470 "c_tests/sqlite3.c"
    case 25: {
      sqlite3 *db = __builtin_va_arg(ap, sqlite3*);
      int iDb;
      sqlite3_mutex_enter(db->mutex);
      iDb = sqlite3FindDbName(db, __builtin_va_arg(ap, const char*));
      if( iDb>=0 ){
        db->init.iDb = iDb;
        db->init.busy = db->init.imposterTable = __builtin_va_arg(ap, int);
        db->init.newTnum = __builtin_va_arg(ap, int);
        if( db->init.busy==0 && db->init.newTnum>0 ){
          sqlite3ResetAllSchemasOfConnection(db);
        }
      }
      sqlite3_mutex_leave(db->mutex);
      break;
    }
# 189513 "c_tests/sqlite3.c"
    case 27: {
      sqlite3_context *pCtx = __builtin_va_arg(ap, sqlite3_context*);
      sqlite3ResultIntReal(pCtx);
      break;
    }
# 189528 "c_tests/sqlite3.c"
    case 30: {
      sqlite3 *db = __builtin_va_arg(ap, sqlite3*);
      u64 *pn = __builtin_va_arg(ap, sqlite3_uint64*);
      *pn = 0;
      (void)db;
      break;
    }
# 189545 "c_tests/sqlite3.c"
    case 31: {
       int opTrace = __builtin_va_arg(ap, int);
       u32 *ptr = __builtin_va_arg(ap, u32*);
       switch( opTrace ){
         case 0: *ptr = sqlite3TreeTrace; break;
         case 1: sqlite3TreeTrace = *ptr; break;
         case 2: *ptr = sqlite3WhereTrace; break;
         case 3: sqlite3WhereTrace = *ptr; break;
       }
       break;
    }
# 189566 "c_tests/sqlite3.c"
    case 33: {
      double rIn = __builtin_va_arg(ap, double);
      LogEst rLogEst = sqlite3LogEstFromDouble(rIn);
      int *pI1 = __builtin_va_arg(ap, int*);
      u64 *pU64 = __builtin_va_arg(ap, u64*);
      int *pI2 = __builtin_va_arg(ap, int*);
      *pI1 = rLogEst;
      *pU64 = sqlite3LogEstToInt(rLogEst);
      *pI2 = sqlite3LogEst(*pU64);
      break;
    }
# 189618 "c_tests/sqlite3.c"
    case 14: {
# 189627 "c_tests/sqlite3.c"
      break;
    }
  }
  __builtin_va_end(ap);

  return rc;
}
# 189643 "c_tests/sqlite3.c"
static const char *databaseName(const char *zName){
  while( zName[-1]!=0 || zName[-2]!=0 || zName[-3]!=0 || zName[-4]!=0 ){
    zName--;
  }
  return zName;
}





static char *appendText(char *p, const char *z){
  size_t n = strlen(z);
  memcpy(p, z, n+1);
  return p+n+1;
}
# 189669 "c_tests/sqlite3.c"
           const char *sqlite3_create_filename(
  const char *zDatabase,
  const char *zJournal,
  const char *zWal,
  int nParam,
  const char **azParam
){
  sqlite3_int64 nByte;
  int i;
  char *pResult, *p;
  nByte = strlen(zDatabase) + strlen(zJournal) + strlen(zWal) + 10;
  for(i=0; i<nParam*2; i++){
    nByte += strlen(azParam[i])+1;
  }
  pResult = p = sqlite3_malloc64( nByte );
  if( p==0 ) return 0;
  memset(p, 0, 4);
  p += 4;
  p = appendText(p, zDatabase);
  for(i=0; i<nParam*2; i++){
    p = appendText(p, azParam[i]);
  }
  *(p++) = 0;
  p = appendText(p, zJournal);
  p = appendText(p, zWal);
  *(p++) = 0;
  *(p++) = 0;
  ((void) (0));
  return pResult + 4;
}






           void sqlite3_free_filename(const char *p){
  if( p==0 ) return;
  p = databaseName(p);
  sqlite3_free((char*)p - 4);
}
# 189723 "c_tests/sqlite3.c"
           const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam){
  if( zFilename==0 || zParam==0 ) return 0;
  zFilename = databaseName(zFilename);
  return uriParameter(zFilename, zParam);
}




           const char *sqlite3_uri_key(const char *zFilename, int N){
  if( zFilename==0 || N<0 ) return 0;
  zFilename = databaseName(zFilename);
  zFilename += sqlite3Strlen30(zFilename) + 1;
  while( (zFilename) && zFilename[0] && (N--)>0 ){
    zFilename += sqlite3Strlen30(zFilename) + 1;
    zFilename += sqlite3Strlen30(zFilename) + 1;
  }
  return zFilename[0] ? zFilename : 0;
}




           int sqlite3_uri_boolean(const char *zFilename, const char *zParam, int bDflt){
  const char *z = sqlite3_uri_parameter(zFilename, zParam);
  bDflt = bDflt!=0;
  return z ? sqlite3GetBoolean(z, bDflt) : bDflt;
}




           sqlite3_int64 sqlite3_uri_int64(
  const char *zFilename,
  const char *zParam,
  sqlite3_int64 bDflt
){
  const char *z = sqlite3_uri_parameter(zFilename, zParam);
  sqlite3_int64 v;
  if( z && sqlite3DecOrHexToI64(z, &v)==0 ){
    bDflt = v;
  }
  return bDflt;
}
# 189778 "c_tests/sqlite3.c"
           const char *sqlite3_filename_database(const char *zFilename){
  if( zFilename==0 ) return 0;
  return databaseName(zFilename);
}
           const char *sqlite3_filename_journal(const char *zFilename){
  if( zFilename==0 ) return 0;
  zFilename = databaseName(zFilename);
  zFilename += sqlite3Strlen30(zFilename) + 1;
  while( (zFilename) && zFilename[0] ){
    zFilename += sqlite3Strlen30(zFilename) + 1;
    zFilename += sqlite3Strlen30(zFilename) + 1;
  }
  return zFilename + 1;
}
           const char *sqlite3_filename_wal(const char *zFilename){



  zFilename = sqlite3_filename_journal(zFilename);
  if( zFilename ) zFilename += sqlite3Strlen30(zFilename) + 1;
  return zFilename;

}




static Btree *sqlite3DbNameToBtree(sqlite3 *db, const char *zDbName){
  int iDb = zDbName ? sqlite3FindDbName(db, zDbName) : 0;
  return iDb<0 ? 0 : db->aDb[iDb].pBt;
}





           const char *sqlite3_db_name(sqlite3 *db, int N){






  if( N<0 || N>=db->nDb ){
    return 0;
  }else{
    return db->aDb[N].zDbSName;
  }
}





           const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName){
  Btree *pBt;






  pBt = sqlite3DbNameToBtree(db, zDbName);
  return pBt ? sqlite3BtreeGetFilename(pBt) : 0;
}





           int sqlite3_db_readonly(sqlite3 *db, const char *zDbName){
  Btree *pBt;






  pBt = sqlite3DbNameToBtree(db, zDbName);
  return pBt ? sqlite3BtreeIsReadonly(pBt) : -1;
}
# 190005 "c_tests/sqlite3.c"
           int sqlite3_compileoption_used(const char *zOptName){
  int i, n;
  int nOpt;
  const char **azCompileOpt;
# 190017 "c_tests/sqlite3.c"
  azCompileOpt = sqlite3CompileOptions(&nOpt);

  if( sqlite3_strnicmp(zOptName, "SQLITE_", 7)==0 ) zOptName += 7;
  n = sqlite3Strlen30(zOptName);



  for(i=0; i<nOpt; i++){
    if( sqlite3_strnicmp(zOptName, azCompileOpt[i], n)==0
     && sqlite3IsIdChar((unsigned char)azCompileOpt[i][n])==0
    ){
      return 1;
    }
  }
  return 0;
}





           const char *sqlite3_compileoption_get(int N){
  int nOpt;
  const char **azCompileOpt;
  azCompileOpt = sqlite3CompileOptions(&nOpt);
  if( N>=0 && N<nOpt ){
    return azCompileOpt[N];
  }
  return 0;
}
# 210256 "c_tests/sqlite3.c"
static const char * const jsonbType[] = {
  "null", "true", "false", "integer", "integer",
  "real", "real", "text", "text", "text",
  "text", "array", "object", "", "", "", ""
};






static const char jsonIsSpace[] = {


  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
# 210309 "c_tests/sqlite3.c"
};







static const char jsonSpaces[] = "\011\012\015\040";
# 210330 "c_tests/sqlite3.c"
static const char jsonIsOk[256] = {


  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
# 210371 "c_tests/sqlite3.c"
};


typedef struct JsonCache JsonCache;
typedef struct JsonString JsonString;
typedef struct JsonParse JsonParse;
# 210403 "c_tests/sqlite3.c"
struct JsonCache {
  sqlite3 *db;
  int nUsed;
  JsonParse *a[4];
};
# 210417 "c_tests/sqlite3.c"
struct JsonString {
  sqlite3_context *pCtx;
  char *zBuf;
  u64 nAlloc;
  u64 nUsed;
  u8 bStatic;
  u8 eErr;
  char zSpace[100];
};
# 210463 "c_tests/sqlite3.c"
struct JsonParse {
  u8 *aBlob;
  u32 nBlob;
  u32 nBlobAlloc;
  char *zJson;
  sqlite3 *db;
  int nJson;
  u32 nJPRef;
  u32 iErr;
  u16 iDepth;
  u8 nErr;
  u8 oom;
  u8 bJsonIsRCStr;
  u8 hasNonstd;
  u8 bReadOnly;

  u8 eEdit;
  int delta;
  u32 nIns;
  u32 iLabel;
  u8 *aIns;
};
# 210514 "c_tests/sqlite3.c"
static void jsonReturnStringAsBlob(JsonString*);
static int jsonArgIsJsonb(sqlite3_value *pJson, JsonParse *p);
static u32 jsonTranslateBlobToText(const JsonParse*,u32,JsonString*);
static void jsonReturnParse(sqlite3_context*,JsonParse*);
static JsonParse *jsonParseFuncArg(sqlite3_context*,sqlite3_value*,u32);
static void jsonParseFree(JsonParse*);
static u32 jsonbPayloadSize(const JsonParse*, u32, u32*);
static u32 jsonUnescapeOneChar(const char*, u32, u32*);
# 210530 "c_tests/sqlite3.c"
static void jsonCacheDelete(JsonCache *p){
  int i;
  for(i=0; i<p->nUsed; i++){
    jsonParseFree(p->a[i]);
  }
  sqlite3DbFree(p->db, p);
}
static void jsonCacheDeleteGeneric(void *p){
  jsonCacheDelete((JsonCache*)p);
}
# 210548 "c_tests/sqlite3.c"
static int jsonCacheInsert(
  sqlite3_context *ctx,
  JsonParse *pParse
){
  JsonCache *p;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  p = sqlite3_get_auxdata(ctx, (-429938));
  if( p==0 ){
    sqlite3 *db = sqlite3_context_db_handle(ctx);
    p = sqlite3DbMallocZero(db, sizeof(*p));
    if( p==0 ) return 7;
    p->db = db;
    sqlite3_set_auxdata(ctx, (-429938), p, jsonCacheDeleteGeneric);
    p = sqlite3_get_auxdata(ctx, (-429938));
    if( p==0 ) return 7;
  }
  if( p->nUsed >= 4 ){
    jsonParseFree(p->a[0]);
    memmove(p->a, &p->a[1], (4 -1)*sizeof(p->a[0]));
    p->nUsed = 4 -1;
  }
  ((void) (0));
  pParse->eEdit = 0;
  pParse->nJPRef++;
  pParse->bReadOnly = 1;
  p->a[p->nUsed] = pParse;
  p->nUsed++;
  return 0;
}
# 210592 "c_tests/sqlite3.c"
static JsonParse *jsonCacheSearch(
  sqlite3_context *ctx,
  sqlite3_value *pArg
){
  JsonCache *p;
  int i;
  const char *zJson;
  int nJson;

  if( sqlite3_value_type(pArg)!=3 ){
    return 0;
  }
  zJson = (const char*)sqlite3_value_text(pArg);
  if( zJson==0 ) return 0;
  nJson = sqlite3_value_bytes(pArg);

  p = sqlite3_get_auxdata(ctx, (-429938));
  if( p==0 ){
    return 0;
  }
  for(i=0; i<p->nUsed; i++){
    if( p->a[i]->zJson==zJson ) break;
  }
  if( i>=p->nUsed ){
    for(i=0; i<p->nUsed; i++){
      if( p->a[i]->nJson!=nJson ) continue;
      if( memcmp(p->a[i]->zJson, zJson, nJson)==0 ) break;
    }
  }
  if( i<p->nUsed ){
    if( i<p->nUsed-1 ){

      JsonParse *tmp = p->a[i];
      memmove(&p->a[i], &p->a[i+1], (p->nUsed-i-1)*sizeof(tmp));
      p->a[p->nUsed-1] = tmp;
      i = p->nUsed - 1;
    }
    ((void) (0));
    return p->a[i];
  }else{
    return 0;
  }
}
# 210643 "c_tests/sqlite3.c"
static void jsonStringZero(JsonString *p){
  p->zBuf = p->zSpace;
  p->nAlloc = sizeof(p->zSpace);
  p->nUsed = 0;
  p->bStatic = 1;
}



static void jsonStringInit(JsonString *p, sqlite3_context *pCtx){
  p->pCtx = pCtx;
  p->eErr = 0;
  jsonStringZero(p);
}




static void jsonStringReset(JsonString *p){
  if( !p->bStatic ) sqlite3RCStrUnref(p->zBuf);
  jsonStringZero(p);
}



static void jsonStringOom(JsonString *p){
  p->eErr |= 0x01;
  if( p->pCtx ) sqlite3_result_error_nomem(p->pCtx);
  jsonStringReset(p);
}




static int jsonStringGrow(JsonString *p, u32 N){
  u64 nTotal = N<p->nAlloc ? p->nAlloc*2 : p->nAlloc+N+10;
  char *zNew;
  if( p->bStatic ){
    if( p->eErr ) return 1;
    zNew = sqlite3RCStrNew(nTotal);
    if( zNew==0 ){
      jsonStringOom(p);
      return 7;
    }
    memcpy(zNew, p->zBuf, (size_t)p->nUsed);
    p->zBuf = zNew;
    p->bStatic = 0;
  }else{
    p->zBuf = sqlite3RCStrResize(p->zBuf, nTotal);
    if( p->zBuf==0 ){
      p->eErr |= 0x01;
      jsonStringZero(p);
      return 7;
    }
  }
  p->nAlloc = nTotal;
  return 0;
}



static __attribute__((noinline)) void jsonStringExpandAndAppend(
  JsonString *p,
  const char *zIn,
  u32 N
){
  ((void) (0));
  if( jsonStringGrow(p,N) ) return;
  memcpy(p->zBuf+p->nUsed, zIn, N);
  p->nUsed += N;
}
static void jsonAppendRaw(JsonString *p, const char *zIn, u32 N){
  if( N==0 ) return;
  if( N+p->nUsed >= p->nAlloc ){
    jsonStringExpandAndAppend(p,zIn,N);
  }else{
    memcpy(p->zBuf+p->nUsed, zIn, N);
    p->nUsed += N;
  }
}
static void jsonAppendRawNZ(JsonString *p, const char *zIn, u32 N){
  ((void) (0));
  if( N+p->nUsed >= p->nAlloc ){
    jsonStringExpandAndAppend(p,zIn,N);
  }else{
    memcpy(p->zBuf+p->nUsed, zIn, N);
    p->nUsed += N;
  }
}



static void jsonPrintf(int N, JsonString *p, const char *zFormat, ...){
  va_list ap;
  if( (p->nUsed + N >= p->nAlloc) && jsonStringGrow(p, N) ) return;
  __builtin_va_start(ap, zFormat);
  sqlite3_vsnprintf(N, p->zBuf+p->nUsed, zFormat, ap);
  __builtin_va_end(ap);
  p->nUsed += (int)strlen(p->zBuf+p->nUsed);
}



static __attribute__((noinline)) void jsonAppendCharExpand(JsonString *p, char c){
  if( jsonStringGrow(p,1) ) return;
  p->zBuf[p->nUsed++] = c;
}
static void jsonAppendChar(JsonString *p, char c){
  if( p->nUsed>=p->nAlloc ){
    jsonAppendCharExpand(p,c);
  }else{
    p->zBuf[p->nUsed++] = c;
  }
}



static void jsonStringTrimOneChar(JsonString *p){
  if( p->eErr==0 ){
    ((void) (0));
    p->nUsed--;
  }
}







static int jsonStringTerminate(JsonString *p){
  jsonAppendChar(p, 0);
  jsonStringTrimOneChar(p);
  return p->eErr==0;
}




static void jsonAppendSeparator(JsonString *p){
  char c;
  if( p->nUsed==0 ) return;
  c = p->zBuf[p->nUsed-1];
  if( c=='[' || c=='{' ) return;
  jsonAppendChar(p, ',');
}







static void jsonAppendControlChar(JsonString *p, u8 c){
  static const char aSpecial[] = {
     0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  };
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( aSpecial[c] ){
    p->zBuf[p->nUsed] = '\\';
    p->zBuf[p->nUsed+1] = aSpecial[c];
    p->nUsed += 2;
  }else{
    p->zBuf[p->nUsed] = '\\';
    p->zBuf[p->nUsed+1] = 'u';
    p->zBuf[p->nUsed+2] = '0';
    p->zBuf[p->nUsed+3] = '0';
    p->zBuf[p->nUsed+4] = "0123456789abcdef"[c>>4];
    p->zBuf[p->nUsed+5] = "0123456789abcdef"[c&0xf];
    p->nUsed += 6;
  }
}
# 210832 "c_tests/sqlite3.c"
static void jsonAppendString(JsonString *p, const char *zIn, u32 N){
  u32 k;
  u8 c;
  const u8 *z = (const u8*)zIn;
  if( z==0 ) return;
  if( (N+p->nUsed+2 >= p->nAlloc) && jsonStringGrow(p,N+2)!=0 ) return;
  p->zBuf[p->nUsed++] = '"';
  while( 1 ){
    k = 0;




    while( 1 ){
      if( k+3>=N ){
        while( k<N && jsonIsOk[z[k]] ){ k++; }
        break;
      }
      if( !jsonIsOk[z[k]] ){
        break;
      }
      if( !jsonIsOk[z[k+1]] ){
        k += 1;
        break;
      }
      if( !jsonIsOk[z[k+2]] ){
        k += 2;
        break;
      }
      if( !jsonIsOk[z[k+3]] ){
        k += 3;
        break;
      }else{
        k += 4;
      }
    }
    if( k>=N ){
      if( k>0 ){
        memcpy(&p->zBuf[p->nUsed], z, k);
        p->nUsed += k;
      }
      break;
    }
    if( k>0 ){
      memcpy(&p->zBuf[p->nUsed], z, k);
      p->nUsed += k;
      z += k;
      N -= k;
    }
    c = z[0];
    if( c=='"' || c=='\\' ){
      if( (p->nUsed+N+3 > p->nAlloc) && jsonStringGrow(p,N+3)!=0 ) return;
      p->zBuf[p->nUsed++] = '\\';
      p->zBuf[p->nUsed++] = c;
    }else if( c=='\'' ){
      p->zBuf[p->nUsed++] = c;
    }else{
      if( (p->nUsed+N+7 > p->nAlloc) && jsonStringGrow(p,N+7)!=0 ) return;
      jsonAppendControlChar(p, c);
    }
    z++;
    N--;
  }
  p->zBuf[p->nUsed++] = '"';
  ((void) (0));
}





static void jsonAppendSqlValue(
  JsonString *p,
  sqlite3_value *pValue
){
  switch( sqlite3_value_type(pValue) ){
    case 5: {
      jsonAppendRawNZ(p, "null", 4);
      break;
    }
    case 2: {
      jsonPrintf(100, p, "%!0.15g", sqlite3_value_double(pValue));
      break;
    }
    case 1: {
      const char *z = (const char*)sqlite3_value_text(pValue);
      u32 n = (u32)sqlite3_value_bytes(pValue);
      jsonAppendRaw(p, z, n);
      break;
    }
    case 3: {
      const char *z = (const char*)sqlite3_value_text(pValue);
      u32 n = (u32)sqlite3_value_bytes(pValue);
      if( sqlite3_value_subtype(pValue)==74 ){
        jsonAppendRaw(p, z, n);
      }else{
        jsonAppendString(p, z, n);
      }
      break;
    }
    default: {
      JsonParse px;
      memset(&px, 0, sizeof(px));
      if( jsonArgIsJsonb(pValue, &px) ){
        jsonTranslateBlobToText(&px, 0, p);
      }else if( p->eErr==0 ){
        sqlite3_result_error(p->pCtx, "JSON cannot hold BLOB values", -1);
        p->eErr = 0x04;
        jsonStringReset(p);
      }
      break;
    }
  }
}
# 210956 "c_tests/sqlite3.c"
static void jsonReturnString(
  JsonString *p,
  JsonParse *pParse,
  sqlite3_context *ctx
){
  ((void) (0));
  ((void) (0));
  if( p->eErr==0 ){
    int flags = ((int)(long int)(sqlite3_user_data(p->pCtx)));
    if( flags & 0x08 ){
      jsonReturnStringAsBlob(p);
    }else if( p->bStatic ){
      sqlite3_result_text64(p->pCtx, p->zBuf, p->nUsed,
                            ((sqlite3_destructor_type)-1), 1);
    }else if( jsonStringTerminate(p) ){
      if( pParse && pParse->bJsonIsRCStr==0 && pParse->nBlobAlloc>0 ){
        int rc;
        pParse->zJson = sqlite3RCStrRef(p->zBuf);
        pParse->nJson = p->nUsed;
        pParse->bJsonIsRCStr = 1;
        rc = jsonCacheInsert(ctx, pParse);
        if( rc==7 ){
          sqlite3_result_error_nomem(ctx);
          jsonStringReset(p);
          return;
        }
      }
      sqlite3_result_text64(p->pCtx, sqlite3RCStrRef(p->zBuf), p->nUsed,
                            sqlite3RCStrUnref,
                            1);
    }else{
      sqlite3_result_error_nomem(p->pCtx);
    }
  }else if( p->eErr & 0x01 ){
    sqlite3_result_error_nomem(p->pCtx);
  }else if( p->eErr & 0x02 ){
    sqlite3_result_error(p->pCtx, "malformed JSON", -1);
  }
  jsonStringReset(p);
}
# 211005 "c_tests/sqlite3.c"
static void jsonParseReset(JsonParse *pParse){
  ((void) (0));
  if( pParse->bJsonIsRCStr ){
    sqlite3RCStrUnref(pParse->zJson);
    pParse->zJson = 0;
    pParse->nJson = 0;
    pParse->bJsonIsRCStr = 0;
  }
  if( pParse->nBlobAlloc ){
    sqlite3DbFree(pParse->db, pParse->aBlob);
    pParse->aBlob = 0;
    pParse->nBlob = 0;
    pParse->nBlobAlloc = 0;
  }
}





static void jsonParseFree(JsonParse *pParse){
  if( pParse ){
    if( pParse->nJPRef>1 ){
      pParse->nJPRef--;
    }else{
      jsonParseReset(pParse);
      sqlite3DbFree(pParse->db, pParse);
    }
  }
}
# 211046 "c_tests/sqlite3.c"
static u8 jsonHexToInt(int h){

  h += 9*(1&(h>>6));




  return (u8)(h & 0xf);
}




static u32 jsonHexToInt4(const char *z){
  u32 v;
  v = (jsonHexToInt(z[0])<<12)
    + (jsonHexToInt(z[1])<<8)
    + (jsonHexToInt(z[2])<<4)
    + jsonHexToInt(z[3]);
  return v;
}




static int jsonIs2Hex(const char *z){
  return (sqlite3CtypeMap[(unsigned char)(z[0])]&0x08) && (sqlite3CtypeMap[(unsigned char)(z[1])]&0x08);
}




static int jsonIs4Hex(const char *z){
  return jsonIs2Hex(z) && jsonIs2Hex(&z[2]);
}
# 211118 "c_tests/sqlite3.c"
static int json5Whitespace(const char *zIn){
  int n = 0;
  const u8 *z = (u8*)zIn;
  while( 1 ){
    switch( z[n] ){
      case 0x09:
      case 0x0a:
      case 0x0b:
      case 0x0c:
      case 0x0d:
      case 0x20: {
        n++;
        break;
      }
      case '/': {
        if( z[n+1]=='*' && z[n+2]!=0 ){
          int j;
          for(j=n+3; z[j]!='/' || z[j-1]!='*'; j++){
            if( z[j]==0 ) goto whitespace_done;
          }
          n = j+1;
          break;
        }else if( z[n+1]=='/' ){
          int j;
          char c;
          for(j=n+2; (c = z[j])!=0; j++){
            if( c=='\n' || c=='\r' ) break;
            if( 0xe2==(u8)c && 0x80==(u8)z[j+1]
             && (0xa8==(u8)z[j+2] || 0xa9==(u8)z[j+2])
            ){
              j += 2;
              break;
            }
          }
          n = j;
          if( z[n] ) n++;
          break;
        }
        goto whitespace_done;
      }
      case 0xc2: {
        if( z[n+1]==0xa0 ){
          n += 2;
          break;
        }
        goto whitespace_done;
      }
      case 0xe1: {
        if( z[n+1]==0x9a && z[n+2]==0x80 ){
          n += 3;
          break;
        }
        goto whitespace_done;
      }
      case 0xe2: {
        if( z[n+1]==0x80 ){
          u8 c = z[n+2];
          if( c<0x80 ) goto whitespace_done;
          if( c<=0x8a || c==0xa8 || c==0xa9 || c==0xaf ){
            n += 3;
            break;
          }
        }else if( z[n+1]==0x81 && z[n+2]==0x9f ){
          n += 3;
          break;
        }
        goto whitespace_done;
      }
      case 0xe3: {
        if( z[n+1]==0x80 && z[n+2]==0x80 ){
          n += 3;
          break;
        }
        goto whitespace_done;
      }
      case 0xef: {
        if( z[n+1]==0xbb && z[n+2]==0xbf ){
          n += 3;
          break;
        }
        goto whitespace_done;
      }
      default: {
        goto whitespace_done;
      }
    }
  }
  whitespace_done:
  return n;
}




static const struct NanInfName {
  char c1;
  char c2;
  char n;
  char eType;
  char nRepl;
  char *zMatch;
  char *zRepl;
} aNanInfName[] = {
  { 'i', 'I', 3, 5, 7, "inf", "9.0e999" },
  { 'i', 'I', 8, 5, 7, "infinity", "9.0e999" },
  { 'n', 'N', 3, 0, 4, "NaN", "null" },
  { 'q', 'Q', 4, 0, 4, "QNaN", "null" },
  { 's', 'S', 4, 0, 4, "SNaN", "null" },
};






static void jsonWrongNumArgs(
  sqlite3_context *pCtx,
  const char *zFuncName
){
  char *zMsg = sqlite3_mprintf("json_%s() needs an odd number of arguments",
                               zFuncName);
  sqlite3_result_error(pCtx, zMsg, -1);
  sqlite3_free(zMsg);
}
# 211252 "c_tests/sqlite3.c"
static int jsonBlobExpand(JsonParse *pParse, u32 N){
  u8 *aNew;
  u64 t;
  ((void) (0));
  if( pParse->nBlobAlloc==0 ){
    t = 100;
  }else{
    t = pParse->nBlobAlloc*2;
  }
  if( t<N ) t = N+100;
  aNew = sqlite3DbRealloc(pParse->db, pParse->aBlob, t);
  if( aNew==0 ){ pParse->oom = 1; return 1; }
  ((void) (0));
  pParse->aBlob = aNew;
  pParse->nBlobAlloc = (u32)t;
  return 0;
}
# 211278 "c_tests/sqlite3.c"
static int jsonBlobMakeEditable(JsonParse *pParse, u32 nExtra){
  u8 *aOld;
  u32 nSize;
  ((void) (0));
  if( pParse->oom ) return 0;
  if( pParse->nBlobAlloc>0 ) return 1;
  aOld = pParse->aBlob;
  nSize = pParse->nBlob + nExtra;
  pParse->aBlob = 0;
  if( jsonBlobExpand(pParse, nSize) ){
    return 0;
  }
  ((void) (0));
  memcpy(pParse->aBlob, aOld, pParse->nBlob);
  return 1;
}



static __attribute__((noinline)) void jsonBlobExpandAndAppendOneByte(
  JsonParse *pParse,
  u8 c
){
  jsonBlobExpand(pParse, pParse->nBlob+1);
  if( pParse->oom==0 ){
    ((void) (0));
    pParse->aBlob[pParse->nBlob++] = c;
  }
}



static void jsonBlobAppendOneByte(JsonParse *pParse, u8 c){
  if( pParse->nBlob >= pParse->nBlobAlloc ){
    jsonBlobExpandAndAppendOneByte(pParse, c);
  }else{
    pParse->aBlob[pParse->nBlob++] = c;
  }
}




static void jsonBlobAppendNode(JsonParse*,u8,u32,const void*);
static __attribute__((noinline)) void jsonBlobExpandAndAppendNode(
  JsonParse *pParse,
  u8 eType,
  u32 szPayload,
  const void *aPayload
){
  if( jsonBlobExpand(pParse, pParse->nBlob+szPayload+9) ) return;
  jsonBlobAppendNode(pParse, eType, szPayload, aPayload);
}
# 211342 "c_tests/sqlite3.c"
static void jsonBlobAppendNode(
  JsonParse *pParse,
  u8 eType,
  u32 szPayload,
  const void *aPayload
){
  u8 *a;
  if( pParse->nBlob+szPayload+9 > pParse->nBlobAlloc ){
    jsonBlobExpandAndAppendNode(pParse,eType,szPayload,aPayload);
    return;
  }
  ((void) (0));
  a = &pParse->aBlob[pParse->nBlob];
  if( szPayload<=11 ){
    a[0] = eType | (szPayload<<4);
    pParse->nBlob += 1;
  }else if( szPayload<=0xff ){
    a[0] = eType | 0xc0;
    a[1] = szPayload & 0xff;
    pParse->nBlob += 2;
  }else if( szPayload<=0xffff ){
    a[0] = eType | 0xd0;
    a[1] = (szPayload >> 8) & 0xff;
    a[2] = szPayload & 0xff;
    pParse->nBlob += 3;
  }else{
    a[0] = eType | 0xe0;
    a[1] = (szPayload >> 24) & 0xff;
    a[2] = (szPayload >> 16) & 0xff;
    a[3] = (szPayload >> 8) & 0xff;
    a[4] = szPayload & 0xff;
    pParse->nBlob += 5;
  }
  if( aPayload ){
    pParse->nBlob += szPayload;
    memcpy(&pParse->aBlob[pParse->nBlob-szPayload], aPayload, szPayload);
  }
}



static int jsonBlobChangePayloadSize(
  JsonParse *pParse,
  u32 i,
  u32 szPayload
){
  u8 *a;
  u8 szType;
  u8 nExtra;
  u8 nNeeded;
  int delta;
  if( pParse->oom ) return 0;
  a = &pParse->aBlob[i];
  szType = a[0]>>4;
  if( szType<=11 ){
    nExtra = 0;
  }else if( szType==12 ){
    nExtra = 1;
  }else if( szType==13 ){
    nExtra = 2;
  }else if( szType==14 ){
    nExtra = 4;
  }else{
    nExtra = 8;
  }
  if( szPayload<=11 ){
    nNeeded = 0;
  }else if( szPayload<=0xff ){
    nNeeded = 1;
  }else if( szPayload<=0xffff ){
    nNeeded = 2;
  }else{
    nNeeded = 4;
  }
  delta = nNeeded - nExtra;
  if( delta ){
    u32 newSize = pParse->nBlob + delta;
    if( delta>0 ){
      if( newSize>pParse->nBlobAlloc && jsonBlobExpand(pParse, newSize) ){
        return 0;
      }
      a = &pParse->aBlob[i];
      memmove(&a[1+delta], &a[1], pParse->nBlob - (i+1));
    }else{
      memmove(&a[1], &a[1-delta], pParse->nBlob - (i+1-delta));
    }
    pParse->nBlob = newSize;
  }
  if( nNeeded==0 ){
    a[0] = (a[0] & 0x0f) | (szPayload<<4);
  }else if( nNeeded==1 ){
    a[0] = (a[0] & 0x0f) | 0xc0;
    a[1] = szPayload & 0xff;
  }else if( nNeeded==2 ){
    a[0] = (a[0] & 0x0f) | 0xd0;
    a[1] = (szPayload >> 8) & 0xff;
    a[2] = szPayload & 0xff;
  }else{
    a[0] = (a[0] & 0x0f) | 0xe0;
    a[1] = (szPayload >> 24) & 0xff;
    a[2] = (szPayload >> 16) & 0xff;
    a[3] = (szPayload >> 8) & 0xff;
    a[4] = szPayload & 0xff;
  }
  return delta;
}






static int jsonIs4HexB(const char *z, int *pOp){
  if( z[0]!='u' ) return 0;
  if( !jsonIs4Hex(&z[1]) ) return 0;
  *pOp = 8;
  return 1;
}
# 211471 "c_tests/sqlite3.c"
static u32 jsonbValidityCheck(
  const JsonParse *pParse,
  u32 i,
  u32 iEnd,
  u32 iDepth
){
  u32 n, sz, j, k;
  const u8 *z;
  u8 x;
  if( iDepth>1000 ) return i+1;
  sz = 0;
  n = jsonbPayloadSize(pParse, i, &sz);
  if( (n==0) ) return i+1;
  if( (i+n+sz!=iEnd) ) return i+1;
  z = pParse->aBlob;
  x = z[i] & 0x0f;
  switch( x ){
    case 0:
    case 1:
    case 2: {
      return n+sz==1 ? 0 : i+1;
    }
    case 3: {
      if( sz<1 ) return i+1;
      j = i+n;
      if( z[j]=='-' ){
        j++;
        if( sz<2 ) return i+1;
      }
      k = i+n+sz;
      while( j<k ){
        if( (sqlite3CtypeMap[(unsigned char)(z[j])]&0x04) ){
          j++;
        }else{
          return j+1;
        }
      }
      return 0;
    }
    case 4: {
      if( sz<3 ) return i+1;
      j = i+n;
      if( z[j]=='-' ){
        if( sz<4 ) return i+1;
        j++;
      }
      if( z[j]!='0' ) return i+1;
      if( z[j+1]!='x' && z[j+1]!='X' ) return j+2;
      j += 2;
      k = i+n+sz;
      while( j<k ){
        if( (sqlite3CtypeMap[(unsigned char)(z[j])]&0x08) ){
          j++;
        }else{
          return j+1;
        }
      }
      return 0;
    }
    case 5:
    case 6: {
      u8 seen = 0;
      if( sz<2 ) return i+1;
      j = i+n;
      k = j+sz;
      if( z[j]=='-' ){
        j++;
        if( sz<3 ) return i+1;
      }
      if( z[j]=='.' ){
        if( x==5 ) return j+1;
        if( !(sqlite3CtypeMap[(unsigned char)(z[j+1])]&0x04) ) return j+1;
        j += 2;
        seen = 1;
      }else if( z[j]=='0' && x==5 ){
        if( j+3>k ) return j+1;
        if( z[j+1]!='.' && z[j+1]!='e' && z[j+1]!='E' ) return j+1;
        j++;
      }
      for(; j<k; j++){
        if( (sqlite3CtypeMap[(unsigned char)(z[j])]&0x04) ) continue;
        if( z[j]=='.' ){
          if( seen>0 ) return j+1;
          if( x==5 && (j==k-1 || !(sqlite3CtypeMap[(unsigned char)(z[j+1])]&0x04)) ){
            return j+1;
          }
          seen = 1;
          continue;
        }
        if( z[j]=='e' || z[j]=='E' ){
          if( seen==2 ) return j+1;
          if( j==k-1 ) return j+1;
          if( z[j+1]=='+' || z[j+1]=='-' ){
            j++;
            if( j==k-1 ) return j+1;
          }
          seen = 2;
          continue;
        }
        return j+1;
      }
      if( seen==0 ) return i+1;
      return 0;
    }
    case 7: {
      j = i+n;
      k = j+sz;
      while( j<k ){
        if( !jsonIsOk[z[j]] && z[j]!='\'' ) return j+1;
        j++;
      }
      return 0;
    }
    case 8:
    case 9: {
      j = i+n;
      k = j+sz;
      while( j<k ){
        if( !jsonIsOk[z[j]] && z[j]!='\'' ){
          if( z[j]=='"' ){
            if( x==8 ) return j+1;
          }else if( z[j]<=0x1f ){

            if( x==8 ) return j+1;
          }else if( (z[j]!='\\') || j+1>=k ){
            return j+1;
          }else if( strchr("\"\\/bfnrt",z[j+1])!=0 ){
            j++;
          }else if( z[j+1]=='u' ){
            if( j+5>=k ) return j+1;
            if( !jsonIs4Hex((const char*)&z[j+2]) ) return j+1;
            j++;
          }else if( x!=9 ){
            return j+1;
          }else{
            u32 c = 0;
            u32 szC = jsonUnescapeOneChar((const char*)&z[j], k-j, &c);
            if( c==0x99999 ) return j+1;
            j += szC - 1;
          }
        }
        j++;
      }
      return 0;
    }
    case 10: {
      return 0;
    }
    case 11: {
      u32 sub;
      j = i+n;
      k = j+sz;
      while( j<k ){
        sz = 0;
        n = jsonbPayloadSize(pParse, j, &sz);
        if( n==0 ) return j+1;
        if( j+n+sz>k ) return j+1;
        sub = jsonbValidityCheck(pParse, j, j+n+sz, iDepth+1);
        if( sub ) return sub;
        j += n + sz;
      }
      ((void) (0));
      return 0;
    }
    case 12: {
      u32 cnt = 0;
      u32 sub;
      j = i+n;
      k = j+sz;
      while( j<k ){
        sz = 0;
        n = jsonbPayloadSize(pParse, j, &sz);
        if( n==0 ) return j+1;
        if( j+n+sz>k ) return j+1;
        if( (cnt & 1)==0 ){
          x = z[j] & 0x0f;
          if( x<7 || x>10 ) return j+1;
        }
        sub = jsonbValidityCheck(pParse, j, j+n+sz, iDepth+1);
        if( sub ) return sub;
        cnt++;
        j += n + sz;
      }
      ((void) (0));
      if( (cnt & 1)!=0 ) return j+1;
      return 0;
    }
    default: {
      return i+1;
    }
  }
}
# 211680 "c_tests/sqlite3.c"
static int jsonTranslateTextToBlob(JsonParse *pParse, u32 i){
  char c;
  u32 j;
  u32 iThis, iStart;
  int x;
  u8 t;
  const char *z = pParse->zJson;
json_parse_restart:
  switch( (u8)z[i] ){
  case '{': {

    iThis = pParse->nBlob;
    jsonBlobAppendNode(pParse, 12, pParse->nJson-i, 0);
    if( ++pParse->iDepth > 1000 ){
      pParse->iErr = i;
      return -1;
    }
    iStart = pParse->nBlob;
    for(j=i+1;;j++){
      u32 iBlob = pParse->nBlob;
      x = jsonTranslateTextToBlob(pParse, j);
      if( x<=0 ){
        int op;
        if( x==(-2) ){
          j = pParse->iErr;
          if( pParse->nBlob!=(u32)iStart ) pParse->hasNonstd = 1;
          break;
        }
        j += json5Whitespace(&z[j]);
        op = 7;
        if( (sqlite3CtypeMap[(unsigned char)(z[j])]&0x42)
         || (z[j]=='\\' && jsonIs4HexB(&z[j+1], &op))
        ){
          int k = j+1;
          while( ((sqlite3CtypeMap[(unsigned char)(z[k])]&0x46) && json5Whitespace(&z[k])==0)
            || (z[k]=='\\' && jsonIs4HexB(&z[k+1], &op))
          ){
            k++;
          }
          ((void) (0));
          jsonBlobAppendNode(pParse, op, k-j, &z[j]);
          pParse->hasNonstd = 1;
          x = k;
        }else{
          if( x!=-1 ) pParse->iErr = j;
          return -1;
        }
      }
      if( pParse->oom ) return -1;
      t = pParse->aBlob[iBlob] & 0x0f;
      if( t<7 || t>10 ){
        pParse->iErr = j;
        return -1;
      }
      j = x;
      if( z[j]==':' ){
        j++;
      }else{
        if( (jsonIsSpace[(unsigned char)z[j]]) ){

          do{ j++; }while( (jsonIsSpace[(unsigned char)z[j]]) );
          if( z[j]==':' ){
            j++;
            goto parse_object_value;
          }
        }
        x = jsonTranslateTextToBlob(pParse, j);
        if( x!=(-5) ){
          if( x!=(-1) ) pParse->iErr = j;
          return -1;
        }
        j = pParse->iErr+1;
      }
    parse_object_value:
      x = jsonTranslateTextToBlob(pParse, j);
      if( x<=0 ){
        if( x!=(-1) ) pParse->iErr = j;
        return -1;
      }
      j = x;
      if( z[j]==',' ){
        continue;
      }else if( z[j]=='}' ){
        break;
      }else{
        if( (jsonIsSpace[(unsigned char)z[j]]) ){
          j += 1 + (u32)strspn(&z[j+1], jsonSpaces);
          if( z[j]==',' ){
            continue;
          }else if( z[j]=='}' ){
            break;
          }
        }
        x = jsonTranslateTextToBlob(pParse, j);
        if( x==(-4) ){
          j = pParse->iErr;
          continue;
        }
        if( x==(-2) ){
          j = pParse->iErr;
          break;
        }
      }
      pParse->iErr = j;
      return -1;
    }
    jsonBlobChangePayloadSize(pParse, iThis, pParse->nBlob - iStart);
    pParse->iDepth--;
    return j+1;
  }
  case '[': {

    iThis = pParse->nBlob;
    ((void) (0));
    jsonBlobAppendNode(pParse, 11, pParse->nJson - i, 0);
    iStart = pParse->nBlob;
    if( pParse->oom ) return -1;
    if( ++pParse->iDepth > 1000 ){
      pParse->iErr = i;
      return -1;
    }
    for(j=i+1;;j++){
      x = jsonTranslateTextToBlob(pParse, j);
      if( x<=0 ){
        if( x==(-3) ){
          j = pParse->iErr;
          if( pParse->nBlob!=iStart ) pParse->hasNonstd = 1;
          break;
        }
        if( x!=(-1) ) pParse->iErr = j;
        return -1;
      }
      j = x;
      if( z[j]==',' ){
        continue;
      }else if( z[j]==']' ){
        break;
      }else{
        if( (jsonIsSpace[(unsigned char)z[j]]) ){
          j += 1 + (u32)strspn(&z[j+1], jsonSpaces);
          if( z[j]==',' ){
            continue;
          }else if( z[j]==']' ){
            break;
          }
        }
        x = jsonTranslateTextToBlob(pParse, j);
        if( x==(-4) ){
          j = pParse->iErr;
          continue;
        }
        if( x==(-3) ){
          j = pParse->iErr;
          break;
        }
      }
      pParse->iErr = j;
      return -1;
    }
    jsonBlobChangePayloadSize(pParse, iThis, pParse->nBlob - iStart);
    pParse->iDepth--;
    return j+1;
  }
  case '\'': {
    u8 opcode;
    char cDelim;
    pParse->hasNonstd = 1;
    opcode = 7;
    goto parse_string;
  case '"':

    opcode = 7;
  parse_string:
    cDelim = z[i];
    j = i+1;
    while( 1 ){
      if( jsonIsOk[(u8)z[j]] ){
        if( !jsonIsOk[(u8)z[j+1]] ){
          j += 1;
        }else if( !jsonIsOk[(u8)z[j+2]] ){
          j += 2;
        }else{
          j += 3;
          continue;
        }
      }
      c = z[j];
      if( c==cDelim ){
        break;
      }else if( c=='\\' ){
        c = z[++j];
        if( c=='"' || c=='\\' || c=='/' || c=='b' || c=='f'
           || c=='n' || c=='r' || c=='t'
           || (c=='u' && jsonIs4Hex(&z[j+1])) ){
          if( opcode==7 ) opcode = 8;
        }else if( c=='\'' || c=='v' || c=='\n'



           || (c=='0' && !(sqlite3CtypeMap[(unsigned char)(z[j+1])]&0x04))

           || (0xe2==(u8)c && 0x80==(u8)z[j+1]
                && (0xa8==(u8)z[j+2] || 0xa9==(u8)z[j+2]))
           || (c=='x' && jsonIs2Hex(&z[j+1])) ){
          opcode = 9;
          pParse->hasNonstd = 1;
        }else if( c=='\r' ){
          if( z[j+1]=='\n' ) j++;
          opcode = 9;
          pParse->hasNonstd = 1;
        }else{
          pParse->iErr = j;
          return -1;
        }
      }else if( c<=0x1f ){
        if( c==0 ){
          pParse->iErr = j;
          return -1;
        }


        opcode = 9;
        pParse->hasNonstd = 1;
      }else if( c=='"' ){
        opcode = 9;
      }
      j++;
    }
    jsonBlobAppendNode(pParse, opcode, j-1-i, &z[i+1]);
    return j+1;
  }
  case 't': {
    if( strncmp(z+i,"true",4)==0 && !(sqlite3CtypeMap[(unsigned char)(z[i+4])]&0x06) ){
      jsonBlobAppendOneByte(pParse, 1);
      return i+4;
    }
    pParse->iErr = i;
    return -1;
  }
  case 'f': {
    if( strncmp(z+i,"false",5)==0 && !(sqlite3CtypeMap[(unsigned char)(z[i+5])]&0x06) ){
      jsonBlobAppendOneByte(pParse, 2);
      return i+5;
    }
    pParse->iErr = i;
    return -1;
  }
  case '+': {
    u8 seenE;
    pParse->hasNonstd = 1;
    t = 0x00;
    goto parse_number;
  case '.':
    if( (sqlite3CtypeMap[(unsigned char)(z[i+1])]&0x04) ){
      pParse->hasNonstd = 1;
      t = 0x03;
      seenE = 0;
      goto parse_number_2;
    }
    pParse->iErr = i;
    return -1;
  case '-':
  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
  case '5':
  case '6':
  case '7':
  case '8':
  case '9':

    t = 0x00;
  parse_number:
    seenE = 0;
    ((void) (0));
    ((void) (0));
    ((void) (0));
    c = z[i];

    if( c<='0' ){
      if( c=='0' ){
        if( (z[i+1]=='x' || z[i+1]=='X') && (sqlite3CtypeMap[(unsigned char)(z[i+2])]&0x08) ){
          ((void) (0));
          pParse->hasNonstd = 1;
          t = 0x01;
          for(j=i+3; (sqlite3CtypeMap[(unsigned char)(z[j])]&0x08); j++){}
          goto parse_number_finish;
        }else if( (sqlite3CtypeMap[(unsigned char)(z[i+1])]&0x04) ){
          pParse->iErr = i+1;
          return -1;
        }
      }else{
        if( !(sqlite3CtypeMap[(unsigned char)(z[i+1])]&0x04) ){



          if( (z[i+1]=='I' || z[i+1]=='i')
           && sqlite3_strnicmp(&z[i+1], "inf",3)==0
          ){
            pParse->hasNonstd = 1;
            if( z[i]=='-' ){
              jsonBlobAppendNode(pParse, 5, 6, "-9e999");
            }else{
              jsonBlobAppendNode(pParse, 5, 5, "9e999");
            }
            return i + (sqlite3_strnicmp(&z[i+4],"inity",5)==0 ? 9 : 4);
          }
          if( z[i+1]=='.' ){
            pParse->hasNonstd = 1;
            t |= 0x01;
            goto parse_number_2;
          }
          pParse->iErr = i;
          return -1;
        }
        if( z[i+1]=='0' ){
          if( (sqlite3CtypeMap[(unsigned char)(z[i+2])]&0x04) ){
            pParse->iErr = i+1;
            return -1;
          }else if( (z[i+2]=='x' || z[i+2]=='X') && (sqlite3CtypeMap[(unsigned char)(z[i+3])]&0x08) ){
            pParse->hasNonstd = 1;
            t |= 0x01;
            for(j=i+4; (sqlite3CtypeMap[(unsigned char)(z[j])]&0x08); j++){}
            goto parse_number_finish;
          }
        }
      }
    }

  parse_number_2:
    for(j=i+1;; j++){
      c = z[j];
      if( (sqlite3CtypeMap[(unsigned char)(c)]&0x04) ) continue;
      if( c=='.' ){
        if( (t & 0x02)!=0 ){
          pParse->iErr = j;
          return -1;
        }
        t |= 0x02;
        continue;
      }
      if( c=='e' || c=='E' ){
        if( z[j-1]<'0' ){
          if( (z[j-1]=='.') && (j-2>=i) && (sqlite3CtypeMap[(unsigned char)(z[j-2])]&0x04) ){
            pParse->hasNonstd = 1;
            t |= 0x01;
          }else{
            pParse->iErr = j;
            return -1;
          }
        }
        if( seenE ){
          pParse->iErr = j;
          return -1;
        }
        t |= 0x02;
        seenE = 1;
        c = z[j+1];
        if( c=='+' || c=='-' ){
          j++;
          c = z[j+1];
        }
        if( c<'0' || c>'9' ){
          pParse->iErr = j;
          return -1;
        }
        continue;
      }
      break;
    }
    if( z[j-1]<'0' ){
      if( (z[j-1]=='.') && (j-2>=i) && (sqlite3CtypeMap[(unsigned char)(z[j-2])]&0x04) ){
        pParse->hasNonstd = 1;
        t |= 0x01;
      }else{
        pParse->iErr = j;
        return -1;
      }
    }
  parse_number_finish:
    ((void) (0));
    ((void) (0));
    ((void) (0));
    if( z[i]=='+' ) i++;
    jsonBlobAppendNode(pParse, 3 +t, j-i, &z[i]);
    return j;
  }
  case '}': {
    pParse->iErr = i;
    return -2;
  }
  case ']': {
    pParse->iErr = i;
    return -3;
  }
  case ',': {
    pParse->iErr = i;
    return -4;
  }
  case ':': {
    pParse->iErr = i;
    return -5;
  }
  case 0: {
    return 0;
  }
  case 0x09:
  case 0x0a:
  case 0x0d:
  case 0x20: {
    i += 1 + (u32)strspn(&z[i+1], jsonSpaces);
    goto json_parse_restart;
  }
  case 0x0b:
  case 0x0c:
  case '/':
  case 0xc2:
  case 0xe1:
  case 0xe2:
  case 0xe3:
  case 0xef: {
    j = json5Whitespace(&z[i]);
    if( j>0 ){
      i += j;
      pParse->hasNonstd = 1;
      goto json_parse_restart;
    }
    pParse->iErr = i;
    return -1;
  }
  case 'n': {
    if( strncmp(z+i,"null",4)==0 && !(sqlite3CtypeMap[(unsigned char)(z[i+4])]&0x06) ){
      jsonBlobAppendOneByte(pParse, 0);
      return i+4;
    }

                   __attribute__((fallthrough));
  }
  default: {
    u32 k;
    int nn;
    c = z[i];
    for(k=0; k<sizeof(aNanInfName)/sizeof(aNanInfName[0]); k++){
      if( c!=aNanInfName[k].c1 && c!=aNanInfName[k].c2 ) continue;
      nn = aNanInfName[k].n;
      if( sqlite3_strnicmp(&z[i], aNanInfName[k].zMatch, nn)!=0 ){
        continue;
      }
      if( (sqlite3CtypeMap[(unsigned char)(z[i+nn])]&0x06) ) continue;
      if( aNanInfName[k].eType==5 ){
        jsonBlobAppendNode(pParse, 5, 5, "9e999");
      }else{
        jsonBlobAppendOneByte(pParse, 0);
      }
      pParse->hasNonstd = 1;
      return i + nn;
    }
    pParse->iErr = i;
    return -1;
  }
  }
}
# 212154 "c_tests/sqlite3.c"
static int jsonConvertTextToBlob(
  JsonParse *pParse,
  sqlite3_context *pCtx
){
  int i;
  const char *zJson = pParse->zJson;
  i = jsonTranslateTextToBlob(pParse, 0);
  if( pParse->oom ) i = -1;
  if( i>0 ){






    while( (jsonIsSpace[(unsigned char)zJson[i]]) ) i++;
    if( zJson[i] ){
      i += json5Whitespace(&zJson[i]);
      if( zJson[i] ){
        if( pCtx ) sqlite3_result_error(pCtx, "malformed JSON", -1);
        jsonParseReset(pParse);
        return 1;
      }
      pParse->hasNonstd = 1;
    }
  }
  if( i<=0 ){
    if( pCtx!=0 ){
      if( pParse->oom ){
        sqlite3_result_error_nomem(pCtx);
      }else{
        sqlite3_result_error(pCtx, "malformed JSON", -1);
      }
    }
    jsonParseReset(pParse);
    return 1;
  }
  return 0;
}






static void jsonReturnStringAsBlob(JsonString *pStr){
  JsonParse px;
  memset(&px, 0, sizeof(px));
  jsonStringTerminate(pStr);
  if( pStr->eErr ){
    sqlite3_result_error_nomem(pStr->pCtx);
    return;
  }
  px.zJson = pStr->zBuf;
  px.nJson = pStr->nUsed;
  px.db = sqlite3_context_db_handle(pStr->pCtx);
  (void)jsonTranslateTextToBlob(&px, 0);
  if( px.oom ){
    sqlite3DbFree(px.db, px.aBlob);
    sqlite3_result_error_nomem(pStr->pCtx);
  }else{
    ((void) (0));
    ((void) (0));
    sqlite3_result_blob(pStr->pCtx, px.aBlob, px.nBlob, ((sqlite3_destructor_type)sqlite3RowSetClear));
  }
}






static u32 jsonbPayloadSize(const JsonParse *pParse, u32 i, u32 *pSz){
  u8 x;
  u32 sz;
  u32 n;
  ((void) (0));
  x = pParse->aBlob[i]>>4;
  if( x<=11 ){
    sz = x;
    n = 1;
  }else if( x==12 ){
    if( i+1>=pParse->nBlob ){
      *pSz = 0;
      return 0;
    }
    sz = pParse->aBlob[i+1];
    n = 2;
  }else if( x==13 ){
    if( i+2>=pParse->nBlob ){
      *pSz = 0;
      return 0;
    }
    sz = (pParse->aBlob[i+1]<<8) + pParse->aBlob[i+2];
    n = 3;
  }else if( x==14 ){
    if( i+4>=pParse->nBlob ){
      *pSz = 0;
      return 0;
    }
    sz = ((u32)pParse->aBlob[i+1]<<24) + (pParse->aBlob[i+2]<<16) +
         (pParse->aBlob[i+3]<<8) + pParse->aBlob[i+4];
    n = 5;
  }else{
    if( i+8>=pParse->nBlob
     || pParse->aBlob[i+1]!=0
     || pParse->aBlob[i+2]!=0
     || pParse->aBlob[i+3]!=0
     || pParse->aBlob[i+4]!=0
    ){
      *pSz = 0;
      return 0;
    }
    sz = ((u32)pParse->aBlob[i+5]<<24) + (pParse->aBlob[i+6]<<16) +
         (pParse->aBlob[i+7]<<8) + pParse->aBlob[i+8];
    n = 9;
  }
  if( (i64)i+sz+n > pParse->nBlob
   && (i64)i+sz+n > pParse->nBlob-pParse->delta
  ){
    *pSz = 0;
    return 0;
  }
  *pSz = sz;
  return n;
}
# 212295 "c_tests/sqlite3.c"
static u32 jsonTranslateBlobToText(
  const JsonParse *pParse,
  u32 i,
  JsonString *pOut
){
  u32 sz, n, j, iEnd;

  n = jsonbPayloadSize(pParse, i, &sz);
  if( n==0 ){
    pOut->eErr |= 0x02;
    return pParse->nBlob+1;
  }
  switch( pParse->aBlob[i] & 0x0f ){
    case 0: {
      jsonAppendRawNZ(pOut, "null", 4);
      return i+1;
    }
    case 1: {
      jsonAppendRawNZ(pOut, "true", 4);
      return i+1;
    }
    case 2: {
      jsonAppendRawNZ(pOut, "false", 5);
      return i+1;
    }
    case 3:
    case 5: {
      if( sz==0 ) goto malformed_jsonb;
      jsonAppendRaw(pOut, (const char*)&pParse->aBlob[i+n], sz);
      break;
    }
    case 4: {
      u32 k = 2;
      sqlite3_uint64 u = 0;
      const char *zIn = (const char*)&pParse->aBlob[i+n];
      int bOverflow = 0;
      if( sz==0 ) goto malformed_jsonb;
      if( zIn[0]=='-' ){
        jsonAppendChar(pOut, '-');
        k++;
      }else if( zIn[0]=='+' ){
        k++;
      }
      for(; k<sz; k++){
        if( !(sqlite3CtypeMap[(unsigned char)(zIn[k])]&0x08) ){
          pOut->eErr |= 0x02;
          break;
        }else if( (u>>60)!=0 ){
          bOverflow = 1;
        }else{
          u = u*16 + sqlite3HexToInt(zIn[k]);
        }
      }
      jsonPrintf(100,pOut,bOverflow?"9.0e999":"%llu", u);
      break;
    }
    case 6: {
      u32 k = 0;
      const char *zIn = (const char*)&pParse->aBlob[i+n];
      if( sz==0 ) goto malformed_jsonb;
      if( zIn[0]=='-' ){
        jsonAppendChar(pOut, '-');
        k++;
      }
      if( zIn[k]=='.' ){
        jsonAppendChar(pOut, '0');
      }
      for(; k<sz; k++){
        jsonAppendChar(pOut, zIn[k]);
        if( zIn[k]=='.' && (k+1==sz || !(sqlite3CtypeMap[(unsigned char)(zIn[k+1])]&0x04)) ){
          jsonAppendChar(pOut, '0');
        }
      }
      break;
    }
    case 7:
    case 8: {
      if( pOut->nUsed+sz+2<=pOut->nAlloc || jsonStringGrow(pOut, sz+2)==0 ){
        pOut->zBuf[pOut->nUsed] = '"';
        memcpy(pOut->zBuf+pOut->nUsed+1,(const char*)&pParse->aBlob[i+n],sz);
        pOut->zBuf[pOut->nUsed+sz+1] = '"';
        pOut->nUsed += sz+2;
      }
      break;
    }
    case 9: {
      const char *zIn;
      u32 k;
      u32 sz2 = sz;
      zIn = (const char*)&pParse->aBlob[i+n];
      jsonAppendChar(pOut, '"');
      while( sz2>0 ){
        for(k=0; k<sz2 && (jsonIsOk[(u8)zIn[k]] || zIn[k]=='\''); k++){}
        if( k>0 ){
          jsonAppendRawNZ(pOut, zIn, k);
          if( k>=sz2 ){
            break;
          }
          zIn += k;
          sz2 -= k;
        }
        if( zIn[0]=='"' ){
          jsonAppendRawNZ(pOut, "\\\"", 2);
          zIn++;
          sz2--;
          continue;
        }
        if( zIn[0]<=0x1f ){
          if( pOut->nUsed+7>pOut->nAlloc && jsonStringGrow(pOut,7) ) break;
          jsonAppendControlChar(pOut, zIn[0]);
          zIn++;
          sz2--;
          continue;
        }
        ((void) (0));
        ((void) (0));
        if( sz2<2 ){
          pOut->eErr |= 0x02;
          break;
        }
        switch( (u8)zIn[1] ){
          case '\'':
            jsonAppendChar(pOut, '\'');
            break;
          case 'v':
            jsonAppendRawNZ(pOut, "\\u000b", 6);
            break;
          case 'x':
            if( sz2<4 ){
              pOut->eErr |= 0x02;
              sz2 = 2;
              break;
            }
            jsonAppendRawNZ(pOut, "\\u00", 4);
            jsonAppendRawNZ(pOut, &zIn[2], 2);
            zIn += 2;
            sz2 -= 2;
            break;
          case '0':
            jsonAppendRawNZ(pOut, "\\u0000", 6);
            break;
          case '\r':
            if( sz2>2 && zIn[2]=='\n' ){
              zIn++;
              sz2--;
            }
            break;
          case '\n':
            break;
          case 0xe2:



            if( sz2<4
             || 0x80!=(u8)zIn[2]
             || (0xa8!=(u8)zIn[3] && 0xa9!=(u8)zIn[3])
            ){
              pOut->eErr |= 0x02;
              sz2 = 2;
              break;
            }
            zIn += 2;
            sz2 -= 2;
            break;
          default:
            jsonAppendRawNZ(pOut, zIn, 2);
            break;
        }
        ((void) (0));
        zIn += 2;
        sz2 -= 2;
      }
      jsonAppendChar(pOut, '"');
      break;
    }
    case 10: {
      jsonAppendString(pOut, (const char*)&pParse->aBlob[i+n], sz);
      break;
    }
    case 11: {
      jsonAppendChar(pOut, '[');
      j = i+n;
      iEnd = j+sz;
      while( j<iEnd && pOut->eErr==0 ){
        j = jsonTranslateBlobToText(pParse, j, pOut);
        jsonAppendChar(pOut, ',');
      }
      if( j>iEnd ) pOut->eErr |= 0x02;
      if( sz>0 ) jsonStringTrimOneChar(pOut);
      jsonAppendChar(pOut, ']');
      break;
    }
    case 12: {
      int x = 0;
      jsonAppendChar(pOut, '{');
      j = i+n;
      iEnd = j+sz;
      while( j<iEnd && pOut->eErr==0 ){
        j = jsonTranslateBlobToText(pParse, j, pOut);
        jsonAppendChar(pOut, (x++ & 1) ? ',' : ':');
      }
      if( (x & 1)!=0 || j>iEnd ) pOut->eErr |= 0x02;
      if( sz>0 ) jsonStringTrimOneChar(pOut);
      jsonAppendChar(pOut, '}');
      break;
    }

    default: {
      malformed_jsonb:
      pOut->eErr |= 0x02;
      break;
    }
  }
  return i+n+sz;
}



typedef struct JsonPretty JsonPretty;
struct JsonPretty {
  JsonParse *pParse;
  JsonString *pOut;
  const char *zIndent;
  u32 szIndent;
  u32 nIndent;
};


static void jsonPrettyIndent(JsonPretty *pPretty){
  u32 jj;
  for(jj=0; jj<pPretty->nIndent; jj++){
    jsonAppendRaw(pPretty->pOut, pPretty->zIndent, pPretty->szIndent);
  }
}
# 212547 "c_tests/sqlite3.c"
static u32 jsonTranslateBlobToPrettyText(
  JsonPretty *pPretty,
  u32 i
){
  u32 sz, n, j, iEnd;
  const JsonParse *pParse = pPretty->pParse;
  JsonString *pOut = pPretty->pOut;
  n = jsonbPayloadSize(pParse, i, &sz);
  if( n==0 ){
    pOut->eErr |= 0x02;
    return pParse->nBlob+1;
  }
  switch( pParse->aBlob[i] & 0x0f ){
    case 11: {
      j = i+n;
      iEnd = j+sz;
      jsonAppendChar(pOut, '[');
      if( j<iEnd ){
        jsonAppendChar(pOut, '\n');
        pPretty->nIndent++;
        while( pOut->eErr==0 ){
          jsonPrettyIndent(pPretty);
          j = jsonTranslateBlobToPrettyText(pPretty, j);
          if( j>=iEnd ) break;
          jsonAppendRawNZ(pOut, ",\n", 2);
        }
        jsonAppendChar(pOut, '\n');
        pPretty->nIndent--;
        jsonPrettyIndent(pPretty);
      }
      jsonAppendChar(pOut, ']');
      i = iEnd;
      break;
    }
    case 12: {
      j = i+n;
      iEnd = j+sz;
      jsonAppendChar(pOut, '{');
      if( j<iEnd ){
        jsonAppendChar(pOut, '\n');
        pPretty->nIndent++;
        while( pOut->eErr==0 ){
          jsonPrettyIndent(pPretty);
          j = jsonTranslateBlobToText(pParse, j, pOut);
          if( j>iEnd ){
            pOut->eErr |= 0x02;
            break;
          }
          jsonAppendRawNZ(pOut, ": ", 2);
          j = jsonTranslateBlobToPrettyText(pPretty, j);
          if( j>=iEnd ) break;
          jsonAppendRawNZ(pOut, ",\n", 2);
        }
        jsonAppendChar(pOut, '\n');
        pPretty->nIndent--;
        jsonPrettyIndent(pPretty);
      }
      jsonAppendChar(pOut, '}');
      i = iEnd;
      break;
    }
    default: {
      i = jsonTranslateBlobToText(pParse, i, pOut);
      break;
    }
  }
  return i;
}





static u32 jsonbArrayCount(JsonParse *pParse, u32 iRoot){
  u32 n, sz, i, iEnd;
  u32 k = 0;
  n = jsonbPayloadSize(pParse, iRoot, &sz);
  iEnd = iRoot+n+sz;
  for(i=iRoot+n; n>0 && i<iEnd; i+=sz+n, k++){
    n = jsonbPayloadSize(pParse, i, &sz);
  }
  return k;
}





static void jsonAfterEditSizeAdjust(JsonParse *pParse, u32 iRoot){
  u32 sz = 0;
  u32 nBlob;
  ((void) (0));
  ((void) (0));
  nBlob = pParse->nBlob;
  pParse->nBlob = pParse->nBlobAlloc;
  (void)jsonbPayloadSize(pParse, iRoot, &sz);
  pParse->nBlob = nBlob;
  sz += pParse->delta;
  pParse->delta += jsonBlobChangePayloadSize(pParse, iRoot, sz);
}
# 212664 "c_tests/sqlite3.c"
static int jsonBlobOverwrite(
  u8 *aOut,
  const u8 *aIns,
  u32 nIns,
  u32 d
){
  u32 szPayload;
  u32 i;
  u8 szHdr;





  static const u8 aType[] = { 0xc0, 0xd0, 0, 0xe0, 0, 0, 0, 0xf0 };

  if( (aIns[0]&0x0f)<=2 ) return 0;
  switch( aIns[0]>>4 ){
    default: {
      if( ((1<<d)&0x116)==0 ) return 0;
      i = d + 1;
      szHdr = 1;
      break;
    }
    case 12: {
      if( ((1<<d)&0x8a)==0) return 0;
      i = d + 2;
      szHdr = 2;
      break;
    }
    case 13: {
      if( d!=2 && d!=6 ) return 0;
      i = d + 3;
      szHdr = 3;
      break;
    }
    case 14: {
      if( d!=4 ) return 0;
      i = 9;
      szHdr = 5;
      break;
    }
    case 15: {
      return 0;
    }
  }
  ((void) (0));
  aOut[0] = (aIns[0] & 0x0f) | aType[i-2];
  memcpy(&aOut[i], &aIns[szHdr], nIns-szHdr);
  szPayload = nIns - szHdr;
  while( 1 ){
    i--;
    aOut[i] = szPayload & 0xff;
    if( i==1 ) break;
    szPayload >>= 8;
  }
  ((void) (0));
  return 1;
}
# 212737 "c_tests/sqlite3.c"
static void jsonBlobEdit(
  JsonParse *pParse,
  u32 iDel,
  u32 nDel,
  const u8 *aIns,
  u32 nIns
){
  i64 d = (i64)nIns - (i64)nDel;
  if( d<0 && d>=(-8) && aIns!=0
   && jsonBlobOverwrite(&pParse->aBlob[iDel], aIns, nIns, (int)-d)
  ){
    return;
  }
  if( d!=0 ){
    if( pParse->nBlob + d > pParse->nBlobAlloc ){
      jsonBlobExpand(pParse, pParse->nBlob+d);
      if( pParse->oom ) return;
    }
    memmove(&pParse->aBlob[iDel+nIns],
            &pParse->aBlob[iDel+nDel],
            pParse->nBlob - (iDel+nDel));
    pParse->nBlob += d;
    pParse->delta += d;
  }
  if( nIns && aIns ){
    memcpy(&pParse->aBlob[iDel], aIns, nIns);
  }
}
# 212776 "c_tests/sqlite3.c"
static u32 jsonBytesToBypass(const char *z, u32 n){
  u32 i = 0;
  while( i+1<n ){
    if( z[i]!='\\' ) return i;
    if( z[i+1]=='\n' ){
      i += 2;
      continue;
    }
    if( z[i+1]=='\r' ){
      if( i+2<n && z[i+2]=='\n' ){
        i += 3;
      }else{
        i += 2;
      }
      continue;
    }
    if( 0xe2==(u8)z[i+1]
     && i+3<n
     && 0x80==(u8)z[i+2]
     && (0xa8==(u8)z[i+3] || 0xa9==(u8)z[i+3])
    ){
      i += 4;
      continue;
    }
    break;
  }
  return i;
}
# 212814 "c_tests/sqlite3.c"
static u32 jsonUnescapeOneChar(const char *z, u32 n, u32 *piOut){
  ((void) (0));
  ((void) (0));
  if( n<2 ){
    *piOut = 0x99999;
    return n;
  }
  switch( (u8)z[1] ){
    case 'u': {
      u32 v, vlo;
      if( n<6 ){
        *piOut = 0x99999;
        return n;
      }
      v = jsonHexToInt4(&z[2]);
      if( (v & 0xfc00)==0xd800
       && n>=12
       && z[6]=='\\'
       && z[7]=='u'
       && ((vlo = jsonHexToInt4(&z[8]))&0xfc00)==0xdc00
      ){
        *piOut = ((v&0x3ff)<<10) + (vlo&0x3ff) + 0x10000;
        return 12;
      }else{
        *piOut = v;
        return 6;
      }
    }
    case 'b': { *piOut = '\b'; return 2; }
    case 'f': { *piOut = '\f'; return 2; }
    case 'n': { *piOut = '\n'; return 2; }
    case 'r': { *piOut = '\r'; return 2; }
    case 't': { *piOut = '\t'; return 2; }
    case 'v': { *piOut = '\v'; return 2; }
    case '0': {
# 212859 "c_tests/sqlite3.c"
      *piOut = (n>2 && (sqlite3CtypeMap[(unsigned char)(z[2])]&0x04)) ? 0x99999 : 0;

      return 2;
    }
    case '\'':
    case '"':
    case '/':
    case '\\':{ *piOut = z[1]; return 2; }
    case 'x': {
      if( n<4 ){
        *piOut = 0x99999;
        return n;
      }
      *piOut = (jsonHexToInt(z[2])<<4) | jsonHexToInt(z[3]);
      return 4;
    }
    case 0xe2:
    case '\r':
    case '\n': {
      u32 nSkip = jsonBytesToBypass(z, n);
      if( nSkip==0 ){
        *piOut = 0x99999;
        return n;
      }else if( nSkip==n ){
        *piOut = 0;
        return n;
      }else if( z[nSkip]=='\\' ){
        return nSkip + jsonUnescapeOneChar(&z[nSkip], n-nSkip, piOut);
      }else{
        int sz = sqlite3Utf8ReadLimited((u8*)&z[nSkip], n-nSkip, piOut);
        return nSkip + sz;
      }
    }
    default: {
      *piOut = 0x99999;
      return 2;
    }
  }
}
# 212907 "c_tests/sqlite3.c"
static __attribute__((noinline)) int jsonLabelCompareEscaped(
  const char *zLeft,
  u32 nLeft,
  int rawLeft,
  const char *zRight,
  u32 nRight,
  int rawRight
){
  u32 cLeft, cRight;
  ((void) (0));
  while( 1 ){
    if( nLeft==0 ){
      cLeft = 0;
    }else if( rawLeft || zLeft[0]!='\\' ){
      cLeft = ((u8*)zLeft)[0];
      if( cLeft>=0xc0 ){
        int sz = sqlite3Utf8ReadLimited((u8*)zLeft, nLeft, &cLeft);
        zLeft += sz;
        nLeft -= sz;
      }else{
        zLeft++;
        nLeft--;
      }
    }else{
      u32 n = jsonUnescapeOneChar(zLeft, nLeft, &cLeft);
      zLeft += n;
      ((void) (0));
      nLeft -= n;
    }
    if( nRight==0 ){
      cRight = 0;
    }else if( rawRight || zRight[0]!='\\' ){
      cRight = ((u8*)zRight)[0];
      if( cRight>=0xc0 ){
        int sz = sqlite3Utf8ReadLimited((u8*)zRight, nRight, &cRight);
        zRight += sz;
        nRight -= sz;
      }else{
        zRight++;
        nRight--;
      }
    }else{
      u32 n = jsonUnescapeOneChar(zRight, nRight, &cRight);
      zRight += n;
      ((void) (0));
      nRight -= n;
    }
    if( cLeft!=cRight ) return 0;
    if( cLeft==0 ) return 1;
  }
}





static int jsonLabelCompare(
  const char *zLeft,
  u32 nLeft,
  int rawLeft,
  const char *zRight,
  u32 nRight,
  int rawRight
){
  if( rawLeft && rawRight ){


    if( nLeft!=nRight ) return 0;
    return memcmp(zLeft, zRight, nLeft)==0;
  }else{
    return jsonLabelCompareEscaped(zLeft, nLeft, rawLeft,
                                   zRight, nRight, rawRight);
  }
}
# 212991 "c_tests/sqlite3.c"
static u32 jsonLookupStep(JsonParse*,u32,const char*,u32);
# 213013 "c_tests/sqlite3.c"
static u32 jsonCreateEditSubstructure(
  JsonParse *pParse,
  JsonParse *pIns,
  const char *zTail
){
  static const u8 emptyObject[] = { 11, 12 };
  int rc;
  memset(pIns, 0, sizeof(*pIns));
  pIns->db = pParse->db;
  if( zTail[0]==0 ){

    pIns->aBlob = pParse->aIns;
    pIns->nBlob = pParse->nIns;
    rc = 0;
  }else{

    pIns->nBlob = 1;
    pIns->aBlob = (u8*)&emptyObject[zTail[0]=='.'];
    pIns->eEdit = pParse->eEdit;
    pIns->nIns = pParse->nIns;
    pIns->aIns = pParse->aIns;
    rc = jsonLookupStep(pIns, 0, zTail, 0);
    pParse->oom |= pIns->oom;
  }
  return rc;
}
# 213057 "c_tests/sqlite3.c"
static u32 jsonLookupStep(
  JsonParse *pParse,
  u32 iRoot,
  const char *zPath,
  u32 iLabel
){
  u32 i, j, k, nKey, sz, n, iEnd, rc;
  const char *zKey;
  u8 x;

  if( zPath[0]==0 ){
    if( pParse->eEdit && jsonBlobMakeEditable(pParse, pParse->nIns) ){
      n = jsonbPayloadSize(pParse, iRoot, &sz);
      sz += n;
      if( pParse->eEdit==1 ){
        if( iLabel>0 ){
          sz += iRoot - iLabel;
          iRoot = iLabel;
        }
        jsonBlobEdit(pParse, iRoot, sz, 0, 0);
      }else if( pParse->eEdit==3 ){

      }else{

        jsonBlobEdit(pParse, iRoot, sz, pParse->aIns, pParse->nIns);
      }
    }
    pParse->iLabel = iLabel;
    return iRoot;
  }
  if( zPath[0]=='.' ){
    int rawKey = 1;
    x = pParse->aBlob[iRoot];
    zPath++;
    if( zPath[0]=='"' ){
      zKey = zPath + 1;
      for(i=1; zPath[i] && zPath[i]!='"'; i++){
        if( zPath[i]=='\\' && zPath[i+1]!=0 ) i++;
      }
      nKey = i-1;
      if( zPath[i] ){
        i++;
      }else{
        return 0xfffffffd;
      }
                         ;
      rawKey = memchr(zKey, '\\', nKey)==0;
    }else{
      zKey = zPath;
      for(i=0; zPath[i] && zPath[i]!='.' && zPath[i]!='['; i++){}
      nKey = i;
      if( nKey==0 ){
        return 0xfffffffd;
      }
    }
    if( (x & 0x0f)!=12 ) return 0xfffffffe;
    n = jsonbPayloadSize(pParse, iRoot, &sz);
    j = iRoot + n;
    iEnd = j+sz;
    while( j<iEnd ){
      int rawLabel;
      const char *zLabel;
      x = pParse->aBlob[j] & 0x0f;
      if( x<7 || x>10 ) return 0xffffffff;
      n = jsonbPayloadSize(pParse, j, &sz);
      if( n==0 ) return 0xffffffff;
      k = j+n;
      if( k+sz>=iEnd ) return 0xffffffff;
      zLabel = (const char*)&pParse->aBlob[k];
      rawLabel = x==7 || x==10;
      if( jsonLabelCompare(zKey, nKey, rawKey, zLabel, sz, rawLabel) ){
        u32 v = k+sz;
        if( ((pParse->aBlob[v])&0x0f)>12 ) return 0xffffffff;
        n = jsonbPayloadSize(pParse, v, &sz);
        if( n==0 || v+n+sz>iEnd ) return 0xffffffff;
        ((void) (0));
        rc = jsonLookupStep(pParse, v, &zPath[i], j);
        if( pParse->delta ) jsonAfterEditSizeAdjust(pParse, iRoot);
        return rc;
      }
      j = k+sz;
      if( ((pParse->aBlob[j])&0x0f)>12 ) return 0xffffffff;
      n = jsonbPayloadSize(pParse, j, &sz);
      if( n==0 ) return 0xffffffff;
      j += n+sz;
    }
    if( j>iEnd ) return 0xffffffff;
    if( pParse->eEdit>=3 ){
      u32 nIns;
      JsonParse v;
      JsonParse ix;
                                          ;
                                          ;
      memset(&ix, 0, sizeof(ix));
      ix.db = pParse->db;
      jsonBlobAppendNode(&ix, rawKey?10:9, nKey, 0);
      pParse->oom |= ix.oom;
      rc = jsonCreateEditSubstructure(pParse, &v, &zPath[i]);
      if( !((rc)>=0xfffffffd)
       && jsonBlobMakeEditable(pParse, ix.nBlob+nKey+v.nBlob)
      ){
        ((void) (0));
        nIns = ix.nBlob + nKey + v.nBlob;
        jsonBlobEdit(pParse, j, 0, 0, nIns);
        if( !pParse->oom ){
          ((void) (0));
          ((void) (0));
          memcpy(&pParse->aBlob[j], ix.aBlob, ix.nBlob);
          k = j + ix.nBlob;
          memcpy(&pParse->aBlob[k], zKey, nKey);
          k += nKey;
          memcpy(&pParse->aBlob[k], v.aBlob, v.nBlob);
          if( (pParse->delta) ) jsonAfterEditSizeAdjust(pParse, iRoot);
        }
      }
      jsonParseReset(&v);
      jsonParseReset(&ix);
      return rc;
    }
  }else if( zPath[0]=='[' ){
    x = pParse->aBlob[iRoot] & 0x0f;
    if( x!=11 ) return 0xfffffffe;
    n = jsonbPayloadSize(pParse, iRoot, &sz);
    k = 0;
    i = 1;
    while( (sqlite3CtypeMap[(unsigned char)(zPath[i])]&0x04) ){
      k = k*10 + zPath[i] - '0';
      i++;
    }
    if( i<2 || zPath[i]!=']' ){
      if( zPath[1]=='#' ){
        k = jsonbArrayCount(pParse, iRoot);
        i = 2;
        if( zPath[2]=='-' && (sqlite3CtypeMap[(unsigned char)(zPath[3])]&0x04) ){
          unsigned int nn = 0;
          i = 3;
          do{
            nn = nn*10 + zPath[i] - '0';
            i++;
          }while( (sqlite3CtypeMap[(unsigned char)(zPath[i])]&0x04) );
          if( nn>k ) return 0xfffffffe;
          k -= nn;
        }
        if( zPath[i]!=']' ){
          return 0xfffffffd;
        }
      }else{
        return 0xfffffffd;
      }
    }
    j = iRoot+n;
    iEnd = j+sz;
    while( j<iEnd ){
      if( k==0 ){
        rc = jsonLookupStep(pParse, j, &zPath[i+1], 0);
        if( pParse->delta ) jsonAfterEditSizeAdjust(pParse, iRoot);
        return rc;
      }
      k--;
      n = jsonbPayloadSize(pParse, j, &sz);
      if( n==0 ) return 0xffffffff;
      j += n+sz;
    }
    if( j>iEnd ) return 0xffffffff;
    if( k>0 ) return 0xfffffffe;
    if( pParse->eEdit>=3 ){
      JsonParse v;
                                          ;
                                          ;
      rc = jsonCreateEditSubstructure(pParse, &v, &zPath[i+1]);
      if( !((rc)>=0xfffffffd)
       && jsonBlobMakeEditable(pParse, v.nBlob)
      ){
        ((void) (0));
        jsonBlobEdit(pParse, j, 0, v.aBlob, v.nBlob);
      }
      jsonParseReset(&v);
      if( pParse->delta ) jsonAfterEditSizeAdjust(pParse, iRoot);
      return rc;
    }
  }else{
    return 0xfffffffd;
  }
  return 0xfffffffe;
}





static void jsonReturnTextJsonFromBlob(
  sqlite3_context *ctx,
  const u8 *aBlob,
  u32 nBlob
){
  JsonParse x;
  JsonString s;

  if( (aBlob==0) ) return;
  memset(&x, 0, sizeof(x));
  x.aBlob = (u8*)aBlob;
  x.nBlob = nBlob;
  jsonStringInit(&s, ctx);
  jsonTranslateBlobToText(&x, 0, &s);
  jsonReturnString(&s, 0, 0);
}
# 213280 "c_tests/sqlite3.c"
static void jsonReturnFromBlob(
  JsonParse *pParse,
  u32 i,
  sqlite3_context *pCtx,
  int eMode
){
  u32 n, sz;
  int rc;
  sqlite3 *db = sqlite3_context_db_handle(pCtx);

  ((void) (0));
  n = jsonbPayloadSize(pParse, i, &sz);
  if( n==0 ){
    sqlite3_result_error(pCtx, "malformed JSON", -1);
    return;
  }
  switch( pParse->aBlob[i] & 0x0f ){
    case 0: {
      if( sz ) goto returnfromblob_malformed;
      sqlite3_result_null(pCtx);
      break;
    }
    case 1: {
      if( sz ) goto returnfromblob_malformed;
      sqlite3_result_int(pCtx, 1);
      break;
    }
    case 2: {
      if( sz ) goto returnfromblob_malformed;
      sqlite3_result_int(pCtx, 0);
      break;
    }
    case 4:
    case 3: {
      sqlite3_int64 iRes = 0;
      char *z;
      int bNeg = 0;
      char x;
      if( sz==0 ) goto returnfromblob_malformed;
      x = (char)pParse->aBlob[i+n];
      if( x=='-' ){
        if( sz<2 ) goto returnfromblob_malformed;
        n++;
        sz--;
        bNeg = 1;
      }
      z = sqlite3DbStrNDup(db, (const char*)&pParse->aBlob[i+n], (int)sz);
      if( z==0 ) goto returnfromblob_oom;
      rc = sqlite3DecOrHexToI64(z, &iRes);
      sqlite3DbFree(db, z);
      if( rc==0 ){
        if( iRes<0 ){






          double r;
          r = (double)*(sqlite3_uint64*)&iRes;
          sqlite3_result_double(pCtx, bNeg ? -r : r);
        }else{
          sqlite3_result_int64(pCtx, bNeg ? -iRes : iRes);
        }
      }else if( rc==3 && bNeg ){
        sqlite3_result_int64(pCtx, (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))));
      }else if( rc==1 ){
        goto returnfromblob_malformed;
      }else{
        if( bNeg ){ n--; sz++; }
        goto to_double;
      }
      break;
    }
    case 6:
    case 5: {
      double r;
      char *z;
      if( sz==0 ) goto returnfromblob_malformed;
    to_double:
      z = sqlite3DbStrNDup(db, (const char*)&pParse->aBlob[i+n], (int)sz);
      if( z==0 ) goto returnfromblob_oom;
      rc = sqlite3AtoF(z, &r, sqlite3Strlen30(z), 1);
      sqlite3DbFree(db, z);
      if( rc<=0 ) goto returnfromblob_malformed;
      sqlite3_result_double(pCtx, r);
      break;
    }
    case 10:
    case 7: {
      sqlite3_result_text(pCtx, (char*)&pParse->aBlob[i+n], sz,
                          ((sqlite3_destructor_type)-1));
      break;
    }
    case 9:
    case 8: {

      u32 iIn, iOut;
      const char *z;
      char *zOut;
      u32 nOut = sz;
      z = (const char*)&pParse->aBlob[i+n];
      zOut = sqlite3DbMallocRaw(db, ((u64)nOut)+1);
      if( zOut==0 ) goto returnfromblob_oom;
      for(iIn=iOut=0; iIn<sz; iIn++){
        char c = z[iIn];
        if( c=='\\' ){
          u32 v;
          u32 szEscape = jsonUnescapeOneChar(&z[iIn], sz-iIn, &v);
          if( v<=0x7f ){
            zOut[iOut++] = (char)v;
          }else if( v<=0x7ff ){
            ((void) (0));
            zOut[iOut++] = (char)(0xc0 | (v>>6));
            zOut[iOut++] = 0x80 | (v&0x3f);
          }else if( v<0x10000 ){
            ((void) (0));
            zOut[iOut++] = 0xe0 | (v>>12);
            zOut[iOut++] = 0x80 | ((v>>6)&0x3f);
            zOut[iOut++] = 0x80 | (v&0x3f);
          }else if( v==0x99999 ){

          }else{
            ((void) (0));
            zOut[iOut++] = 0xf0 | (v>>18);
            zOut[iOut++] = 0x80 | ((v>>12)&0x3f);
            zOut[iOut++] = 0x80 | ((v>>6)&0x3f);
            zOut[iOut++] = 0x80 | (v&0x3f);
          }
          iIn += szEscape - 1;
        }else{
          zOut[iOut++] = c;
        }
      }
      ((void) (0));
      zOut[iOut] = 0;
      sqlite3_result_text(pCtx, zOut, iOut, ((sqlite3_destructor_type)sqlite3RowSetClear));
      break;
    }
    case 11:
    case 12: {
      if( eMode==0 ){
        if( (((int)(long int)(sqlite3_user_data(pCtx))) & 0x08)!=0 ){
          eMode = 2;
        }else{
          eMode = 1;
        }
      }
      if( eMode==2 ){
        sqlite3_result_blob(pCtx, &pParse->aBlob[i], sz+n, ((sqlite3_destructor_type)-1));
      }else{
        jsonReturnTextJsonFromBlob(pCtx, &pParse->aBlob[i], sz+n);
      }
      break;
    }
    default: {
      goto returnfromblob_malformed;
    }
  }
  return;

returnfromblob_oom:
  sqlite3_result_error_nomem(pCtx);
  return;

returnfromblob_malformed:
  sqlite3_result_error(pCtx, "malformed JSON", -1);
  return;
}
# 213467 "c_tests/sqlite3.c"
static int jsonFunctionArgToBlob(
  sqlite3_context *ctx,
  sqlite3_value *pArg,
  JsonParse *pParse
){
  int eType = sqlite3_value_type(pArg);
  static u8 aNull[] = { 0x00 };
  memset(pParse, 0, sizeof(pParse[0]));
  pParse->db = sqlite3_context_db_handle(ctx);
  switch( eType ){
    default: {
      pParse->aBlob = aNull;
      pParse->nBlob = 1;
      return 0;
    }
    case 4: {
      if( !jsonArgIsJsonb(pArg, pParse) ){
        sqlite3_result_error(ctx, "JSON cannot hold BLOB values", -1);
        return 1;
      }
      break;
    }
    case 3: {
      const char *zJson = (const char*)sqlite3_value_text(pArg);
      int nJson = sqlite3_value_bytes(pArg);
      if( zJson==0 ) return 1;
      if( sqlite3_value_subtype(pArg)==74 ){
        pParse->zJson = (char*)zJson;
        pParse->nJson = nJson;
        if( jsonConvertTextToBlob(pParse, ctx) ){
          sqlite3_result_error(ctx, "malformed JSON", -1);
          sqlite3DbFree(pParse->db, pParse->aBlob);
          memset(pParse, 0, sizeof(pParse[0]));
          return 1;
        }
      }else{
        jsonBlobAppendNode(pParse, 10, nJson, zJson);
      }
      break;
    }
    case 2: {
      double r = sqlite3_value_double(pArg);
      if( (sqlite3IsNaN(r)) ){
        jsonBlobAppendNode(pParse, 0, 0, 0);
      }else{
        int n = sqlite3_value_bytes(pArg);
        const char *z = (const char*)sqlite3_value_text(pArg);
        if( z==0 ) return 1;
        if( z[0]=='I' ){
          jsonBlobAppendNode(pParse, 5, 5, "9e999");
        }else if( z[0]=='-' && z[1]=='I' ){
          jsonBlobAppendNode(pParse, 5, 6, "-9e999");
        }else{
          jsonBlobAppendNode(pParse, 5, n, z);
        }
      }
      break;
    }
    case 1: {
      int n = sqlite3_value_bytes(pArg);
      const char *z = (const char*)sqlite3_value_text(pArg);
      if( z==0 ) return 1;
      jsonBlobAppendNode(pParse, 3, n, z);
      break;
    }
  }
  if( pParse->oom ){
    sqlite3_result_error_nomem(ctx);
    return 1;
  }else{
    return 0;
  }
}







static char *jsonBadPathError(
  sqlite3_context *ctx,
  const char *zPath
){
  char *zMsg = sqlite3_mprintf("bad JSON path: %Q", zPath);
  if( ctx==0 ) return zMsg;
  if( zMsg ){
    sqlite3_result_error(ctx, zMsg, -1);
    sqlite3_free(zMsg);
  }else{
    sqlite3_result_error_nomem(ctx);
  }
  return 0;
}
# 213570 "c_tests/sqlite3.c"
static void jsonInsertIntoBlob(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv,
  int eEdit
){
  int i;
  u32 rc = 0;
  const char *zPath = 0;
  int flgs;
  JsonParse *p;
  JsonParse ax;

  ((void) (0));
  flgs = argc==1 ? 0 : 0x01;
  p = jsonParseFuncArg(ctx, argv[0], flgs);
  if( p==0 ) return;
  for(i=1; i<argc-1; i+=2){
    if( sqlite3_value_type(argv[i])==5 ) continue;
    zPath = (const char*)sqlite3_value_text(argv[i]);
    if( zPath==0 ){
      sqlite3_result_error_nomem(ctx);
      jsonParseFree(p);
      return;
    }
    if( zPath[0]!='$' ) goto jsonInsertIntoBlob_patherror;
    if( jsonFunctionArgToBlob(ctx, argv[i+1], &ax) ){
      jsonParseReset(&ax);
      jsonParseFree(p);
      return;
    }
    if( zPath[1]==0 ){
      if( eEdit==2 || eEdit==4 ){
        jsonBlobEdit(p, 0, p->nBlob, ax.aBlob, ax.nBlob);
      }
      rc = 0;
   }else{
      p->eEdit = eEdit;
      p->nIns = ax.nBlob;
      p->aIns = ax.aBlob;
      p->delta = 0;
      rc = jsonLookupStep(p, 0, zPath+1, 0);
    }
    jsonParseReset(&ax);
    if( rc==0xfffffffe ) continue;
    if( ((rc)>=0xfffffffd) ) goto jsonInsertIntoBlob_patherror;
  }
  jsonReturnParse(ctx, p);
  jsonParseFree(p);
  return;

jsonInsertIntoBlob_patherror:
  jsonParseFree(p);
  if( rc==0xffffffff ){
    sqlite3_result_error(ctx, "malformed JSON", -1);
  }else{
    jsonBadPathError(ctx, zPath);
  }
  return;
}
# 213659 "c_tests/sqlite3.c"
static int jsonArgIsJsonb(sqlite3_value *pArg, JsonParse *p){
  u32 n, sz = 0;
  u8 c;
  if( sqlite3_value_type(pArg)!=4 ) return 0;
  p->aBlob = (u8*)sqlite3_value_blob(pArg);
  p->nBlob = (u32)sqlite3_value_bytes(pArg);
  if( p->nBlob>0
   && (p->aBlob!=0)
   && ((c = p->aBlob[0]) & 0x0f)<=12
   && (n = jsonbPayloadSize(p, 0, &sz))>0
   && sz+n==p->nBlob
   && ((c & 0x0f)>2 || sz==0)
   && (sz>7
      || (c!=0x7b && c!=0x5b && !(sqlite3CtypeMap[(unsigned char)(c)]&0x04))
      || jsonbValidityCheck(p, 0, p->nBlob, 1)==0)
  ){
    return 1;
  }
  p->aBlob = 0;
  p->nBlob = 0;
  return 0;
}
# 213698 "c_tests/sqlite3.c"
static JsonParse *jsonParseFuncArg(
  sqlite3_context *ctx,
  sqlite3_value *pArg,
  u32 flgs
){
  int eType;
  JsonParse *p = 0;
  JsonParse *pFromCache = 0;
  sqlite3 *db;

  ((void) (0));
  eType = sqlite3_value_type(pArg);
  if( eType==5 ){
    return 0;
  }
  pFromCache = jsonCacheSearch(ctx, pArg);
  if( pFromCache ){
    pFromCache->nJPRef++;
    if( (flgs & 0x01)==0 ){
      return pFromCache;
    }
  }
  db = sqlite3_context_db_handle(ctx);
rebuild_from_cache:
  p = sqlite3DbMallocZero(db, sizeof(*p));
  if( p==0 ) goto json_pfa_oom;
  memset(p, 0, sizeof(*p));
  p->db = db;
  p->nJPRef = 1;
  if( pFromCache!=0 ){
    u32 nBlob = pFromCache->nBlob;
    p->aBlob = sqlite3DbMallocRaw(db, nBlob);
    if( p->aBlob==0 ) goto json_pfa_oom;
    memcpy(p->aBlob, pFromCache->aBlob, nBlob);
    p->nBlobAlloc = p->nBlob = nBlob;
    p->hasNonstd = pFromCache->hasNonstd;
    jsonParseFree(pFromCache);
    return p;
  }
  if( eType==4 ){
    if( jsonArgIsJsonb(pArg,p) ){
      if( (flgs & 0x01)!=0 && jsonBlobMakeEditable(p, 0)==0 ){
        goto json_pfa_oom;
      }
      return p;
    }
# 213756 "c_tests/sqlite3.c"
  }
  p->zJson = (char*)sqlite3_value_text(pArg);
  p->nJson = sqlite3_value_bytes(pArg);
  if( db->mallocFailed ) goto json_pfa_oom;
  if( p->nJson==0 ) goto json_pfa_malformed;
  ((void) (0));
  if( jsonConvertTextToBlob(p, (flgs & 0x02) ? 0 : ctx) ){
    if( flgs & 0x02 ){
      p->nErr = 1;
      return p;
    }else{
      jsonParseFree(p);
      return 0;
    }
  }else{
    int isRCStr = sqlite3ValueIsOfClass(pArg, sqlite3RCStrUnref);
    int rc;
    if( !isRCStr ){
      char *zNew = sqlite3RCStrNew( p->nJson );
      if( zNew==0 ) goto json_pfa_oom;
      memcpy(zNew, p->zJson, p->nJson);
      p->zJson = zNew;
      p->zJson[p->nJson] = 0;
    }else{
      sqlite3RCStrRef(p->zJson);
    }
    p->bJsonIsRCStr = 1;
    rc = jsonCacheInsert(ctx, p);
    if( rc==7 ) goto json_pfa_oom;
    if( flgs & 0x01 ){
      pFromCache = p;
      p = 0;
      goto rebuild_from_cache;
    }
  }
  return p;

json_pfa_malformed:
  if( flgs & 0x02 ){
    p->nErr = 1;
    return p;
  }else{
    jsonParseFree(p);
    sqlite3_result_error(ctx, "malformed JSON", -1);
    return 0;
  }

json_pfa_oom:
  jsonParseFree(pFromCache);
  jsonParseFree(p);
  sqlite3_result_error_nomem(ctx);
  return 0;
}






static void jsonReturnParse(
  sqlite3_context *ctx,
  JsonParse *p
){
  int flgs;
  if( p->oom ){
    sqlite3_result_error_nomem(ctx);
    return;
  }
  flgs = ((int)(long int)(sqlite3_user_data(ctx)));
  if( flgs & 0x08 ){
    if( p->nBlobAlloc>0 && !p->bReadOnly ){
      sqlite3_result_blob(ctx, p->aBlob, p->nBlob, ((sqlite3_destructor_type)sqlite3RowSetClear));
      p->nBlobAlloc = 0;
    }else{
      sqlite3_result_blob(ctx, p->aBlob, p->nBlob, ((sqlite3_destructor_type)-1));
    }
  }else{
    JsonString s;
    jsonStringInit(&s, ctx);
    p->delta = 0;
    jsonTranslateBlobToText(p, 0, &s);
    jsonReturnString(&s, p, ctx);
    sqlite3_result_subtype(ctx, 74);
  }
}
# 214000 "c_tests/sqlite3.c"
static void jsonQuoteFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonString jx;
  (void)(argc);

  jsonStringInit(&jx, ctx);
  jsonAppendSqlValue(&jx, argv[0]);
  jsonReturnString(&jx, 0, 0);
  sqlite3_result_subtype(ctx, 74);
}






static void jsonArrayFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  int i;
  JsonString jx;

  jsonStringInit(&jx, ctx);
  jsonAppendChar(&jx, '[');
  for(i=0; i<argc; i++){
    jsonAppendSeparator(&jx);
    jsonAppendSqlValue(&jx, argv[i]);
  }
  jsonAppendChar(&jx, ']');
  jsonReturnString(&jx, 0, 0);
  sqlite3_result_subtype(ctx, 74);
}
# 214045 "c_tests/sqlite3.c"
static void jsonArrayLengthFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonParse *p;
  sqlite3_int64 cnt = 0;
  u32 i;
  u8 eErr = 0;

  p = jsonParseFuncArg(ctx, argv[0], 0);
  if( p==0 ) return;
  if( argc==2 ){
    const char *zPath = (const char*)sqlite3_value_text(argv[1]);
    if( zPath==0 ){
      jsonParseFree(p);
      return;
    }
    i = jsonLookupStep(p, 0, zPath[0]=='$' ? zPath+1 : "@", 0);
    if( ((i)>=0xfffffffd) ){
      if( i==0xfffffffe ){

      }else if( i==0xfffffffd ){
        jsonBadPathError(ctx, zPath);
      }else{
        sqlite3_result_error(ctx, "malformed JSON", -1);
      }
      eErr = 1;
      i = 0;
    }
  }else{
    i = 0;
  }
  if( (p->aBlob[i] & 0x0f)==11 ){
    cnt = jsonbArrayCount(p, i);
  }
  if( !eErr ) sqlite3_result_int64(ctx, cnt);
  jsonParseFree(p);
}


static int jsonAllAlphanum(const char *z, int n){
  int i;
  for(i=0; i<n && ((sqlite3CtypeMap[(unsigned char)(z[i])]&0x06) || z[i]=='_'); i++){}
  return i==n;
}
# 214112 "c_tests/sqlite3.c"
static void jsonExtractFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonParse *p = 0;
  int flags;
  int i;
  JsonString jx;

  if( argc<2 ) return;
  p = jsonParseFuncArg(ctx, argv[0], 0);
  if( p==0 ) return;
  flags = ((int)(long int)(sqlite3_user_data(ctx)));
  jsonStringInit(&jx, ctx);
  if( argc>2 ){
    jsonAppendChar(&jx, '[');
  }
  for(i=1; i<argc; i++){

    const char *zPath = (const char*)sqlite3_value_text(argv[i]);
    int nPath;
    u32 j;
    if( zPath==0 ) goto json_extract_error;
    nPath = sqlite3Strlen30(zPath);
    if( zPath[0]=='$' ){
      j = jsonLookupStep(p, 0, zPath+1, 0);
    }else if( (flags & 0x03) ){
# 214153 "c_tests/sqlite3.c"
      jsonStringInit(&jx, ctx);
      if( sqlite3_value_type(argv[i])==1 ){
        jsonAppendRawNZ(&jx, "[", 1);
        if( zPath[0]=='-' ) jsonAppendRawNZ(&jx,"#",1);
        jsonAppendRaw(&jx, zPath, nPath);
        jsonAppendRawNZ(&jx, "]", 2);
      }else if( jsonAllAlphanum(zPath, nPath) ){
        jsonAppendRawNZ(&jx, ".", 1);
        jsonAppendRaw(&jx, zPath, nPath);
      }else if( zPath[0]=='[' && nPath>=3 && zPath[nPath-1]==']' ){
        jsonAppendRaw(&jx, zPath, nPath);
      }else{
        jsonAppendRawNZ(&jx, ".\"", 2);
        jsonAppendRaw(&jx, zPath, nPath);
        jsonAppendRawNZ(&jx, "\"", 1);
      }
      jsonStringTerminate(&jx);
      j = jsonLookupStep(p, 0, jx.zBuf, 0);
      jsonStringReset(&jx);
    }else{
      jsonBadPathError(ctx, zPath);
      goto json_extract_error;
    }
    if( j<p->nBlob ){
      if( argc==2 ){
        if( flags & 0x01 ){
          jsonStringInit(&jx, ctx);
          jsonTranslateBlobToText(p, j, &jx);
          jsonReturnString(&jx, 0, 0);
          jsonStringReset(&jx);
          ((void) (0));
          sqlite3_result_subtype(ctx, 74);
        }else{
          jsonReturnFromBlob(p, j, ctx, 0);
          if( (flags & (0x02|0x08))==0
           && (p->aBlob[j]&0x0f)>=11
          ){
            sqlite3_result_subtype(ctx, 74);
          }
        }
      }else{
        jsonAppendSeparator(&jx);
        jsonTranslateBlobToText(p, j, &jx);
      }
    }else if( j==0xfffffffe ){
      if( argc==2 ){
        goto json_extract_error;
      }else{
        jsonAppendSeparator(&jx);
        jsonAppendRawNZ(&jx, "null", 4);
      }
    }else if( j==0xffffffff ){
      sqlite3_result_error(ctx, "malformed JSON", -1);
      goto json_extract_error;
    }else{
      jsonBadPathError(ctx, zPath);
      goto json_extract_error;
    }
  }
  if( argc>2 ){
    jsonAppendChar(&jx, ']');
    jsonReturnString(&jx, 0, 0);
    if( (flags & 0x08)==0 ){
      sqlite3_result_subtype(ctx, 74);
    }
  }
json_extract_error:
  jsonStringReset(&jx);
  jsonParseFree(p);
  return;
}
# 214279 "c_tests/sqlite3.c"
static int jsonMergePatch(
  JsonParse *pTarget,
  u32 iTarget,
  const JsonParse *pPatch,
  u32 iPatch
){
  u8 x;
  u32 n, sz=0;
  u32 iTCursor;
  u32 iTStart;
  u32 iTEndBE;
  u32 iTEnd;
  u8 eTLabel;
  u32 iTLabel = 0;
  u32 nTLabel = 0;
  u32 szTLabel = 0;
  u32 iTValue = 0;
  u32 nTValue = 0;
  u32 szTValue = 0;

  u32 iPCursor;
  u32 iPEnd;
  u8 ePLabel;
  u32 iPLabel;
  u32 nPLabel;
  u32 szPLabel;
  u32 iPValue;
  u32 nPValue;
  u32 szPValue;

  ((void) (0));
  ((void) (0));
  x = pPatch->aBlob[iPatch] & 0x0f;
  if( x!=12 ){
    u32 szPatch;
    u32 szTarget;
    n = jsonbPayloadSize(pPatch, iPatch, &sz);
    szPatch = n+sz;
    sz = 0;
    n = jsonbPayloadSize(pTarget, iTarget, &sz);
    szTarget = n+sz;
    jsonBlobEdit(pTarget, iTarget, szTarget, pPatch->aBlob+iPatch, szPatch);
    return pTarget->oom ? 3 : 0;
  }
  x = pTarget->aBlob[iTarget] & 0x0f;
  if( x!=12 ){
    n = jsonbPayloadSize(pTarget, iTarget, &sz);
    jsonBlobEdit(pTarget, iTarget+n, sz, 0, 0);
    x = pTarget->aBlob[iTarget];
    pTarget->aBlob[iTarget] = (x & 0xf0) | 12;
  }
  n = jsonbPayloadSize(pPatch, iPatch, &sz);
  if( (n==0) ) return 2;
  iPCursor = iPatch+n;
  iPEnd = iPCursor+sz;
  n = jsonbPayloadSize(pTarget, iTarget, &sz);
  if( (n==0) ) return 1;
  iTStart = iTarget+n;
  iTEndBE = iTStart+sz;

  while( iPCursor<iPEnd ){
    iPLabel = iPCursor;
    ePLabel = pPatch->aBlob[iPCursor] & 0x0f;
    if( ePLabel<7 || ePLabel>10 ){
      return 2;
    }
    nPLabel = jsonbPayloadSize(pPatch, iPCursor, &szPLabel);
    if( nPLabel==0 ) return 2;
    iPValue = iPCursor + nPLabel + szPLabel;
    if( iPValue>=iPEnd ) return 2;
    nPValue = jsonbPayloadSize(pPatch, iPValue, &szPValue);
    if( nPValue==0 ) return 2;
    iPCursor = iPValue + nPValue + szPValue;
    if( iPCursor>iPEnd ) return 2;

    iTCursor = iTStart;
    iTEnd = iTEndBE + pTarget->delta;
    while( iTCursor<iTEnd ){
      int isEqual;
      iTLabel = iTCursor;
      eTLabel = pTarget->aBlob[iTCursor] & 0x0f;
      if( eTLabel<7 || eTLabel>10 ){
        return 1;
      }
      nTLabel = jsonbPayloadSize(pTarget, iTCursor, &szTLabel);
      if( nTLabel==0 ) return 1;
      iTValue = iTLabel + nTLabel + szTLabel;
      if( iTValue>=iTEnd ) return 1;
      nTValue = jsonbPayloadSize(pTarget, iTValue, &szTValue);
      if( nTValue==0 ) return 1;
      if( iTValue + nTValue + szTValue > iTEnd ) return 1;
      isEqual = jsonLabelCompare(
                   (const char*)&pPatch->aBlob[iPLabel+nPLabel],
                   szPLabel,
                   (ePLabel==7 || ePLabel==10),
                   (const char*)&pTarget->aBlob[iTLabel+nTLabel],
                   szTLabel,
                   (eTLabel==7 || eTLabel==10));
      if( isEqual ) break;
      iTCursor = iTValue + nTValue + szTValue;
    }
    x = pPatch->aBlob[iPValue] & 0x0f;
    if( iTCursor<iTEnd ){

      if( x==0 ){

        jsonBlobEdit(pTarget, iTLabel, nTLabel+szTLabel+nTValue+szTValue, 0,0);

        if( (pTarget->oom) ) return 3;
      }else{

        int rc, savedDelta = pTarget->delta;
        pTarget->delta = 0;
        rc = jsonMergePatch(pTarget, iTValue, pPatch, iPValue);
        if( rc ) return rc;
        pTarget->delta += savedDelta;
      }
    }else if( x>0 ){

      u32 szNew = szPLabel+nPLabel;
      if( (pPatch->aBlob[iPValue] & 0x0f)!=12 ){
        jsonBlobEdit(pTarget, iTEnd, 0, 0, szPValue+nPValue+szNew);
        if( pTarget->oom ) return 3;
        memcpy(&pTarget->aBlob[iTEnd], &pPatch->aBlob[iPLabel], szNew);
        memcpy(&pTarget->aBlob[iTEnd+szNew],
               &pPatch->aBlob[iPValue], szPValue+nPValue);
      }else{
        int rc, savedDelta;
        jsonBlobEdit(pTarget, iTEnd, 0, 0, szNew+1);
        if( pTarget->oom ) return 3;
        memcpy(&pTarget->aBlob[iTEnd], &pPatch->aBlob[iPLabel], szNew);
        pTarget->aBlob[iTEnd+szNew] = 0x00;
        savedDelta = pTarget->delta;
        pTarget->delta = 0;
        rc = jsonMergePatch(pTarget, iTEnd+szNew,pPatch,iPValue);
        if( rc ) return rc;
        pTarget->delta += savedDelta;
      }
    }
  }
  if( pTarget->delta ) jsonAfterEditSizeAdjust(pTarget, iTarget);
  return pTarget->oom ? 3 : 0;
}







static void jsonPatchFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonParse *pTarget;
  JsonParse *pPatch;
  int rc;

  (void)(argc);
  ((void) (0));
  pTarget = jsonParseFuncArg(ctx, argv[0], 0x01);
  if( pTarget==0 ) return;
  pPatch = jsonParseFuncArg(ctx, argv[1], 0);
  if( pPatch ){
    rc = jsonMergePatch(pTarget, 0, pPatch, 0);
    if( rc==0 ){
      jsonReturnParse(ctx, pTarget);
    }else if( rc==3 ){
      sqlite3_result_error_nomem(ctx);
    }else{
      sqlite3_result_error(ctx, "malformed JSON", -1);
    }
    jsonParseFree(pPatch);
  }
  jsonParseFree(pTarget);
}







static void jsonObjectFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  int i;
  JsonString jx;
  const char *z;
  u32 n;

  if( argc&1 ){
    sqlite3_result_error(ctx, "json_object() requires an even number "
                                  "of arguments", -1);
    return;
  }
  jsonStringInit(&jx, ctx);
  jsonAppendChar(&jx, '{');
  for(i=0; i<argc; i+=2){
    if( sqlite3_value_type(argv[i])!=3 ){
      sqlite3_result_error(ctx, "json_object() labels must be TEXT", -1);
      jsonStringReset(&jx);
      return;
    }
    jsonAppendSeparator(&jx);
    z = (const char*)sqlite3_value_text(argv[i]);
    n = sqlite3_value_bytes(argv[i]);
    jsonAppendString(&jx, z, n);
    jsonAppendChar(&jx, ':');
    jsonAppendSqlValue(&jx, argv[i+1]);
  }
  jsonAppendChar(&jx, '}');
  jsonReturnString(&jx, 0, 0);
  sqlite3_result_subtype(ctx, 74);
}
# 214505 "c_tests/sqlite3.c"
static void jsonRemoveFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonParse *p;
  const char *zPath = 0;
  int i;
  u32 rc;

  if( argc<1 ) return;
  p = jsonParseFuncArg(ctx, argv[0], argc>1 ? 0x01 : 0);
  if( p==0 ) return;
  for(i=1; i<argc; i++){
    zPath = (const char*)sqlite3_value_text(argv[i]);
    if( zPath==0 ){
      goto json_remove_done;
    }
    if( zPath[0]!='$' ){
      goto json_remove_patherror;
    }
    if( zPath[1]==0 ){

      goto json_remove_done;
    }
    p->eEdit = 1;
    p->delta = 0;
    rc = jsonLookupStep(p, 0, zPath+1, 0);
    if( ((rc)>=0xfffffffd) ){
      if( rc==0xfffffffe ){
        continue;
      }else if( rc==0xfffffffd ){
        jsonBadPathError(ctx, zPath);
      }else{
        sqlite3_result_error(ctx, "malformed JSON", -1);
      }
      goto json_remove_done;
    }
  }
  jsonReturnParse(ctx, p);
  jsonParseFree(p);
  return;

json_remove_patherror:
  jsonBadPathError(ctx, zPath);

json_remove_done:
  jsonParseFree(p);
  return;
}







static void jsonReplaceFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  if( argc<1 ) return;
  if( (argc&1)==0 ) {
    jsonWrongNumArgs(ctx, "replace");
    return;
  }
  jsonInsertIntoBlob(ctx, argc, argv, 2);
}
# 214588 "c_tests/sqlite3.c"
static void jsonSetFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){

  int flags = ((int)(long int)(sqlite3_user_data(ctx)));
  int bIsSet = (flags&0x04)!=0;

  if( argc<1 ) return;
  if( (argc&1)==0 ) {
    jsonWrongNumArgs(ctx, bIsSet ? "set" : "insert");
    return;
  }
  jsonInsertIntoBlob(ctx, argc, argv, bIsSet ? 4 : 3);
}
# 214612 "c_tests/sqlite3.c"
static void jsonTypeFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonParse *p;
  const char *zPath = 0;
  u32 i;

  p = jsonParseFuncArg(ctx, argv[0], 0);
  if( p==0 ) return;
  if( argc==2 ){
    zPath = (const char*)sqlite3_value_text(argv[1]);
    if( zPath==0 ) goto json_type_done;
    if( zPath[0]!='$' ){
      jsonBadPathError(ctx, zPath);
      goto json_type_done;
    }
    i = jsonLookupStep(p, 0, zPath+1, 0);
    if( ((i)>=0xfffffffd) ){
      if( i==0xfffffffe ){

      }else if( i==0xfffffffd ){
        jsonBadPathError(ctx, zPath);
      }else{
        sqlite3_result_error(ctx, "malformed JSON", -1);
      }
      goto json_type_done;
    }
  }else{
    i = 0;
  }
  sqlite3_result_text(ctx, jsonbType[p->aBlob[i]&0x0f], -1, ((sqlite3_destructor_type)0));
json_type_done:
  jsonParseFree(p);
}
# 214659 "c_tests/sqlite3.c"
static void jsonPrettyFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonString s;
  JsonPretty x;

  memset(&x, 0, sizeof(x));
  x.pParse = jsonParseFuncArg(ctx, argv[0], 0);
  if( x.pParse==0 ) return;
  x.pOut = &s;
  jsonStringInit(&s, ctx);
  if( argc==1 || (x.zIndent = (const char*)sqlite3_value_text(argv[1]))==0 ){
    x.zIndent = "    ";
    x.szIndent = 4;
  }else{
    x.szIndent = (u32)strlen(x.zIndent);
  }
  jsonTranslateBlobToPrettyText(&x, 0);
  jsonReturnString(&s, 0, 0);
  jsonParseFree(x.pParse);
}
# 214740 "c_tests/sqlite3.c"
static void jsonValidFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonParse *p;
  u8 flags = 1;
  u8 res = 0;
  if( argc==2 ){
    i64 f = sqlite3_value_int64(argv[1]);
    if( f<1 || f>15 ){
      sqlite3_result_error(ctx, "FLAGS parameter to json_valid() must be"
                                " between 1 and 15", -1);
      return;
    }
    flags = f & 0x0f;
  }
  switch( sqlite3_value_type(argv[0]) ){
    case 5: {




      return;
    }
    case 4: {
      JsonParse py;
      memset(&py, 0, sizeof(py));
      if( jsonArgIsJsonb(argv[0], &py) ){
        if( flags & 0x04 ){


          res = 1;
        }else if( flags & 0x08 ){


          res = 0==jsonbValidityCheck(&py, 0, py.nBlob, 1);
        }
        break;
      }


                     __attribute__((fallthrough));
    }
    default: {
      JsonParse px;
      if( (flags & 0x3)==0 ) break;
      memset(&px, 0, sizeof(px));

      p = jsonParseFuncArg(ctx, argv[0], 0x02);
      if( p ){
        if( p->oom ){
          sqlite3_result_error_nomem(ctx);
        }else if( p->nErr ){

        }else if( (flags & 0x02)!=0 || p->hasNonstd==0 ){
          res = 1;
        }
        jsonParseFree(p);
      }else{
        sqlite3_result_error_nomem(ctx);
      }
      break;
    }
  }
  sqlite3_result_int(ctx, res);
}
# 214822 "c_tests/sqlite3.c"
static void jsonErrorFunc(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  i64 iErrPos = 0;
  JsonParse s;

  ((void) (0));
  (void)(argc);
  memset(&s, 0, sizeof(s));
  s.db = sqlite3_context_db_handle(ctx);
  if( jsonArgIsJsonb(argv[0], &s) ){
    iErrPos = (i64)jsonbValidityCheck(&s, 0, s.nBlob, 1);
  }else{
    s.zJson = (char*)sqlite3_value_text(argv[0]);
    if( s.zJson==0 ) return;
    s.nJson = sqlite3_value_bytes(argv[0]);
    if( jsonConvertTextToBlob(&s,0) ){
      if( s.oom ){
        iErrPos = -1;
      }else{

        u32 k;
        ((void) (0));
        for(k=0; k<s.iErr && (s.zJson[k]); k++){
          if( (s.zJson[k] & 0xc0)!=0x80 ) iErrPos++;
        }
        iErrPos++;
      }
    }
  }
  jsonParseReset(&s);
  if( iErrPos<0 ){
    sqlite3_result_error_nomem(ctx);
  }else{
    sqlite3_result_int64(ctx, iErrPos);
  }
}
# 214870 "c_tests/sqlite3.c"
static void jsonArrayStep(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonString *pStr;
  (void)(argc);
  pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));
  if( pStr ){
    if( pStr->zBuf==0 ){
      jsonStringInit(pStr, ctx);
      jsonAppendChar(pStr, '[');
    }else if( pStr->nUsed>1 ){
      jsonAppendChar(pStr, ',');
    }
    pStr->pCtx = ctx;
    jsonAppendSqlValue(pStr, argv[0]);
  }
}
static void jsonArrayCompute(sqlite3_context *ctx, int isFinal){
  JsonString *pStr;
  pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);
  if( pStr ){
    int flags;
    pStr->pCtx = ctx;
    jsonAppendChar(pStr, ']');
    flags = ((int)(long int)(sqlite3_user_data(ctx)));
    if( pStr->eErr ){
      jsonReturnString(pStr, 0, 0);
      return;
    }else if( flags & 0x08 ){
      jsonReturnStringAsBlob(pStr);
      if( isFinal ){
        if( !pStr->bStatic ) sqlite3RCStrUnref(pStr->zBuf);
      }else{
        jsonStringTrimOneChar(pStr);
      }
      return;
    }else if( isFinal ){
      sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed,
                          pStr->bStatic ? ((sqlite3_destructor_type)-1) :
                              sqlite3RCStrUnref);
      pStr->bStatic = 1;
    }else{
      sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed, ((sqlite3_destructor_type)-1));
      jsonStringTrimOneChar(pStr);
    }
  }else{
    sqlite3_result_text(ctx, "[]", 2, ((sqlite3_destructor_type)0));
  }
  sqlite3_result_subtype(ctx, 74);
}
static void jsonArrayValue(sqlite3_context *ctx){
  jsonArrayCompute(ctx, 0);
}
static void jsonArrayFinal(sqlite3_context *ctx){
  jsonArrayCompute(ctx, 1);
}
# 214936 "c_tests/sqlite3.c"
static void jsonGroupInverse(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  unsigned int i;
  int inStr = 0;
  int nNest = 0;
  char *z;
  char c;
  JsonString *pStr;
  (void)(argc);
  (void)(argv);
  pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);



  if( (!pStr) ) return;

  z = pStr->zBuf;
  for(i=1; i<pStr->nUsed && ((c = z[i])!=',' || inStr || nNest); i++){
    if( c=='"' ){
      inStr = !inStr;
    }else if( c=='\\' ){
      i++;
    }else if( !inStr ){
      if( c=='{' || c=='[' ) nNest++;
      if( c=='}' || c==']' ) nNest--;
    }
  }
  if( i<pStr->nUsed ){
    pStr->nUsed -= i;
    memmove(&z[1], &z[i+1], (size_t)pStr->nUsed-1);
    z[pStr->nUsed] = 0;
  }else{
    pStr->nUsed = 1;
  }
}
# 214984 "c_tests/sqlite3.c"
static void jsonObjectStep(
  sqlite3_context *ctx,
  int argc,
  sqlite3_value **argv
){
  JsonString *pStr;
  const char *z;
  u32 n;
  (void)(argc);
  pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));
  if( pStr ){
    z = (const char*)sqlite3_value_text(argv[0]);
    n = sqlite3Strlen30(z);
    if( pStr->zBuf==0 ){
      jsonStringInit(pStr, ctx);
      jsonAppendChar(pStr, '{');
    }else if( pStr->nUsed>1 && z!=0 ){
      jsonAppendChar(pStr, ',');
    }
    pStr->pCtx = ctx;
    if( z!=0 ){
      jsonAppendString(pStr, z, n);
      jsonAppendChar(pStr, ':');
      jsonAppendSqlValue(pStr, argv[1]);
    }
  }
}
static void jsonObjectCompute(sqlite3_context *ctx, int isFinal){
  JsonString *pStr;
  pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);
  if( pStr ){
    int flags;
    jsonAppendChar(pStr, '}');
    pStr->pCtx = ctx;
    flags = ((int)(long int)(sqlite3_user_data(ctx)));
    if( pStr->eErr ){
      jsonReturnString(pStr, 0, 0);
      return;
    }else if( flags & 0x08 ){
      jsonReturnStringAsBlob(pStr);
      if( isFinal ){
        if( !pStr->bStatic ) sqlite3RCStrUnref(pStr->zBuf);
      }else{
        jsonStringTrimOneChar(pStr);
      }
      return;
    }else if( isFinal ){
      sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed,
                          pStr->bStatic ? ((sqlite3_destructor_type)-1) :
                          sqlite3RCStrUnref);
      pStr->bStatic = 1;
    }else{
      sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed, ((sqlite3_destructor_type)-1));
      jsonStringTrimOneChar(pStr);
    }
  }else{
    sqlite3_result_text(ctx, "{}", 2, ((sqlite3_destructor_type)0));
  }
  sqlite3_result_subtype(ctx, 74);
}
static void jsonObjectValue(sqlite3_context *ctx){
  jsonObjectCompute(ctx, 0);
}
static void jsonObjectFinal(sqlite3_context *ctx){
  jsonObjectCompute(ctx, 1);
}







typedef struct JsonParent JsonParent;
struct JsonParent {
  u32 iHead;
  u32 iValue;
  u32 iEnd;
  u32 nPath;
  i64 iKey;
};

typedef struct JsonEachCursor JsonEachCursor;
struct JsonEachCursor {
  sqlite3_vtab_cursor base;
  u32 iRowid;
  u32 i;
  u32 iEnd;
  u32 nRoot;
  u8 eType;
  u8 bRecursive;
  u8 eMode;
  u32 nParent;
  u32 nParentAlloc;
  JsonParent *aParent;
  sqlite3 *db;
  JsonString path;
  JsonParse sParse;
};
typedef struct JsonEachConnection JsonEachConnection;
struct JsonEachConnection {
  sqlite3_vtab base;
  sqlite3 *db;
  u8 eMode;
  u8 bRecursive;
};



static int jsonEachConnect(
  sqlite3 *db,
  void *pAux,
  int argc, const char *const*argv,
  sqlite3_vtab **ppVtab,
  char **pzErr
){
  JsonEachConnection *pNew;
  int rc;
# 215118 "c_tests/sqlite3.c"
  (void)(pzErr);
  (void)(argv);
  (void)(argc);
  (void)(pAux);
  rc = sqlite3_declare_vtab(db,
     "CREATE TABLE x(key,value,type,atom,id,parent,fullkey,path,"
                    "json HIDDEN,root HIDDEN)");
  if( rc==0 ){
    pNew = (JsonEachConnection*)sqlite3DbMallocZero(db, sizeof(*pNew));
    *ppVtab = (sqlite3_vtab*)pNew;
    if( pNew==0 ) return 7;
    sqlite3_vtab_config(db, 2);
    pNew->db = db;
    pNew->eMode = argv[0][4]=='b' ? 2 : 1;
    pNew->bRecursive = argv[0][4+pNew->eMode]=='t';
  }
  return rc;
}


static int jsonEachDisconnect(sqlite3_vtab *pVtab){
  JsonEachConnection *p = (JsonEachConnection*)pVtab;
  sqlite3DbFree(p->db, pVtab);
  return 0;
}


static int jsonEachOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){
  JsonEachConnection *pVtab = (JsonEachConnection*)p;
  JsonEachCursor *pCur;

  (void)(p);
  pCur = sqlite3DbMallocZero(pVtab->db, sizeof(*pCur));
  if( pCur==0 ) return 7;
  pCur->db = pVtab->db;
  pCur->eMode = pVtab->eMode;
  pCur->bRecursive = pVtab->bRecursive;
  jsonStringZero(&pCur->path);
  *ppCursor = &pCur->base;
  return 0;
}



static void jsonEachCursorReset(JsonEachCursor *p){
  jsonParseReset(&p->sParse);
  jsonStringReset(&p->path);
  sqlite3DbFree(p->db, p->aParent);
  p->iRowid = 0;
  p->i = 0;
  p->aParent = 0;
  p->nParent = 0;
  p->nParentAlloc = 0;
  p->iEnd = 0;
  p->eType = 0;
}


static int jsonEachClose(sqlite3_vtab_cursor *cur){
  JsonEachCursor *p = (JsonEachCursor*)cur;
  jsonEachCursorReset(p);

  sqlite3DbFree(p->db, cur);
  return 0;
}



static int jsonEachEof(sqlite3_vtab_cursor *cur){
  JsonEachCursor *p = (JsonEachCursor*)cur;
  return p->i >= p->iEnd;
}






static int jsonSkipLabel(JsonEachCursor *p){
  if( p->eType==12 ){
    u32 sz = 0;
    u32 n = jsonbPayloadSize(&p->sParse, p->i, &sz);
    return p->i + n + sz;
  }else{
    return p->i;
  }
}




static void jsonAppendPathName(JsonEachCursor *p){
  ((void) (0));
  ((void) (0));
  if( p->eType==11 ){
    jsonPrintf(30, &p->path, "[%lld]", p->aParent[p->nParent-1].iKey);
  }else{
    u32 n, sz = 0, k, i;
    const char *z;
    int needQuote = 0;
    n = jsonbPayloadSize(&p->sParse, p->i, &sz);
    k = p->i + n;
    z = (const char*)&p->sParse.aBlob[k];
    if( sz==0 || !(sqlite3CtypeMap[(unsigned char)(z[0])]&0x02) ){
      needQuote = 1;
    }else{
      for(i=0; i<sz; i++){
        if( !(sqlite3CtypeMap[(unsigned char)(z[i])]&0x06) ){
          needQuote = 1;
          break;
        }
      }
    }
    if( needQuote ){
      jsonPrintf(sz+4,&p->path,".\"%.*s\"", sz, z);
    }else{
      jsonPrintf(sz+2,&p->path,".%.*s", sz, z);
    }
  }
}


static int jsonEachNext(sqlite3_vtab_cursor *cur){
  JsonEachCursor *p = (JsonEachCursor*)cur;
  int rc = 0;
  if( p->bRecursive ){
    u8 x;
    u8 levelChange = 0;
    u32 n, sz = 0;
    u32 i = jsonSkipLabel(p);
    x = p->sParse.aBlob[i] & 0x0f;
    n = jsonbPayloadSize(&p->sParse, i, &sz);
    if( x==12 || x==11 ){
      JsonParent *pParent;
      if( p->nParent>=p->nParentAlloc ){
        JsonParent *pNew;
        u64 nNew;
        nNew = p->nParentAlloc*2 + 3;
        pNew = sqlite3DbRealloc(p->db, p->aParent, sizeof(JsonParent)*nNew);
        if( pNew==0 ) return 7;
        p->nParentAlloc = (u32)nNew;
        p->aParent = pNew;
      }
      levelChange = 1;
      pParent = &p->aParent[p->nParent];
      pParent->iHead = p->i;
      pParent->iValue = i;
      pParent->iEnd = i + n + sz;
      pParent->iKey = -1;
      pParent->nPath = (u32)p->path.nUsed;
      if( p->eType && p->nParent ){
        jsonAppendPathName(p);
        if( p->path.eErr ) rc = 7;
      }
      p->nParent++;
      p->i = i + n;
    }else{
      p->i = i + n + sz;
    }
    while( p->nParent>0 && p->i >= p->aParent[p->nParent-1].iEnd ){
      p->nParent--;
      p->path.nUsed = p->aParent[p->nParent].nPath;
      levelChange = 1;
    }
    if( levelChange ){
      if( p->nParent>0 ){
        JsonParent *pParent = &p->aParent[p->nParent-1];
        u32 iVal = pParent->iValue;
        p->eType = p->sParse.aBlob[iVal] & 0x0f;
      }else{
        p->eType = 0;
      }
    }
  }else{
    u32 n, sz = 0;
    u32 i = jsonSkipLabel(p);
    n = jsonbPayloadSize(&p->sParse, i, &sz);
    p->i = i + n + sz;
  }
  if( p->eType==11 && p->nParent ){
    p->aParent[p->nParent-1].iKey++;
  }
  p->iRowid++;
  return rc;
}



static int jsonEachPathLength(JsonEachCursor *p){
  u32 n = p->path.nUsed;
  char *z = p->path.zBuf;
  if( p->iRowid==0 && p->bRecursive && n>=2 ){
    while( n>1 ){
      n--;
      if( z[n]=='[' || z[n]=='.' ){
        u32 x, sz = 0;
        char cSaved = z[n];
        z[n] = 0;
        ((void) (0));
        x = jsonLookupStep(&p->sParse, 0, z+1, 0);
        z[n] = cSaved;
        if( ((x)>=0xfffffffd) ) continue;
        if( x + jsonbPayloadSize(&p->sParse, x, &sz) == p->i ) break;
      }
    }
  }
  return n;
}


static int jsonEachColumn(
  sqlite3_vtab_cursor *cur,
  sqlite3_context *ctx,
  int iColumn
){
  JsonEachCursor *p = (JsonEachCursor*)cur;
  switch( iColumn ){
    case 0: {
      if( p->nParent==0 ){
        u32 n, j;
        if( p->nRoot==1 ) break;
        j = jsonEachPathLength(p);
        n = p->nRoot - j;
        if( n==0 ){
          break;
        }else if( p->path.zBuf[j]=='[' ){
          i64 x;
          sqlite3Atoi64(&p->path.zBuf[j+1], &x, n-1, 1);
          sqlite3_result_int64(ctx, x);
        }else if( p->path.zBuf[j+1]=='"' ){
          sqlite3_result_text(ctx, &p->path.zBuf[j+2], n-3, ((sqlite3_destructor_type)-1));
        }else{
          sqlite3_result_text(ctx, &p->path.zBuf[j+1], n-1, ((sqlite3_destructor_type)-1));
        }
        break;
      }
      if( p->eType==12 ){
        jsonReturnFromBlob(&p->sParse, p->i, ctx, 1);
      }else{
        ((void) (0));
        sqlite3_result_int64(ctx, p->aParent[p->nParent-1].iKey);
      }
      break;
    }
    case 1: {
      u32 i = jsonSkipLabel(p);
      jsonReturnFromBlob(&p->sParse, i, ctx, p->eMode);
      if( (p->sParse.aBlob[i] & 0x0f)>=11 ){
        sqlite3_result_subtype(ctx, 74);
      }
      break;
    }
    case 2: {
      u32 i = jsonSkipLabel(p);
      u8 eType = p->sParse.aBlob[i] & 0x0f;
      sqlite3_result_text(ctx, jsonbType[eType], -1, ((sqlite3_destructor_type)0));
      break;
    }
    case 3: {
      u32 i = jsonSkipLabel(p);
      if( (p->sParse.aBlob[i] & 0x0f)<11 ){
        jsonReturnFromBlob(&p->sParse, i, ctx, 1);
      }
      break;
    }
    case 4: {
      sqlite3_result_int64(ctx, (sqlite3_int64)p->i);
      break;
    }
    case 5: {
      if( p->nParent>0 && p->bRecursive ){
        sqlite3_result_int64(ctx, p->aParent[p->nParent-1].iHead);
      }
      break;
    }
    case 6: {
      u64 nBase = p->path.nUsed;
      if( p->nParent ) jsonAppendPathName(p);
      sqlite3_result_text64(ctx, p->path.zBuf, p->path.nUsed,
                            ((sqlite3_destructor_type)-1), 1);
      p->path.nUsed = nBase;
      break;
    }
    case 7: {
      u32 n = jsonEachPathLength(p);
      sqlite3_result_text64(ctx, p->path.zBuf, n,
                            ((sqlite3_destructor_type)-1), 1);
      break;
    }
    default: {
      sqlite3_result_text(ctx, p->path.zBuf, p->nRoot, ((sqlite3_destructor_type)0));
      break;
    }
    case 8: {
      if( p->sParse.zJson==0 ){
        sqlite3_result_blob(ctx, p->sParse.aBlob, p->sParse.nBlob,
                            ((sqlite3_destructor_type)-1));
      }else{
        sqlite3_result_text(ctx, p->sParse.zJson, -1, ((sqlite3_destructor_type)-1));
      }
      break;
    }
  }
  return 0;
}


static int jsonEachRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
  JsonEachCursor *p = (JsonEachCursor*)cur;
  *pRowid = p->iRowid;
  return 0;
}






static int jsonEachBestIndex(
  sqlite3_vtab *tab,
  sqlite3_index_info *pIdxInfo
){
  int i;
  int aIdx[2];
  int unusableMask = 0;
  int idxMask = 0;
  const struct sqlite3_index_constraint *pConstraint;



  ((void) (0));
  (void)(tab);
  aIdx[0] = aIdx[1] = -1;
  pConstraint = pIdxInfo->aConstraint;
  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
    int iCol;
    int iMask;
    if( pConstraint->iColumn < 8 ) continue;
    iCol = pConstraint->iColumn - 8;
    ((void) (0));
                       ;
    iMask = 1 << iCol;
    if( pConstraint->usable==0 ){
      unusableMask |= iMask;
    }else if( pConstraint->op==2 ){
      aIdx[iCol] = i;
      idxMask |= iMask;
    }
  }
  if( pIdxInfo->nOrderBy>0
   && pIdxInfo->aOrderBy[0].iColumn<0
   && pIdxInfo->aOrderBy[0].desc==0
  ){
    pIdxInfo->orderByConsumed = 1;
  }

  if( (unusableMask & ~idxMask)!=0 ){


    return 19;
  }
  if( aIdx[0]<0 ){



    pIdxInfo->idxNum = 0;
  }else{
    pIdxInfo->estimatedCost = 1.0;
    i = aIdx[0];
    pIdxInfo->aConstraintUsage[i].argvIndex = 1;
    pIdxInfo->aConstraintUsage[i].omit = 1;
    if( aIdx[1]<0 ){
      pIdxInfo->idxNum = 1;
    }else{
      i = aIdx[1];
      pIdxInfo->aConstraintUsage[i].argvIndex = 2;
      pIdxInfo->aConstraintUsage[i].omit = 1;
      pIdxInfo->idxNum = 3;
    }
  }
  return 0;
}


static int jsonEachFilter(
  sqlite3_vtab_cursor *cur,
  int idxNum, const char *idxStr,
  int argc, sqlite3_value **argv
){
  JsonEachCursor *p = (JsonEachCursor*)cur;
  const char *zRoot = 0;
  u32 i, n, sz;

  (void)(idxStr);
  (void)(argc);
  jsonEachCursorReset(p);
  if( idxNum==0 ) return 0;
  memset(&p->sParse, 0, sizeof(p->sParse));
  p->sParse.nJPRef = 1;
  p->sParse.db = p->db;
  if( jsonArgIsJsonb(argv[0], &p->sParse) ){

  }else{
    p->sParse.zJson = (char*)sqlite3_value_text(argv[0]);
    p->sParse.nJson = sqlite3_value_bytes(argv[0]);
    if( p->sParse.zJson==0 ){
      p->i = p->iEnd = 0;
      return 0;
    }
    if( jsonConvertTextToBlob(&p->sParse, 0) ){
      if( p->sParse.oom ){
        return 7;
      }
      goto json_each_malformed_input;
    }
  }
  if( idxNum==3 ){
    zRoot = (const char*)sqlite3_value_text(argv[1]);
    if( zRoot==0 ) return 0;
    if( zRoot[0]!='$' ){
      sqlite3_free(cur->pVtab->zErrMsg);
      cur->pVtab->zErrMsg = jsonBadPathError(0, zRoot);
      jsonEachCursorReset(p);
      return cur->pVtab->zErrMsg ? 1 : 7;
    }
    p->nRoot = sqlite3Strlen30(zRoot);
    if( zRoot[1]==0 ){
      i = p->i = 0;
      p->eType = 0;
    }else{
      i = jsonLookupStep(&p->sParse, 0, zRoot+1, 0);
      if( ((i)>=0xfffffffd) ){
        if( i==0xfffffffe ){
          p->i = 0;
          p->eType = 0;
          p->iEnd = 0;
          return 0;
        }
        sqlite3_free(cur->pVtab->zErrMsg);
        cur->pVtab->zErrMsg = jsonBadPathError(0, zRoot);
        jsonEachCursorReset(p);
        return cur->pVtab->zErrMsg ? 1 : 7;
      }
      if( p->sParse.iLabel ){
        p->i = p->sParse.iLabel;
        p->eType = 12;
      }else{
        p->i = i;
        p->eType = 11;
      }
    }
    jsonAppendRaw(&p->path, zRoot, p->nRoot);
  }else{
    i = p->i = 0;
    p->eType = 0;
    p->nRoot = 1;
    jsonAppendRaw(&p->path, "$", 1);
  }
  p->nParent = 0;
  n = jsonbPayloadSize(&p->sParse, i, &sz);
  p->iEnd = i+n+sz;
  if( (p->sParse.aBlob[i] & 0x0f)>=11 && !p->bRecursive ){
    p->i = i + n;
    p->eType = p->sParse.aBlob[i] & 0x0f;
    p->aParent = sqlite3DbMallocZero(p->db, sizeof(JsonParent));
    if( p->aParent==0 ) return 7;
    p->nParent = 1;
    p->nParentAlloc = 1;
    p->aParent[0].iKey = 0;
    p->aParent[0].iEnd = p->iEnd;
    p->aParent[0].iHead = p->i;
    p->aParent[0].iValue = i;
  }
  return 0;

json_each_malformed_input:
  sqlite3_free(cur->pVtab->zErrMsg);
  cur->pVtab->zErrMsg = sqlite3_mprintf("malformed JSON");
  jsonEachCursorReset(p);
  return cur->pVtab->zErrMsg ? 1 : 7;
}


static sqlite3_module jsonEachModule = {
  0,
  0,
  jsonEachConnect,
  jsonEachBestIndex,
  jsonEachDisconnect,
  0,
  jsonEachOpen,
  jsonEachClose,
  jsonEachFilter,
  jsonEachNext,
  jsonEachEof,
  jsonEachColumn,
  jsonEachRowid,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
};






static void sqlite3RegisterJsonFunctions(void){

  static FuncDef aJsonFunc[] = {






    {1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonRemoveFunc,0, 0, 0, "json", {0} },
    {1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((1)*0x08))),0,jsonRemoveFunc,0, 0, 0, "jsonb", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((0)*0x8000)| ((1)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonArrayFunc,0, 0, 0, "json_array", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((0)*0x8000)| ((1)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0|((1)*0x08))),0,jsonArrayFunc,0, 0, 0, "jsonb_array", {0} },
    {1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonArrayLengthFunc,0, 0, 0, "json_array_length", {0} },
    {2, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonArrayLengthFunc,0, 0, 0, "json_array_length", {0} },
    {1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonErrorFunc,0, 0, 0, "json_error_position", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonExtractFunc,0, 0, 0, "json_extract", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((1)*0x08))),0,jsonExtractFunc,0, 0, 0, "jsonb_extract", {0} },
    {2, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0x01|((0)*0x08))),0,jsonExtractFunc,0, 0, 0, "->", {0} },
    {2, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0x02|((0)*0x08))),0,jsonExtractFunc,0, 0, 0, "->>", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((1)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonSetFunc,0, 0, 0, "json_insert", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((1)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((1)*0x08))),0,jsonSetFunc,0, 0, 0, "jsonb_insert", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((0)*0x8000)| ((1)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonObjectFunc,0, 0, 0, "json_object", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((0)*0x8000)| ((1)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0|((1)*0x08))),0,jsonObjectFunc,0, 0, 0, "jsonb_object", {0} },
    {2, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonPatchFunc,0, 0, 0, "json_patch", {0} },
    {2, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((1)*0x08))),0,jsonPatchFunc,0, 0, 0, "jsonb_patch", {0} },
    {1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonPrettyFunc,0, 0, 0, "json_pretty", {0} },
    {2, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonPrettyFunc,0, 0, 0, "json_pretty", {0} },
    {1, 0x00800000|0x000000800|0x0800| 1|((0)*0x8000)| ((1)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonQuoteFunc,0, 0, 0, "json_quote", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonRemoveFunc,0, 0, 0, "json_remove", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((1)*0x08))),0,jsonRemoveFunc,0, 0, 0, "jsonb_remove", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((1)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonReplaceFunc,0, 0, 0, "json_replace", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((1)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((1)*0x08))),0,jsonReplaceFunc,0, 0, 0, "jsonb_replace", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((1)*0x000100000)|((1)*0x001000000), ((void*)(long int)(0x04|((0)*0x08))),0,jsonSetFunc,0, 0, 0, "json_set", {0} },
    {-1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((1)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0x04|((1)*0x08))),0,jsonSetFunc,0, 0, 0, "jsonb_set", {0} },
    {1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonTypeFunc,0, 0, 0, "json_type", {0} },
    {2, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonTypeFunc,0, 0, 0, "json_type", {0} },
    {1, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonValidFunc,0, 0, 0, "json_valid", {0} },
    {2, 0x00800000|0x000000800|0x0800| 1|((1)*0x8000)| ((0)*0x000100000)|((0)*0x001000000), ((void*)(long int)(0|((0)*0x08))),0,jsonValidFunc,0, 0, 0, "json_valid", {0} },



    {1, 0x00800000|1|(0*0x0020)|0x000100000|0x001000000|1| 0x000000800, ((void*)(long int)(0)), 0, jsonArrayStep,jsonArrayFinal,jsonArrayValue,jsonGroupInverse,"json_group_array", {0}},



    {1, 0x00800000|1|(0*0x0020)|0x000100000|0x001000000|1|0x000000800, ((void*)(long int)(0x08)), 0, jsonArrayStep,jsonArrayFinal,jsonArrayValue,jsonGroupInverse,"jsonb_group_array", {0}},


    {2, 0x00800000|1|(0*0x0020)|0x000100000|0x001000000|1|0x000000800, ((void*)(long int)(0)), 0, jsonObjectStep,jsonObjectFinal,jsonObjectValue,jsonGroupInverse,"json_group_object", {0}},


    {2, 0x00800000|1|(0*0x0020)|0x000100000|0x001000000|1| 0x000000800, ((void*)(long int)(0x08)), 0, jsonObjectStep,jsonObjectFinal,jsonObjectValue,jsonGroupInverse,"jsonb_group_object", {0}}



  };
  sqlite3InsertBuiltinFuncs(aJsonFunc, ((int)(sizeof(aJsonFunc)/sizeof(aJsonFunc[0]))));

}






static Module *sqlite3JsonVtabRegister(sqlite3 *db, const char *zName){
  unsigned int i;
  static const char *azModule[] = {
    "json_each", "json_tree", "jsonb_each", "jsonb_tree"
  };
  ((void) (0));
  for(i=0; i<sizeof(azModule)/sizeof(azModule[0]); i++){
    if( sqlite3StrICmp(azModule[i],zName)==0 ){
      return sqlite3VtabCreateModule(db, azModule[i], &jsonEachModule, 0, 0);
    }
  }
  return 0;
}
# 265950 "c_tests/sqlite3.c"
           const char *sqlite3_sourceid(void){ return "2026-01-09 17:27:48 b270f8339eb13b504d0b2ba154ebca966b7dde08e40c3ed7d559749818cb2075"; }
